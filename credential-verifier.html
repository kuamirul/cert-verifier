<html>

<head></head>

<body>
    <div hidden="" by-polymer-bundler="">
        <link rel="import" href="shared_bundle_1.html">
        <dom-module id="credential-verifier-styles"><template><style>:host{direction:ltr;display:block;font-size:14px;font-family:"Open Sans", -apple-system, BlinkMacSystemFont, sans-serif;line-height:1.33333333;letter-spacing:-.24px;color:rgba(3, 21, 50, 1);border:1px solid rgba(22, 40, 55, .13);box-sizing:border-box;border-radius:2px;}:host.failure{border:1px solid #FFF;}:host .cf-container{border-radius:2px;-webkit-transition:margin .3s ease, border .3s ease;-o-transition:margin .3s ease, border .3s ease;transition:margin .3s ease, border .3s ease;}:host.failure .cf-container{border:3px solid #D0021B;}:host .main{background:#FFF;padding:38px;border-top-left-radius:2px;border-top-right-radius:2px;}:host .main > .view-record-link{display:none;}:host footer{background-color:#F8F8F8;padding:24px 38px;border-bottom-left-radius:2px;border-bottom-right-radius:2px;}:host footer > span{max-width:50%;display:inline-block;}:host footer > .blockcerts-logo{float:right;}:host .main,
      :host footer{-webkit-transition:border .4s linear;-o-transition:border .4s linear;transition:border .4s linear;}:host .modal .main{padding:30px 40px 90px;}:host .modal footer{position:absolute;width:100%;left:0;bottom:0;box-sizing:border-box;background:rgba(3, 21, 50, 0.9);}:host .modal .blockcerts-logo{margin-top:0;}:host .modal .blockcerts-logo path,
      :host .modal .blockcerts-logo rect{fill:#FFF;}:host .card{overflow:hidden;display:-ms-flexbox;display:-webkit-flex;display:flex;text-align:left;}:host .card-logo{display:-ms-flexbox;display:-webkit-flex;display:flex;-webkit-align-items:center;-ms-flex-align:center;align-items:center;max-width:20%;}@media all and (-ms-high-contrast: none){*::-ms-backdrop, .card-logo{width:20%;}}:host .card-logo img{max-width:140px;max-height:100%;width:auto;height:auto;vertical-align:middle;}:host .card-info{box-sizing:border-box;border-bottom:1px solid rgba(3, 21, 50, .05);margin:0 0 0 18px;flex:1;display:-ms-flexbox;display:-webkit-flex;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between;}:host .card-title > a{display:-ms-flexbox;display:-webkit-flex;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between;-webkit-align-items:baseline;-ms-flex-align:baseline;align-items:baseline;}:host .card-title .view-record-link{display:block;}:host .card-info > span{margin:0 0 18px;}:host .card-title span{color:rgba(3, 21, 50, 1);}:host .card-title span{white-space:nowrap;}:host .card-title span svg{margin-left:8px;vertical-align:middle;}:host h2,
      :host h3{font-weight:normal;font-size:21px;letter-spacing:-.42px;word-break:break-word;}:host h2{margin:4px 0;padding-right:12px;}:host h3{margin:6px 0;line-height:1.19047619;font-weight:600;}:host h4{font-size:15px;font-weight:600;letter-spacing:.06px;margin:0 0 4px;}:host span{font-size:.875em;line-height:1.35714286;color:rgba(3, 21, 50, .7);}:host span a,
      :host a span{text-decoration:underline;}:host a{color:rgba(3, 21, 50, 1);text-decoration:none;}:host .url-field{position:relative;margin:6px 0;}:host .url-field input{padding-right:132px;margin:0;}:host .url-field button{position:absolute;right:0;top:0;overflow:hidden;margin:0;}:host input{font-size:15px;color:rgba(3, 21, 50, 1);border-radius:2px;padding:12px 15px;background-color:rgba(243, 244, 245, 6);border:solid 1px rgba(3, 21, 50, .13);box-sizing:border-box;width:100%;}:host input::-moz-placeholder{font-family:"Open Sans", -apple-system, BlinkMacSystemFont, sans-serif;color:rgba(3, 21, 50, .3);letter-spacing:-.25px;}:host input::-webkit-input-placeholder{font-family:"Open Sans", -apple-system, BlinkMacSystemFont, sans-serif;color:rgba(3, 21, 50, .3);letter-spacing:-.25px;}:host input:-moz-placeholder{font-family:"Open Sans", -apple-system, BlinkMacSystemFont, sans-serif;color:rgba(3, 21, 50, .3);letter-spacing:-.25px;}:host input:-ms-input-placeholder{font-family:"Open Sans", -apple-system, BlinkMacSystemFont, sans-serif;color:rgba(3, 21, 50, .3);letter-spacing:-.25px;}:host button{background-color:rgba(42, 178, 123, 1);border-radius:0 2px 2px 0;color:#FFFFFF;cursor:pointer;display:block;font-size:15px;font-weight:500;padding:12px 38px;border:0 none;height:100%;}:host button:focus,
      :host input:focus{outline:none;}:host .file-selector{position:relative;}:host .file-selector+span{margin-left:4px;font-size:12px;}:host .file-selector input{position:absolute;top:0;left:0;width:100%;height:100%;opacity:0;cursor:pointer;z-index:1;padding:0;}:host .verification{margin:30px 0 0 158px;position:relative;}:host ul{margin:0;padding:0;list-style-type:none;}:host li{position:relative;padding-left:33px;}:host .step{margin:0 0 13px;}:host .step > a{display:block;}:host .progress{padding-top:0;position:absolute;left:0;top:0;background-color:rgba(42, 178, 123, 1);width:14px;border-radius:7px;margin:2px 0;box-sizing:content-box;-webkit-transition:height .4s ease-in-out, padding-top .4s ease-in;-o-transition:height .4s ease-in-out, padding-top .4s ease-in;transition:height .4s ease-in-out, padding-top .4s ease-in;}:host .progress.no-transition{-webkit-transition:none !important;-moz-transition:none !important;-o-transition:none !important;transition:none !important;}:host .step-dot{position:absolute;left:-5px;top:-3px;width:24px;height:24px;background-color:#FFFFFF;border-radius:50%;-webkit-transition:all .2s ease-out;-o-transition:all .2s ease-out;transition:all .2s ease-out;z-index:2;box-sizing:content-box;}:host .sub-steps{display:block;height:0;-webkit-transition:height .6s ease-out;-o-transition:height .6s ease-out;transition:height .6s ease-out;margin:0 0 0 -33px;padding-top:5px;overflow:hidden;}:host .step.out-starting .step-dot,
      :host .step.step-verified > .step-dot,
      :host .sub-steps .step-dot{width:4px;height:4px;left:5px;}:host .step.out-starting .step-dot{top:8px;}:host .sub-steps .step-dot{top:10px;}:host .starting .step-dot{left:1px;top:3px;width:12px;height:12px;}:host .step .loading-txt,
      :host .step.starting > a,
      :host .step.starting .sub-steps{display:none;}:host .step.starting .loading-txt{display:block;}:host .step.opened .sub-steps{height:auto;}:host .step .error-bar{content:'';position:absolute;top:0;left:0;background-color:#D0021B;display:none;width:14px;border-radius:7px;z-index:1;}:host .step.failure .error-bar{display:block;}:host li.sub-step{margin:0;line-height:1.71428571;}:host li.sub-step .error{background:rgba(208,2,27,0.05);border-radius:2px;letter-spacing:.05px;padding:5px 10px 10px;margin-top:5px;}:host li.sub-step .error span{color:#D0021B;font-weight:600;font-size:14px;}:host li.sub-step .error p{margin:0;line-height:1.35714286;}:host li.sub-step .error{display:none;}:host li.sub-step.failure .error{display:block;}:host li.sub-step .step-dot{margin:0;background-color:rgba(255, 255, 255, .8);}:host .step.opened .step-arrow{transform:rotate(180deg);}:host .step.success > .step-dot,
      :host .step.failure > .step-dot{box-shadow:0 2px 4px 0 rgba(22,40,55,0.21);}:host .step > .step-dot::after{opacity:0;display:block;transition:opacity .2s linear .3s;content:'';}:host .step.success > .step-dot::after{width:5px;height:11px;border:solid rgba(42, 178, 123, 1);border-width:0 2px 2px 0;transform:rotate(45deg);margin-left:9px;margin-top:4px;}:host .step.failure > .step-dot::before,
      :host .step.failure > .step-dot::after{position:absolute;left:11px;top:5px;content:' ';height:14px;width:2px;background-color:#D0021B;}:host .step.failure > .step-dot::before{transform:rotate(45deg);}:host .step.failure > .step-dot::after{transform:rotate(-45deg);}:host .step.failure > .step-dot::after,
      :host .step.success > .step-dot::after{opacity:1;}:host .step-arrow{width:0;height:0;border-left:4px solid transparent;border-right:4px solid transparent;border-bottom:4px solid rgba(118, 128, 135, 1);display:inline-block;vertical-align:2px;margin:0 6px;-webkit-transition:-webkit-transform .3s ease-in;transition:-webkit-transform .3s ease-in;-o-transition:transform .3s ease-in;transition:transform .3s ease-in, -webkit-transform .3s ease-in;}:host .step-verified > .step-dot{top:12px;-webkit-transition:all .6s ease-out;-o-transition:all .6s ease-out;transition:all .6s ease-out;}:host .step-verified.in > .step-dot{transform:scale(1) !important;top:-6px;left:-12px;width:38px;height:38px;}:host .step-verified > .step-dot::before{content:'';position:absolute;top:0;bottom:0;left:0;right:0;background-image:url("data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjBweCIgaGVpZ2h0PSIyM3B4IiB2aWV3Qm94PSIwIDAgMjAgMjMiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+CiAgICA8ZyBpZD0iVmVyaWZpY2F0aW9uIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj4KICAgICAgICA8ZyBpZD0iMyIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTI1NC4wMDAwMDAsIC00NzQuMDAwMDAwKSIgZmlsbD0iIzJBQjI3QiI+CiAgICAgICAgICAgIDxnIGlkPSJHcm91cCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMjQ4LjAwMDAwMCwgNDY5LjAwMDAwMCkiPgogICAgICAgICAgICAgICAgPHBhdGggZD0iTTE2LDUgTDYsOS4xODE4MTgxOCBMNiwxNS40NTQ1NDU1IEM2LDIxLjI1NjgxODIgMTAuMjY2NjY2NywyNi42ODI3MjczIDE2LDI4IEMyMS43MzMzMzMzLDI2LjY4MjcyNzMgMjYsMjEuMjU2ODE4MiAyNiwxNS40NTQ1NDU1IEwyNiw5LjE4MTgxODE4IEwxNiw1IEwxNiw1IFogTTksMTcuNzUzNzE1NSBMMTAuNTI3NSwxNi4yNTY5MDAyIEwxMy4zMzMzMzMzLDE4Ljk5NTc1MzcgTDIwLjQ3MjUsMTIgTDIyLDEzLjUwNzQzMSBMMTMuMzMzMzMzMywyMiBMOSwxNy43NTM3MTU1IFoiIGlkPSJTaGFwZSI+PC9wYXRoPgogICAgICAgICAgICA8L2c+CiAgICAgICAgPC9nPgogICAgPC9nPgo8L3N2Zz4=");background-repeat:no-repeat;background-position:center;opacity:0;-webkit-transition:opacity .3s ease-out .3s;-o-transition:opacity .3s ease-out .3s;transition:opacity .3s ease-out .3s;}:host .step-verified.in > .step-dot::before{opacity:1;}:host .step.step-verified > .step-dot::after{display:none;}:host .step-verified h4{color:rgba(42, 178, 123, 1);font-size:21px;letter-spacing:.08px;}:host .step-verified h4,
      :host .step-verified span{opacity:0;-webkit-transition:opacity .3s linear .3s;-o-transition:opacity .3s linear .3s;transition:opacity .3s linear .3s;}:host .step-verified.in h4,
      :host .step-verified.in span{opacity:1;}:host hr.sep{border:0;display:none;height:1px;background-color:#e0e0e0;width:100%;margin:20px 0;}:host.drag-on{-webkit-box-shadow:0 0 15px -5px dimgrey;box-shadow:0 0 15px -5px dimgrey;}:host.cf-mq-600 .main{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;}:host.cf-mq-600 .card-logo{max-width:35%;}:host.cf-mq-600 h2, h3{font-size:16px;line-height:1;}:host.cf-mq-600 li.sub-step .error p{font-size:12px;}:host.cf-mq-800 .card-logo img{max-width:100%;}:host.cf-mq-600 .cf-container .verification{margin:20px auto 0;}:host.cf-mq-600 .cf-container .card-title .view-record-link{display:none;}:host.cf-mq-600 .cf-container .main > .view-record-link{display:block;width:100%;padding:20px 0;text-align:center;margin-top:10px;}:host.cf-mq-600 .cf-container .main > .view-record-link span{font-size:16px;}</style></template></dom-module>
    </div>
    <dom-module id="credential-verifier"><template><style include="credential-verifier-styles"></style><section class="cf-container"><section class$="main drag {{_view}}"><template is="dom-if" if="{{_certificate}}"><div class="card"><div class="card-logo"><img src="[[_issuerLogo]]" alt="[[_issuer]]"></div><div class="card-info"><div class="card-title"><a href="[[_certificateLink]]" target="_blank"><h2>{{_certificateName}}</h2><span class="view-record-link">View Record <svg width="7" height="11" viewBox="0 0 7 11" xmlns="http://www.w3.org/2000/svg"><g stroke="#000" stroke-width="1.7" fill="none" fill-rule="evenodd" stroke-linecap="square"><path d="M1.9645 9.0355L5.5 5.5M1.9645 1.9645L5.5 5.5"></path></g></svg></span></a><h3>[[_recipient]]</h3></div><span>Issued [[_issueDate]] by [[_issuer]]</span></div></div><a href="[[_certificateLink]]" target="_blank" class="view-record-link"><span>View Record</span></a><div class="verification"><div class="progress"></div><ul class="steps"><template is="dom-repeat" as="step" index-as="stepIdx" items="[[_renderedSteps]]" filter="isStepReached" observe="status"><li class$="step [[step.status]] list-[[stepIdx]] out-[[step.status]]"><div class="error-bar"></div><div class="step-dot"></div><h4>[[step.label]]</h4><div class="loading-txt"><svg width="20" height="7" viewBox="0 0 120 30" xmlns="http://www.w3.org/2000/svg"><circle cx="15" cy="15" r="15"><animate attributeName="r" from="15" to="15" begin="0s" dur="0.8s" values="15;9;15" calcMode="linear" repeatCount="indefinite"></animate><animate attributeName="fill-opacity" from="1" to="1" begin="0s" dur="0.8s" values="1;.5;1" calcMode="linear" repeatCount="indefinite"></animate></circle><circle cx="60" cy="15" r="9" fill-opacity=".9"><animate attributeName="r" from="9" to="9" begin="0s" dur="0.8s" values="9;15;9" calcMode="linear" repeatCount="indefinite"></animate><animate attributeName="fill-opacity" from=".5" to=".5" begin="0s" dur="0.8s" values=".5;1;.5" calcMode="linear" repeatCount="indefinite"></animate></circle><circle cx="105" cy="15" r="15"><animate attributeName="r" from="15" to="15" begin="0s" dur="0.8s" values="15;9;15" calcMode="linear" repeatCount="indefinite"></animate><animate attributeName="fill-opacity" from="1" to="1" begin="0s" dur="0.8s" values="1;.5;1" calcMode="linear" repeatCount="indefinite"></animate></circle></svg></div><a href="javascript:;" on-tap="toggleSubSteps"><span data-idx$="[[stepIdx]]">{{getSubStepTogglerText(step.toggleSubSteps, step.subSteps.length)}}<div class="step-arrow"></div></span></a><ul class$="sub-steps sublist-[[stepIdx]]"><template is="dom-repeat" items$="{{step.subSteps}}"><li class$="sub-step [[item.status]]"><div class="step-dot"></div><span>[[item.label]]</span><div class="error"><span>[[item.errorTitle]]</span><p>[[item.errorMessage]]</p></div></li></template></ul>
        </li>
        </template><template is="dom-if" if="[[_showSuccess]]"><li class="step success step-verified"><div class="step-dot"></div><h4>Verified</h4><template is="dom-if" if="[[!_isMainnet]]"><span>This is a valid [[_network]] certificate</span><br></template><template is="dom-if" if="[[_transactionLink]]"><span><a href="[[_transactionLink]]" target="_blank">View Blockchain Transaction</a></span></template></li>
        </template>
        </ul>
        </div>
        </template><template is="dom-if" if="{{!_certificate}}"><div class="url-field"><input type="text" on-keyup="urlFieldChanged" id="certificate-json-url" placeholder="Credential URL"> <button on-tap="loadJsonUrl" disabled$="{{_verifyBtnDisabled]]"><template is="dom-if" if="{{_showSpinner}}"><svg class="lds-spinner" width="42px" height="100%" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" preserveAspectRatio="xMidYMid" style="background: none;"><g transform="rotate(0 50 50)"><rect x="47" y="24" rx="9.4" ry="4.8" width="6" height="12" fill="#ffffff"><animate attributeName="opacity" values="1;0" times="0;1" dur="1s" begin="-0.9166666666666666s" repeatCount="indefinite"></animate></rect></g><g transform="rotate(30 50 50)"><rect x="47" y="24" rx="9.4" ry="4.8" width="6" height="12" fill="#ffffff"><animate attributeName="opacity" values="1;0" times="0;1" dur="1s" begin="-0.8333333333333334s" repeatCount="indefinite"></animate></rect></g><g transform="rotate(60 50 50)"><rect x="47" y="24" rx="9.4" ry="4.8" width="6" height="12" fill="#ffffff"><animate attributeName="opacity" values="1;0" times="0;1" dur="1s" begin="-0.75s" repeatCount="indefinite"></animate></rect></g><g transform="rotate(90 50 50)"><rect x="47" y="24" rx="9.4" ry="4.8" width="6" height="12" fill="#ffffff"><animate attributeName="opacity" values="1;0" times="0;1" dur="1s" begin="-0.6666666666666666s" repeatCount="indefinite"></animate></rect></g><g transform="rotate(120 50 50)"><rect x="47" y="24" rx="9.4" ry="4.8" width="6" height="12" fill="#ffffff"><animate attributeName="opacity" values="1;0" times="0;1" dur="1s" begin="-0.5833333333333334s" repeatCount="indefinite"></animate></rect></g><g transform="rotate(150 50 50)"><rect x="47" y="24" rx="9.4" ry="4.8" width="6" height="12" fill="#ffffff"><animate attributeName="opacity" values="1;0" times="0;1" dur="1s" begin="-0.5s" repeatCount="indefinite"></animate></rect></g><g transform="rotate(180 50 50)"><rect x="47" y="24" rx="9.4" ry="4.8" width="6" height="12" fill="#ffffff"><animate attributeName="opacity" values="1;0" times="0;1" dur="1s" begin="-0.4166666666666667s" repeatCount="indefinite"></animate></rect></g><g transform="rotate(210 50 50)"><rect x="47" y="24" rx="9.4" ry="4.8" width="6" height="12" fill="#ffffff"><animate attributeName="opacity" values="1;0" times="0;1" dur="1s" begin="-0.3333333333333333s" repeatCount="indefinite"></animate></rect></g><g transform="rotate(240 50 50)"><rect x="47" y="24" rx="9.4" ry="4.8" width="6" height="12" fill="#ffffff"><animate attributeName="opacity" values="1;0" times="0;1" dur="1s" begin="-0.25s" repeatCount="indefinite"></animate></rect></g><g transform="rotate(270 50 50)"><rect x="47" y="24" rx="9.4" ry="4.8" width="6" height="12" fill="#ffffff"><animate attributeName="opacity" values="1;0" times="0;1" dur="1s" begin="-0.16666666666666666s" repeatCount="indefinite"></animate></rect></g><g transform="rotate(300 50 50)"><rect x="47" y="24" rx="9.4" ry="4.8" width="6" height="12" fill="#ffffff"><animate attributeName="opacity" values="1;0" times="0;1" dur="1s" begin="-0.08333333333333333s" repeatCount="indefinite"></animate></rect></g><g transform="rotate(330 50 50)"><rect x="47" y="24" rx="9.4" ry="4.8" width="6" height="12" fill="#ffffff"><animate attributeName="opacity" values="1;0" times="0;1" dur="1s" begin="0s" repeatCount="indefinite"></animate></rect></g></svg></template><template is="dom-if" if="{{!_showSpinner}}">Verify</template></button>
        </div>
        <div class="error"><span>{{_errorMsg}}</span></div>
        </template>
        <hr class="sep">
        </section>
        <footer class="drag"><template is="dom-if" if="{{!_certificate}}"><span><a href="javascript:;" class="file-selector">Choose JSON file<input type="file" id="file-selector" accept="application/json" on-change="setFile"> </a><span>(you can also drag &amp; drop your file).</span></span></template><template is="dom-if" if="{{_certificate}}"><span><a href="javascript:;" on-tap="resetStandalone">Verify another record</a></span></template>
            <div class="blockcerts-logo"><a href="http://www.blockcerts.org" target="_blank"><svg width="113px" height="16px" viewBox="0 0 113 16" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><defs></defs><g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd" fill-opacity="0.37"><g id="blockcerts-logo" transform="translate(0.000000, -2.000000)" fill="#162837" fill-rule="nonzero"><path d="M19.5,5.06256945 L22.9958467,5.06256945 C24.617584,5.06256945 25.789567,5.29884552 26.5118308,5.77140473 C27.2340946,6.24396395 27.5952211,6.99038151 27.5952211,8.01067982 C27.5952211,8.69803869 27.4180141,9.26993416 27.0635947,9.72638339 C26.7091752,10.1828327 26.1990337,10.4701229 25.5331548,10.5882627 L25.5331548,10.6688121 C26.3601335,10.8245419 26.9682758,11.1319693 27.3576002,11.5911035 C27.7469246,12.0502377 27.9415838,12.6718049 27.9415838,13.4558236 C27.9415838,14.5137118 27.5724025,15.3420205 26.8340287,15.9407745 C26.0956549,16.5395285 25.0686595,16.8389011 23.7530117,16.8389011 L19.5,16.8389011 L19.5,5.06256945 Z M21.4251322,9.92775706 L23.2777698,9.92775706 C24.0832685,9.92775706 24.6712737,9.80022169 25.0418031,9.54514712 C25.4123325,9.29007254 25.5975944,8.85645225 25.5975944,8.24427327 C25.5975944,7.69116419 25.3975653,7.29110585 24.9975009,7.04408626 C24.5974366,6.79706667 23.9624447,6.67355873 23.0925061,6.67355873 L21.4251322,6.67355873 L21.4251322,9.92775706 Z M21.4251322,11.4904167 L21.4251322,15.2198568 L23.4710886,15.2198568 C24.2765872,15.2198568 24.8847296,15.0654719 25.2955339,14.7566974 C25.7063383,14.4479229 25.9117373,13.9606036 25.9117373,13.2947247 C25.9117373,12.6825457 25.7023108,12.2287882 25.2834515,11.9334387 C24.8645922,11.6380892 24.2282578,11.4904167 23.3744292,11.4904167 L21.4251322,11.4904167 Z M29.8953916,16.8389011 L29.8953916,5.06256945 L31.8205237,5.06256945 L31.8205237,15.1876371 L36.8065356,15.1876371 L36.8065356,16.8389011 L29.8953916,16.8389011 Z M48.4665536,10.9346254 C48.4665536,12.8517122 47.9872891,14.3418624 47.0287457,15.4051206 C46.0702024,16.4683789 44.7129575,17 42.9569704,17 C41.1795033,17 39.8142036,16.4724063 38.8610302,15.417203 C37.9078567,14.3619998 37.4312772,12.8624522 37.4312772,10.9185155 C37.4312772,8.97457869 37.9105417,7.48174356 38.8690851,6.43996528 C39.8276285,5.39818701 41.1956132,4.87730568 42.9730803,4.87730568 C44.7236973,4.87730568 46.0769148,5.40624187 47.0327734,6.46413012 C47.9886317,7.52201836 48.4665536,9.01216855 48.4665536,10.9346254 Z M39.4772336,10.9346254 C39.4772336,12.384523 39.7698937,13.4840121 40.3552227,14.2331259 C40.9405517,14.9822397 41.8077923,15.3567909 42.9569704,15.3567909 C44.1007786,15.3567909 44.9639915,14.9862671 45.5466357,14.2452083 C46.1292796,13.5041496 46.4205973,12.4006329 46.4205973,10.9346254 C46.4205973,9.49009776 46.1319648,8.39463599 45.5546906,7.64820724 C44.9774165,6.90177847 44.1168884,6.52856969 42.9730803,6.52856969 C41.8185322,6.52856969 40.9472642,6.90177847 40.3592502,7.64820724 C39.7712361,8.39463599 39.4772336,9.49009776 39.4772336,10.9346254 Z M55.5110875,6.54467959 C54.4048694,6.54467959 53.5349439,6.93668306 52.9012851,7.72070175 C52.267626,8.50472046 51.9508013,9.58675743 51.9508013,10.9668451 C51.9508013,12.4113727 52.2555437,13.5041496 52.8650377,14.2452083 C53.4745317,14.9862671 54.3565394,15.3567909 55.5110875,15.3567909 C56.0104969,15.3567909 56.4937888,15.3071193 56.960978,15.2077744 C57.4281673,15.1084296 57.9141441,14.9808942 58.4189233,14.8251645 L58.4189233,16.4764285 C57.4952848,16.8254779 56.4481523,17 55.2774942,17 C53.5537269,17 52.230044,16.4777762 51.3064055,15.4333129 C50.3827671,14.3888497 49.9209548,12.894672 49.9209548,10.9507353 C49.9209548,9.72637727 50.1451485,8.65508014 50.5935427,7.73681166 C51.041937,6.81854317 51.6903538,6.11508489 52.5388124,5.6264157 C53.3872709,5.13774651 54.3833893,4.89341558 55.5271976,4.89341558 C56.7300756,4.89341558 57.841647,5.14580137 58.8619454,5.65058054 L58.1692199,7.25351487 C57.7718405,7.06556518 57.3516451,6.90044043 56.9086208,6.75813566 C56.4655966,6.6158309 55.9997568,6.54467959 55.5110875,6.54467959 Z M69.4506556,16.8389011 L67.2194355,16.8389011 L63.522215,11.5065265 L62.3864676,12.4328454 L62.3864676,16.8389011 L60.4613353,16.8389011 L60.4613353,5.06256945 L62.3864676,5.06256945 L62.3864676,10.684922 C62.9127266,10.0405231 63.4362929,9.42029843 63.9571822,8.82422942 L67.1388858,5.06256945 L69.3298314,5.06256945 C67.2731248,7.47906546 65.7990842,9.20012177 64.9076657,10.2257901 L69.4506556,16.8389011 Z M75.6494201,5.63447064 C74.1726725,5.63447064 73.0100869,6.10702277 72.1616284,7.05214121 C71.3131696,7.99725964 70.8889467,9.29140808 70.8889467,10.9346254 C70.8889467,12.6154326 71.2890051,13.9203209 72.0891337,14.8493293 C72.8892625,15.7783378 74.0330533,16.242835 75.5205409,16.242835 C76.5086192,16.242835 77.4161342,16.1166421 78.2431127,15.8642525 L78.2431127,16.5891977 C77.4644642,16.8630673 76.4925103,17 75.3272222,17 C73.673265,17 72.3710617,16.4656939 71.4205732,15.3970657 C70.4700848,14.3284374 69.9948476,12.8356023 69.9948476,10.9185155 C69.9948476,9.72100746 70.2217264,8.66582002 70.6754907,7.75292154 C71.129255,6.84002305 71.781699,6.13522229 72.6328427,5.63849812 C73.4839862,5.14177394 74.4733922,4.89341558 75.6010904,4.89341558 C76.7502684,4.89341558 77.7786064,5.108212 78.6861348,5.53781129 L78.355882,6.27886635 C77.4966834,5.84926707 76.5945384,5.63447064 75.6494201,5.63447064 Z M86.8100316,16.8389011 L80.3741293,16.8389011 L80.3741293,5.06256945 L86.8100316,5.06256945 L86.8100316,5.81973441 L81.1957339,5.81973441 L81.1957339,10.2741198 L86.4958886,10.2741198 L86.4958886,11.0312847 L81.1957339,11.0312847 L81.1957339,16.0817361 L86.8100316,16.0817361 L86.8100316,16.8389011 Z M89.8029274,11.7079002 L89.8029274,16.8389011 L88.9813228,16.8389011 L88.9813228,5.06256945 L91.7844442,5.06256945 C93.2450817,5.06256945 94.3244339,5.33240746 95.0225327,5.87209156 C95.7206316,6.41177567 96.0696758,7.22397464 96.0696758,8.30871284 C96.0696758,9.09810153 95.8615917,9.76397044 95.4454173,10.3063395 C95.0292429,10.8487086 94.396936,11.2380272 93.5484774,11.4743068 L96.7462912,16.8389011 L95.7635877,16.8389011 L92.726873,11.7079002 L89.8029274,11.7079002 Z M89.8029274,10.9990649 L92.0502574,10.9990649 C93.0437059,10.9990649 93.814288,10.7775561 94.3620271,10.3345318 C94.909766,9.8915076 95.1836315,9.23772099 95.1836315,8.37315242 C95.1836315,7.4763639 94.9151361,6.82391977 94.378137,6.41580044 C93.8411379,6.00768112 92.9658423,5.80362452 91.7522245,5.80362452 L89.8029274,5.80362452 L89.8029274,10.9990649 Z M101.358231,16.8389011 L100.528572,16.8389011 L100.528572,5.8358443 L96.7024723,5.8358443 L96.7024723,5.06256945 L105.184331,5.06256945 L105.184331,5.8358443 L101.358231,5.8358443 L101.358231,16.8389011 Z M112.9377,13.8021863 C112.9377,14.7848947 112.576573,15.5635317 111.85431,16.1381207 C111.132046,16.7127098 110.172174,17 108.974666,17 C107.535509,17 106.431992,16.8415876 105.664083,16.5247582 L105.664083,15.7031536 C106.512542,16.062943 107.594579,16.242835 108.910227,16.242835 C109.876825,16.242835 110.64338,16.0213262 111.209914,15.5783019 C111.776448,15.1352777 112.059711,14.5539849 112.059711,13.8344061 C112.059711,13.3886968 111.965737,13.0195154 111.777788,12.7268509 C111.589838,12.4341864 111.283753,12.1670334 110.859524,11.9253838 C110.435294,11.6837342 109.812385,11.4232935 108.990776,11.144054 C107.787898,10.7305647 106.956904,10.2835196 106.49777,9.80290539 C106.038636,9.32229119 105.809072,8.68192935 105.809072,7.88180069 C105.809072,7.00112214 106.154089,6.28289661 106.844133,5.72710253 C107.534177,5.17130845 108.421555,4.89341558 109.506293,4.89341558 C110.612511,4.89341558 111.651589,5.10284209 112.623557,5.52170139 L112.325524,6.23053668 C111.348186,5.82241735 110.413821,5.61836075 109.522403,5.61836075 C108.652464,5.61836075 107.959746,5.8197324 107.444226,6.22248173 C106.928707,6.62523106 106.670952,7.17296194 106.670952,7.86569079 C106.670952,8.30066007 106.750158,8.65775912 106.908573,8.93699866 C107.066987,9.2162382 107.326085,9.46728151 107.685875,9.69013615 C108.045664,9.91299077 108.663204,10.1801438 109.538513,10.4916033 C110.456781,10.8084328 111.146815,11.1158602 111.608634,11.4138947 C112.070453,11.7119292 112.407415,12.0502335 112.619529,12.4288179 C112.831644,12.8074023 112.9377,13.2651872 112.9377,13.8021863 Z" id="BLOCKCERTS"></path><path d="M10.9580699,13.4113689 C10.9580699,13.8630088 10.5919434,14.2291353 10.1403035,14.2291353 L0.81776652,14.2291353 C0.366126608,14.2291353 1.20000012e-07,13.8630088 1.2000001e-07,13.4113689 C1.2000001e-07,12.959729 0.366126608,12.5936025 0.81776652,12.5936025 L10.1403035,12.5936025 C10.5919434,12.5936025 10.9580699,12.959729 10.9580699,13.4113689 Z" id="Rectangle"></path><path d="M14.2291354,13.411369 C14.2291354,13.8630089 13.8630089,14.2291354 13.411369,14.2291354 C12.9597291,14.2291354 12.5936026,13.8630089 12.5936026,13.411369 C12.5936026,12.9597291 12.9597291,12.5936026 13.411369,12.5936026 C13.8630089,12.5936026 14.2291354,12.9597291 14.2291354,13.411369 Z" id="Rectangle"></path><path d="M9.4860908,16.6824348 C9.4860908,17.1340748 9.11996431,17.5002012 8.6683244,17.5002012 C8.21668449,17.5002012 7.850558,17.1340748 7.850558,16.6824348 C7.850558,16.2307949 8.21668449,15.8646684 8.6683244,15.8646684 C9.11996431,15.8646684 9.4860908,16.2307949 9.4860908,16.6824348 Z" id="Rectangle"></path><path d="M14.2291356,6.869238 C14.2291356,7.32087791 13.8630092,7.6870044 13.4113692,7.6870044 C12.9597293,7.6870044 12.5936028,7.32087791 12.5936028,6.869238 C12.5936028,6.41759809 12.9597293,6.0514716 13.4113692,6.0514716 C13.8630092,6.0514716 14.2291356,6.41759809 14.2291356,6.869238 Z" id="Rectangle"></path><path d="M1.63553264,6.8692384 C1.63553264,7.32087831 1.26940615,7.6870048 0.81776624,7.6870048 C0.366126328,7.6870048 -1.60000013e-07,7.32087831 -1.60000013e-07,6.8692384 C-1.60000013e-07,6.41759849 0.366126328,6.051472 0.81776624,6.051472 C1.26940615,6.051472 1.63553264,6.41759849 1.63553264,6.8692384 Z" id="Rectangle"></path><rect id="Rectangle" transform="translate(7.196344, 3.598172) rotate(90.000000) translate(-7.196344, -3.598172) " x="6.37857744" y="2.78040592" width="1.6355328" height="1.6355328" rx="0.8177664"></rect><path d="M6.37857804,10.1403025 C6.37857804,10.5919424 6.01245155,10.9580689 5.56081164,10.9580689 C5.10917173,10.9580689 4.74304524,10.5919424 4.74304524,10.1403025 C4.74304524,9.68866261 5.10917173,9.32253612 5.56081164,9.32253612 C6.01245155,9.32253612 6.37857804,9.68866261 6.37857804,10.1403025 Z" id="Rectangle"></path><path d="M14.2291348,3.5981724 C14.2291348,4.04981231 13.8630083,4.4159388 13.4113684,4.4159388 L10.4674093,4.4159388 C10.0157694,4.4159388 9.64964292,4.04981231 9.64964292,3.5981724 C9.64964292,3.14653249 10.0157694,2.780406 10.4674093,2.780406 L13.4113684,2.780406 C13.8630083,2.780406 14.2291348,3.14653249 14.2291348,3.5981724 Z" id="Rectangle"></path><rect id="Rectangle" transform="translate(2.371523, 3.598172) rotate(90.000000) translate(-2.371523, -3.598172) " x="1.55375644" y="1.226649" width="1.6355328" height="4.74304512" rx="0.8177664"></rect><path d="M14.229135,10.140303 C14.229135,10.5919429 13.8630085,10.9580694 13.4113686,10.9580694 L8.83187672,10.9580694 C8.38023681,10.9580694 8.01411032,10.5919429 8.01411032,10.140303 C8.01411032,9.68866309 8.38023681,9.3225366 8.83187672,9.3225366 L13.4113686,9.3225366 C13.8630085,9.3225366 14.229135,9.68866309 14.229135,10.140303 Z" id="Rectangle"></path><path d="M3.1075118,10.1403032 C3.1075118,10.5919431 2.74138531,10.9580696 2.2897454,10.9580696 L0.81776588,10.9580696 C0.366125968,10.9580696 -5.20000015e-07,10.5919431 -5.20000015e-07,10.1403032 C-5.20000015e-07,9.68866325 0.366125968,9.32253676 0.81776588,9.32253676 L2.2897454,9.32253676 C2.74138531,9.32253676 3.1075118,9.68866325 3.1075118,10.1403032 Z" id="Rectangle"></path><path d="M14.2291356,16.6824352 C14.2291356,17.1340751 13.8630091,17.5002016 13.4113692,17.5002016 L11.9393897,17.5002016 C11.4877498,17.5002016 11.1216233,17.1340751 11.1216233,16.6824352 C11.1216233,16.2307953 11.4877498,15.8646688 11.9393897,15.8646688 L13.4113692,15.8646688 C13.8630091,15.8646688 14.2291356,16.2307953 14.2291356,16.6824352 Z" id="Rectangle"></path><path d="M6.2150248,16.6824353 C6.2150248,17.1340752 5.84889831,17.5002017 5.3972584,17.5002017 L0.81776656,17.5002017 C0.366126648,17.5002017 1.59999985e-07,17.1340752 1.59999985e-07,16.6824353 C1.59999985e-07,16.2307954 0.366126648,15.8646689 0.81776656,15.8646689 L5.3972584,15.8646689 C5.84889831,15.8646689 6.2150248,16.2307954 6.2150248,16.6824353 Z" id="Rectangle"></path><path d="M10.9580703,6.86923768 C10.9580703,7.32087759 10.5919438,7.68700408 10.1403039,7.68700408 L4.08883256,7.68700408 C3.63719265,7.68700408 3.27106616,7.32087759 3.27106616,6.86923768 C3.27106616,6.41759777 3.63719265,6.05147128 4.08883256,6.05147128 L10.1403039,6.05147128 C10.5919438,6.05147128 10.9580703,6.41759777 10.9580703,6.86923768 Z" id="Rectangle"></path></g></g></svg></a></div>
        </footer>
        </section>
        </template>
        <script>
            "use strict";
            var _createClass = function() {
                function defineProperties(target, props) {
                    for (var i = 0, descriptor; i < props.length; i++) {
                        descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || !1;
                        descriptor.configurable = !0;
                        if ("value" in descriptor) descriptor.writable = !0;
                        Object.defineProperty(target, descriptor.key, descriptor)
                    }
                }
                return function(Constructor, protoProps, staticProps) {
                    if (protoProps) defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) defineProperties(Constructor, staticProps);
                    return Constructor
                }
            }();

            function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function")
                }
            }
            var Tracker = function() {
                function Tracker(issuerData, baseHref, assertionUID, origin) {
                    _classCallCheck(this, Tracker);
                    this.origin = origin || "web-viewer";
                    this.baseUrl = issuerData.analyticsURL ? issuerData.analyticsURL : baseHref.split("/certificate/")[0] + "/api/event/certificate";
                    this.assertionUID = assertionUID
                }
                _createClass(Tracker, [{
                    key: "track",
                    value: function(action, socialNetwork) {
                        if (!this.assertionUID || !action || "" === action) {
                            return
                        }
                        socialNetwork = socialNetwork || "";
                        var xhr = new XMLHttpRequest,
                            params = {
                                key: this.assertionUID,
                                action: action,
                                metadata: {
                                    application: socialNetwork,
                                    platform: this.origin
                                }
                            };
                        xhr.addEventListener("load", function() {});
                        xhr.addEventListener("error", function(event) {
                            console.error("Failed calling event endpoint", event)
                        });
                        xhr.open("POST", this.baseUrl);
                        xhr.setRequestHeader("Content-Type", "application/json; charset=utf-8");
                        xhr.send(JSON.stringify(params))
                    }
                }]);
                return Tracker
            }();
        </script>
        <script>
            (function(f) {
                if ("object" === typeof exports && "undefined" !== typeof module) {
                    module.exports = f()
                } else if ("function" === typeof define && define.amd) {
                    define([], f)
                } else {
                    var g;
                    if ("undefined" !== typeof window) {
                        g = window
                    } else if ("undefined" !== typeof global) {
                        g = global
                    } else if ("undefined" !== typeof self) {
                        g = self
                    } else {
                        g = this
                    }
                    g.Verifier = f()
                }
            })(function() {
                var _MathPI = Math.PI,
                    _Stringprototype = String.prototype,
                    _Mathsqrt = Math.sqrt,
                    _Mathround = Math.round,
                    _Mathceil = Math.ceil,
                    _Mathexp = Math.exp,
                    _Mathexpm = Math.expm1,
                    _StringfromCharCode = String.fromCharCode,
                    _Mathabs = Math.abs,
                    _Mathpow = Math.pow,
                    _Mathlog = Math.log,
                    _MathLN = Math.LN2,
                    _Mathmax = Math.max,
                    _Mathfloor = Math.floor,
                    _Mathmin = Math.min,
                    define;
                return function() {
                    function e(t, n, r) {
                        function s(o, u) {
                            if (!n[o]) {
                                if (!t[o]) {
                                    var a = "function" == typeof require && require;
                                    if (!u && a) return a(o, !0);
                                    if (i) return i(o, !0);
                                    var f = new Error("Cannot find module '" + o + "'");
                                    throw f.code = "MODULE_NOT_FOUND", f
                                }
                                var l = n[o] = {
                                    exports: {}
                                };
                                t[o][0].call(l.exports, function(e) {
                                    var n = t[o][1][e];
                                    return s(n ? n : e)
                                }, l, l.exports, e, t, n, r)
                            }
                            return n[o].exports
                        }
                        for (var i = "function" == typeof require && require, o = 0; o < r.length; o++) s(r[o]);
                        return s
                    }
                    return e
                }()({
                    1: [function(require, module) {
                        "use strict";
                        var _ref;

                        function _defineProperty(obj, key, value) {
                            if (key in obj) {
                                Object.defineProperty(obj, key, {
                                    value: value,
                                    enumerable: !0,
                                    configurable: !0,
                                    writable: !0
                                })
                            } else {
                                obj[key] = value
                            }
                            return obj
                        }

                        function _classCallCheck(instance, Constructor) {
                            if (!(instance instanceof Constructor)) {
                                throw new TypeError("Cannot call a class as a function")
                            }
                        }

                        function _possibleConstructorReturn(self, call) {
                            if (!self) {
                                throw new ReferenceError("this hasn't been initialised - super() hasn't been called")
                            }
                            return call && ("object" === typeof call || "function" === typeof call) ? call : self
                        }

                        function _inherits(subClass, superClass) {
                            if ("function" !== typeof superClass && null !== superClass) {
                                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass)
                            }
                            subClass.prototype = Object.create(superClass && superClass.prototype, {
                                constructor: {
                                    value: subClass,
                                    enumerable: !1,
                                    writable: !0,
                                    configurable: !0
                                }
                            });
                            if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass
                        }
                        var Status = {
                                getTransactionId: "getTransactionId",
                                computingLocalHash: "computingLocalHash",
                                fetchingRemoteHash: "fetchingRemoteHash",
                                gettingIssuerProfile: "gettingIssuerProfile",
                                parsingIssuerKeys: "parsingIssuerKeys",
                                comparingHashes: "comparingHashes",
                                checkingMerkleRoot: "checkingMerkleRoot",
                                checkingReceipt: "checkingReceipt",
                                checkingIssuerSignature: "checkingIssuerSignature",
                                checkingAuthenticity: "checkingAuthenticity",
                                checkingRevokedStatus: "checkingRevokedStatus",
                                checkingExpiresDate: "checkingExpiresDate",
                                success: "success",
                                failure: "failure",
                                starting: "starting",
                                mockSuccess: "mockSuccess",
                                final: "final"
                            },
                            BlockchainRawTransactionIdPlaceholder = "{TRANSACTION_ID}",
                            verboseMessageMap = {};
                        verboseMessageMap[Status.getTransactionId] = "Getting transaction ID";
                        verboseMessageMap[Status.computingLocalHash] = "Computing Local Hash";
                        verboseMessageMap[Status.fetchingRemoteHash] = "Fetching remote hash";
                        verboseMessageMap[Status.gettingIssuerProfile] = "Getting issuer profile";
                        verboseMessageMap[Status.parsingIssuerKeys] = "Parsing issuer keys";
                        verboseMessageMap[Status.comparingHashes] = "Comparing Hashes";
                        verboseMessageMap[Status.checkingMerkleRoot] = "Checking Merkle Root";
                        verboseMessageMap[Status.checkingReceipt] = "Checking Receipt";
                        verboseMessageMap[Status.checkingIssuerSignature] = "Checking Issuer Signature";
                        verboseMessageMap[Status.checkingAuthenticity] = "Checking Authenticity";
                        verboseMessageMap[Status.checkingRevokedStatus] = "Checking Revoked Status";
                        verboseMessageMap[Status.checkingExpiresDate] = "Checking Expires Date";
                        verboseMessageMap[Status.success] = "Success";
                        verboseMessageMap[Status.failure] = "Failure";
                        verboseMessageMap[Status.starting] = "Starting";
                        verboseMessageMap[Status.mockSuccess] = "mockSuccess";
                        verboseMessageMap[Status.final] = "Final";
                        var VerifierError = function(_Error) {
                            _inherits(VerifierError, _Error);

                            function VerifierError(stepCode, message) {
                                _classCallCheck(this, VerifierError);
                                var _this = _possibleConstructorReturn(this, (VerifierError.__proto__ || Object.getPrototypeOf(VerifierError)).call(this, message));
                                _this.stepCode = stepCode;
                                return _this
                            }
                            return VerifierError
                        }(Error);
                        module.exports = {
                            CertificateVersion: {
                                v1_1: "1.1",
                                v1_2: "1.2",
                                v2_0: "2.0"
                            },
                            Blockchain: {
                                bitcoin: "bitcoin",
                                testnet: "testnet",
                                regtest: "regtest",
                                mocknet: "mocknet",
                                ethmain: "ethmain",
                                ethropst: "ethropst",
                                ethtest: "ethtest"
                            },
                            BlockchainRawTransactionUrl: {
                                bitcoin: "https://blockchain.info/rawtx/" + BlockchainRawTransactionIdPlaceholder,
                                testnet: "https://testnet.blockchain.info/rawtx/" + BlockchainRawTransactionIdPlaceholder,
                                regtest: "",
                                mocknet: "",
                                ethmain: "https://etherscan.io/tx/" + BlockchainRawTransactionIdPlaceholder,
                                ethropst: "https://ropsten.etherscan.io/getRawTx?tx=" + BlockchainRawTransactionIdPlaceholder,
                                ethtest: ""
                            },
                            BlockchainTransactionUrl: {
                                bitcoin: "https://blockchain.info/tx/" + BlockchainRawTransactionIdPlaceholder,
                                testnet: "https://testnet.blockchain.info/tx/" + BlockchainRawTransactionIdPlaceholder,
                                regtest: "",
                                mocknet: "",
                                ethmain: "https://etherscan.io/tx/" + BlockchainRawTransactionIdPlaceholder,
                                ethropst: "https://ropsten.etherscan.io/tx/" + BlockchainRawTransactionIdPlaceholder,
                                ethtest: ""
                            },
                            BlockchainRawTransactionIdPlaceholder: BlockchainRawTransactionIdPlaceholder,
                            ChainSignatureValue: {
                                bitcoin: "bitcoinMainnet",
                                testnet: "bitcoinTestnet",
                                regtest: "bitcoinRegtest",
                                ethmain: "ethereumMainnet",
                                ethropst: "ethereumRopsten",
                                ethtest: "ethereumTestnet",
                                mocknet: "mockchain"
                            },
                            VerifierError: VerifierError,
                            SecurityContextUrl: "https://w3id.org/security/v1",
                            Url: {
                                blockCypherUrl: "https://api.blockcypher.com/v1/btc/main/txs/",
                                blockCypherTestUrl: "https://api.blockcypher.com/v1/btc/test3/txs/",
                                chainSoUrl: "https://chain.so/api/v2/get_tx/BTC/",
                                chainSoTestUrl: "https://chain.so/api/v2/get_tx/BTCTEST/",
                                etherScanMainUrl: "https://api.etherscan.io/api?module=proxy",
                                etherScanRopstenUrl: "https://api-ropsten.etherscan.io/api?module=proxy"
                            },
                            generateRevocationReason: function(reason) {
                                reason = reason.trim();
                                reason = 0 < reason.length ? " Reason given: " + reason + ("." !== reason.slice(-1) ? "." : "") : "";
                                return "This certificate has been revoked by the issuer." + reason
                            },
                            Status: Status,
                            getVerboseMessage: function(status) {
                                return verboseMessageMap[status]
                            },
                            MininumConfirmations: 1,
                            MinimumBlockchainExplorers: 1,
                            Race: !1,
                            CheckForUnmappedFields: !0,
                            PublicKey: "ecdsa-koblitz-pubkey:1",
                            Contexts: {
                                obi: {
                                    "@context": {
                                        id: "@id",
                                        type: "@type",
                                        extensions: "https://w3id.org/openbadges/extensions#",
                                        obi: "https://w3id.org/openbadges#",
                                        validation: "obi:validation",
                                        cred: "https://w3id.org/credentials#",
                                        dc: "http://purl.org/dc/terms/",
                                        schema: "http://schema.org/",
                                        sec: "https://w3id.org/security#",
                                        xsd: "http://www.w3.org/2001/XMLSchema#",
                                        AlignmentObject: "schema:AlignmentObject",
                                        CryptographicKey: "sec:Key",
                                        Endorsement: "cred:Credential",
                                        Assertion: "obi:Assertion",
                                        BadgeClass: "obi:BadgeClass",
                                        Criteria: "obi:Criteria",
                                        Evidence: "obi:Evidence",
                                        Extension: "obi:Extension",
                                        FrameValidation: "obi:FrameValidation",
                                        IdentityObject: "obi:IdentityObject",
                                        Image: "obi:Image",
                                        HostedBadge: "obi:HostedBadge",
                                        hosted: "obi:HostedBadge",
                                        Issuer: "obi:Issuer",
                                        Profile: "obi:Profile",
                                        RevocationList: "obi:RevocationList",
                                        SignedBadge: "obi:SignedBadge",
                                        signed: "obi:SignedBadge",
                                        TypeValidation: "obi:TypeValidation",
                                        VerificationObject: "obi:VerificationObject",
                                        author: {
                                            "@id": "schema:author",
                                            "@type": "@id"
                                        },
                                        caption: {
                                            "@id": "schema:caption"
                                        },
                                        claim: {
                                            "@id": "cred:claim",
                                            "@type": "@id"
                                        },
                                        created: {
                                            "@id": "dc:created",
                                            "@type": "xsd:dateTime"
                                        },
                                        creator: {
                                            "@id": "dc:creator",
                                            "@type": "@id"
                                        },
                                        description: {
                                            "@id": "schema:description"
                                        },
                                        email: {
                                            "@id": "schema:email"
                                        },
                                        endorsement: {
                                            "@id": "cred:credential",
                                            "@type": "@id"
                                        },
                                        expires: {
                                            "@id": "sec:expiration",
                                            "@type": "xsd:dateTime"
                                        },
                                        genre: {
                                            "@id": "schema:genre"
                                        },
                                        image: {
                                            "@id": "schema:image",
                                            "@type": "@id"
                                        },
                                        name: {
                                            "@id": "schema:name"
                                        },
                                        owner: {
                                            "@id": "sec:owner",
                                            "@type": "@id"
                                        },
                                        publicKey: {
                                            "@id": "sec:publicKey",
                                            "@type": "@id"
                                        },
                                        publicKeyPem: {
                                            "@id": "sec:publicKeyPem"
                                        },
                                        related: {
                                            "@id": "dc:relation",
                                            "@type": "@id"
                                        },
                                        startsWith: {
                                            "@id": "http://purl.org/dqm-vocabulary/v1/dqm#startsWith"
                                        },
                                        tags: {
                                            "@id": "schema:keywords"
                                        },
                                        targetDescription: {
                                            "@id": "schema:targetDescription"
                                        },
                                        targetFramework: {
                                            "@id": "schema:targetFramework"
                                        },
                                        targetName: {
                                            "@id": "schema:targetName"
                                        },
                                        targetUrl: {
                                            "@id": "schema:targetUrl"
                                        },
                                        telephone: {
                                            "@id": "schema:telephone"
                                        },
                                        url: {
                                            "@id": "schema:url",
                                            "@type": "@id"
                                        },
                                        version: {
                                            "@id": "schema:version"
                                        },
                                        alignment: {
                                            "@id": "obi:alignment",
                                            "@type": "@id"
                                        },
                                        allowedOrigins: {
                                            "@id": "obi:allowedOrigins"
                                        },
                                        audience: {
                                            "@id": "obi:audience"
                                        },
                                        badge: {
                                            "@id": "obi:badge",
                                            "@type": "@id"
                                        },
                                        criteria: {
                                            "@id": "obi:criteria",
                                            "@type": "@id"
                                        },
                                        endorsementComment: {
                                            "@id": "obi:endorsementComment"
                                        },
                                        evidence: {
                                            "@id": "obi:evidence",
                                            "@type": "@id"
                                        },
                                        hashed: {
                                            "@id": "obi:hashed",
                                            "@type": "xsd:boolean"
                                        },
                                        identity: {
                                            "@id": "obi:identityHash"
                                        },
                                        issuedOn: {
                                            "@id": "obi:issueDate",
                                            "@type": "xsd:dateTime"
                                        },
                                        issuer: {
                                            "@id": "obi:issuer",
                                            "@type": "@id"
                                        },
                                        narrative: {
                                            "@id": "obi:narrative"
                                        },
                                        recipient: {
                                            "@id": "obi:recipient",
                                            "@type": "@id"
                                        },
                                        revocationList: {
                                            "@id": "obi:revocationList",
                                            "@type": "@id"
                                        },
                                        revocationReason: {
                                            "@id": "obi:revocationReason"
                                        },
                                        revoked: {
                                            "@id": "obi:revoked",
                                            "@type": "xsd:boolean"
                                        },
                                        revokedAssertions: {
                                            "@id": "obi:revoked"
                                        },
                                        salt: {
                                            "@id": "obi:salt"
                                        },
                                        targetCode: {
                                            "@id": "obi:targetCode"
                                        },
                                        uid: {
                                            "@id": "obi:uid"
                                        },
                                        validatesType: "obi:validatesType",
                                        validationFrame: "obi:validationFrame",
                                        validationSchema: "obi:validationSchema",
                                        verification: {
                                            "@id": "obi:verify",
                                            "@type": "@id"
                                        },
                                        verificationProperty: {
                                            "@id": "obi:verificationProperty"
                                        },
                                        verify: "verification"
                                    }
                                },
                                blockcerts: {
                                    "@context": {
                                        id: "@id",
                                        type: "@type",
                                        bc: "https://w3id.org/blockcerts#",
                                        obi: "https://w3id.org/openbadges#",
                                        cp: "https://w3id.org/chainpoint#",
                                        schema: "http://schema.org/",
                                        sec: "https://w3id.org/security#",
                                        xsd: "http://www.w3.org/2001/XMLSchema#",
                                        MerkleProof2017: "sec:MerkleProof2017",
                                        RecipientProfile: "bc:RecipientProfile",
                                        SignatureLine: "bc:SignatureLine",
                                        MerkleProofVerification2017: "bc:MerkleProofVerification2017",
                                        recipientProfile: "bc:recipientProfile",
                                        signatureLines: "bc:signatureLines",
                                        introductionUrl: {
                                            "@id": "bc:introductionUrl",
                                            "@type": "@id"
                                        },
                                        subtitle: "bc:subtitle",
                                        jobTitle: "schema:jobTitle",
                                        creator: {
                                            "@id": "dc:creator",
                                            "@type": "@id"
                                        },
                                        expires: {
                                            "@id": "sec:expiration",
                                            "@type": "xsd:dateTime"
                                        },
                                        revoked: {
                                            "@id": "sec:expiration",
                                            "@type": "xsd:dateTime"
                                        },
                                        CryptographicKey: "sec:Key",
                                        signature: "sec:signature",
                                        verification: "bc:verification",
                                        publicKeys: "bc:publicKeys",
                                        ChainpointSHA256v2: "cp:ChainpointSHA256v2",
                                        BTCOpReturn: "cp:BTCOpReturn",
                                        targetHash: "cp:targetHash",
                                        merkleRoot: "cp:merkleRoot",
                                        proof: "cp:proof",
                                        anchors: "cp:anchors",
                                        sourceId: "cp:sourceId",
                                        right: "cp:right",
                                        left: "cp:left"
                                    },
                                    "obi:validation": [{
                                        "obi:validatesType": "RecipientProfile",
                                        "obi:validationSchema": "https://w3id.org/blockcerts/schema/2.0-alpha/recipientSchema.json"
                                    }, {
                                        "obi:validatesType": "SignatureLine",
                                        "obi:validationSchema": "https://w3id.org/blockcerts/schema/2.0-alpha/signatureLineSchema.json"
                                    }, {
                                        "obi:validatesType": "MerkleProof2017",
                                        "obi:validationSchema": "https://w3id.org/blockcerts/schema/2.0-alpha/merkleProof2017Schema.json"
                                    }]
                                },
                                blockcertsv1_2: {
                                    "@context": [(_ref = {
                                        id: "@id",
                                        type: "@type",
                                        bc: "https://w3id.org/blockcerts#",
                                        obi: "https://w3id.org/openbadges#",
                                        cp: "https://w3id.org/chainpoint#",
                                        extensions: "https://w3id.org/openbadges/extensions#",
                                        validation: "obi:validation",
                                        xsd: "http://www.w3.org/2001/XMLSchema#",
                                        schema: "http://schema.org/",
                                        sec: "https://w3id.org/security#",
                                        Assertion: "bc:Assertion",
                                        Certificate: "bc:Certificate",
                                        Issuer: "bc:Issuer",
                                        BlockchainCertificate: "bc:BlockchainCertificate",
                                        CertificateDocument: "bc:CertificateDocument",
                                        issuer: {
                                            "@id": "bc:issuer",
                                            "@type": "@id"
                                        },
                                        recipient: {
                                            "@id": "bc:recipient",
                                            "@type": "@id"
                                        },
                                        blockchaincertificate: {
                                            "@id": "bc:blockchaincertificate",
                                            "@type": "@id"
                                        },
                                        certificate: {
                                            "@id": "bc:certificate",
                                            "@type": "@id"
                                        },
                                        document: {
                                            "@id": "bc:document",
                                            "@type": "@id"
                                        },
                                        assertion: {
                                            "@id": "bc:assertion",
                                            "@type": "@id"
                                        },
                                        verify: {
                                            "@id": "bc:verify",
                                            "@type": "@id"
                                        }
                                    }, _defineProperty(_ref, "recipient", {
                                        "@id": "bc:recipient",
                                        "@type": "@id"
                                    }), _defineProperty(_ref, "receipt", {
                                        "@id": "bc:receipt",
                                        "@type": "@id"
                                    }), _defineProperty(_ref, "publicKey", {
                                        "@id": "bc:publicKey"
                                    }), _defineProperty(_ref, "revocationKey", {
                                        "@id": "bc:revocationKey"
                                    }), _defineProperty(_ref, "image:signature", {
                                        "@id": "bc:image:signature"
                                    }), _defineProperty(_ref, "signature", {
                                        "@id": "bc:signature"
                                    }), _defineProperty(_ref, "familyName", {
                                        "@id": "schema:familyName"
                                    }), _defineProperty(_ref, "givenName", {
                                        "@id": "schema:givenName"
                                    }), _defineProperty(_ref, "jobTitle", {
                                        "@id": "schema:jobTitle"
                                    }), _defineProperty(_ref, "signer", {
                                        "@id": "bc:signer",
                                        "@type": "@id"
                                    }), _defineProperty(_ref, "attribute-signed", {
                                        "@id": "bc:attribute-signed"
                                    }), _defineProperty(_ref, "ECDSA(secp256k1)", "bc:SignedBadge"), _defineProperty(_ref, "subtitle", {
                                        "@id": "bc:subtitle"
                                    }), _defineProperty(_ref, "email", "schema:email"), _defineProperty(_ref, "hashed", {
                                        "@id": "obi:hashed",
                                        "@type": "xsd:boolean"
                                    }), _defineProperty(_ref, "image", {
                                        "@id": "schema:image",
                                        "@type": "@id"
                                    }), _defineProperty(_ref, "salt", {
                                        "@id": "obi:salt"
                                    }), _defineProperty(_ref, "identity", {
                                        "@id": "obi:identityHash"
                                    }), _defineProperty(_ref, "issuedOn", {
                                        "@id": "obi:issueDate",
                                        "@type": "xsd:dateTime"
                                    }), _defineProperty(_ref, "expires", {
                                        "@id": "sec:expiration",
                                        "@type": "xsd:dateTime"
                                    }), _defineProperty(_ref, "evidence", {
                                        "@id": "obi:evidence",
                                        "@type": "@id"
                                    }), _defineProperty(_ref, "criteria", {
                                        "@id": "obi:criteria",
                                        "@type": "@id"
                                    }), _defineProperty(_ref, "tags", {
                                        "@id": "schema:keywords"
                                    }), _defineProperty(_ref, "alignment", {
                                        "@id": "obi:alignment",
                                        "@type": "@id"
                                    }), _defineProperty(_ref, "revocationList", {
                                        "@id": "obi:revocationList",
                                        "@type": "@id"
                                    }), _defineProperty(_ref, "name", {
                                        "@id": "schema:name"
                                    }), _defineProperty(_ref, "description", {
                                        "@id": "schema:description"
                                    }), _defineProperty(_ref, "url", {
                                        "@id": "schema:url",
                                        "@type": "@id"
                                    }), _defineProperty(_ref, "uid", {
                                        "@id": "obi:uid"
                                    }), _defineProperty(_ref, "revocationList", "obi:revocationList"), _defineProperty(_ref, "TypeValidation", "obi:TypeValidation"), _defineProperty(_ref, "FrameValidation", "obi:FrameValidation"), _defineProperty(_ref, "validatesType", "obi:validatesType"), _defineProperty(_ref, "validationSchema", "obi:validationSchema"), _defineProperty(_ref, "validationFrame", "obi:validationFrame"), _defineProperty(_ref, "ChainpointSHA224v2", "cp:ChainpointSHA224v2"), _defineProperty(_ref, "ChainpointSHA256v2", "cp:ChainpointSHA256v2"), _defineProperty(_ref, "ChainpointSHA384v2", "cp:ChainpointSHA384v2"), _defineProperty(_ref, "ChainpointSHA512v2", "cp:ChainpointSHA512v2"), _defineProperty(_ref, "ChainpointSHA3-224v2", "cp:ChainpointSHA3-224v2"), _defineProperty(_ref, "ChainpointSHA3-256v2", "cp:ChainpointSHA3-256v2"), _defineProperty(_ref, "ChainpointSHA3-384v2", "cp:ChainpointSHA3-384v2"), _defineProperty(_ref, "ChainpointSHA3-512v2", "cp:ChainpointSHA3-512v2"), _defineProperty(_ref, "BTCOpReturn", "cp:BTCOpReturn"), _defineProperty(_ref, "targetHash", "cp:targetHash"), _defineProperty(_ref, "merkleRoot", "cp:merkleRoot"), _defineProperty(_ref, "proof", "cp:proof"), _defineProperty(_ref, "anchors", "cp:anchors"), _defineProperty(_ref, "sourceId", "cp:sourceId"), _defineProperty(_ref, "right", "cp:right"), _defineProperty(_ref, "left", "cp:left"), _ref)],
                                    validation: [{
                                        type: "TypeValidation",
                                        validatesType: "Assertion",
                                        validationSchema: "https://w3id.org/blockcerts/schema/1.2/assertion-1.2.json"
                                    }, {
                                        type: "TypeValidation",
                                        validatesType: "Certificate",
                                        validationSchema: "https://w3id.org/blockcerts/schema/1.2/certificate-1.2.json"
                                    }, {
                                        type: "TypeValidation",
                                        validatesType: "Issuer",
                                        validationSchema: "https://w3id.org/blockcerts/schema/1.2/issuer-1.2.json"
                                    }, {
                                        type: "TypeValidation",
                                        validatesType: "CertificateDocument",
                                        validationSchema: "https://w3id.org/blockcerts/schema/1.2/certificate-document-1.2.json"
                                    }, {
                                        type: "TypeValidation",
                                        validatesType: "BlockchainCertificate",
                                        validationSchema: "https://w3id.org/blockcerts/schema/1.2/blockchain-certificate-1.2.json"
                                    }, {
                                        type: "TypeValidation",
                                        validatesType: "BlockchainReceipt",
                                        validationSchema: "https://w3id.org/blockcerts/schema/1.2/blockchain-receipt-1.2.json"
                                    }]
                                },
                                blockcertsv2: {
                                    "@context": {
                                        id: "@id",
                                        type: "@type",
                                        bc: "https://w3id.org/blockcerts#",
                                        obi: "https://w3id.org/openbadges#",
                                        cp: "https://w3id.org/chainpoint#",
                                        schema: "http://schema.org/",
                                        sec: "https://w3id.org/security#",
                                        xsd: "http://www.w3.org/2001/XMLSchema#",
                                        MerkleProof2017: "sec:MerkleProof2017",
                                        RecipientProfile: "bc:RecipientProfile",
                                        SignatureLine: "bc:SignatureLine",
                                        MerkleProofVerification2017: "bc:MerkleProofVerification2017",
                                        recipientProfile: "bc:recipientProfile",
                                        signatureLines: "bc:signatureLines",
                                        introductionUrl: {
                                            "@id": "bc:introductionUrl",
                                            "@type": "@id"
                                        },
                                        subtitle: "bc:subtitle",
                                        jobTitle: "schema:jobTitle",
                                        expires: {
                                            "@id": "sec:expiration",
                                            "@type": "xsd:dateTime"
                                        },
                                        revoked: {
                                            "@id": "obi:revoked",
                                            "@type": "xsd:boolean"
                                        },
                                        CryptographicKey: "sec:Key",
                                        signature: "sec:signature",
                                        verification: {
                                            "@id": "obi:verify",
                                            "@type": "@id"
                                        },
                                        publicKey: {
                                            "@id": "sec:publicKey",
                                            "@type": "@id"
                                        },
                                        ChainpointSHA256v2: "cp:ChainpointSHA256v2",
                                        BTCOpReturn: "cp:BTCOpReturn",
                                        targetHash: "cp:targetHash",
                                        merkleRoot: "cp:merkleRoot",
                                        proof: "cp:proof",
                                        anchors: "cp:anchors",
                                        sourceId: "cp:sourceId",
                                        right: "cp:right",
                                        left: "cp:left"
                                    },
                                    "obi:validation": [{
                                        "obi:validatesType": "RecipientProfile",
                                        "obi:validationSchema": "https://w3id.org/blockcerts/schema/2.0/recipientSchema.json"
                                    }, {
                                        "obi:validatesType": "SignatureLine",
                                        "obi:validationSchema": "https://w3id.org/blockcerts/schema/2.0/signatureLineSchema.json"
                                    }, {
                                        "obi:validatesType": "MerkleProof2017",
                                        "obi:validationSchema": "https://w3id.org/blockcerts/schema/2.0/merkleProof2017Schema.json"
                                    }]
                                }
                            }
                        }
                    }, {}],
                    2: [function(require, module, exports) {
                        "use strict";
                        Object.defineProperty(exports, "__esModule", {
                            value: !0
                        });
                        exports.getBlockcypherFetcher = function(transactionId, chain) {
                            var blockCypherUrl;
                            if (chain === _default.Blockchain.bitcoin) {
                                blockCypherUrl = _default.Url.blockCypherUrl + transactionId + "?limit=500"
                            } else {
                                blockCypherUrl = _default.Url.blockCypherTestUrl + transactionId + "?limit=500"
                            }
                            var blockcypherFetcher = new Promise(function(resolve, reject) {
                                return (0, _promisifiedRequests.request)({
                                    url: blockCypherUrl
                                }).then(function(response) {
                                    var responseData = JSON.parse(response);
                                    try {
                                        var txData = parseBlockCypherResponse(responseData);
                                        resolve(txData)
                                    } catch (err) {
                                        reject(err.message)
                                    }
                                }).catch(function() {
                                    reject(new _default.VerifierError(_default.Status.fetchingRemoteHash, "Unable to get remote hash"))
                                })
                            });
                            return blockcypherFetcher
                        };
                        exports.getChainSoFetcher = function(transactionId, chain) {
                            var chainSoUrl;
                            if (chain === _default.Blockchain.bitcoin) {
                                chainSoUrl = _default.Url.chainSoUrl + transactionId
                            } else {
                                chainSoUrl = _default.Url.chainSoTestUrl + transactionId
                            }
                            var chainSoFetcher = new Promise(function(resolve, reject) {
                                return (0, _promisifiedRequests.request)({
                                    url: chainSoUrl
                                }).then(function(response) {
                                    var responseData = JSON.parse(response);
                                    try {
                                        var txData = parseChainSoResponse(responseData);
                                        resolve(txData)
                                    } catch (err) {
                                        reject(new _default.VerifierError(_default.Status.fetchingRemoteHash, "Unable to get remote hash"))
                                    }
                                }).catch(function() {
                                    reject(new _default.VerifierError(_default.Status.fetchingRemoteHash, "Unable to get remote hash"))
                                })
                            });
                            return chainSoFetcher
                        };
                        var _promisifiedRequests = require("./promisifiedRequests"),
                            _verifierModels = require("./verifierModels"),
                            _default = require("../config/default"),
                            _utils = require("./utils");
                        require("string.prototype.startswith");

                        function parseBlockCypherResponse(jsonResponse) {
                            if (jsonResponse.confirmations < _default.MininumConfirmations) {
                                throw new _default.VerifierError("Number of transaction confirmations were less than the minimum required, according to Blockcypher API")
                            }
                            var time = (0, _utils.dateToUnixTimestamp)(jsonResponse.received),
                                outputs = jsonResponse.outputs,
                                lastOutput = outputs[outputs.length - 1],
                                issuingAddress = jsonResponse.inputs[0].addresses[0],
                                opReturnScript = cleanupRemoteHash(lastOutput.script),
                                revokedAddresses = outputs.filter(function(output) {
                                    return !!output.spent_by
                                }).map(function(output) {
                                    return output.addresses[0]
                                });
                            return new _verifierModels.TransactionData(opReturnScript, issuingAddress, time, revokedAddresses)
                        }

                        function parseChainSoResponse(jsonResponse) {
                            if (jsonResponse.data.confirmations < _default.MininumConfirmations) {
                                throw new _default.VerifierError("Number of transaction confirmations were less than the minimum required, according to Chain.so API")
                            }
                            var time = new Date(1e3 * jsonResponse.data.time),
                                outputs = jsonResponse.data.outputs,
                                lastOutput = outputs[outputs.length - 1],
                                issuingAddress = jsonResponse.data.inputs[0].address,
                                opReturnScript = cleanupRemoteHash(lastOutput.script);
                            return new _verifierModels.TransactionData(opReturnScript, issuingAddress, time, void 0)
                        }

                        function cleanupRemoteHash(remoteHash) {
                            for (var prefixes = ["6a20", "OP_RETURN "], i = 0, prefix; i < prefixes.length; i++) {
                                prefix = prefixes[i];
                                if (remoteHash.startsWith(prefix)) {
                                    return remoteHash.slice(prefix.length)
                                }
                            }
                            return remoteHash
                        }
                    }, {
                        "../config/default": 1,
                        "./promisifiedRequests": 8,
                        "./utils": 9,
                        "./verifierModels": 11,
                        "string.prototype.startswith": 435
                    }],
                    3: [function(require, module, exports) {
                        "use strict";
                        Object.defineProperty(exports, "__esModule", {
                            value: !0
                        });
                        exports.lookForTx = function(transactionId, chain, certificateVersion) {
                            var BlockchainExplorers;
                            switch (chain) {
                                case _default.Blockchain.bitcoin:
                                case _default.Blockchain.regtest:
                                case _default.Blockchain.testnet:
                                case _default.Blockchain.mocknet:
                                    BlockchainExplorers = BitcoinExplorers;
                                    break;
                                case _default.Blockchain.ethmain:
                                case _default.Blockchain.ethropst:
                                    BlockchainExplorers = EthereumExplorers;
                                    break;
                                default:
                                    return Promise.reject(new _default.VerifierError(_default.Status.fetchingRemoteHash, "Invalid chain; does not map to known BlockchainExplorers."));
                            }
                            if (0 > _default.MinimumBlockchainExplorers || _default.MinimumBlockchainExplorers > BlockchainExplorers.length) {
                                return Promise.reject(new _default.VerifierError(_default.Status.fetchingRemoteHash, "Invalid application configuration; check the MinimumBlockchainExplorers configuration value"))
                            }
                            if (_default.MinimumBlockchainExplorers > BlockchainExplorersWithSpentOutputInfo.length && (certificateVersion == _default.CertificateVersion.v1_1 || certificateVersion == _default.CertificateVersion.v1_2)) {
                                return Promise.reject(new _default.VerifierError(_default.Status.fetchingRemoteHash, "Invalid application configuration; check the MinimumBlockchainExplorers configuration value"))
                            }
                            var promises = [];
                            if (certificateVersion == _default.CertificateVersion.v1_1 || certificateVersion == _default.CertificateVersion.v1_2) {
                                for (var limit = _default.Race ? BlockchainExplorersWithSpentOutputInfo.length : _default.MinimumBlockchainExplorers, i = 0; i < limit; i++) {
                                    promises.push(BlockchainExplorersWithSpentOutputInfo[i](transactionId, chain))
                                }
                            } else {
                                for (var limit = _default.Race ? BlockchainExplorers.length : _default.MinimumBlockchainExplorers, j = 0; j < limit; j++) {
                                    promises.push(BlockchainExplorers[j](transactionId, chain))
                                }
                            }
                            return new Promise(function(resolve, reject) {
                                return PromiseProperRace(promises, _default.MinimumBlockchainExplorers).then(function(winners) {
                                    if (!winners || 0 == winners.length) {
                                        return Promise.reject(new _default.VerifierError(_default.Status.fetchingRemoteHash, "Could not confirm the transaction. No blockchain apis returned a response. This could be because of rate limiting."))
                                    }
                                    for (var firstResponse = winners[0], i = 1, thisResponse; i < winners.length; i++) {
                                        thisResponse = winners[i];
                                        if (firstResponse.issuingAddress !== thisResponse.issuingAddress) {
                                            throw new _default.VerifierError(_default.Status.fetchingRemoteHash, "Issuing addresses returned by the blockchain APIs were different")
                                        }
                                        if (firstResponse.remoteHash !== thisResponse.remoteHash) {
                                            throw new _default.VerifierError(_default.Status.fetchingRemoteHash, "Remote hashes returned by the blockchain APIs were different")
                                        }
                                    }
                                    resolve(firstResponse)
                                }).catch(function(err) {
                                    reject(new _default.VerifierError(_default.Status.fetchingRemoteHash, err.message))
                                })
                            })
                        };
                        var _debug = require("debug"),
                            _debug2 = function(obj) {
                                return obj && obj.__esModule ? obj : {
                                    default: obj
                                }
                            }(_debug),
                            _default = require("../config/default"),
                            _ethereumExplorers = require("./ethereumExplorers"),
                            _bitcoinExplorers = require("./bitcoinExplorers");
                        var log = (0, _debug2.default)("blockchainConnectors"),
                            BitcoinExplorers = [function(transactionId, chain) {
                                return (0, _bitcoinExplorers.getChainSoFetcher)(transactionId, chain)
                            }, function(transactionId, chain) {
                                return (0, _bitcoinExplorers.getBlockcypherFetcher)(transactionId, chain)
                            }],
                            EthereumExplorers = [function(transactionId, chain) {
                                return (0, _ethereumExplorers.getEtherScanFetcher)(transactionId, chain)
                            }],
                            BlockchainExplorersWithSpentOutputInfo = [function(transactionId, chain) {
                                return (0, _bitcoinExplorers.getBlockcypherFetcher)(transactionId, chain)
                            }];
                        var PromiseProperRace = function PromiseProperRace(promises, count) {
                            var results = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : [];
                            promises = Array.from(promises);
                            if (promises.length < count) {
                                return Promise.reject(new _default.VerifierError(_default.Status.fetchingRemoteHash, "Could not confirm the transaction"))
                            }
                            var indexPromises = promises.map(function(p, index) {
                                return p.then(function() {
                                    return index
                                }).catch(function(err) {
                                    log(err);
                                    throw index
                                })
                            });
                            return Promise.race(indexPromises).then(function(index) {
                                var p = promises.splice(index, 1)[0];
                                p.then(function(e) {
                                    return results.push(e)
                                });
                                if (1 === count) {
                                    return results
                                }
                                return PromiseProperRace(promises, count - 1, results)
                            }).catch(function(index) {
                                promises.splice(index, 1);
                                return PromiseProperRace(promises, count, results)
                            })
                        }
                    }, {
                        "../config/default": 1,
                        "./bitcoinExplorers": 2,
                        "./ethereumExplorers": 6,
                        debug: 380
                    }],
                    4: [function(require, module, exports) {
                        "use strict";
                        Object.defineProperty(exports, "__esModule", {
                            value: !0
                        });
                        exports.SignatureImage = exports.Certificate = void 0;
                        var _typeof = "function" === typeof Symbol && "symbol" === typeof Symbol.iterator ? function(obj) {
                                return typeof obj
                            } : function(obj) {
                                return obj && "function" === typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj
                            },
                            _createClass = function() {
                                function defineProperties(target, props) {
                                    for (var i = 0, descriptor; i < props.length; i++) {
                                        descriptor = props[i];
                                        descriptor.enumerable = descriptor.enumerable || !1;
                                        descriptor.configurable = !0;
                                        if ("value" in descriptor) descriptor.writable = !0;
                                        Object.defineProperty(target, descriptor.key, descriptor)
                                    }
                                }
                                return function(Constructor, protoProps, staticProps) {
                                    if (protoProps) defineProperties(Constructor.prototype, protoProps);
                                    if (staticProps) defineProperties(Constructor, staticProps);
                                    return Constructor
                                }
                            }(),
                            _default = require("../config/default");

                        function _classCallCheck(instance, Constructor) {
                            if (!(instance instanceof Constructor)) {
                                throw new TypeError("Cannot call a class as a function")
                            }
                        }
                        require("string.prototype.startswith");
                        var isBitcoinMainnetAddress = function(bitcoinAddress) {
                                if (bitcoinAddress.startsWith("1") || bitcoinAddress.startsWith(_default.PublicKey)) {
                                    return !0
                                }
                                return !1
                            },
                            getChain = function(signature, bitcoinAddress) {
                                var anchor = signature.anchors[0];
                                if (anchor.chain) {
                                    var chain = anchor.chain;
                                    if (chain == _default.ChainSignatureValue.bitcoin) {
                                        return _default.Blockchain.bitcoin
                                    } else if (chain == _default.ChainSignatureValue.testnet) {
                                        return _default.Blockchain.testnet
                                    } else if (chain == _default.ChainSignatureValue.regtest) {
                                        return _default.Blockchain.regtest
                                    } else if (chain == _default.ChainSignatureValue.mocknet) {
                                        return _default.Blockchain.mocknet
                                    } else if (chain == _default.ChainSignatureValue.ethmain) {
                                        return _default.Blockchain.ethmain
                                    } else if (chain == _default.ChainSignatureValue.ethropst) {
                                        return _default.Blockchain.ethropst
                                    } else {
                                        throw new Error("Didn't recognize chain value")
                                    }
                                }
                                if (isBitcoinMainnetAddress(bitcoinAddress)) {
                                    return _default.Blockchain.bitcoin
                                }
                                return _default.Blockchain.testnet
                            },
                            getNameForChain = function(chain) {
                                return chain.toString()
                            },
                            getTransactionId = function(certificateReceipt) {
                                try {
                                    return certificateReceipt.anchors[0].sourceId
                                } catch (e) {
                                    throw new _default.VerifierError("Can't verify this certificate without a transaction ID to compare against.")
                                }
                            },
                            getRawTransactionLink = function(transactionId, chain) {
                                try {
                                    return _default.BlockchainRawTransactionUrl[chain].replace(_default.BlockchainRawTransactionIdPlaceholder, transactionId)
                                } catch (e) {
                                    throw new _default.VerifierError("Can't get the raw transaction link.")
                                }
                            },
                            getTransactionLink = function(transactionId, chain) {
                                try {
                                    return _default.BlockchainTransactionUrl[chain].replace(_default.BlockchainRawTransactionIdPlaceholder, transactionId)
                                } catch (e) {
                                    throw new _default.VerifierError("Can't get the raw transaction link.")
                                }
                            },
                            Certificate = exports.Certificate = function() {
                                function Certificate(version, name, title, subtitle, description, certificateImage, signatureImage, sealImage, id, issuer, receipt, signature, publicKey, revocationKey, chain, expires) {
                                    _classCallCheck(this, Certificate);
                                    this.version = version;
                                    this.name = name;
                                    this.title = title;
                                    this.subtitle = subtitle;
                                    this.description = description;
                                    this.certificateImage = certificateImage;
                                    this.signatureImage = signatureImage;
                                    this.sealImage = sealImage;
                                    this.id = id;
                                    this.issuer = issuer;
                                    this.receipt = receipt;
                                    this.signature = signature;
                                    this.publicKey = publicKey;
                                    this.revocationKey = revocationKey;
                                    this.chain = chain;
                                    this.chainAsString = getNameForChain(chain);
                                    this.expires = expires;
                                    this.transactionId = getTransactionId(this.receipt);
                                    this.rawTransactionLink = getRawTransactionLink(this.transactionId, this.chain);
                                    this.transactionLink = getTransactionLink(this.transactionId, this.chain)
                                }
                                _createClass(Certificate, null, [{
                                    key: "parseV1",
                                    value: function(certificateJson) {
                                        var certificate = certificateJson.certificate || certificateJson.document.certificate,
                                            recipient = certificateJson.recipient || certificateJson.document.recipient,
                                            assertion = certificateJson.document.assertion,
                                            certificateImage = certificate.image,
                                            name = recipient.givenName + " " + recipient.familyName,
                                            title = certificate.title || certificate.name,
                                            description = certificate.description,
                                            signatureImage = certificateJson.document && certificateJson.document.assertion && certificateJson.document.assertion["image:signature"],
                                            expires = assertion.expires,
                                            signatureImageObjects = [];
                                        if (signatureImage.constructor === Array) {
                                            for (var index in signatureImage) {
                                                var signatureLine = signatureImage[index],
                                                    jobTitle = "jobTitle" in signatureLine ? signatureLine.jobTitle : null,
                                                    signerName = "name" in signatureLine ? signatureLine.name : null,
                                                    signatureObject = new SignatureImage(signatureLine.image, jobTitle, signerName);
                                                signatureImageObjects.push(signatureObject)
                                            }
                                        } else {
                                            var signatureObject = new SignatureImage(signatureImage, null, null);
                                            signatureImageObjects.push(signatureObject)
                                        }
                                        var sealImage = certificate.issuer.image,
                                            subtitle = certificate.subtitle;
                                        if ("object" == ("undefined" === typeof subtitle ? "undefined" : _typeof(subtitle))) {
                                            subtitle = subtitle.display ? subtitle.content : ""
                                        }
                                        var id = assertion.uid,
                                            issuer = certificate.issuer,
                                            receipt = certificateJson.receipt,
                                            signature = certificateJson.document.signature,
                                            publicKey = recipient.publicKey,
                                            revocationKey = recipient.revocationKey || null,
                                            version = void 0;
                                        if ("undefined" === typeof receipt) {
                                            version = _default.CertificateVersion.v1_1
                                        } else {
                                            version = _default.CertificateVersion.v1_2
                                        }
                                        var chain;
                                        if (isBitcoinMainnetAddress(publicKey)) {
                                            chain = _default.Blockchain.bitcoin
                                        } else {
                                            chain = _default.Blockchain.testnet
                                        }
                                        return new Certificate(version, name, title, subtitle, description, certificateImage, signatureImageObjects, sealImage, id, issuer, receipt, signature, publicKey, revocationKey, chain, expires)
                                    }
                                }, {
                                    key: "parseV2",
                                    value: function(certificateJson) {
                                        var id = certificateJson.id,
                                            recipient = certificateJson.recipient,
                                            expires = certificateJson.expires,
                                            receipt = certificateJson.signature,
                                            badge = certificateJson.badge,
                                            certificateImage = badge.image,
                                            title = badge.name,
                                            description = badge.description,
                                            subtitle = badge.subtitle,
                                            issuer = badge.issuer,
                                            issuerKey = certificateJson.verification.publicKey || certificateJson.verification.creator,
                                            recipientProfile = certificateJson.recipientProfile || certificateJson.recipient.recipientProfile,
                                            sealImage = issuer.image,
                                            publicKey = recipientProfile.publicKey,
                                            name = recipientProfile.name,
                                            signatureImageObjects = [];
                                        for (var index in badge.signatureLines) {
                                            var signatureLine = badge.signatureLines[index],
                                                signatureObject = new SignatureImage(signatureLine.image, signatureLine.jobTitle, signatureLine.name);
                                            signatureImageObjects.push(signatureObject)
                                        }
                                        var chain = getChain(certificateJson.signature, issuerKey);
                                        return new Certificate(_default.CertificateVersion.v2_0, name, title, subtitle, description, certificateImage, signatureImageObjects, sealImage, id, issuer, receipt, null, publicKey, null, chain, expires)
                                    }
                                }, {
                                    key: "parseJson",
                                    value: function(certificateJson) {
                                        var version = certificateJson["@context"];
                                        if (version instanceof Array) {
                                            return this.parseV2(certificateJson)
                                        } else {
                                            return this.parseV1(certificateJson)
                                        }
                                    }
                                }]);
                                return Certificate
                            }(),
                            SignatureImage = exports.SignatureImage = function SignatureImage(image, jobTitle, name) {
                                _classCallCheck(this, SignatureImage);
                                this.image = image;
                                this.jobTitle = jobTitle;
                                this.name = name
                            }
                    }, {
                        "../config/default": 1,
                        "string.prototype.startswith": 435
                    }],
                    5: [function(require, module, exports) {
                        "use strict";
                        Object.defineProperty(exports, "__esModule", {
                            value: !0
                        });
                        exports.ensureNotRevokedBySpentOutput = function(revokedAddresses, issuerRevocationKey, recipientRevocationKey) {
                            if (issuerRevocationKey) {
                                var revokedAssertionId = revokedAddresses.findIndex(function(address) {
                                    return address === issuerRevocationKey
                                });
                                if (-1 !== revokedAssertionId) {
                                    throw new _default.VerifierError(_default.Status.checkingRevokedStatus, (0, _default.generateRevocationReason)(revokedAddresses[revokedAssertionId].revocationReason))
                                }
                            }
                            if (recipientRevocationKey) {
                                var _revokedAssertionId = revokedAddresses.findIndex(function(address) {
                                    return address === recipientRevocationKey
                                });
                                if (-1 !== _revokedAssertionId) {
                                    throw new _default.VerifierError(_default.Status.checkingRevokedStatus, (0, _default.generateRevocationReason)(revokedAddresses[_revokedAssertionId].revocationReason))
                                }
                            }
                        };
                        exports.ensureNotRevokedByList = function(revokedAssertions, assertionUid) {
                            if (!revokedAssertions) {
                                return
                            }
                            var revokedAddresses = revokedAssertions.map(function(output) {
                                    return output.id
                                }),
                                revokedAssertionId = revokedAddresses.findIndex(function(id) {
                                    return id === assertionUid
                                });
                            if (-1 !== revokedAssertionId) {
                                throw new _default.VerifierError(_default.Status.checkingRevokedStatus, (0, _default.generateRevocationReason)(revokedAssertions[revokedAssertionId].revocationReason))
                            }
                        };
                        exports.ensureIssuerSignature = function(issuerKey, certificateUid, certificateSignature, chain) {
                            var bitcoinChain = chain === _default.Blockchain.bitcoin ? _bitcoinjsLib2.default.networks.bitcoin : _bitcoinjsLib2.default.networks.testnet;
                            if (!_bitcoinjsLib2.default.message.verify(issuerKey, certificateSignature, certificateUid, bitcoinChain)) {
                                throw new _default.VerifierError("Issuer key doesn't match derived address.")
                            }
                        };
                        exports.ensureHashesEqual = function(actual, expected) {
                            if (actual !== expected) {
                                throw new _default.VerifierError(_default.Status.comparingHashes, "Computed hash does not match remote hash")
                            }
                        };
                        exports.ensureMerkleRootEqual = function(merkleRoot, remoteHash) {
                            if (merkleRoot !== remoteHash) {
                                throw new _default.VerifierError(_default.Status.checkingMerkleRoot, "Merkle root does not match remote hash.")
                            }
                        };
                        exports.ensureValidIssuingKey = function(keyMap, txIssuingAddress, txTime) {
                            var validKey = !1,
                                theKey = getCaseInsensitiveKey(keyMap, txIssuingAddress);
                            txTime = (0, _utils.dateToUnixTimestamp)(txTime);
                            if (theKey) {
                                validKey = !0;
                                if (theKey.created) {
                                    validKey &= txTime >= theKey.created
                                }
                                if (theKey.revoked) {
                                    validKey &= txTime <= theKey.revoked
                                }
                                if (theKey.expires) {
                                    validKey &= txTime <= theKey.expires
                                }
                            }
                            if (!validKey) {
                                throw new _default.VerifierError(_default.Status.checkingAuthenticity, "Transaction occurred at time when issuing address was not considered valid.")
                            }
                        };
                        exports.ensureValidReceipt = function(receipt) {
                            var proofHash = receipt.targetHash,
                                merkleRoot = receipt.merkleRoot;
                            try {
                                var proof = receipt.proof;
                                if (!!proof) {
                                    for (var index in proof) {
                                        var node = proof[index];
                                        if ("undefined" !== typeof node.left) {
                                            var appendedBuffer = _toByteArray("" + node.left + proofHash);
                                            proofHash = (0, _sha2.default)(appendedBuffer)
                                        } else if ("undefined" !== typeof node.right) {
                                            var appendedBuffer = _toByteArray("" + proofHash + node.right);
                                            proofHash = (0, _sha2.default)(appendedBuffer)
                                        } else {
                                            throw new _default.VerifierError(_default.Status.checkingReceipt, "We should never get here.")
                                        }
                                    }
                                }
                            } catch (e) {
                                throw new _default.VerifierError(_default.Status.checkingReceipt, "The receipt is malformed. There was a problem navigating the merkle tree in the receipt.")
                            }
                            if (proofHash !== merkleRoot) {
                                throw new _default.VerifierError(_default.Status.checkingReceipt, "Invalid Merkle Receipt. Proof hash didn't match Merkle root")
                            }
                        };
                        exports.computeLocalHashV1_1 = function(certificateString) {
                            var correctedData = certificateString.slice(0, -1);
                            return (0, _sha2.default)(correctedData)
                        };
                        exports.getTransactionId = function(certificate) {
                            var transactionId;
                            try {
                                transactionId = certificate.receipt.anchors[0].sourceId;
                                return transactionId
                            } catch (e) {
                                throw new _default.VerifierError(_default.Status.getTransactionId, "Can't verify this certificate without a transaction ID to compare against.")
                            }
                        };
                        exports.computeLocalHash = function(document, version) {
                            var expandContext = document["@context"];
                            if (version === _default.CertificateVersion.v2_0 && _default.CheckForUnmappedFields) {
                                if (expandContext.find(function(x) {
                                        return x === Object(x) && "@vocab" in x
                                    })) {
                                    expandContext = null
                                } else {
                                    expandContext.push({
                                        "@vocab": "http://fallback.org/"
                                    })
                                }
                            }
                            var nodeDocumentLoader = _jsonld2.default.documentLoaders.node(),
                                customLoader = function(url, callback) {
                                    if (url in CONTEXTS) {
                                        return callback(null, {
                                            contextUrl: null,
                                            document: CONTEXTS[url],
                                            documentUrl: url
                                        })
                                    }
                                    return nodeDocumentLoader(url, callback)
                                };
                            _jsonld2.default.documentLoader = customLoader;
                            var normalizeArgs = {
                                algorithm: "URDNA2015",
                                format: "application/nquads"
                            };
                            if (expandContext) {
                                normalizeArgs.expandContext = expandContext
                            }
                            return new Promise(function(resolve, reject) {
                                _jsonld2.default.normalize(document, normalizeArgs, function(err, normalized) {
                                    if (!!err) {
                                        reject(new _default.VerifierError(_default.Status.computingLocalHash, "Failed JSON-LD normalization"))
                                    } else {
                                        var unmappedFields = getUnmappedFields(normalized);
                                        if (unmappedFields) {
                                            reject(new _default.VerifierError(_default.Status.computingLocalHash, "Found unmapped fields during JSON-LD normalization"))
                                        } else {
                                            resolve((0, _sha2.default)(_toUTF8Data(normalized)))
                                        }
                                    }
                                })
                            })
                        };
                        exports.ensureNotExpired = function(expires) {
                            if (!expires) {
                                return
                            }
                            var expiryDate = (0, _utils.dateToUnixTimestamp)(expires);
                            if (new Date >= expiryDate) {
                                throw new _default.VerifierError(_default.Status.checkingExpiresDate, "This certificate has expired.")
                            }
                        };
                        var _bitcoinjsLib = require("bitcoinjs-lib"),
                            _bitcoinjsLib2 = _interopRequireDefault(_bitcoinjsLib),
                            _jsonld = require("jsonld"),
                            _jsonld2 = _interopRequireDefault(_jsonld),
                            _debug = require("debug"),
                            _debug2 = _interopRequireDefault(_debug),
                            _default = require("../config/default"),
                            _sha = require("sha256"),
                            _sha2 = _interopRequireDefault(_sha),
                            _utils = require("./utils");

                        function _interopRequireDefault(obj) {
                            return obj && obj.__esModule ? obj : {
                                default: obj
                            }
                        }(0, _debug2.default)("checks");
                        require("string.prototype.startswith");
                        var OBI_CONTEXT = _default.Contexts.obi,
                            BLOCKCERTS_CONTEXT = _default.Contexts.blockcerts,
                            BLOCKCERTSV1_2_CONTEXT = _default.Contexts.blockcertsv1_2,
                            BLOCKCERTSV2_CONTEXT = _default.Contexts.blockcertsv2,
                            CONTEXTS = {};
                        CONTEXTS["https://w3id.org/blockcerts/schema/2.0-alpha/context.json"] = BLOCKCERTS_CONTEXT;
                        CONTEXTS["https://www.blockcerts.org/schema/2.0-alpha/context.json"] = BLOCKCERTS_CONTEXT;
                        CONTEXTS["https://w3id.org/openbadges/v2"] = OBI_CONTEXT;
                        CONTEXTS["https://openbadgespec.org/v2/context.json"] = OBI_CONTEXT;
                        CONTEXTS["https://w3id.org/blockcerts/v2"] = BLOCKCERTSV2_CONTEXT;
                        CONTEXTS["https://www.w3id.org/blockcerts/schema/2.0/context.json"] = BLOCKCERTSV2_CONTEXT;
                        CONTEXTS["https://w3id.org/blockcerts/v1"] = BLOCKCERTSV1_2_CONTEXT;

                        function getUnmappedFields(normalized) {
                            var myRegexp = /<http:\/\/fallback\.org\/(.*)>/,
                                matches = myRegexp.exec(normalized);
                            if (matches) {
                                for (var unmappedFields = [], i = 0; i < matches.length; i++) {
                                    unmappedFields.push(matches[i])
                                }
                                return unmappedFields
                            }
                            return null
                        }

                        function _toByteArray(hexString) {
                            for (var outArray = [], byteSize = 2, i = 0; i < hexString.length; i += byteSize) {
                                outArray.push(parseInt(hexString.substring(i, i + byteSize), 16))
                            }
                            return outArray
                        }

                        function _toUTF8Data(string) {
                            for (var utf8 = [], i = 0, charcode; i < string.length; i++) {
                                charcode = string.charCodeAt(i);
                                if (128 > charcode) utf8.push(charcode);
                                else if (2048 > charcode) {
                                    utf8.push(192 | charcode >> 6, 128 | 63 & charcode)
                                } else if (55296 > charcode || 57344 <= charcode) {
                                    utf8.push(224 | charcode >> 12, 128 | 63 & charcode >> 6, 128 | 63 & charcode)
                                } else {
                                    i++;
                                    charcode = 65536 + ((1023 & charcode) << 10 | 1023 & string.charCodeAt(i));
                                    utf8.push(240 | charcode >> 18, 128 | 63 & charcode >> 12, 128 | 63 & charcode >> 6, 128 | 63 & charcode)
                                }
                            }
                            return utf8
                        }

                        function getCaseInsensitiveKey(obj, value) {
                            var key = null;
                            for (var prop in obj) {
                                if (obj.hasOwnProperty(prop)) {
                                    if (prop.toLowerCase() === value.toLowerCase()) {
                                        key = prop
                                    }
                                }
                            }
                            return obj[key]
                        }
                    }, {
                        "../config/default": 1,
                        "./utils": 9,
                        "bitcoinjs-lib": 29,
                        debug: 380,
                        jsonld: 396,
                        sha256: 429,
                        "string.prototype.startswith": 435
                    }],
                    6: [function(require, module, exports) {
                        "use strict";
                        Object.defineProperty(exports, "__esModule", {
                            value: !0
                        });
                        exports.getEtherScanFetcher = function(transactionId, chain) {
                            var action = "&action=eth_getTransactionByHash&txhash=",
                                etherScanUrl = void 0;
                            if (chain === _default.Blockchain.ethmain) {
                                etherScanUrl = _default.Url.etherScanMainUrl + action + transactionId
                            } else {
                                etherScanUrl = _default.Url.etherScanRopstenUrl + action + transactionId
                            }
                            var etherScanFetcher = new Promise(function(resolve, reject) {
                                return (0, _promisifiedRequests.request)({
                                    url: etherScanUrl
                                }).then(function(response) {
                                    var responseTxData = JSON.parse(response);
                                    try {
                                        var blockFetcher = getEtherScanBlock(responseTxData, chain);
                                        blockFetcher.then(function(blockResponse) {
                                            var txData = parseEtherScanResponse(responseTxData, blockResponse);
                                            resolve(txData)
                                        }).catch(function() {
                                            reject(new _default.VerifierError(_default.Status.fetchingRemoteHash, "Unable to get remote hash"))
                                        })
                                    } catch (err) {
                                        reject(new _default.VerifierError(_default.Status.fetchingRemoteHash, "Unable to get remote hash"))
                                    }
                                }).catch(function() {
                                    reject(new _default.VerifierError(_default.Status.fetchingRemoteHash, "Unable to get remote hash"))
                                })
                            });
                            return etherScanFetcher
                        };
                        var _promisifiedRequests = require("./promisifiedRequests"),
                            _default = require("../config/default"),
                            _verifierModels = require("./verifierModels");
                        require("string.prototype.startswith");

                        function parseEtherScanResponse(jsonResponse, block) {
                            var data = jsonResponse.result,
                                date = new Date(1e3 * parseInt(block.timestamp, 16)),
                                issuingAddress = data.from,
                                opReturnScript = cleanupRemoteHash(data.input);
                            return new _verifierModels.TransactionData(opReturnScript, issuingAddress, date, void 0)
                        }

                        function getEtherScanBlock(jsonResponse, chain) {
                            var data = jsonResponse.result,
                                blockNumber = data.blockNumber,
                                action = "&action=eth_getBlockByNumber&boolean=true&tag=",
                                etherScanUrl = void 0;
                            if (chain === _default.Blockchain.ethmain) {
                                etherScanUrl = _default.Url.etherScanMainUrl + action + blockNumber
                            } else {
                                etherScanUrl = _default.Url.etherScanRopstenUrl + action + blockNumber
                            }
                            return new Promise(function(resolve, reject) {
                                return (0, _promisifiedRequests.request)({
                                    url: etherScanUrl
                                }).then(function(response) {
                                    var responseData = JSON.parse(response),
                                        blockData = responseData.result;
                                    try {
                                        var checkConfirmationsFetcher = checkEtherScanConfirmations(chain, blockNumber);
                                        checkConfirmationsFetcher.then(function() {
                                            resolve(blockData)
                                        }).catch(function() {
                                            reject(new _default.VerifierError(_default.Status.fetchingRemoteHash, "Unable to get remote hash"))
                                        })
                                    } catch (err) {
                                        reject(new _default.VerifierError(_default.Status.fetchingRemoteHash, "Unable to get remote hash"))
                                    }
                                }).catch(function() {
                                    reject(new _default.VerifierError(_default.Status.fetchingRemoteHash, "Unable to get remote hash"))
                                })
                            })
                        }

                        function checkEtherScanConfirmations(chain, blockNumber) {
                            var action = "&action=eth_blockNumber",
                                etherScanUrl = void 0;
                            if (chain === _default.Blockchain.ethmain) {
                                etherScanUrl = _default.Url.etherScanMainUrl + action
                            } else {
                                etherScanUrl = _default.Url.etherScanRopstenUrl + action
                            }
                            return new Promise(function(resolve, reject) {
                                return (0, _promisifiedRequests.request)({
                                    url: etherScanUrl
                                }).then(function(response) {
                                    var responseData = JSON.parse(response),
                                        currentBlockCount = responseData.result;
                                    try {
                                        if (currentBlockCount - blockNumber < _default.MininumConfirmations) {
                                            reject(new _default.VerifierError(_default.Status.fetchingRemoteHash, "Number of transaction confirmations were less than the minimum required, according to EtherScan API"))
                                        }
                                        resolve(currentBlockCount)
                                    } catch (err) {
                                        reject(new _default.VerifierError(_default.Status.fetchingRemoteHash, "Unable to get remote hash"))
                                    }
                                }).catch(function() {
                                    reject(new _default.VerifierError(_default.Status.fetchingRemoteHash, "Unable to get remote hash"))
                                })
                            })
                        }

                        function cleanupRemoteHash(remoteHash) {
                            var prefix = "0x";
                            if (remoteHash.startsWith(prefix)) {
                                return remoteHash.slice(prefix.length)
                            }
                            return remoteHash
                        }
                    }, {
                        "../config/default": 1,
                        "./promisifiedRequests": 8,
                        "./verifierModels": 11,
                        "string.prototype.startswith": 435
                    }],
                    7: [function(require, module, exports) {
                        "use strict";
                        Object.defineProperty(exports, "__esModule", {
                            value: !0
                        });
                        exports.CertificateVerifier = exports.SignatureImage = exports.Certificate = exports.Status = exports.CertificateVersion = exports.Blockchain = void 0;
                        var _certificate = require("./certificate");
                        Object.defineProperty(exports, "Certificate", {
                            enumerable: !0,
                            get: function() {
                                return _certificate.Certificate
                            }
                        });
                        Object.defineProperty(exports, "SignatureImage", {
                            enumerable: !0,
                            get: function() {
                                return _certificate.SignatureImage
                            }
                        });
                        var _verifier = require("./verifier");
                        Object.defineProperty(exports, "CertificateVerifier", {
                            enumerable: !0,
                            get: function() {
                                return _verifier.CertificateVerifier
                            }
                        });
                        require("babel-polyfill");
                        var _default = require("../config/default");
                        exports.Blockchain = _default.Blockchain;
                        exports.CertificateVersion = _default.CertificateVersion;
                        exports.Status = _default.Status
                    }, {
                        "../config/default": 1,
                        "./certificate": 4,
                        "./verifier": 10,
                        "babel-polyfill": 13
                    }],
                    8: [function(require, module, exports) {
                        "use strict";
                        Object.defineProperty(exports, "__esModule", {
                            value: !0
                        });
                        exports.request = function(obj) {
                            return new Promise(function(resolve, reject) {
                                var url = obj.url,
                                    request = new XMLHttpRequest;
                                request.addEventListener("load", function() {
                                    if (200 <= request.status && 300 > request.status) {
                                        resolve(request.responseText)
                                    } else {
                                        var failureMessage = "Error fetching url:" + url + "; status code:" + request.status;
                                        reject(new Error(failureMessage))
                                    }
                                });
                                request.ontimeout = function(e) {
                                    console.log("ontimeout", e)
                                };
                                request.onreadystatechange = function() {
                                    if (404 === request.status) {
                                        reject(new Error("Error fetching url:" + url + "; status code:" + request.status))
                                    }
                                };
                                request.addEventListener("error", function() {
                                    log("Request failed with error " + request.responseText);
                                    reject(new Error(request.responseText))
                                });
                                request.responseType = "json";
                                request.open(obj.method || "GET", url);
                                if (obj.body) {
                                    request.send(JSON.stringify(obj.body))
                                } else {
                                    request.send()
                                }
                            })
                        };
                        exports.readFileAsync = function(path) {
                            return regeneratorRuntime.async(function(_context) {
                                while (1) {
                                    switch (_context.prev = _context.next) {
                                        case 0:
                                            _context.next = 2;
                                            return regeneratorRuntime.awrap(readFile(path));
                                        case 2:
                                            return _context.abrupt("return", _context.sent);
                                        case 3:
                                        case "end":
                                            return _context.stop();
                                    }
                                }
                            }, null, this)
                        };
                        exports.readFile = readFile;
                        var _fs = require("fs"),
                            _fs2 = _interopRequireDefault(_fs),
                            _debug = require("debug"),
                            _debug2 = _interopRequireDefault(_debug);

                        function _interopRequireDefault(obj) {
                            return obj && obj.__esModule ? obj : {
                                default: obj
                            }
                        }
                        var XMLHttpRequest = require("xmlhttprequest").XMLHttpRequest,
                            log = (0, _debug2.default)("promisifiedRequests");

                        function readFile(path) {
                            return new Promise(function(resolve, reject) {
                                _fs2.default.readFile(path, "utf8", function(err, data) {
                                    if (err) {
                                        reject(err)
                                    } else {
                                        resolve(data)
                                    }
                                })
                            })
                        }
                    }, {
                        debug: 380,
                        fs: 39,
                        xmlhttprequest: 449
                    }],
                    9: [function(require, module, exports) {
                        "use strict";
                        Object.defineProperty(exports, "__esModule", {
                            value: !0
                        });
                        exports.dateToUnixTimestamp = function(date) {
                            return dateFromIso(date)
                        };

                        function noOffset(s) {
                            var day = s.slice(0, -5).split(/\D/).map(function(itm) {
                                return parseInt(itm, 10) || 0
                            });
                            day[1] -= 1;
                            day = new Date(Date.UTC.apply(Date, day));
                            var offsetString = s.slice(-5),
                                offset = parseInt(offsetString, 10) / 100;
                            if ("+" === offsetString.slice(0, 1)) offset *= -1;
                            day.setHours(day.getHours() + offset);
                            return day.getTime()
                        }

                        function dateFromRegex(s) {
                            var day, tz = void 0,
                                rx = /^(\d{4}\-\d\d\-\d\d([tT][\d:\.]*)?)([zZ]|([+\-])(\d\d):?(\d\d))?$/,
                                p = rx.exec(s) || [];
                            if (p[1]) {
                                day = p[1].split(/\D/).map(function(itm) {
                                    return parseInt(itm, 10) || 0
                                });
                                day[1] -= 1;
                                day = new Date(Date.UTC.apply(Date, day));
                                if (!day.getDate()) return NaN;
                                if (p[5]) {
                                    tz = 60 * (parseInt(p[5], 10) / 100);
                                    if (p[6]) tz += parseInt(p[6], 10);
                                    if ("+" === p[4]) tz *= -1;
                                    if (tz) day.setUTCMinutes(day.getUTCMinutes() + tz)
                                }
                                return day
                            }
                            return NaN
                        }

                        function dateFromIso(isoDate) {
                            var diso = Date.parse(isoDate);
                            if (diso) {
                                return new Date(diso)
                            }
                            var offsetDate = noOffset(isoDate);
                            if (offsetDate) {
                                return offsetDate
                            }
                            return dateFromRegex(isoDate)
                        }
                    }, {}],
                    10: [function(require, module, exports) {
                        "use strict";
                        Object.defineProperty(exports, "__esModule", {
                            value: !0
                        });
                        exports.CertificateVerifier = void 0;
                        var _createClass = function() {
                                function defineProperties(target, props) {
                                    for (var i = 0, descriptor; i < props.length; i++) {
                                        descriptor = props[i];
                                        descriptor.enumerable = descriptor.enumerable || !1;
                                        descriptor.configurable = !0;
                                        if ("value" in descriptor) descriptor.writable = !0;
                                        Object.defineProperty(target, descriptor.key, descriptor)
                                    }
                                }
                                return function(Constructor, protoProps, staticProps) {
                                    if (protoProps) defineProperties(Constructor.prototype, protoProps);
                                    if (staticProps) defineProperties(Constructor, staticProps);
                                    return Constructor
                                }
                            }(),
                            _debug = require("debug"),
                            _debug2 = function(obj) {
                                return obj && obj.__esModule ? obj : {
                                    default: obj
                                }
                            }(_debug),
                            _certificate = require("./certificate"),
                            _default = require("../config/default"),
                            _checks = require("./checks"),
                            checks = _interopRequireWildcard(_checks),
                            _blockchainConnectors = require("./blockchainConnectors"),
                            blockchainConnectors = _interopRequireWildcard(_blockchainConnectors),
                            _verifierModels = require("./verifierModels");

                        function _interopRequireWildcard(obj) {
                            if (obj && obj.__esModule) {
                                return obj
                            } else {
                                var newObj = {};
                                if (null != obj) {
                                    for (var key in obj) {
                                        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]
                                    }
                                }
                                newObj.default = obj;
                                return newObj
                            }
                        }

                        function _classCallCheck(instance, Constructor) {
                            if (!(instance instanceof Constructor)) {
                                throw new TypeError("Cannot call a class as a function")
                            }
                        }
                        var log = (0, _debug2.default)("verifier");
                        require("string.prototype.startswith");
                        var noop = function() {},
                            CertificateVerifier = exports.CertificateVerifier = function() {
                                function CertificateVerifier(certificateString, statusCallback) {
                                    _classCallCheck(this, CertificateVerifier);
                                    var certificateJson = JSON.parse(certificateString);
                                    this.certificate = _certificate.Certificate.parseJson(certificateJson);
                                    var document = certificateJson.document;
                                    if (!document) {
                                        var certCopy = JSON.parse(certificateString);
                                        delete certCopy.signature;
                                        document = certCopy
                                    }
                                    this.document = document;
                                    this.statusCallback = statusCallback || noop;
                                    this.completionCallback = null;
                                    this.certificateString = certificateString;
                                    this._stepsStatuses = []
                                }
                                _createClass(CertificateVerifier, [{
                                    key: "_updateCallback",
                                    value: function(stepCode, message, status) {
                                        if (null != stepCode) {
                                            this.statusCallback(stepCode, message, status)
                                        }
                                    }
                                }, {
                                    key: "_succeed",
                                    value: function() {
                                        var status;
                                        if (this.certificate.chain === _default.Blockchain.mocknet || this.certificate.chain === _default.Blockchain.regtest) {
                                            log("This mock Blockcert passed all checks. Mocknet mode is only used for issuers to test their workflow locally. This Blockcert was not recorded on a blockchain, and it should not be considered a verified Blockcert.");
                                            status = _default.Status.mockSuccess
                                        } else {
                                            log("success");
                                            status = _default.Status.success
                                        }
                                        this.completionCallback(_default.Status.final, "", status);
                                        return status
                                    }
                                }, {
                                    key: "_failed",
                                    value: function(stepCode, message) {
                                        stepCode = stepCode || "";
                                        message = message || "";
                                        log("failure:" + message);
                                        this.completionCallback(stepCode, message, _default.Status.failure);
                                        return _default.Status.failure
                                    }
                                }, {
                                    key: "_isFailing",
                                    value: function() {
                                        return 0 < this._stepsStatuses.length && -1 < this._stepsStatuses.indexOf(_default.Status.failure)
                                    }
                                }, {
                                    key: "doAction",
                                    value: function(stepCode, action) {
                                        if (this._isFailing()) {
                                            return
                                        }
                                        var message = (0, _default.getVerboseMessage)(stepCode);
                                        log(message);
                                        this._updateCallback(stepCode, message, _default.Status.starting);
                                        try {
                                            var res = action();
                                            this._updateCallback(stepCode, message, _default.Status.success);
                                            this._stepsStatuses.push(_default.Status.success);
                                            return res
                                        } catch (err) {
                                            this._updateCallback(stepCode, err.message, _default.Status.failure);
                                            this._stepsStatuses.push(_default.Status.failure)
                                        }
                                    }
                                }, {
                                    key: "doAsyncAction",
                                    value: function(stepCode, action) {
                                        var message, res;
                                        return regeneratorRuntime.async(function(_context) {
                                            while (1) {
                                                switch (_context.prev = _context.next) {
                                                    case 0:
                                                        if (!this._isFailing()) {
                                                            _context.next = 2;
                                                            break
                                                        }
                                                        return _context.abrupt("return");
                                                    case 2:
                                                        message = void 0;
                                                        if (null != stepCode) {
                                                            message = (0, _default.getVerboseMessage)(stepCode);
                                                            log(message);
                                                            this._updateCallback(stepCode, message, _default.Status.starting)
                                                        }
                                                        _context.prev = 4;
                                                        _context.next = 7;
                                                        return regeneratorRuntime.awrap(action());
                                                    case 7:
                                                        res = _context.sent;
                                                        this._updateCallback(stepCode, message, _default.Status.success);
                                                        this._stepsStatuses.push(_default.Status.success);
                                                        return _context.abrupt("return", res);
                                                    case 13:
                                                        _context.prev = 13;
                                                        _context.t0 = _context["catch"](4);
                                                        this._updateCallback(stepCode, _context.t0.message, _default.Status.failure);
                                                        this._stepsStatuses.push(_default.Status.failure);
                                                    case 17:
                                                    case "end":
                                                        return _context.stop();
                                                }
                                            }
                                        }, null, this, [
                                            [4, 13]
                                        ])
                                    }
                                }, {
                                    key: "verifyV1_2",
                                    value: function() {
                                        var _this = this,
                                            transactionId, docToVerify, localHash, txData, issuerProfileJson, issuerKeyMap;
                                        return regeneratorRuntime.async(function(_context5) {
                                            while (1) {
                                                switch (_context5.prev = _context5.next) {
                                                    case 0:
                                                        transactionId = this.doAction(_default.Status.getTransactionId, function() {
                                                            return checks.getTransactionId(_this.certificate)
                                                        });
                                                        docToVerify = this.document;
                                                        _context5.next = 4;
                                                        return regeneratorRuntime.awrap(this.doAsyncAction(_default.Status.computingLocalHash, function() {
                                                            return regeneratorRuntime.async(function(_context2) {
                                                                while (1) {
                                                                    switch (_context2.prev = _context2.next) {
                                                                        case 0:
                                                                            return _context2.abrupt("return", checks.computeLocalHash(docToVerify, _this.certificate.version));
                                                                        case 1:
                                                                        case "end":
                                                                            return _context2.stop();
                                                                    }
                                                                }
                                                            }, null, _this)
                                                        }));
                                                    case 4:
                                                        localHash = _context5.sent;
                                                        _context5.next = 7;
                                                        return regeneratorRuntime.awrap(this.doAsyncAction(_default.Status.fetchingRemoteHash, function() {
                                                            return regeneratorRuntime.async(function(_context3) {
                                                                while (1) {
                                                                    switch (_context3.prev = _context3.next) {
                                                                        case 0:
                                                                            return _context3.abrupt("return", blockchainConnectors.lookForTx(transactionId, _this.certificate.chain, _this.certificate.version));
                                                                        case 1:
                                                                        case "end":
                                                                            return _context3.stop();
                                                                    }
                                                                }
                                                            }, null, _this)
                                                        }));
                                                    case 7:
                                                        txData = _context5.sent;
                                                        _context5.next = 10;
                                                        return regeneratorRuntime.awrap(this.doAsyncAction(_default.Status.gettingIssuerProfile, function() {
                                                            return regeneratorRuntime.async(function(_context4) {
                                                                while (1) {
                                                                    switch (_context4.prev = _context4.next) {
                                                                        case 0:
                                                                            return _context4.abrupt("return", (0, _verifierModels.getIssuerProfile)(_this.certificate.issuer.id));
                                                                        case 1:
                                                                        case "end":
                                                                            return _context4.stop();
                                                                    }
                                                                }
                                                            }, null, _this)
                                                        }));
                                                    case 10:
                                                        issuerProfileJson = _context5.sent;
                                                        _context5.next = 13;
                                                        return regeneratorRuntime.awrap(this.doAsyncAction(_default.Status.parsingIssuerKeys, function() {
                                                            return (0, _verifierModels.parseIssuerKeys)(issuerProfileJson)
                                                        }));
                                                    case 13:
                                                        issuerKeyMap = _context5.sent;
                                                        this.doAction(_default.Status.comparingHashes, function() {
                                                            checks.ensureHashesEqual(localHash, _this.certificate.receipt.targetHash)
                                                        });
                                                        this.doAction(_default.Status.checkingMerkleRoot, function() {
                                                            return checks.ensureMerkleRootEqual(_this.certificate.receipt.merkleRoot, txData.remoteHash)
                                                        });
                                                        this.doAction(_default.Status.checkingReceipt, function() {
                                                            return checks.ensureValidReceipt(_this.certificate.receipt)
                                                        });
                                                        this.doAction(_default.Status.checkingRevokedStatus, function() {
                                                            return checks.ensureNotRevokedBySpentOutput(txData.revokedAddresses, (0, _verifierModels.parseRevocationKey)(issuerProfileJson), _this.certificate.revocationKey)
                                                        });
                                                        this.doAction(_default.Status.checkingAuthenticity, function() {
                                                            return checks.ensureValidIssuingKey(issuerKeyMap, txData.issuingAddress, txData.time)
                                                        });
                                                        this.doAction(_default.Status.checkingExpiresDate, function() {
                                                            return checks.ensureNotExpired(_this.certificate.expires)
                                                        });
                                                    case 20:
                                                    case "end":
                                                        return _context5.stop();
                                                }
                                            }
                                        }, null, this)
                                    }
                                }, {
                                    key: "verifyV2",
                                    value: function() {
                                        var _this2 = this,
                                            transactionId, docToVerify, localHash, txData, issuerKeyMap, revokedAssertions;
                                        return regeneratorRuntime.async(function(_context10) {
                                            while (1) {
                                                switch (_context10.prev = _context10.next) {
                                                    case 0:
                                                        transactionId = this.doAction(_default.Status.getTransactionId, function() {
                                                            return checks.getTransactionId(_this2.certificate)
                                                        });
                                                        docToVerify = this.document;
                                                        _context10.next = 4;
                                                        return regeneratorRuntime.awrap(this.doAsyncAction(_default.Status.computingLocalHash, function() {
                                                            return regeneratorRuntime.async(function(_context6) {
                                                                while (1) {
                                                                    switch (_context6.prev = _context6.next) {
                                                                        case 0:
                                                                            return _context6.abrupt("return", checks.computeLocalHash(docToVerify, _this2.certificate.version));
                                                                        case 1:
                                                                        case "end":
                                                                            return _context6.stop();
                                                                    }
                                                                }
                                                            }, null, _this2)
                                                        }));
                                                    case 4:
                                                        localHash = _context10.sent;
                                                        _context10.next = 7;
                                                        return regeneratorRuntime.awrap(this.doAsyncAction(_default.Status.fetchingRemoteHash, function() {
                                                            return regeneratorRuntime.async(function(_context7) {
                                                                while (1) {
                                                                    switch (_context7.prev = _context7.next) {
                                                                        case 0:
                                                                            return _context7.abrupt("return", blockchainConnectors.lookForTx(transactionId, _this2.certificate.chain));
                                                                        case 1:
                                                                        case "end":
                                                                            return _context7.stop();
                                                                    }
                                                                }
                                                            }, null, _this2)
                                                        }));
                                                    case 7:
                                                        txData = _context10.sent;
                                                        _context10.next = 10;
                                                        return regeneratorRuntime.awrap(this.doAsyncAction(_default.Status.parsingIssuerKeys, function() {
                                                            return regeneratorRuntime.async(function(_context8) {
                                                                while (1) {
                                                                    switch (_context8.prev = _context8.next) {
                                                                        case 0:
                                                                            return _context8.abrupt("return", (0, _verifierModels.getIssuerKeys)(_this2.certificate.issuer.id));
                                                                        case 1:
                                                                        case "end":
                                                                            return _context8.stop();
                                                                    }
                                                                }
                                                            }, null, _this2)
                                                        }));
                                                    case 10:
                                                        issuerKeyMap = _context10.sent;
                                                        _context10.next = 13;
                                                        return regeneratorRuntime.awrap(this.doAsyncAction(null, function() {
                                                            return regeneratorRuntime.async(function(_context9) {
                                                                while (1) {
                                                                    switch (_context9.prev = _context9.next) {
                                                                        case 0:
                                                                            return _context9.abrupt("return", (0, _verifierModels.getRevokedAssertions)(_this2.certificate.issuer.revocationList));
                                                                        case 1:
                                                                        case "end":
                                                                            return _context9.stop();
                                                                    }
                                                                }
                                                            }, null, _this2)
                                                        }));
                                                    case 13:
                                                        revokedAssertions = _context10.sent;
                                                        this.doAction(_default.Status.comparingHashes, function() {
                                                            return checks.ensureHashesEqual(localHash, _this2.certificate.receipt.targetHash)
                                                        });
                                                        this.doAction(_default.Status.checkingMerkleRoot, function() {
                                                            return checks.ensureMerkleRootEqual(_this2.certificate.receipt.merkleRoot, txData.remoteHash)
                                                        });
                                                        this.doAction(_default.Status.checkingReceipt, function() {
                                                            return checks.ensureValidReceipt(_this2.certificate.receipt)
                                                        });
                                                        this.doAction(_default.Status.checkingRevokedStatus, function() {
                                                            return checks.ensureNotRevokedByList(revokedAssertions, _this2.certificate.id)
                                                        });
                                                        this.doAction(_default.Status.checkingAuthenticity, function() {
                                                            return checks.ensureValidIssuingKey(issuerKeyMap, txData.issuingAddress, txData.time)
                                                        });
                                                        this.doAction(_default.Status.checkingExpiresDate, function() {
                                                            return checks.ensureNotExpired(_this2.certificate.expires)
                                                        });
                                                    case 20:
                                                    case "end":
                                                        return _context10.stop();
                                                }
                                            }
                                        }, null, this)
                                    }
                                }, {
                                    key: "verifyV2Mock",
                                    value: function() {
                                        var _this3 = this,
                                            docToVerify, localHash;
                                        return regeneratorRuntime.async(function(_context12) {
                                            while (1) {
                                                switch (_context12.prev = _context12.next) {
                                                    case 0:
                                                        docToVerify = this.document;
                                                        _context12.next = 3;
                                                        return regeneratorRuntime.awrap(this.doAsyncAction(_default.Status.computingLocalHash, function() {
                                                            return regeneratorRuntime.async(function(_context11) {
                                                                while (1) {
                                                                    switch (_context11.prev = _context11.next) {
                                                                        case 0:
                                                                            return _context11.abrupt("return", checks.computeLocalHash(docToVerify, _this3.certificate.version));
                                                                        case 1:
                                                                        case "end":
                                                                            return _context11.stop();
                                                                    }
                                                                }
                                                            }, null, _this3)
                                                        }));
                                                    case 3:
                                                        localHash = _context12.sent;
                                                        this.doAction(_default.Status.comparingHashes, function() {
                                                            return checks.ensureHashesEqual(localHash, _this3.certificate.receipt.targetHash)
                                                        });
                                                        this.doAction(_default.Status.checkingReceipt, function() {
                                                            return checks.ensureValidReceipt(_this3.certificate.receipt)
                                                        });
                                                        this.doAction(_default.Status.checkingExpiresDate, function() {
                                                            return checks.ensureNotExpired(_this3.certificate.expires)
                                                        });
                                                    case 7:
                                                    case "end":
                                                        return _context12.stop();
                                                }
                                            }
                                        }, null, this)
                                    }
                                }, {
                                    key: "verify",
                                    value: function(completionCallback) {
                                        return regeneratorRuntime.async(function(_context13) {
                                            while (1) {
                                                switch (_context13.prev = _context13.next) {
                                                    case 0:
                                                        if (!(this.certificate.version === _default.CertificateVersion.v1_1)) {
                                                            _context13.next = 2;
                                                            break
                                                        }
                                                        throw new _default.VerifierError("", "Verification of 1.1 certificates is not supported by this component. See the python cert-verifier for legacy verification");
                                                    case 2:
                                                        this.completionCallback = completionCallback || noop;
                                                        _context13.prev = 3;
                                                        if (!(this.certificate.version === _default.CertificateVersion.v1_2)) {
                                                            _context13.next = 9;
                                                            break
                                                        }
                                                        _context13.next = 7;
                                                        return regeneratorRuntime.awrap(this.verifyV1_2());
                                                    case 7:
                                                        _context13.next = 16;
                                                        break;
                                                    case 9:
                                                        if (!(this.certificate.chain === _default.Blockchain.mocknet || this.certificate.chain === _default.Blockchain.regtest)) {
                                                            _context13.next = 14;
                                                            break
                                                        }
                                                        _context13.next = 12;
                                                        return regeneratorRuntime.awrap(this.verifyV2Mock());
                                                    case 12:
                                                        _context13.next = 16;
                                                        break;
                                                    case 14:
                                                        _context13.next = 16;
                                                        return regeneratorRuntime.awrap(this.verifyV2());
                                                    case 16:
                                                        if (!(-1 < this._stepsStatuses.indexOf(_default.Status.failure))) {
                                                            _context13.next = 20;
                                                            break
                                                        }
                                                        return _context13.abrupt("return", this._failed(_default.Status.final));
                                                    case 20:
                                                        return _context13.abrupt("return", this._succeed());
                                                    case 21:
                                                        _context13.next = 25;
                                                        break;
                                                    case 23:
                                                        _context13.prev = 23;
                                                        _context13.t0 = _context13["catch"](3);
                                                    case 25:
                                                    case "end":
                                                        return _context13.stop();
                                                }
                                            }
                                        }, null, this, [
                                            [3, 23]
                                        ])
                                    }
                                }]);
                                return CertificateVerifier
                            }()
                    }, {
                        "../config/default": 1,
                        "./blockchainConnectors": 3,
                        "./certificate": 4,
                        "./checks": 5,
                        "./verifierModels": 11,
                        debug: 380,
                        "string.prototype.startswith": 435
                    }],
                    11: [function(require, module, exports) {
                        "use strict";
                        Object.defineProperty(exports, "__esModule", {
                            value: !0
                        });
                        exports.Key = exports.TransactionData = void 0;
                        exports.parseIssuerKeys = parseIssuerKeys;
                        exports.parseRevocationKey = function(issuerProfileJson) {
                            if (issuerProfileJson.revocationKeys && 0 < issuerProfileJson.revocationKeys.length) {
                                return issuerProfileJson.revocationKeys[0].key
                            }
                            return null
                        };
                        exports.getIssuerProfile = getIssuerProfile;
                        exports.getIssuerKeys = function(issuerId) {
                            var issuerKeyFetcher = new Promise(function(resolve, reject) {
                                return getIssuerProfile(issuerId).then(function(issuerProfileJson) {
                                    try {
                                        var issuerKeyMap = parseIssuerKeys(issuerProfileJson);
                                        resolve(issuerKeyMap)
                                    } catch (err) {
                                        reject(new _default.VerifierError(_default.Status.parsingIssuerKeys, err))
                                    }
                                }).catch(function(err) {
                                    reject(new _default.VerifierError(_default.Status.parsingIssuerKeys, err))
                                })
                            });
                            return issuerKeyFetcher
                        };
                        exports.getRevokedAssertions = function(revocationListUrl) {
                            if (!revocationListUrl) {
                                return Promise.resolve([])
                            }
                            var revocationListFetcher = new Promise(function(resolve, reject) {
                                return (0, _promisifiedRequests.request)({
                                    url: revocationListUrl
                                }).then(function(response) {
                                    try {
                                        var issuerRevocationJson = JSON.parse(response),
                                            revokedAssertions = issuerRevocationJson.revokedAssertions ? issuerRevocationJson.revokedAssertions : [];
                                        resolve(revokedAssertions)
                                    } catch (err) {
                                        reject(new _default.VerifierError(_default.Status.parsingIssuerKeys, "Unable to get revocation assertion"))
                                    }
                                }).catch(function() {
                                    reject(new _default.VerifierError(_default.Status.parsingIssuerKeys, "Unable to get revocation assertion"))
                                })
                            });
                            return revocationListFetcher
                        };
                        var _promisifiedRequests = require("./promisifiedRequests"),
                            _default = require("../config/default"),
                            _utils = require("./utils");

                        function _classCallCheck(instance, Constructor) {
                            if (!(instance instanceof Constructor)) {
                                throw new TypeError("Cannot call a class as a function")
                            }
                        }
                        var TransactionData = exports.TransactionData = function TransactionData(remoteHash, issuingAddress, time, revokedAddresses) {
                                _classCallCheck(this, TransactionData);
                                this.remoteHash = remoteHash;
                                this.issuingAddress = issuingAddress;
                                this.time = time;
                                this.revokedAddresses = revokedAddresses
                            },
                            Key = exports.Key = function Key(publicKey, created, revoked, expires) {
                                _classCallCheck(this, Key);
                                this.publicKey = publicKey;
                                this.created = created;
                                this.revoked = revoked;
                                this.expires = expires
                            };

                        function parseIssuerKeys(issuerProfileJson) {
                            try {
                                var keyMap = {};
                                if ("@context" in issuerProfileJson) {
                                    for (var responseKeys = issuerProfileJson.publicKey || issuerProfileJson.publicKeys, i = 0; i < responseKeys.length; i++) {
                                        var key = responseKeys[i],
                                            created = key.created ? (0, _utils.dateToUnixTimestamp)(key.created) : null,
                                            revoked = key.revoked ? (0, _utils.dateToUnixTimestamp)(key.revoked) : null,
                                            expires = key.expires ? (0, _utils.dateToUnixTimestamp)(key.expires) : null,
                                            publicKeyTemp = key.id || key.publicKey,
                                            publicKey = publicKeyTemp.replace("ecdsa-koblitz-pubkey:", ""),
                                            k = new Key(publicKey, created, revoked, expires);
                                        keyMap[k.publicKey] = k
                                    }
                                } else {
                                    var issuerKeys = issuerProfileJson.issuerKeys || [],
                                        issuerKey = issuerKeys[0].key,
                                        k = new Key(issuerKey, null, null, null);
                                    keyMap[k.publicKey] = k
                                }
                                return keyMap
                            } catch (e) {
                                throw new _default.VerifierError(_default.Status.parsingIssuerKeys, "Unable to parse JSON out of issuer identification data.")
                            }
                        }

                        function getIssuerProfile(issuerId) {
                            var issuerProfileFetcher = new Promise(function(resolve, reject) {
                                return (0, _promisifiedRequests.request)({
                                    url: issuerId
                                }).then(function(response) {
                                    try {
                                        var issuerProfileJson = JSON.parse(response);
                                        resolve(issuerProfileJson)
                                    } catch (err) {
                                        reject(new _default.VerifierError(_default.Status.gettingIssuerProfile, err))
                                    }
                                }).catch(function() {
                                    reject(new _default.VerifierError(_default.Status.gettingIssuerProfile, "Unable to get issuer profile"))
                                })
                            });
                            return issuerProfileFetcher
                        }
                    }, {
                        "../config/default": 1,
                        "./promisifiedRequests": 8,
                        "./utils": 9
                    }],
                    12: [function(require, module) {
                        (function(global) {
                            "use strict";

                            function compare(a, b) {
                                if (a === b) {
                                    return 0
                                }
                                for (var x = a.length, y = b.length, i = 0, len = _Mathmin(x, y); i < len; ++i) {
                                    if (a[i] !== b[i]) {
                                        x = a[i];
                                        y = b[i];
                                        break
                                    }
                                }
                                if (x < y) {
                                    return -1
                                }
                                if (y < x) {
                                    return 1
                                }
                                return 0
                            }

                            function isBuffer(b) {
                                if (global.Buffer && "function" === typeof global.Buffer.isBuffer) {
                                    return global.Buffer.isBuffer(b)
                                }
                                return !!(null != b && b._isBuffer)
                            }
                            var util = require("util/"),
                                hasOwn = Object.prototype.hasOwnProperty,
                                pSlice = Array.prototype.slice,
                                functionsHaveNames = function() {
                                    return "foo" === function() {}.name
                                }();

                            function pToString(obj) {
                                return Object.prototype.toString.call(obj)
                            }

                            function isView(arrbuf) {
                                if (isBuffer(arrbuf)) {
                                    return !1
                                }
                                if ("function" !== typeof global.ArrayBuffer) {
                                    return !1
                                }
                                if ("function" === typeof ArrayBuffer.isView) {
                                    return ArrayBuffer.isView(arrbuf)
                                }
                                if (!arrbuf) {
                                    return !1
                                }
                                if (arrbuf instanceof DataView) {
                                    return !0
                                }
                                if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
                                    return !0
                                }
                                return !1
                            }
                            var assert = module.exports = ok,
                                regex = /\s*function\s+([^\(\s]*)\s*/;

                            function getName(func) {
                                if (!util.isFunction(func)) {
                                    return
                                }
                                if (functionsHaveNames) {
                                    return func.name
                                }
                                var str = func.toString(),
                                    match = str.match(regex);
                                return match && match[1]
                            }
                            assert.AssertionError = function(options) {
                                this.name = "AssertionError";
                                this.actual = options.actual;
                                this.expected = options.expected;
                                this.operator = options.operator;
                                if (options.message) {
                                    this.message = options.message;
                                    this.generatedMessage = !1
                                } else {
                                    this.message = getMessage(this);
                                    this.generatedMessage = !0
                                }
                                var stackStartFunction = options.stackStartFunction || fail;
                                if (Error.captureStackTrace) {
                                    Error.captureStackTrace(this, stackStartFunction)
                                } else {
                                    var err = new Error;
                                    if (err.stack) {
                                        var out = err.stack,
                                            fn_name = getName(stackStartFunction),
                                            idx = out.indexOf("\n" + fn_name);
                                        if (0 <= idx) {
                                            var next_line = out.indexOf("\n", idx + 1);
                                            out = out.substring(next_line + 1)
                                        }
                                        this.stack = out
                                    }
                                }
                            };
                            util.inherits(assert.AssertionError, Error);

                            function truncate(s, n) {
                                if ("string" === typeof s) {
                                    return s.length < n ? s : s.slice(0, n)
                                } else {
                                    return s
                                }
                            }

                            function inspect(something) {
                                if (functionsHaveNames || !util.isFunction(something)) {
                                    return util.inspect(something)
                                }
                                var rawname = getName(something),
                                    name = rawname ? ": " + rawname : "";
                                return "[Function" + name + "]"
                            }

                            function getMessage(self) {
                                return truncate(inspect(self.actual), 128) + " " + self.operator + " " + truncate(inspect(self.expected), 128)
                            }

                            function fail(actual, expected, message, operator, stackStartFunction) {
                                throw new assert.AssertionError({
                                    message: message,
                                    actual: actual,
                                    expected: expected,
                                    operator: operator,
                                    stackStartFunction: stackStartFunction
                                })
                            }
                            assert.fail = fail;

                            function ok(value, message) {
                                if (!value) fail(value, !0, message, "==", assert.ok)
                            }
                            assert.ok = ok;
                            assert.equal = function(actual, expected, message) {
                                if (actual != expected) fail(actual, expected, message, "==", assert.equal)
                            };
                            assert.notEqual = function(actual, expected, message) {
                                if (actual == expected) {
                                    fail(actual, expected, message, "!=", assert.notEqual)
                                }
                            };
                            assert.deepEqual = function(actual, expected, message) {
                                if (!_deepEqual(actual, expected, !1)) {
                                    fail(actual, expected, message, "deepEqual", assert.deepEqual)
                                }
                            };
                            assert.deepStrictEqual = function(actual, expected, message) {
                                if (!_deepEqual(actual, expected, !0)) {
                                    fail(actual, expected, message, "deepStrictEqual", assert.deepStrictEqual)
                                }
                            };

                            function _deepEqual(actual, expected, strict, memos) {
                                if (actual === expected) {
                                    return !0
                                } else if (isBuffer(actual) && isBuffer(expected)) {
                                    return 0 === compare(actual, expected)
                                } else if (util.isDate(actual) && util.isDate(expected)) {
                                    return actual.getTime() === expected.getTime()
                                } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
                                    return actual.source === expected.source && actual.global === expected.global && actual.multiline === expected.multiline && actual.lastIndex === expected.lastIndex && actual.ignoreCase === expected.ignoreCase
                                } else if ((null === actual || "object" !== typeof actual) && (null === expected || "object" !== typeof expected)) {
                                    return strict ? actual === expected : actual == expected
                                } else if (isView(actual) && isView(expected) && pToString(actual) === pToString(expected) && !(actual instanceof Float32Array || actual instanceof Float64Array)) {
                                    return 0 === compare(new Uint8Array(actual.buffer), new Uint8Array(expected.buffer))
                                } else if (isBuffer(actual) !== isBuffer(expected)) {
                                    return !1
                                } else {
                                    memos = memos || {
                                        actual: [],
                                        expected: []
                                    };
                                    var actualIndex = memos.actual.indexOf(actual);
                                    if (-1 !== actualIndex) {
                                        if (actualIndex === memos.expected.indexOf(expected)) {
                                            return !0
                                        }
                                    }
                                    memos.actual.push(actual);
                                    memos.expected.push(expected);
                                    return objEquiv(actual, expected, strict, memos)
                                }
                            }

                            function isArguments(object) {
                                return "[object Arguments]" == Object.prototype.toString.call(object)
                            }

                            function objEquiv(a, b, strict, actualVisitedObjects) {
                                if (null === a || a === void 0 || null === b || b === void 0) return !1;
                                if (util.isPrimitive(a) || util.isPrimitive(b)) return a === b;
                                if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b)) return !1;
                                var aIsArgs = isArguments(a),
                                    bIsArgs = isArguments(b);
                                if (aIsArgs && !bIsArgs || !aIsArgs && bIsArgs) return !1;
                                if (aIsArgs) {
                                    a = pSlice.call(a);
                                    b = pSlice.call(b);
                                    return _deepEqual(a, b, strict)
                                }
                                var ka = objectKeys(a),
                                    kb = objectKeys(b),
                                    key, i;
                                if (ka.length !== kb.length) return !1;
                                ka.sort();
                                kb.sort();
                                for (i = ka.length - 1; 0 <= i; i--) {
                                    if (ka[i] !== kb[i]) return !1
                                }
                                for (i = ka.length - 1; 0 <= i; i--) {
                                    key = ka[i];
                                    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects)) return !1
                                }
                                return !0
                            }
                            assert.notDeepEqual = function(actual, expected, message) {
                                if (_deepEqual(actual, expected, !1)) {
                                    fail(actual, expected, message, "notDeepEqual", assert.notDeepEqual)
                                }
                            };
                            assert.notDeepStrictEqual = notDeepStrictEqual;

                            function notDeepStrictEqual(actual, expected, message) {
                                if (_deepEqual(actual, expected, !0)) {
                                    fail(actual, expected, message, "notDeepStrictEqual", notDeepStrictEqual)
                                }
                            }
                            assert.strictEqual = function(actual, expected, message) {
                                if (actual !== expected) {
                                    fail(actual, expected, message, "===", assert.strictEqual)
                                }
                            };
                            assert.notStrictEqual = function(actual, expected, message) {
                                if (actual === expected) {
                                    fail(actual, expected, message, "!==", assert.notStrictEqual)
                                }
                            };

                            function expectedException(actual, expected) {
                                if (!actual || !expected) {
                                    return !1
                                }
                                if ("[object RegExp]" == Object.prototype.toString.call(expected)) {
                                    return expected.test(actual)
                                }
                                try {
                                    if (actual instanceof expected) {
                                        return !0
                                    }
                                } catch (e) {}
                                if (Error.isPrototypeOf(expected)) {
                                    return !1
                                }
                                return !0 === expected.call({}, actual)
                            }

                            function _tryBlock(block) {
                                var error;
                                try {
                                    block()
                                } catch (e) {
                                    error = e
                                }
                                return error
                            }

                            function _throws(shouldThrow, block, expected, message) {
                                var actual;
                                if ("function" !== typeof block) {
                                    throw new TypeError("\"block\" argument must be a function")
                                }
                                if ("string" === typeof expected) {
                                    message = expected;
                                    expected = null
                                }
                                actual = _tryBlock(block);
                                message = (expected && expected.name ? " (" + expected.name + ")." : ".") + (message ? " " + message : ".");
                                if (shouldThrow && !actual) {
                                    fail(actual, expected, "Missing expected exception" + message)
                                }
                                var userProvidedMessage = "string" === typeof message,
                                    isUnwantedException = !shouldThrow && util.isError(actual),
                                    isUnexpectedException = !shouldThrow && actual && !expected;
                                if (isUnwantedException && userProvidedMessage && expectedException(actual, expected) || isUnexpectedException) {
                                    fail(actual, expected, "Got unwanted exception" + message)
                                }
                                if (shouldThrow && actual && expected && !expectedException(actual, expected) || !shouldThrow && actual) {
                                    throw actual
                                }
                            }
                            assert.throws = function(block, error, message) {
                                _throws(!0, block, error, message)
                            };
                            assert.doesNotThrow = function(block, error, message) {
                                _throws(!1, block, error, message)
                            };
                            assert.ifError = function(err) {
                                if (err) throw err
                            };
                            var objectKeys = Object.keys || function(obj) {
                                var keys = [];
                                for (var key in obj) {
                                    if (hasOwn.call(obj, key)) keys.push(key)
                                }
                                return keys
                            }
                        }).call(this, "undefined" !== typeof global ? global : "undefined" !== typeof self ? self : "undefined" !== typeof window ? window : {})
                    }, {
                        "util/": 447
                    }],
                    13: [function(require) {
                        (function(global) {
                            "use strict";
                            require("core-js/shim");
                            require("regenerator-runtime/runtime");
                            require("core-js/fn/regexp/escape");
                            if (global._babelPolyfill) {
                                throw new Error("only one instance of babel-polyfill is allowed")
                            }
                            global._babelPolyfill = !0;

                            function define(O, key, value) {
                                O[key] || Object["defineProperty"](O, key, {
                                    writable: !0,
                                    configurable: !0,
                                    value: value
                                })
                            }
                            define(String.prototype, "padLeft", "".padStart);
                            define(String.prototype, "padRight", "".padEnd);
                            "pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill".split(",").forEach(function(key) {
                                [][key] && define(Array, key, Function.call.bind([][key]))
                            })
                        }).call(this, "undefined" !== typeof global ? global : "undefined" !== typeof self ? self : "undefined" !== typeof window ? window : {})
                    }, {
                        "core-js/fn/regexp/escape": 50,
                        "core-js/shim": 373,
                        "regenerator-runtime/runtime": 418
                    }],
                    14: [function(require, module) {
                        module.exports = function(ALPHABET) {
                            for (var ALPHABET_MAP = {}, BASE = ALPHABET.length, LEADER = ALPHABET.charAt(0), i = 0; i < ALPHABET.length; i++) {
                                ALPHABET_MAP[ALPHABET.charAt(i)] = i
                            }

                            function encode(source) {
                                if (0 === source.length) return "";
                                for (var digits = [0], i = 0; i < source.length; ++i) {
                                    for (var j = 0, carry = source[i]; j < digits.length; ++j) {
                                        carry += digits[j] << 8;
                                        digits[j] = carry % BASE;
                                        carry = 0 | carry / BASE
                                    }
                                    while (0 < carry) {
                                        digits.push(carry % BASE);
                                        carry = 0 | carry / BASE
                                    }
                                }
                                for (var string = "", k = 0; 0 === source[k] && k < source.length - 1; ++k) string += ALPHABET[0];
                                for (var q = digits.length - 1; 0 <= q; --q) string += ALPHABET[digits[q]];
                                return string
                            }

                            function decodeUnsafe(string) {
                                if (0 === string.length) return [];
                                for (var bytes = [0], i = 0, value; i < string.length; i++) {
                                    value = ALPHABET_MAP[string[i]];
                                    if (value === void 0) return;
                                    for (var j = 0, carry = value; j < bytes.length; ++j) {
                                        carry += bytes[j] * BASE;
                                        bytes[j] = 255 & carry;
                                        carry >>= 8
                                    }
                                    while (0 < carry) {
                                        bytes.push(255 & carry);
                                        carry >>= 8
                                    }
                                }
                                for (var k = 0; string[k] === LEADER && k < string.length - 1; ++k) {
                                    bytes.push(0)
                                }
                                return bytes.reverse()
                            }
                            return {
                                encode: encode,
                                decodeUnsafe: decodeUnsafe,
                                decode: function(string) {
                                    var array = decodeUnsafe(string);
                                    if (array) return array;
                                    throw new Error("Non-base" + BASE + " character")
                                }
                            }
                        }
                    }, {}],
                    15: [function(require, module, exports) {
                        "use strict";
                        exports.byteLength = function(b64) {
                            return 3 * b64.length / 4 - placeHoldersCount(b64)
                        };
                        exports.toByteArray = toByteArray;
                        exports.fromByteArray = fromByteArray;
                        for (var lookup = [], revLookup = [], Arr = "undefined" !== typeof Uint8Array ? Uint8Array : Array, code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", i = 0, len = code.length; i < len; ++i) {
                            lookup[i] = code[i];
                            revLookup[code.charCodeAt(i)] = i
                        }
                        revLookup["-".charCodeAt(0)] = 62;
                        revLookup["_".charCodeAt(0)] = 63;

                        function placeHoldersCount(b64) {
                            var len = b64.length;
                            if (0 < len % 4) {
                                throw new Error("Invalid string. Length must be a multiple of 4")
                            }
                            return "=" === b64[len - 2] ? 2 : "=" === b64[len - 1] ? 1 : 0
                        }

                        function toByteArray(b64) {
                            var i, l, tmp, placeHolders, arr, len = b64.length;
                            placeHolders = placeHoldersCount(b64);
                            arr = new Arr(3 * len / 4 - placeHolders);
                            l = 0 < placeHolders ? len - 4 : len;
                            var L = 0;
                            for (i = 0; i < l; i += 4) {
                                tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
                                arr[L++] = 255 & tmp >> 16;
                                arr[L++] = 255 & tmp >> 8;
                                arr[L++] = 255 & tmp
                            }
                            if (2 === placeHolders) {
                                tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
                                arr[L++] = 255 & tmp
                            } else if (1 === placeHolders) {
                                tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
                                arr[L++] = 255 & tmp >> 8;
                                arr[L++] = 255 & tmp
                            }
                            return arr
                        }

                        function tripletToBase64(num) {
                            return lookup[63 & num >> 18] + lookup[63 & num >> 12] + lookup[63 & num >> 6] + lookup[63 & num]
                        }

                        function encodeChunk(uint8, start, end) {
                            for (var tmp, output = [], i = start; i < end; i += 3) {
                                tmp = (16711680 & uint8[i] << 16) + (65280 & uint8[i + 1] << 8) + (255 & uint8[i + 2]);
                                output.push(tripletToBase64(tmp))
                            }
                            return output.join("")
                        }

                        function fromByteArray(uint8) {
                            for (var tmp, len = uint8.length, extraBytes = len % 3, output = "", parts = [], maxChunkLength = 16383, i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
                                parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength))
                            }
                            if (1 === extraBytes) {
                                tmp = uint8[len - 1];
                                output += lookup[tmp >> 2];
                                output += lookup[63 & tmp << 4];
                                output += "=="
                            } else if (2 === extraBytes) {
                                tmp = (uint8[len - 2] << 8) + uint8[len - 1];
                                output += lookup[tmp >> 10];
                                output += lookup[63 & tmp >> 4];
                                output += lookup[63 & tmp << 2];
                                output += "="
                            }
                            parts.push(output);
                            return parts.join("")
                        }
                    }, {}],
                    16: [function(require, module) {
                        function BigInteger(a, b, c) {
                            if (!(this instanceof BigInteger)) return new BigInteger(a, b, c);
                            if (null != a) {
                                if ("number" == typeof a) this.fromNumber(a, b, c);
                                else if (null == b && "string" != typeof a) this.fromString(a, 256);
                                else this.fromString(a, b)
                            }
                        }
                        var proto = BigInteger.prototype;
                        proto.__bigi = require("../package.json").version;
                        BigInteger.isBigInteger = function(obj, check_ver) {
                            return obj && obj.__bigi && (!check_ver || obj.__bigi === proto.__bigi)
                        };
                        var dbits;
                        BigInteger.prototype.am = function(i, x, w, j, c, n) {
                            while (0 <= --n) {
                                var v = x * this[i++] + w[j] + c;
                                c = _Mathfloor(v / 67108864);
                                w[j++] = 67108863 & v
                            }
                            return c
                        };
                        dbits = 26;
                        BigInteger.prototype.DB = dbits;
                        BigInteger.prototype.DM = (1 << dbits) - 1;
                        var DV = BigInteger.prototype.DV = 1 << dbits,
                            BI_FP = 52;
                        BigInteger.prototype.FV = 4503599627370496;
                        BigInteger.prototype.F1 = BI_FP - dbits;
                        BigInteger.prototype.F2 = 2 * dbits - BI_FP;
                        var BI_RC = [],
                            rr, vv;
                        rr = "0".charCodeAt(0);
                        for (vv = 0; 9 >= vv; ++vv) BI_RC[rr++] = vv;
                        rr = "a".charCodeAt(0);
                        for (vv = 10; 36 > vv; ++vv) BI_RC[rr++] = vv;
                        rr = "A".charCodeAt(0);
                        for (vv = 10; 36 > vv; ++vv) BI_RC[rr++] = vv;

                        function int2char(n) {
                            return "0123456789abcdefghijklmnopqrstuvwxyz".charAt(n)
                        }

                        function intAt(s, i) {
                            var c = BI_RC[s.charCodeAt(i)];
                            return null == c ? -1 : c
                        }

                        function nbv(i) {
                            var r = new BigInteger;
                            r.fromInt(i);
                            return r
                        }

                        function nbits(x) {
                            var r = 1,
                                t;
                            if (0 != (t = x >>> 16)) {
                                x = t;
                                r += 16
                            }
                            if (0 != (t = x >> 8)) {
                                x = t;
                                r += 8
                            }
                            if (0 != (t = x >> 4)) {
                                x = t;
                                r += 4
                            }
                            if (0 != (t = x >> 2)) {
                                x = t;
                                r += 2
                            }
                            if (0 != (t = x >> 1)) {
                                x = t;
                                r += 1
                            }
                            return r
                        }

                        function Classic(m) {
                            this.m = m
                        }
                        Classic.prototype.convert = function(x) {
                            if (0 > x.s || 0 <= x.compareTo(this.m)) return x.mod(this.m);
                            else return x
                        };
                        Classic.prototype.revert = function(x) {
                            return x
                        };
                        Classic.prototype.reduce = function(x) {
                            x.divRemTo(this.m, null, x)
                        };
                        Classic.prototype.mulTo = function(x, y, r) {
                            x.multiplyTo(y, r);
                            this.reduce(r)
                        };
                        Classic.prototype.sqrTo = function(x, r) {
                            x.squareTo(r);
                            this.reduce(r)
                        };

                        function Montgomery(m) {
                            this.m = m;
                            this.mp = m.invDigit();
                            this.mpl = 32767 & this.mp;
                            this.mph = this.mp >> 15;
                            this.um = (1 << m.DB - 15) - 1;
                            this.mt2 = 2 * m.t
                        }
                        Montgomery.prototype.convert = function(x) {
                            var r = new BigInteger;
                            x.abs().dlShiftTo(this.m.t, r);
                            r.divRemTo(this.m, null, r);
                            if (0 > x.s && 0 < r.compareTo(BigInteger.ZERO)) this.m.subTo(r, r);
                            return r
                        };
                        Montgomery.prototype.revert = function(x) {
                            var r = new BigInteger;
                            x.copyTo(r);
                            this.reduce(r);
                            return r
                        };
                        Montgomery.prototype.reduce = function(x) {
                            while (x.t <= this.mt2) x[x.t++] = 0;
                            for (var i = 0; i < this.m.t; ++i) {
                                var j = 32767 & x[i],
                                    u0 = j * this.mpl + ((j * this.mph + (x[i] >> 15) * this.mpl & this.um) << 15) & x.DM;
                                j = i + this.m.t;
                                x[j] += this.m.am(0, u0, x, i, 0, this.m.t);
                                while (x[j] >= x.DV) {
                                    x[j] -= x.DV;
                                    x[++j]++
                                }
                            }
                            x.clamp();
                            x.drShiftTo(this.m.t, x);
                            if (0 <= x.compareTo(this.m)) x.subTo(this.m, x)
                        };
                        Montgomery.prototype.mulTo = function(x, y, r) {
                            x.multiplyTo(y, r);
                            this.reduce(r)
                        };
                        Montgomery.prototype.sqrTo = function(x, r) {
                            x.squareTo(r);
                            this.reduce(r)
                        };
                        proto.copyTo = function(r) {
                            for (var i = this.t - 1; 0 <= i; --i) r[i] = this[i];
                            r.t = this.t;
                            r.s = this.s
                        };
                        proto.fromInt = function(x) {
                            this.t = 1;
                            this.s = 0 > x ? -1 : 0;
                            if (0 < x) this[0] = x;
                            else if (-1 > x) this[0] = x + DV;
                            else this.t = 0
                        };
                        proto.fromString = function(s, b) {
                            var self = this,
                                k;
                            if (16 == b) k = 4;
                            else if (8 == b) k = 3;
                            else if (256 == b) k = 8;
                            else if (2 == b) k = 1;
                            else if (32 == b) k = 5;
                            else if (4 == b) k = 2;
                            else {
                                self.fromRadix(s, b);
                                return
                            }
                            self.t = 0;
                            self.s = 0;
                            var i = s.length,
                                mi = !1,
                                sh = 0;
                            while (0 <= --i) {
                                var x = 8 == k ? 255 & s[i] : intAt(s, i);
                                if (0 > x) {
                                    if ("-" == s.charAt(i)) mi = !0;
                                    continue
                                }
                                mi = !1;
                                if (0 == sh) self[self.t++] = x;
                                else if (sh + k > self.DB) {
                                    self[self.t - 1] |= (x & (1 << self.DB - sh) - 1) << sh;
                                    self[self.t++] = x >> self.DB - sh
                                } else self[self.t - 1] |= x << sh;
                                sh += k;
                                if (sh >= self.DB) sh -= self.DB
                            }
                            if (8 == k && 0 != (128 & s[0])) {
                                self.s = -1;
                                if (0 < sh) self[self.t - 1] |= (1 << self.DB - sh) - 1 << sh
                            }
                            self.clamp();
                            if (mi) BigInteger.ZERO.subTo(self, self)
                        };
                        proto.clamp = function() {
                            var c = this.s & this.DM;
                            while (0 < this.t && this[this.t - 1] == c) --this.t
                        };
                        proto.dlShiftTo = function(n, r) {
                            var i;
                            for (i = this.t - 1; 0 <= i; --i) r[i + n] = this[i];
                            for (i = n - 1; 0 <= i; --i) r[i] = 0;
                            r.t = this.t + n;
                            r.s = this.s
                        };
                        proto.drShiftTo = function(n, r) {
                            for (var i = n; i < this.t; ++i) r[i - n] = this[i];
                            r.t = _Mathmax(this.t - n, 0);
                            r.s = this.s
                        };
                        proto.lShiftTo = function(n, r) {
                            var self = this,
                                bs = n % self.DB,
                                cbs = self.DB - bs,
                                ds = _Mathfloor(n / self.DB),
                                c = self.s << bs & self.DM,
                                i;
                            for (i = self.t - 1; 0 <= i; --i) {
                                r[i + ds + 1] = self[i] >> cbs | c;
                                c = (self[i] & (1 << cbs) - 1) << bs
                            }
                            for (i = ds - 1; 0 <= i; --i) r[i] = 0;
                            r[ds] = c;
                            r.t = self.t + ds + 1;
                            r.s = self.s;
                            r.clamp()
                        };
                        proto.rShiftTo = function(n, r) {
                            var self = this;
                            r.s = self.s;
                            var ds = _Mathfloor(n / self.DB);
                            if (ds >= self.t) {
                                r.t = 0;
                                return
                            }
                            var bs = n % self.DB,
                                cbs = self.DB - bs,
                                bm = (1 << bs) - 1;
                            r[0] = self[ds] >> bs;
                            for (var i = ds + 1; i < self.t; ++i) {
                                r[i - ds - 1] |= (self[i] & bm) << cbs;
                                r[i - ds] = self[i] >> bs
                            }
                            if (0 < bs) r[self.t - ds - 1] |= (self.s & bm) << cbs;
                            r.t = self.t - ds;
                            r.clamp()
                        };
                        proto.subTo = function(a, r) {
                            var self = this,
                                i = 0,
                                c = 0,
                                m = _Mathmin(a.t, self.t);
                            while (i < m) {
                                c += self[i] - a[i];
                                r[i++] = c & self.DM;
                                c >>= self.DB
                            }
                            if (a.t < self.t) {
                                c -= a.s;
                                while (i < self.t) {
                                    c += self[i];
                                    r[i++] = c & self.DM;
                                    c >>= self.DB
                                }
                                c += self.s
                            } else {
                                c += self.s;
                                while (i < a.t) {
                                    c -= a[i];
                                    r[i++] = c & self.DM;
                                    c >>= self.DB
                                }
                                c -= a.s
                            }
                            r.s = 0 > c ? -1 : 0;
                            if (-1 > c) r[i++] = self.DV + c;
                            else if (0 < c) r[i++] = c;
                            r.t = i;
                            r.clamp()
                        };
                        proto.multiplyTo = function(a, r) {
                            var x = this.abs(),
                                y = a.abs(),
                                i = x.t;
                            r.t = i + y.t;
                            while (0 <= --i) r[i] = 0;
                            for (i = 0; i < y.t; ++i) r[i + x.t] = x.am(0, y[i], r, i, 0, x.t);
                            r.s = 0;
                            r.clamp();
                            if (this.s != a.s) BigInteger.ZERO.subTo(r, r)
                        };
                        proto.squareTo = function(r) {
                            var x = this.abs(),
                                i = r.t = 2 * x.t;
                            while (0 <= --i) r[i] = 0;
                            for (i = 0; i < x.t - 1; ++i) {
                                var c = x.am(i, x[i], r, 2 * i, 0, 1);
                                if ((r[i + x.t] += x.am(i + 1, 2 * x[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV) {
                                    r[i + x.t] -= x.DV;
                                    r[i + x.t + 1] = 1
                                }
                            }
                            if (0 < r.t) r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1);
                            r.s = 0;
                            r.clamp()
                        };
                        proto.divRemTo = function(m, q, r) {
                            var self = this,
                                pm = m.abs();
                            if (0 >= pm.t) return;
                            var pt = self.abs();
                            if (pt.t < pm.t) {
                                if (null != q) q.fromInt(0);
                                if (null != r) self.copyTo(r);
                                return
                            }
                            if (null == r) r = new BigInteger;
                            var y = new BigInteger,
                                ts = self.s,
                                ms = m.s,
                                nsh = self.DB - nbits(pm[pm.t - 1]);
                            if (0 < nsh) {
                                pm.lShiftTo(nsh, y);
                                pt.lShiftTo(nsh, r)
                            } else {
                                pm.copyTo(y);
                                pt.copyTo(r)
                            }
                            var ys = y.t,
                                y0 = y[ys - 1];
                            if (0 == y0) return;
                            var yt = y0 * (1 << self.F1) + (1 < ys ? y[ys - 2] >> self.F2 : 0),
                                d1 = self.FV / yt,
                                d2 = (1 << self.F1) / yt,
                                e = 1 << self.F2,
                                i = r.t,
                                j = i - ys,
                                t = null == q ? new BigInteger : q;
                            y.dlShiftTo(j, t);
                            if (0 <= r.compareTo(t)) {
                                r[r.t++] = 1;
                                r.subTo(t, r)
                            }
                            BigInteger.ONE.dlShiftTo(ys, t);
                            t.subTo(y, y);
                            while (y.t < ys) y[y.t++] = 0;
                            while (0 <= --j) {
                                var qd = r[--i] == y0 ? self.DM : _Mathfloor(r[i] * d1 + (r[i - 1] + e) * d2);
                                if ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd) {
                                    y.dlShiftTo(j, t);
                                    r.subTo(t, r);
                                    while (r[i] < --qd) r.subTo(t, r)
                                }
                            }
                            if (null != q) {
                                r.drShiftTo(ys, q);
                                if (ts != ms) BigInteger.ZERO.subTo(q, q)
                            }
                            r.t = ys;
                            r.clamp();
                            if (0 < nsh) r.rShiftTo(nsh, r);
                            if (0 > ts) BigInteger.ZERO.subTo(r, r)
                        };
                        proto.invDigit = function() {
                            if (1 > this.t) return 0;
                            var x = this[0];
                            if (0 == (1 & x)) return 0;
                            var y = 3 & x;
                            y = 15 & y * (2 - (15 & x) * y);
                            y = 255 & y * (2 - (255 & x) * y);
                            y = 65535 & y * (2 - (65535 & (65535 & x) * y));
                            y = y * (2 - x * y % this.DV) % this.DV;
                            return 0 < y ? this.DV - y : -y
                        };
                        proto.isEven = function() {
                            return 0 == (0 < this.t ? 1 & this[0] : this.s)
                        };
                        proto.exp = function(e, z) {
                            if (4294967295 < e || 1 > e) return BigInteger.ONE;
                            var r = new BigInteger,
                                r2 = new BigInteger,
                                g = z.convert(this),
                                i = nbits(e) - 1;
                            g.copyTo(r);
                            while (0 <= --i) {
                                z.sqrTo(r, r2);
                                if (0 < (e & 1 << i)) z.mulTo(r2, g, r);
                                else {
                                    var t = r;
                                    r = r2;
                                    r2 = t
                                }
                            }
                            return z.revert(r)
                        };
                        proto.toString = function(b) {
                            var self = this;
                            if (0 > self.s) return "-" + self.negate().toString(b);
                            var k;
                            if (16 == b) k = 4;
                            else if (8 == b) k = 3;
                            else if (2 == b) k = 1;
                            else if (32 == b) k = 5;
                            else if (4 == b) k = 2;
                            else return self.toRadix(b);
                            var km = (1 << k) - 1,
                                d, m = !1,
                                r = "",
                                i = self.t,
                                p = self.DB - i * self.DB % k;
                            if (0 < i--) {
                                if (p < self.DB && 0 < (d = self[i] >> p)) {
                                    m = !0;
                                    r = int2char(d)
                                }
                                while (0 <= i) {
                                    if (p < k) {
                                        d = (self[i] & (1 << p) - 1) << k - p;
                                        d |= self[--i] >> (p += self.DB - k)
                                    } else {
                                        d = self[i] >> (p -= k) & km;
                                        if (0 >= p) {
                                            p += self.DB;
                                            --i
                                        }
                                    }
                                    if (0 < d) m = !0;
                                    if (m) r += int2char(d)
                                }
                            }
                            return m ? r : "0"
                        };
                        proto.negate = function() {
                            var r = new BigInteger;
                            BigInteger.ZERO.subTo(this, r);
                            return r
                        };
                        proto.abs = function() {
                            return 0 > this.s ? this.negate() : this
                        };
                        proto.compareTo = function(a) {
                            var r = this.s - a.s;
                            if (0 != r) return r;
                            var i = this.t;
                            r = i - a.t;
                            if (0 != r) return 0 > this.s ? -r : r;
                            while (0 <= --i)
                                if (0 != (r = this[i] - a[i])) return r;
                            return 0
                        };
                        proto.bitLength = function() {
                            if (0 >= this.t) return 0;
                            return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ this.s & this.DM)
                        };
                        proto.byteLength = function() {
                            return this.bitLength() >> 3
                        };
                        proto.mod = function(a) {
                            var r = new BigInteger;
                            this.abs().divRemTo(a, null, r);
                            if (0 > this.s && 0 < r.compareTo(BigInteger.ZERO)) a.subTo(r, r);
                            return r
                        };
                        proto.modPowInt = function(e, m) {
                            var z;
                            if (256 > e || m.isEven()) z = new Classic(m);
                            else z = new Montgomery(m);
                            return this.exp(e, z)
                        };

                        function op_and(x, y) {
                            return x & y
                        }

                        function op_or(x, y) {
                            return x | y
                        }

                        function op_xor(x, y) {
                            return x ^ y
                        }

                        function op_andnot(x, y) {
                            return x & ~y
                        }

                        function lbit(x) {
                            if (0 == x) return -1;
                            var r = 0;
                            if (0 == (65535 & x)) {
                                x >>= 16;
                                r += 16
                            }
                            if (0 == (255 & x)) {
                                x >>= 8;
                                r += 8
                            }
                            if (0 == (15 & x)) {
                                x >>= 4;
                                r += 4
                            }
                            if (0 == (3 & x)) {
                                x >>= 2;
                                r += 2
                            }
                            if (0 == (1 & x)) ++r;
                            return r
                        }

                        function cbit(x) {
                            var r = 0;
                            while (0 != x) {
                                x &= x - 1;
                                ++r
                            }
                            return r
                        }

                        function NullExp() {}

                        function nNop(x) {
                            return x
                        }
                        NullExp.prototype.convert = nNop;
                        NullExp.prototype.revert = nNop;
                        NullExp.prototype.mulTo = function(x, y, r) {
                            x.multiplyTo(y, r)
                        };
                        NullExp.prototype.sqrTo = function(x, r) {
                            x.squareTo(r)
                        };

                        function Barrett(m) {
                            this.r2 = new BigInteger;
                            this.q3 = new BigInteger;
                            BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);
                            this.mu = this.r2.divide(m);
                            this.m = m
                        }
                        Barrett.prototype.convert = function(x) {
                            if (0 > x.s || x.t > 2 * this.m.t) return x.mod(this.m);
                            else if (0 > x.compareTo(this.m)) return x;
                            else {
                                var r = new BigInteger;
                                x.copyTo(r);
                                this.reduce(r);
                                return r
                            }
                        };
                        Barrett.prototype.revert = function(x) {
                            return x
                        };
                        Barrett.prototype.reduce = function(x) {
                            var self = this;
                            x.drShiftTo(self.m.t - 1, self.r2);
                            if (x.t > self.m.t + 1) {
                                x.t = self.m.t + 1;
                                x.clamp()
                            }
                            self.mu.multiplyUpperTo(self.r2, self.m.t + 1, self.q3);
                            self.m.multiplyLowerTo(self.q3, self.m.t + 1, self.r2);
                            while (0 > x.compareTo(self.r2)) x.dAddOffset(1, self.m.t + 1);
                            x.subTo(self.r2, x);
                            while (0 <= x.compareTo(self.m)) x.subTo(self.m, x)
                        };
                        Barrett.prototype.mulTo = function(x, y, r) {
                            x.multiplyTo(y, r);
                            this.reduce(r)
                        };
                        Barrett.prototype.sqrTo = function(x, r) {
                            x.squareTo(r);
                            this.reduce(r)
                        };
                        var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997],
                            lplim = (1 << 26) / lowprimes[lowprimes.length - 1];
                        proto.chunkSize = function(r) {
                            return _Mathfloor(_MathLN * this.DB / _Mathlog(r))
                        };
                        proto.toRadix = function(b) {
                            if (null == b) b = 10;
                            if (0 == this.signum() || 2 > b || 36 < b) return "0";
                            var cs = this.chunkSize(b),
                                a = _Mathpow(b, cs),
                                d = nbv(a),
                                y = new BigInteger,
                                z = new BigInteger,
                                r = "";
                            this.divRemTo(d, y, z);
                            while (0 < y.signum()) {
                                r = (a + z.intValue()).toString(b).substr(1) + r;
                                y.divRemTo(d, y, z)
                            }
                            return z.intValue().toString(b) + r
                        };
                        proto.fromRadix = function(s, b) {
                            var self = this;
                            self.fromInt(0);
                            if (null == b) b = 10;
                            for (var cs = self.chunkSize(b), d = _Mathpow(b, cs), mi = !1, j = 0, w = 0, i = 0, x; i < s.length; ++i) {
                                x = intAt(s, i);
                                if (0 > x) {
                                    if ("-" == s.charAt(i) && 0 == self.signum()) mi = !0;
                                    continue
                                }
                                w = b * w + x;
                                if (++j >= cs) {
                                    self.dMultiply(d);
                                    self.dAddOffset(w, 0);
                                    j = 0;
                                    w = 0
                                }
                            }
                            if (0 < j) {
                                self.dMultiply(_Mathpow(b, j));
                                self.dAddOffset(w, 0)
                            }
                            if (mi) BigInteger.ZERO.subTo(self, self)
                        };
                        proto.fromNumber = function(a, b, c) {
                            var self = this;
                            if ("number" == typeof b) {
                                if (2 > a) self.fromInt(1);
                                else {
                                    self.fromNumber(a, c);
                                    if (!self.testBit(a - 1)) self.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, self);
                                    if (self.isEven()) self.dAddOffset(1, 0);
                                    while (!self.isProbablePrime(b)) {
                                        self.dAddOffset(2, 0);
                                        if (self.bitLength() > a) self.subTo(BigInteger.ONE.shiftLeft(a - 1), self)
                                    }
                                }
                            } else {
                                var x = [],
                                    t = 7 & a;
                                x.length = (a >> 3) + 1;
                                b.nextBytes(x);
                                if (0 < t) x[0] &= (1 << t) - 1;
                                else x[0] = 0;
                                self.fromString(x, 256)
                            }
                        };
                        proto.bitwiseTo = function(a, op, r) {
                            var self = this,
                                i, f, m = _Mathmin(a.t, self.t);
                            for (i = 0; i < m; ++i) r[i] = op(self[i], a[i]);
                            if (a.t < self.t) {
                                f = a.s & self.DM;
                                for (i = m; i < self.t; ++i) r[i] = op(self[i], f);
                                r.t = self.t
                            } else {
                                f = self.s & self.DM;
                                for (i = m; i < a.t; ++i) r[i] = op(f, a[i]);
                                r.t = a.t
                            }
                            r.s = op(self.s, a.s);
                            r.clamp()
                        };
                        proto.changeBit = function(n, op) {
                            var r = BigInteger.ONE.shiftLeft(n);
                            this.bitwiseTo(r, op, r);
                            return r
                        };
                        proto.addTo = function(a, r) {
                            var self = this,
                                i = 0,
                                c = 0,
                                m = _Mathmin(a.t, self.t);
                            while (i < m) {
                                c += self[i] + a[i];
                                r[i++] = c & self.DM;
                                c >>= self.DB
                            }
                            if (a.t < self.t) {
                                c += a.s;
                                while (i < self.t) {
                                    c += self[i];
                                    r[i++] = c & self.DM;
                                    c >>= self.DB
                                }
                                c += self.s
                            } else {
                                c += self.s;
                                while (i < a.t) {
                                    c += a[i];
                                    r[i++] = c & self.DM;
                                    c >>= self.DB
                                }
                                c += a.s
                            }
                            r.s = 0 > c ? -1 : 0;
                            if (0 < c) r[i++] = c;
                            else if (-1 > c) r[i++] = self.DV + c;
                            r.t = i;
                            r.clamp()
                        };
                        proto.dMultiply = function(n) {
                            this[this.t] = this.am(0, n - 1, this, 0, 0, this.t);
                            ++this.t;
                            this.clamp()
                        };
                        proto.dAddOffset = function(n, w) {
                            if (0 == n) return;
                            while (this.t <= w) this[this.t++] = 0;
                            this[w] += n;
                            while (this[w] >= this.DV) {
                                this[w] -= this.DV;
                                if (++w >= this.t) this[this.t++] = 0;
                                ++this[w]
                            }
                        };
                        proto.multiplyLowerTo = function(a, n, r) {
                            var i = _Mathmin(this.t + a.t, n);
                            r.s = 0;
                            r.t = i;
                            while (0 < i) r[--i] = 0;
                            var j;
                            for (j = r.t - this.t; i < j; ++i) r[i + this.t] = this.am(0, a[i], r, i, 0, this.t);
                            for (j = _Mathmin(a.t, n); i < j; ++i) this.am(0, a[i], r, i, 0, n - i);
                            r.clamp()
                        };
                        proto.multiplyUpperTo = function(a, n, r) {
                            --n;
                            var i = r.t = this.t + a.t - n;
                            r.s = 0;
                            while (0 <= --i) r[i] = 0;
                            for (i = _Mathmax(n - this.t, 0); i < a.t; ++i) r[this.t + i - n] = this.am(n - i, a[i], r, 0, 0, this.t + i - n);
                            r.clamp();
                            r.drShiftTo(1, r)
                        };
                        proto.modInt = function(n) {
                            if (0 >= n) return 0;
                            var d = this.DV % n,
                                r = 0 > this.s ? n - 1 : 0;
                            if (0 < this.t)
                                if (0 == d) r = this[0] % n;
                                else
                                    for (var i = this.t - 1; 0 <= i; --i) r = (d * r + this[i]) % n;
                            return r
                        };
                        proto.millerRabin = function(t) {
                            var n1 = this.subtract(BigInteger.ONE),
                                k = n1.getLowestSetBit();
                            if (0 >= k) return !1;
                            var r = n1.shiftRight(k);
                            t = t + 1 >> 1;
                            if (t > lowprimes.length) t = lowprimes.length;
                            for (var a = new BigInteger(null), j, bases = [], i = 0; i < t; ++i) {
                                for (;;) {
                                    j = lowprimes[_Mathfloor(Math.random() * lowprimes.length)];
                                    if (-1 == bases.indexOf(j)) break
                                }
                                bases.push(j);
                                a.fromInt(j);
                                var y = a.modPow(r, this);
                                if (0 != y.compareTo(BigInteger.ONE) && 0 != y.compareTo(n1)) {
                                    var j = 1;
                                    while (j++ < k && 0 != y.compareTo(n1)) {
                                        y = y.modPowInt(2, this);
                                        if (0 == y.compareTo(BigInteger.ONE)) return !1
                                    }
                                    if (0 != y.compareTo(n1)) return !1
                                }
                            }
                            return !0
                        };
                        proto.clone = function() {
                            var r = new BigInteger;
                            this.copyTo(r);
                            return r
                        };
                        proto.intValue = function() {
                            if (0 > this.s) {
                                if (1 == this.t) return this[0] - this.DV;
                                else if (0 == this.t) return -1
                            } else if (1 == this.t) return this[0];
                            else if (0 == this.t) return 0;
                            return (this[1] & (1 << 32 - this.DB) - 1) << this.DB | this[0]
                        };
                        proto.byteValue = function() {
                            return 0 == this.t ? this.s : this[0] << 24 >> 24
                        };
                        proto.shortValue = function() {
                            return 0 == this.t ? this.s : this[0] << 16 >> 16
                        };
                        proto.signum = function() {
                            if (0 > this.s) return -1;
                            else if (0 >= this.t || 1 == this.t && 0 >= this[0]) return 0;
                            else return 1
                        };
                        proto.toByteArray = function() {
                            var self = this,
                                i = self.t,
                                r = [];
                            r[0] = self.s;
                            var p = self.DB - i * self.DB % 8,
                                d, k = 0;
                            if (0 < i--) {
                                if (p < self.DB && (d = self[i] >> p) != (self.s & self.DM) >> p) r[k++] = d | self.s << self.DB - p;
                                while (0 <= i) {
                                    if (8 > p) {
                                        d = (self[i] & (1 << p) - 1) << 8 - p;
                                        d |= self[--i] >> (p += self.DB - 8)
                                    } else {
                                        d = 255 & self[i] >> (p -= 8);
                                        if (0 >= p) {
                                            p += self.DB;
                                            --i
                                        }
                                    }
                                    if (0 != (128 & d)) d |= -256;
                                    if (0 === k && (128 & self.s) != (128 & d)) ++k;
                                    if (0 < k || d != self.s) r[k++] = d
                                }
                            }
                            return r
                        };
                        proto.equals = function(a) {
                            return 0 == this.compareTo(a)
                        };
                        proto.min = function(a) {
                            return 0 > this.compareTo(a) ? this : a
                        };
                        proto.max = function(a) {
                            return 0 < this.compareTo(a) ? this : a
                        };
                        proto.and = function(a) {
                            var r = new BigInteger;
                            this.bitwiseTo(a, op_and, r);
                            return r
                        };
                        proto.or = function(a) {
                            var r = new BigInteger;
                            this.bitwiseTo(a, op_or, r);
                            return r
                        };
                        proto.xor = function(a) {
                            var r = new BigInteger;
                            this.bitwiseTo(a, op_xor, r);
                            return r
                        };
                        proto.andNot = function(a) {
                            var r = new BigInteger;
                            this.bitwiseTo(a, op_andnot, r);
                            return r
                        };
                        proto.not = function() {
                            for (var r = new BigInteger, i = 0; i < this.t; ++i) r[i] = this.DM & ~this[i];
                            r.t = this.t;
                            r.s = ~this.s;
                            return r
                        };
                        proto.shiftLeft = function(n) {
                            var r = new BigInteger;
                            if (0 > n) this.rShiftTo(-n, r);
                            else this.lShiftTo(n, r);
                            return r
                        };
                        proto.shiftRight = function(n) {
                            var r = new BigInteger;
                            if (0 > n) this.lShiftTo(-n, r);
                            else this.rShiftTo(n, r);
                            return r
                        };
                        proto.getLowestSetBit = function() {
                            for (var i = 0; i < this.t; ++i)
                                if (0 != this[i]) return i * this.DB + lbit(this[i]);
                            if (0 > this.s) return this.t * this.DB;
                            return -1
                        };
                        proto.bitCount = function() {
                            for (var r = 0, x = this.s & this.DM, i = 0; i < this.t; ++i) r += cbit(this[i] ^ x);
                            return r
                        };
                        proto.testBit = function(n) {
                            var j = _Mathfloor(n / this.DB);
                            if (j >= this.t) return 0 != this.s;
                            return 0 != (this[j] & 1 << n % this.DB)
                        };
                        proto.setBit = function(n) {
                            return this.changeBit(n, op_or)
                        };
                        proto.clearBit = function(n) {
                            return this.changeBit(n, op_andnot)
                        };
                        proto.flipBit = function(n) {
                            return this.changeBit(n, op_xor)
                        };
                        proto.add = function(a) {
                            var r = new BigInteger;
                            this.addTo(a, r);
                            return r
                        };
                        proto.subtract = function(a) {
                            var r = new BigInteger;
                            this.subTo(a, r);
                            return r
                        };
                        proto.multiply = function(a) {
                            var r = new BigInteger;
                            this.multiplyTo(a, r);
                            return r
                        };
                        proto.divide = function(a) {
                            var r = new BigInteger;
                            this.divRemTo(a, r, null);
                            return r
                        };
                        proto.remainder = function(a) {
                            var r = new BigInteger;
                            this.divRemTo(a, null, r);
                            return r
                        };
                        proto.divideAndRemainder = function(a) {
                            var q = new BigInteger,
                                r = new BigInteger;
                            this.divRemTo(a, q, r);
                            return [q, r]
                        };
                        proto.modPow = function(e, m) {
                            var i = e.bitLength(),
                                k, r = nbv(1),
                                z;
                            if (0 >= i) return r;
                            else if (18 > i) k = 1;
                            else if (48 > i) k = 3;
                            else if (144 > i) k = 4;
                            else if (768 > i) k = 5;
                            else k = 6;
                            if (8 > i) z = new Classic(m);
                            else if (m.isEven()) z = new Barrett(m);
                            else z = new Montgomery(m);
                            var g = [],
                                n = 3,
                                k1 = k - 1,
                                km = (1 << k) - 1;
                            g[1] = z.convert(this);
                            if (1 < k) {
                                var g2 = new BigInteger;
                                z.sqrTo(g[1], g2);
                                while (n <= km) {
                                    g[n] = new BigInteger;
                                    z.mulTo(g2, g[n - 2], g[n]);
                                    n += 2
                                }
                            }
                            var j = e.t - 1,
                                w, is1 = !0,
                                r2 = new BigInteger,
                                t;
                            i = nbits(e[j]) - 1;
                            while (0 <= j) {
                                if (i >= k1) w = e[j] >> i - k1 & km;
                                else {
                                    w = (e[j] & (1 << i + 1) - 1) << k1 - i;
                                    if (0 < j) w |= e[j - 1] >> this.DB + i - k1
                                }
                                n = k;
                                while (0 == (1 & w)) {
                                    w >>= 1;
                                    --n
                                }
                                if (0 > (i -= n)) {
                                    i += this.DB;
                                    --j
                                }
                                if (is1) {
                                    g[w].copyTo(r);
                                    is1 = !1
                                } else {
                                    while (1 < n) {
                                        z.sqrTo(r, r2);
                                        z.sqrTo(r2, r);
                                        n -= 2
                                    }
                                    if (0 < n) z.sqrTo(r, r2);
                                    else {
                                        t = r;
                                        r = r2;
                                        r2 = t
                                    }
                                    z.mulTo(r2, g[w], r)
                                }
                                while (0 <= j && 0 == (e[j] & 1 << i)) {
                                    z.sqrTo(r, r2);
                                    t = r;
                                    r = r2;
                                    r2 = t;
                                    if (0 > --i) {
                                        i = this.DB - 1;
                                        --j
                                    }
                                }
                            }
                            return z.revert(r)
                        };
                        proto.modInverse = function(m) {
                            var ac = m.isEven();
                            if (0 === this.signum()) throw new Error("division by zero");
                            if (this.isEven() && ac || 0 == m.signum()) return BigInteger.ZERO;
                            var u = m.clone(),
                                v = this.clone(),
                                a = nbv(1),
                                b = nbv(0),
                                c = nbv(0),
                                d = nbv(1);
                            while (0 != u.signum()) {
                                while (u.isEven()) {
                                    u.rShiftTo(1, u);
                                    if (ac) {
                                        if (!a.isEven() || !b.isEven()) {
                                            a.addTo(this, a);
                                            b.subTo(m, b)
                                        }
                                        a.rShiftTo(1, a)
                                    } else if (!b.isEven()) b.subTo(m, b);
                                    b.rShiftTo(1, b)
                                }
                                while (v.isEven()) {
                                    v.rShiftTo(1, v);
                                    if (ac) {
                                        if (!c.isEven() || !d.isEven()) {
                                            c.addTo(this, c);
                                            d.subTo(m, d)
                                        }
                                        c.rShiftTo(1, c)
                                    } else if (!d.isEven()) d.subTo(m, d);
                                    d.rShiftTo(1, d)
                                }
                                if (0 <= u.compareTo(v)) {
                                    u.subTo(v, u);
                                    if (ac) a.subTo(c, a);
                                    b.subTo(d, b)
                                } else {
                                    v.subTo(u, v);
                                    if (ac) c.subTo(a, c);
                                    d.subTo(b, d)
                                }
                            }
                            if (0 != v.compareTo(BigInteger.ONE)) return BigInteger.ZERO;
                            while (0 <= d.compareTo(m)) d.subTo(m, d);
                            while (0 > d.signum()) d.addTo(m, d);
                            return d
                        };
                        proto.pow = function(e) {
                            return this.exp(e, new NullExp)
                        };
                        proto.gcd = function(a) {
                            var x = 0 > this.s ? this.negate() : this.clone(),
                                y = 0 > a.s ? a.negate() : a.clone();
                            if (0 > x.compareTo(y)) {
                                var t = x;
                                x = y;
                                y = t
                            }
                            var i = x.getLowestSetBit(),
                                g = y.getLowestSetBit();
                            if (0 > g) return x;
                            if (i < g) g = i;
                            if (0 < g) {
                                x.rShiftTo(g, x);
                                y.rShiftTo(g, y)
                            }
                            while (0 < x.signum()) {
                                if (0 < (i = x.getLowestSetBit())) x.rShiftTo(i, x);
                                if (0 < (i = y.getLowestSetBit())) y.rShiftTo(i, y);
                                if (0 <= x.compareTo(y)) {
                                    x.subTo(y, x);
                                    x.rShiftTo(1, x)
                                } else {
                                    y.subTo(x, y);
                                    y.rShiftTo(1, y)
                                }
                            }
                            if (0 < g) y.lShiftTo(g, y);
                            return y
                        };
                        proto.isProbablePrime = function(t) {
                            var i, x = this.abs();
                            if (1 == x.t && x[0] <= lowprimes[lowprimes.length - 1]) {
                                for (i = 0; i < lowprimes.length; ++i)
                                    if (x[0] == lowprimes[i]) return !0;
                                return !1
                            }
                            if (x.isEven()) return !1;
                            i = 1;
                            while (i < lowprimes.length) {
                                var m = lowprimes[i],
                                    j = i + 1;
                                while (j < lowprimes.length && m < lplim) m *= lowprimes[j++];
                                m = x.modInt(m);
                                while (i < j)
                                    if (0 == m % lowprimes[i++]) return !1
                            }
                            return x.millerRabin(t)
                        };
                        proto.square = function() {
                            var r = new BigInteger;
                            this.squareTo(r);
                            return r
                        };
                        BigInteger.ZERO = nbv(0);
                        BigInteger.ONE = nbv(1);
                        BigInteger.valueOf = nbv;
                        module.exports = BigInteger
                    }, {
                        "../package.json": 19
                    }],
                    17: [function(require) {
                        (function(Buffer) {
                            var assert = require("assert"),
                                BigInteger = require("./bigi");
                            BigInteger.fromByteArrayUnsigned = function(byteArray) {
                                if (128 & byteArray[0]) {
                                    return new BigInteger([0].concat(byteArray))
                                }
                                return new BigInteger(byteArray)
                            };
                            BigInteger.prototype.toByteArrayUnsigned = function() {
                                var byteArray = this.toByteArray();
                                return 0 === byteArray[0] ? byteArray.slice(1) : byteArray
                            };
                            BigInteger.fromDERInteger = function(byteArray) {
                                return new BigInteger(byteArray)
                            };
                            BigInteger.prototype.toDERInteger = BigInteger.prototype.toByteArray;
                            BigInteger.fromBuffer = function(buffer) {
                                if (128 & buffer[0]) {
                                    var byteArray = Array.prototype.slice.call(buffer);
                                    return new BigInteger([0].concat(byteArray))
                                }
                                return new BigInteger(buffer)
                            };
                            BigInteger.fromHex = function(hex) {
                                if ("" === hex) return BigInteger.ZERO;
                                assert.equal(hex, hex.match(/^[A-Fa-f0-9]+/), "Invalid hex string");
                                assert.equal(hex.length % 2, 0, "Incomplete hex");
                                return new BigInteger(hex, 16)
                            };
                            BigInteger.prototype.toBuffer = function(size) {
                                var byteArray = this.toByteArrayUnsigned(),
                                    zeros = [],
                                    padding = size - byteArray.length;
                                while (zeros.length < padding) zeros.push(0);
                                return new Buffer(zeros.concat(byteArray))
                            };
                            BigInteger.prototype.toHex = function(size) {
                                return this.toBuffer(size).toString("hex")
                            }
                        }).call(this, require("buffer").Buffer)
                    }, {
                        "./bigi": 16,
                        assert: 12,
                        buffer: 45
                    }],
                    18: [function(require, module) {
                        var BigInteger = require("./bigi");
                        require("./convert");
                        module.exports = BigInteger
                    }, {
                        "./bigi": 16,
                        "./convert": 17
                    }],
                    19: [function(require, module) {
                        module.exports = {
                            _args: [
                                ["bigi@1.4.2", "/Users/matthieu/Projects/cert-verifier-js/code"]
                            ],
                            _from: "bigi@1.4.2",
                            _id: "bigi@1.4.2",
                            _inBundle: !1,
                            _integrity: "sha1-nGZalfiLiwj8Bc/XMfVhhZ1yWCU=",
                            _location: "/bigi",
                            _phantomChildren: {},
                            _requested: {
                                type: "version",
                                registry: !0,
                                raw: "bigi@1.4.2",
                                name: "bigi",
                                escapedName: "bigi",
                                rawSpec: "1.4.2",
                                saveSpec: null,
                                fetchSpec: "1.4.2"
                            },
                            _requiredBy: ["/", "/bitcoinjs-lib", "/ecurve"],
                            _resolved: "https://registry.npmjs.org/bigi/-/bigi-1.4.2.tgz",
                            _spec: "1.4.2",
                            _where: "/Users/matthieu/Projects/cert-verifier-js/code",
                            bugs: {
                                url: "https://github.com/cryptocoinjs/bigi/issues"
                            },
                            dependencies: {},
                            description: "Big integers.",
                            devDependencies: {
                                coveralls: "^2.11.2",
                                istanbul: "^0.3.5",
                                jshint: "^2.5.1",
                                mocha: "^2.1.0",
                                mochify: "^2.1.0"
                            },
                            homepage: "https://github.com/cryptocoinjs/bigi#readme",
                            keywords: ["cryptography", "math", "bitcoin", "arbitrary", "precision", "arithmetic", "big", "integer", "int", "number", "biginteger", "bigint", "bignumber", "decimal", "float"],
                            main: "./lib/index.js",
                            name: "bigi",
                            repository: {
                                url: "git+https://github.com/cryptocoinjs/bigi.git",
                                type: "git"
                            },
                            scripts: {
                                "browser-test": "mochify --wd -R spec",
                                coverage: "istanbul cover ./node_modules/.bin/_mocha -- --reporter list test/*.js",
                                coveralls: "npm run-script coverage && node ./node_modules/.bin/coveralls < coverage/lcov.info",
                                jshint: "jshint --config jshint.json lib/*.js ; true",
                                test: "_mocha -- test/*.js",
                                unit: "mocha"
                            },
                            testling: {
                                files: "test/*.js",
                                harness: "mocha",
                                browsers: ["ie/9..latest", "firefox/latest", "chrome/latest", "safari/6.0..latest", "iphone/6.0..latest", "android-browser/4.2..latest"]
                            },
                            version: "1.4.2"
                        }
                    }, {}],
                    20: [function(require, module) {
                        var Buffer = require("safe-buffer").Buffer;
                        module.exports = {
                            check: function(buffer) {
                                if (8 > buffer.length) return !1;
                                if (72 < buffer.length) return !1;
                                if (48 !== buffer[0]) return !1;
                                if (buffer[1] !== buffer.length - 2) return !1;
                                if (2 !== buffer[2]) return !1;
                                var lenR = buffer[3];
                                if (0 === lenR) return !1;
                                if (5 + lenR >= buffer.length) return !1;
                                if (2 !== buffer[4 + lenR]) return !1;
                                var lenS = buffer[5 + lenR];
                                if (0 === lenS) return !1;
                                if (6 + lenR + lenS !== buffer.length) return !1;
                                if (128 & buffer[4]) return !1;
                                if (1 < lenR && 0 === buffer[4] && !(128 & buffer[5])) return !1;
                                if (128 & buffer[lenR + 6]) return !1;
                                if (1 < lenS && 0 === buffer[lenR + 6] && !(128 & buffer[lenR + 7])) return !1;
                                return !0
                            },
                            decode: function(buffer) {
                                if (8 > buffer.length) throw new Error("DER sequence length is too short");
                                if (72 < buffer.length) throw new Error("DER sequence length is too long");
                                if (48 !== buffer[0]) throw new Error("Expected DER sequence");
                                if (buffer[1] !== buffer.length - 2) throw new Error("DER sequence length is invalid");
                                if (2 !== buffer[2]) throw new Error("Expected DER integer");
                                var lenR = buffer[3];
                                if (0 === lenR) throw new Error("R length is zero");
                                if (5 + lenR >= buffer.length) throw new Error("R length is too long");
                                if (2 !== buffer[4 + lenR]) throw new Error("Expected DER integer (2)");
                                var lenS = buffer[5 + lenR];
                                if (0 === lenS) throw new Error("S length is zero");
                                if (6 + lenR + lenS !== buffer.length) throw new Error("S length is invalid");
                                if (128 & buffer[4]) throw new Error("R value is negative");
                                if (1 < lenR && 0 === buffer[4] && !(128 & buffer[5])) throw new Error("R value excessively padded");
                                if (128 & buffer[lenR + 6]) throw new Error("S value is negative");
                                if (1 < lenS && 0 === buffer[lenR + 6] && !(128 & buffer[lenR + 7])) throw new Error("S value excessively padded");
                                return {
                                    r: buffer.slice(4, 4 + lenR),
                                    s: buffer.slice(6 + lenR)
                                }
                            },
                            encode: function(r, s) {
                                var lenR = r.length,
                                    lenS = s.length;
                                if (0 === lenR) throw new Error("R length is zero");
                                if (0 === lenS) throw new Error("S length is zero");
                                if (33 < lenR) throw new Error("R length is too long");
                                if (33 < lenS) throw new Error("S length is too long");
                                if (128 & r[0]) throw new Error("R value is negative");
                                if (128 & s[0]) throw new Error("S value is negative");
                                if (1 < lenR && 0 === r[0] && !(128 & r[1])) throw new Error("R value excessively padded");
                                if (1 < lenS && 0 === s[0] && !(128 & s[1])) throw new Error("S value excessively padded");
                                var signature = Buffer.allocUnsafe(6 + lenR + lenS);
                                signature[0] = 48;
                                signature[1] = signature.length - 2;
                                signature[2] = 2;
                                signature[3] = r.length;
                                r.copy(signature, 4);
                                signature[4 + lenR] = 2;
                                signature[5 + lenR] = s.length;
                                s.copy(signature, 6 + lenR);
                                return signature
                            }
                        }
                    }, {
                        "safe-buffer": 420
                    }],
                    21: [function(require, module) {
                        (function(Buffer) {
                            var bs58check = require("bs58check"),
                                bscript = require("./script"),
                                networks = require("./networks"),
                                typeforce = require("typeforce"),
                                types = require("./types");

                            function fromBase58Check(address) {
                                var payload = bs58check.decode(address);
                                if (21 > payload.length) throw new TypeError(address + " is too short");
                                if (21 < payload.length) throw new TypeError(address + " is too long");
                                var version = payload[0],
                                    hash = payload.slice(1);
                                return {
                                    hash: hash,
                                    version: version
                                }
                            }

                            function toBase58Check(hash, version) {
                                typeforce(types.tuple(types.Hash160bit, types.UInt8), arguments);
                                var payload = new Buffer(21);
                                payload.writeUInt8(version, 0);
                                hash.copy(payload, 1);
                                return bs58check.encode(payload)
                            }
                            module.exports = {
                                fromBase58Check: fromBase58Check,
                                fromOutputScript: function(scriptPubKey, network) {
                                    network = network || networks.bitcoin;
                                    if (bscript.isPubKeyHashOutput(scriptPubKey)) return toBase58Check(bscript.compile(scriptPubKey).slice(3, 23), network.pubKeyHash);
                                    if (bscript.isScriptHashOutput(scriptPubKey)) return toBase58Check(bscript.compile(scriptPubKey).slice(2, 22), network.scriptHash);
                                    throw new Error(bscript.toASM(scriptPubKey) + " has no matching Address")
                                },
                                toBase58Check: toBase58Check,
                                toOutputScript: function(address, network) {
                                    network = network || networks.bitcoin;
                                    var decode = fromBase58Check(address);
                                    if (decode.version === network.pubKeyHash) return bscript.pubKeyHashOutput(decode.hash);
                                    if (decode.version === network.scriptHash) return bscript.scriptHashOutput(decode.hash);
                                    throw new Error(address + " has no matching Script")
                                }
                            }
                        }).call(this, require("buffer").Buffer)
                    }, {
                        "./networks": 31,
                        "./script": 33,
                        "./types": 37,
                        bs58check: 41,
                        buffer: 45,
                        typeforce: 440
                    }],
                    22: [function(require, module) {
                        (function(Buffer) {
                            var createHash = require("create-hash"),
                                bufferutils = require("./bufferutils"),
                                bcrypto = require("./crypto"),
                                bufferCompare = require("buffer-compare"),
                                bufferReverse = require("buffer-reverse"),
                                Transaction = require("./transaction");

                            function Block() {
                                this.version = 1;
                                this.prevHash = null;
                                this.merkleRoot = null;
                                this.timestamp = 0;
                                this.bits = 0;
                                this.nonce = 0
                            }
                            Block.fromBuffer = function(buffer) {
                                if (80 > buffer.length) throw new Error("Buffer too small (< 80 bytes)");
                                var offset = 0;

                                function readSlice(n) {
                                    offset += n;
                                    return buffer.slice(offset - n, offset)
                                }

                                function readUInt32() {
                                    var i = buffer.readUInt32LE(offset);
                                    offset += 4;
                                    return i
                                }
                                var block = new Block;
                                block.version = readUInt32();
                                block.prevHash = readSlice(32);
                                block.merkleRoot = readSlice(32);
                                block.timestamp = readUInt32();
                                block.bits = readUInt32();
                                block.nonce = readUInt32();
                                if (80 === buffer.length) return block;

                                function readVarInt() {
                                    var vi = bufferutils.readVarInt(buffer, offset);
                                    offset += vi.size;
                                    return vi.number
                                }

                                function readTransaction() {
                                    var tx = Transaction.fromBuffer(buffer.slice(offset), !0);
                                    offset += tx.byteLength();
                                    return tx
                                }
                                var nTransactions = readVarInt();
                                block.transactions = [];
                                for (var i = 0, tx; i < nTransactions; ++i) {
                                    tx = readTransaction();
                                    block.transactions.push(tx)
                                }
                                return block
                            };
                            Block.fromHex = function(hex) {
                                return Block.fromBuffer(new Buffer(hex, "hex"))
                            };
                            Block.prototype.getHash = function() {
                                return bcrypto.hash256(this.toBuffer(!0))
                            };
                            Block.prototype.getId = function() {
                                return bufferReverse(this.getHash()).toString("hex")
                            };
                            Block.prototype.getUTCDate = function() {
                                var date = new Date(0);
                                date.setUTCSeconds(this.timestamp);
                                return date
                            };
                            Block.prototype.toBuffer = function(headersOnly) {
                                var buffer = new Buffer(80),
                                    offset = 0;

                                function writeSlice(slice) {
                                    slice.copy(buffer, offset);
                                    offset += slice.length
                                }

                                function writeUInt32(i) {
                                    buffer.writeUInt32LE(i, offset);
                                    offset += 4
                                }
                                writeUInt32(this.version);
                                writeSlice(this.prevHash);
                                writeSlice(this.merkleRoot);
                                writeUInt32(this.timestamp);
                                writeUInt32(this.bits);
                                writeUInt32(this.nonce);
                                if (headersOnly || !this.transactions) return buffer;
                                var txLenBuffer = bufferutils.varIntBuffer(this.transactions.length),
                                    txBuffers = this.transactions.map(function(tx) {
                                        return tx.toBuffer()
                                    });
                                return Buffer.concat([buffer, txLenBuffer].concat(txBuffers))
                            };
                            Block.prototype.toHex = function(headersOnly) {
                                return this.toBuffer(headersOnly).toString("hex")
                            };
                            Block.calculateTarget = function(bits) {
                                var mantissa = 8388607 & bits,
                                    i = 31 - (((4278190080 & bits) >> 24) - 3),
                                    target = new Buffer(32);
                                target.fill(0);
                                target[i] = 255 & mantissa;
                                target[i - 1] = mantissa >> 8;
                                target[i - 2] = mantissa >> 16;
                                target[i - 3] = mantissa >> 24;
                                return target
                            };
                            Block.calculateMerkleRoot = function(transactions) {
                                var length = transactions.length;
                                if (0 === length) throw TypeError("Cannot compute merkle root for zero transactions");
                                var hashes = transactions.map(function(transaction) {
                                    return transaction.getHash()
                                });
                                while (1 < length) {
                                    for (var j = 0, i = 0, hasher; i < length; i += 2, ++j) {
                                        hasher = createHash("sha256");
                                        hasher.update(hashes[i]);
                                        hasher.update(i + 1 !== length ? hashes[i + 1] : hashes[i]);
                                        hashes[j] = bcrypto.sha256(hasher.digest())
                                    }
                                    length = j
                                }
                                return hashes[0]
                            };
                            Block.prototype.checkMerkleRoot = function() {
                                if (!this.transactions) return !1;
                                var actualMerkleRoot = Block.calculateMerkleRoot(this.transactions);
                                return 0 === bufferCompare(this.merkleRoot, actualMerkleRoot)
                            };
                            Block.prototype.checkProofOfWork = function() {
                                var hash = bufferReverse(this.getHash()),
                                    target = Block.calculateTarget(this.bits);
                                return 0 >= bufferCompare(hash, target)
                            };
                            module.exports = Block
                        }).call(this, require("buffer").Buffer)
                    }, {
                        "./bufferutils": 23,
                        "./crypto": 24,
                        "./transaction": 35,
                        buffer: 45,
                        "buffer-compare": 42,
                        "buffer-reverse": 44,
                        "create-hash": 375
                    }],
                    23: [function(require, module) {
                        (function(Buffer) {
                            var opcodes = require("./opcodes.json");

                            function verifuint(value, max) {
                                if ("number" !== typeof value) throw new Error("cannot write a non-number as a number");
                                if (0 > value) throw new Error("specified a negative value for writing an unsigned value");
                                if (value > max) throw new Error("value is larger than maximum value for type");
                                if (_Mathfloor(value) !== value) throw new Error("value has a fractional component")
                            }

                            function pushDataSize(i) {
                                return i < opcodes.OP_PUSHDATA1 ? 1 : 255 >= i ? 2 : 65535 >= i ? 3 : 5
                            }

                            function readUInt64LE(buffer, offset) {
                                var a = buffer.readUInt32LE(offset),
                                    b = buffer.readUInt32LE(offset + 4);
                                b *= 4294967296;
                                verifuint(b + a, 9007199254740991);
                                return b + a
                            }

                            function writeUInt64LE(buffer, value, offset) {
                                verifuint(value, 9007199254740991);
                                buffer.writeInt32LE(-1 & value, offset);
                                buffer.writeUInt32LE(_Mathfloor(value / 4294967296), offset + 4)
                            }

                            function varIntSize(i) {
                                return 253 > i ? 1 : 65536 > i ? 3 : 4294967296 > i ? 5 : 9
                            }

                            function writeVarInt(buffer, number, offset) {
                                var size = varIntSize(number);
                                if (1 === size) {
                                    buffer.writeUInt8(number, offset)
                                } else if (3 === size) {
                                    buffer.writeUInt8(253, offset);
                                    buffer.writeUInt16LE(number, offset + 1)
                                } else if (5 === size) {
                                    buffer.writeUInt8(254, offset);
                                    buffer.writeUInt32LE(number, offset + 1)
                                } else {
                                    buffer.writeUInt8(255, offset);
                                    writeUInt64LE(buffer, number, offset + 1)
                                }
                                return size
                            }
                            module.exports = {
                                equal: require("buffer-equals"),
                                pushDataSize: pushDataSize,
                                readPushDataInt: function(buffer, offset) {
                                    var opcode = buffer.readUInt8(offset),
                                        number, size;
                                    if (opcode < opcodes.OP_PUSHDATA1) {
                                        number = opcode;
                                        size = 1
                                    } else if (opcode === opcodes.OP_PUSHDATA1) {
                                        if (offset + 2 > buffer.length) return null;
                                        number = buffer.readUInt8(offset + 1);
                                        size = 2
                                    } else if (opcode === opcodes.OP_PUSHDATA2) {
                                        if (offset + 3 > buffer.length) return null;
                                        number = buffer.readUInt16LE(offset + 1);
                                        size = 3
                                    } else {
                                        if (offset + 5 > buffer.length) return null;
                                        if (opcode !== opcodes.OP_PUSHDATA4) throw new Error("Unexpected opcode");
                                        number = buffer.readUInt32LE(offset + 1);
                                        size = 5
                                    }
                                    return {
                                        opcode: opcode,
                                        number: number,
                                        size: size
                                    }
                                },
                                readUInt64LE: readUInt64LE,
                                readVarInt: function(buffer, offset) {
                                    var t = buffer.readUInt8(offset),
                                        number, size;
                                    if (253 > t) {
                                        number = t;
                                        size = 1
                                    } else if (254 > t) {
                                        number = buffer.readUInt16LE(offset + 1);
                                        size = 3
                                    } else if (255 > t) {
                                        number = buffer.readUInt32LE(offset + 1);
                                        size = 5
                                    } else {
                                        number = readUInt64LE(buffer, offset + 1);
                                        size = 9
                                    }
                                    return {
                                        number: number,
                                        size: size
                                    }
                                },
                                reverse: require("buffer-reverse"),
                                varIntBuffer: function(i) {
                                    var size = varIntSize(i),
                                        buffer = new Buffer(size);
                                    writeVarInt(buffer, i, 0);
                                    return buffer
                                },
                                varIntSize: varIntSize,
                                writePushDataInt: function(buffer, number, offset) {
                                    var size = pushDataSize(number);
                                    if (1 === size) {
                                        buffer.writeUInt8(number, offset)
                                    } else if (2 === size) {
                                        buffer.writeUInt8(opcodes.OP_PUSHDATA1, offset);
                                        buffer.writeUInt8(number, offset + 1)
                                    } else if (3 === size) {
                                        buffer.writeUInt8(opcodes.OP_PUSHDATA2, offset);
                                        buffer.writeUInt16LE(number, offset + 1)
                                    } else {
                                        buffer.writeUInt8(opcodes.OP_PUSHDATA4, offset);
                                        buffer.writeUInt32LE(number, offset + 1)
                                    }
                                    return size
                                },
                                writeUInt64LE: writeUInt64LE,
                                writeVarInt: writeVarInt
                            }
                        }).call(this, require("buffer").Buffer)
                    }, {
                        "./opcodes.json": 32,
                        buffer: 45,
                        "buffer-equals": 43,
                        "buffer-reverse": 44
                    }],
                    24: [function(require, module) {
                        var createHash = require("create-hash");

                        function ripemd160(buffer) {
                            return createHash("rmd160").update(buffer).digest()
                        }

                        function sha256(buffer) {
                            return createHash("sha256").update(buffer).digest()
                        }
                        module.exports = {
                            hash160: function(buffer) {
                                return ripemd160(sha256(buffer))
                            },
                            hash256: function(buffer) {
                                return sha256(sha256(buffer))
                            },
                            ripemd160: ripemd160,
                            sha1: function(buffer) {
                                return createHash("sha1").update(buffer).digest()
                            },
                            sha256: sha256
                        }
                    }, {
                        "create-hash": 375
                    }],
                    25: [function(require, module) {
                        (function(Buffer) {
                            var createHmac = require("create-hmac"),
                                typeforce = require("typeforce"),
                                types = require("./types"),
                                BigInteger = require("bigi"),
                                ECSignature = require("./ecsignature"),
                                ZERO = new Buffer([0]),
                                ONE = new Buffer([1]),
                                ecurve = require("ecurve"),
                                secp256k1 = ecurve.getCurveByName("secp256k1");

                            function deterministicGenerateK(hash, x, checkSig) {
                                typeforce(types.tuple(types.Hash256bit, types.Buffer256bit, types.Function), arguments);
                                var k = new Buffer(32),
                                    v = new Buffer(32);
                                v.fill(1);
                                k.fill(0);
                                k = createHmac("sha256", k).update(v).update(ZERO).update(x).update(hash).digest();
                                v = createHmac("sha256", k).update(v).digest();
                                k = createHmac("sha256", k).update(v).update(ONE).update(x).update(hash).digest();
                                v = createHmac("sha256", k).update(v).digest();
                                v = createHmac("sha256", k).update(v).digest();
                                var T = BigInteger.fromBuffer(v);
                                while (0 >= T.signum() || 0 <= T.compareTo(secp256k1.n) || !checkSig(T)) {
                                    k = createHmac("sha256", k).update(v).update(ZERO).digest();
                                    v = createHmac("sha256", k).update(v).digest();
                                    v = createHmac("sha256", k).update(v).digest();
                                    T = BigInteger.fromBuffer(v)
                                }
                                return T
                            }
                            var N_OVER_TWO = secp256k1.n.shiftRight(1);

                            function recoverPubKey(e, signature, i) {
                                typeforce(types.tuple(types.BigInt, types.ECSignature, types.UInt2), arguments);
                                var n = secp256k1.n,
                                    G = secp256k1.G,
                                    r = signature.r,
                                    s = signature.s;
                                if (0 >= r.signum() || 0 <= r.compareTo(n)) throw new Error("Invalid r value");
                                if (0 >= s.signum() || 0 <= s.compareTo(n)) throw new Error("Invalid s value");
                                var x = i >> 1 ? r.add(n) : r,
                                    R = secp256k1.pointFromX(1 & i, x),
                                    nR = R.multiply(n);
                                if (!secp256k1.isInfinity(nR)) throw new Error("nR is not a valid curve point");
                                var rInv = r.modInverse(n),
                                    eNeg = e.negate().mod(n),
                                    Q = R.multiplyTwo(s, G, eNeg).multiply(rInv);
                                secp256k1.validate(Q);
                                return Q
                            }
                            module.exports = {
                                calcPubKeyRecoveryParam: function(e, signature, Q) {
                                    typeforce(types.tuple(types.BigInt, types.ECSignature, types.ECPoint), arguments);
                                    for (var i = 0, Qprime; 4 > i; i++) {
                                        Qprime = recoverPubKey(e, signature, i);
                                        if (Qprime.equals(Q)) {
                                            return i
                                        }
                                    }
                                    throw new Error("Unable to find valid recovery factor")
                                },
                                deterministicGenerateK: deterministicGenerateK,
                                recoverPubKey: recoverPubKey,
                                sign: function(hash, d) {
                                    typeforce(types.tuple(types.Hash256bit, types.BigInt), arguments);
                                    var x = d.toBuffer(32),
                                        e = BigInteger.fromBuffer(hash),
                                        n = secp256k1.n,
                                        G = secp256k1.G,
                                        r, s;
                                    deterministicGenerateK(hash, x, function(k) {
                                        var Q = G.multiply(k);
                                        if (secp256k1.isInfinity(Q)) return !1;
                                        r = Q.affineX.mod(n);
                                        if (0 === r.signum()) return !1;
                                        s = k.modInverse(n).multiply(e.add(d.multiply(r))).mod(n);
                                        if (0 === s.signum()) return !1;
                                        return !0
                                    });
                                    if (0 < s.compareTo(N_OVER_TWO)) {
                                        s = n.subtract(s)
                                    }
                                    return new ECSignature(r, s)
                                },
                                verify: function(hash, signature, Q) {
                                    typeforce(types.tuple(types.Hash256bit, types.ECSignature, types.ECPoint), arguments);
                                    var n = secp256k1.n,
                                        G = secp256k1.G,
                                        r = signature.r,
                                        s = signature.s;
                                    if (0 >= r.signum() || 0 <= r.compareTo(n)) return !1;
                                    if (0 >= s.signum() || 0 <= s.compareTo(n)) return !1;
                                    var e = BigInteger.fromBuffer(hash),
                                        sInv = s.modInverse(n),
                                        u1 = e.multiply(sInv).mod(n),
                                        u2 = r.multiply(sInv).mod(n),
                                        R = G.multiplyTwo(u1, Q, u2);
                                    if (secp256k1.isInfinity(R)) return !1;
                                    var xR = R.affineX,
                                        v = xR.mod(n);
                                    return v.equals(r)
                                },
                                __curve: secp256k1
                            }
                        }).call(this, require("buffer").Buffer)
                    }, {
                        "./ecsignature": 27,
                        "./types": 37,
                        bigi: 18,
                        buffer: 45,
                        "create-hmac": 378,
                        ecurve: 384,
                        typeforce: 440
                    }],
                    26: [function(require, module) {
                        var baddress = require("./address"),
                            bcrypto = require("./crypto"),
                            ecdsa = require("./ecdsa"),
                            randomBytes = require("randombytes"),
                            typeforce = require("typeforce"),
                            types = require("./types"),
                            wif = require("wif"),
                            NETWORKS = require("./networks"),
                            BigInteger = require("bigi"),
                            ecurve = require("ecurve"),
                            secp256k1 = ecdsa.__curve;

                        function ECPair(d, Q, options) {
                            if (options) {
                                typeforce({
                                    compressed: types.maybe(types.Boolean),
                                    network: types.maybe(types.Network)
                                }, options)
                            }
                            options = options || {};
                            if (d) {
                                if (0 >= d.signum()) throw new Error("Private key must be greater than 0");
                                if (0 <= d.compareTo(secp256k1.n)) throw new Error("Private key must be less than the curve order");
                                if (Q) throw new TypeError("Unexpected publicKey parameter");
                                this.d = d
                            } else {
                                typeforce(types.ECPoint, Q);
                                this.__Q = Q
                            }
                            this.compressed = options.compressed === void 0 ? !0 : options.compressed;
                            this.network = options.network || NETWORKS.bitcoin
                        }
                        Object.defineProperty(ECPair.prototype, "Q", {
                            get: function() {
                                if (!this.__Q && this.d) {
                                    this.__Q = secp256k1.G.multiply(this.d)
                                }
                                return this.__Q
                            }
                        });
                        ECPair.fromPublicKeyBuffer = function(buffer, network) {
                            var Q = ecurve.Point.decodeFrom(secp256k1, buffer);
                            return new ECPair(null, Q, {
                                compressed: Q.compressed,
                                network: network
                            })
                        };
                        ECPair.fromWIF = function(string, network) {
                            var decoded = wif.decode(string),
                                version = decoded.version;
                            if (types.Array(network)) {
                                network = network.filter(function(network) {
                                    return version === network.wif
                                }).pop();
                                if (!network) throw new Error("Unknown network version")
                            } else {
                                network = network || NETWORKS.bitcoin;
                                if (version !== network.wif) throw new Error("Invalid network version")
                            }
                            var d = BigInteger.fromBuffer(decoded.privateKey);
                            return new ECPair(d, null, {
                                compressed: decoded.compressed,
                                network: network
                            })
                        };
                        ECPair.makeRandom = function(options) {
                            options = options || {};
                            var rng = options.rng || randomBytes,
                                d;
                            do {
                                var buffer = rng(32);
                                typeforce(types.Buffer256bit, buffer);
                                d = BigInteger.fromBuffer(buffer)
                            } while (0 >= d.signum() || 0 <= d.compareTo(secp256k1.n));
                            return new ECPair(d, null, options)
                        };
                        ECPair.prototype.getAddress = function() {
                            return baddress.toBase58Check(bcrypto.hash160(this.getPublicKeyBuffer()), this.getNetwork().pubKeyHash)
                        };
                        ECPair.prototype.getNetwork = function() {
                            return this.network
                        };
                        ECPair.prototype.getPublicKeyBuffer = function() {
                            return this.Q.getEncoded(this.compressed)
                        };
                        ECPair.prototype.sign = function(hash) {
                            if (!this.d) throw new Error("Missing private key");
                            return ecdsa.sign(hash, this.d)
                        };
                        ECPair.prototype.toWIF = function() {
                            if (!this.d) throw new Error("Missing private key");
                            return wif.encode(this.network.wif, this.d.toBuffer(32), this.compressed)
                        };
                        ECPair.prototype.verify = function(hash, signature) {
                            return ecdsa.verify(hash, signature, this.Q)
                        };
                        module.exports = ECPair
                    }, {
                        "./address": 21,
                        "./crypto": 24,
                        "./ecdsa": 25,
                        "./networks": 31,
                        "./types": 37,
                        bigi: 18,
                        ecurve: 384,
                        randombytes: 404,
                        typeforce: 440,
                        wif: 448
                    }],
                    27: [function(require, module) {
                        (function(Buffer) {
                            var bip66 = require("bip66"),
                                typeforce = require("typeforce"),
                                types = require("./types"),
                                BigInteger = require("bigi");

                            function ECSignature(r, s) {
                                typeforce(types.tuple(types.BigInt, types.BigInt), arguments);
                                this.r = r;
                                this.s = s
                            }
                            ECSignature.parseCompact = function(buffer) {
                                if (65 !== buffer.length) throw new Error("Invalid signature length");
                                var flagByte = buffer.readUInt8(0) - 27;
                                if (flagByte !== (7 & flagByte)) throw new Error("Invalid signature parameter");
                                var r = BigInteger.fromBuffer(buffer.slice(1, 33)),
                                    s = BigInteger.fromBuffer(buffer.slice(33));
                                return {
                                    compressed: !!(4 & flagByte),
                                    i: 3 & flagByte,
                                    signature: new ECSignature(r, s)
                                }
                            };
                            ECSignature.fromDER = function(buffer) {
                                var decode = bip66.decode(buffer),
                                    r = BigInteger.fromDERInteger(decode.r),
                                    s = BigInteger.fromDERInteger(decode.s);
                                return new ECSignature(r, s)
                            };
                            ECSignature.parseScriptSignature = function(buffer) {
                                var hashType = buffer.readUInt8(buffer.length - 1),
                                    hashTypeMod = ~128 & hashType;
                                if (0 >= hashTypeMod || 4 <= hashTypeMod) throw new Error("Invalid hashType " + hashType);
                                return {
                                    signature: ECSignature.fromDER(buffer.slice(0, -1)),
                                    hashType: hashType
                                }
                            };
                            ECSignature.prototype.toCompact = function(i, compressed) {
                                if (compressed) {
                                    i += 4
                                }
                                i += 27;
                                var buffer = new Buffer(65);
                                buffer.writeUInt8(i, 0);
                                this.r.toBuffer(32).copy(buffer, 1);
                                this.s.toBuffer(32).copy(buffer, 33);
                                return buffer
                            };
                            ECSignature.prototype.toDER = function() {
                                var r = new Buffer(this.r.toDERInteger()),
                                    s = new Buffer(this.s.toDERInteger());
                                return bip66.encode(r, s)
                            };
                            ECSignature.prototype.toScriptSignature = function(hashType) {
                                var hashTypeMod = ~128 & hashType;
                                if (0 >= hashTypeMod || 4 <= hashTypeMod) throw new Error("Invalid hashType " + hashType);
                                var hashTypeBuffer = new Buffer(1);
                                hashTypeBuffer.writeUInt8(hashType, 0);
                                return Buffer.concat([this.toDER(), hashTypeBuffer])
                            };
                            module.exports = ECSignature
                        }).call(this, require("buffer").Buffer)
                    }, {
                        "./types": 37,
                        bigi: 18,
                        bip66: 20,
                        buffer: 45,
                        typeforce: 440
                    }],
                    28: [function(require, module) {
                        (function(Buffer) {
                            var base58check = require("bs58check"),
                                bcrypto = require("./crypto"),
                                createHmac = require("create-hmac"),
                                typeforce = require("typeforce"),
                                types = require("./types"),
                                NETWORKS = require("./networks"),
                                BigInteger = require("bigi"),
                                ECPair = require("./ecpair"),
                                ecurve = require("ecurve"),
                                curve = ecurve.getCurveByName("secp256k1");

                            function HDNode(keyPair, chainCode) {
                                typeforce(types.tuple("ECPair", types.Buffer256bit), arguments);
                                if (!keyPair.compressed) throw new TypeError("BIP32 only allows compressed keyPairs");
                                this.keyPair = keyPair;
                                this.chainCode = chainCode;
                                this.depth = 0;
                                this.index = 0;
                                this.parentFingerprint = 0
                            }
                            HDNode.HIGHEST_BIT = 2147483648;
                            HDNode.LENGTH = 78;
                            HDNode.MASTER_SECRET = new Buffer("Bitcoin seed");
                            HDNode.fromSeedBuffer = function(seed, network) {
                                typeforce(types.tuple(types.Buffer, types.maybe(types.Network)), arguments);
                                if (16 > seed.length) throw new TypeError("Seed should be at least 128 bits");
                                if (64 < seed.length) throw new TypeError("Seed should be at most 512 bits");
                                var I = createHmac("sha512", HDNode.MASTER_SECRET).update(seed).digest(),
                                    IL = I.slice(0, 32),
                                    IR = I.slice(32),
                                    pIL = BigInteger.fromBuffer(IL),
                                    keyPair = new ECPair(pIL, null, {
                                        network: network
                                    });
                                return new HDNode(keyPair, IR)
                            };
                            HDNode.fromSeedHex = function(hex, network) {
                                return HDNode.fromSeedBuffer(new Buffer(hex, "hex"), network)
                            };
                            HDNode.fromBase58 = function(string, networks) {
                                var buffer = base58check.decode(string);
                                if (78 !== buffer.length) throw new Error("Invalid buffer length");
                                var version = buffer.readUInt32BE(0),
                                    network;
                                if (Array.isArray(networks)) {
                                    network = networks.filter(function(network) {
                                        return version === network.bip32.private || version === network.bip32.public
                                    }).pop();
                                    if (!network) throw new Error("Unknown network version")
                                } else {
                                    network = networks || NETWORKS.bitcoin
                                }
                                if (version !== network.bip32.private && version !== network.bip32.public) throw new Error("Invalid network version");
                                var depth = buffer[4],
                                    parentFingerprint = buffer.readUInt32BE(5);
                                if (0 === depth) {
                                    if (0 !== parentFingerprint) throw new Error("Invalid parent fingerprint")
                                }
                                var index = buffer.readUInt32BE(9);
                                if (0 === depth && 0 !== index) throw new Error("Invalid index");
                                var chainCode = buffer.slice(13, 45),
                                    keyPair;
                                if (version === network.bip32.private) {
                                    if (0 !== buffer.readUInt8(45)) throw new Error("Invalid private key");
                                    var d = BigInteger.fromBuffer(buffer.slice(46, 78));
                                    keyPair = new ECPair(d, null, {
                                        network: network
                                    })
                                } else {
                                    var Q = ecurve.Point.decodeFrom(curve, buffer.slice(45, 78));
                                    if (!Q.compressed) throw new Error("Invalid public key");
                                    curve.validate(Q);
                                    keyPair = new ECPair(null, Q, {
                                        network: network
                                    })
                                }
                                var hd = new HDNode(keyPair, chainCode);
                                hd.depth = depth;
                                hd.index = index;
                                hd.parentFingerprint = parentFingerprint;
                                return hd
                            };
                            HDNode.prototype.getAddress = function() {
                                return this.keyPair.getAddress()
                            };
                            HDNode.prototype.getIdentifier = function() {
                                return bcrypto.hash160(this.keyPair.getPublicKeyBuffer())
                            };
                            HDNode.prototype.getFingerprint = function() {
                                return this.getIdentifier().slice(0, 4)
                            };
                            HDNode.prototype.getNetwork = function() {
                                return this.keyPair.getNetwork()
                            };
                            HDNode.prototype.getPublicKeyBuffer = function() {
                                return this.keyPair.getPublicKeyBuffer()
                            };
                            HDNode.prototype.neutered = function() {
                                var neuteredKeyPair = new ECPair(null, this.keyPair.Q, {
                                        network: this.keyPair.network
                                    }),
                                    neutered = new HDNode(neuteredKeyPair, this.chainCode);
                                neutered.depth = this.depth;
                                neutered.index = this.index;
                                neutered.parentFingerprint = this.parentFingerprint;
                                return neutered
                            };
                            HDNode.prototype.sign = function(hash) {
                                return this.keyPair.sign(hash)
                            };
                            HDNode.prototype.verify = function(hash, signature) {
                                return this.keyPair.verify(hash, signature)
                            };
                            HDNode.prototype.toBase58 = function(__isPrivate) {
                                if (__isPrivate !== void 0) throw new TypeError("Unsupported argument in 2.0.0");
                                var network = this.keyPair.network,
                                    version = !this.isNeutered() ? network.bip32.private : network.bip32.public,
                                    buffer = new Buffer(78);
                                buffer.writeUInt32BE(version, 0);
                                buffer.writeUInt8(this.depth, 4);
                                buffer.writeUInt32BE(this.parentFingerprint, 5);
                                buffer.writeUInt32BE(this.index, 9);
                                this.chainCode.copy(buffer, 13);
                                if (!this.isNeutered()) {
                                    buffer.writeUInt8(0, 45);
                                    this.keyPair.d.toBuffer(32).copy(buffer, 46)
                                } else {
                                    this.keyPair.getPublicKeyBuffer().copy(buffer, 45)
                                }
                                return base58check.encode(buffer)
                            };
                            HDNode.prototype.derive = function(index) {
                                typeforce(types.UInt32, index);
                                var isHardened = index >= HDNode.HIGHEST_BIT,
                                    data = new Buffer(37);
                                if (isHardened) {
                                    if (this.isNeutered()) throw new TypeError("Could not derive hardened child key");
                                    data[0] = 0;
                                    this.keyPair.d.toBuffer(32).copy(data, 1);
                                    data.writeUInt32BE(index, 33)
                                } else {
                                    this.keyPair.getPublicKeyBuffer().copy(data, 0);
                                    data.writeUInt32BE(index, 33)
                                }
                                var I = createHmac("sha512", this.chainCode).update(data).digest(),
                                    IL = I.slice(0, 32),
                                    IR = I.slice(32),
                                    pIL = BigInteger.fromBuffer(IL);
                                if (0 <= pIL.compareTo(curve.n)) {
                                    return this.derive(index + 1)
                                }
                                var derivedKeyPair;
                                if (!this.isNeutered()) {
                                    var ki = pIL.add(this.keyPair.d).mod(curve.n);
                                    if (0 === ki.signum()) {
                                        return this.derive(index + 1)
                                    }
                                    derivedKeyPair = new ECPair(ki, null, {
                                        network: this.keyPair.network
                                    })
                                } else {
                                    var Ki = curve.G.multiply(pIL).add(this.keyPair.Q);
                                    if (curve.isInfinity(Ki)) {
                                        return this.derive(index + 1)
                                    }
                                    derivedKeyPair = new ECPair(null, Ki, {
                                        network: this.keyPair.network
                                    })
                                }
                                var hd = new HDNode(derivedKeyPair, IR);
                                hd.depth = this.depth + 1;
                                hd.index = index;
                                hd.parentFingerprint = this.getFingerprint().readUInt32BE(0);
                                return hd
                            };
                            HDNode.prototype.deriveHardened = function(index) {
                                typeforce(types.UInt31, index);
                                return this.derive(index + HDNode.HIGHEST_BIT)
                            };
                            HDNode.prototype.isNeutered = function() {
                                return !this.keyPair.d
                            };
                            HDNode.prototype.derivePath = function(path) {
                                typeforce(types.Bip32Path, path);
                                var splitPath = path.split("/");
                                if ("m" === splitPath[0]) {
                                    if (this.parentFingerprint) {
                                        throw new Error("Not a master node")
                                    }
                                    splitPath = splitPath.slice(1)
                                }
                                return splitPath.reduce(function(prevHd, indexStr) {
                                    var index;
                                    if ("'" === indexStr.slice(-1)) {
                                        index = parseInt(indexStr.slice(0, -1), 10);
                                        return prevHd.deriveHardened(index)
                                    } else {
                                        index = parseInt(indexStr, 10);
                                        return prevHd.derive(index)
                                    }
                                }, this)
                            };
                            HDNode.prototype.toString = HDNode.prototype.toBase58;
                            module.exports = HDNode
                        }).call(this, require("buffer").Buffer)
                    }, {
                        "./crypto": 24,
                        "./ecpair": 26,
                        "./networks": 31,
                        "./types": 37,
                        bigi: 18,
                        bs58check: 41,
                        buffer: 45,
                        "create-hmac": 378,
                        ecurve: 384,
                        typeforce: 440
                    }],
                    29: [function(require, module) {
                        module.exports = {
                            Block: require("./block"),
                            ECPair: require("./ecpair"),
                            ECSignature: require("./ecsignature"),
                            HDNode: require("./hdnode"),
                            Transaction: require("./transaction"),
                            TransactionBuilder: require("./transaction_builder"),
                            address: require("./address"),
                            bufferutils: require("./bufferutils"),
                            crypto: require("./crypto"),
                            message: require("./message"),
                            networks: require("./networks"),
                            opcodes: require("./opcodes.json"),
                            script: require("./script")
                        }
                    }, {
                        "./address": 21,
                        "./block": 22,
                        "./bufferutils": 23,
                        "./crypto": 24,
                        "./ecpair": 26,
                        "./ecsignature": 27,
                        "./hdnode": 28,
                        "./message": 30,
                        "./networks": 31,
                        "./opcodes.json": 32,
                        "./script": 33,
                        "./transaction": 35,
                        "./transaction_builder": 36
                    }],
                    30: [function(require, module) {
                        (function(Buffer) {
                            var bufferutils = require("./bufferutils"),
                                bcrypto = require("./crypto"),
                                ecdsa = require("./ecdsa"),
                                networks = require("./networks"),
                                BigInteger = require("bigi"),
                                ECPair = require("./ecpair"),
                                ECSignature = require("./ecsignature");

                            function magicHash(message, network) {
                                var messagePrefix = new Buffer(network.messagePrefix),
                                    messageBuffer = new Buffer(message),
                                    lengthBuffer = bufferutils.varIntBuffer(messageBuffer.length),
                                    buffer = Buffer.concat([messagePrefix, lengthBuffer, messageBuffer]);
                                return bcrypto.hash256(buffer)
                            }
                            module.exports = {
                                magicHash: magicHash,
                                sign: function(keyPair, message, network) {
                                    network = network || networks.bitcoin;
                                    var hash = magicHash(message, network),
                                        signature = keyPair.sign(hash),
                                        e = BigInteger.fromBuffer(hash),
                                        i = ecdsa.calcPubKeyRecoveryParam(e, signature, keyPair.Q);
                                    return signature.toCompact(i, keyPair.compressed)
                                },
                                verify: function(address, signature, message, network) {
                                    if (!Buffer.isBuffer(signature)) {
                                        signature = new Buffer(signature, "base64")
                                    }
                                    network = network || networks.bitcoin;
                                    var hash = magicHash(message, network),
                                        parsed = ECSignature.parseCompact(signature),
                                        e = BigInteger.fromBuffer(hash),
                                        Q = ecdsa.recoverPubKey(e, parsed.signature, parsed.i),
                                        keyPair = new ECPair(null, Q, {
                                            compressed: parsed.compressed,
                                            network: network
                                        });
                                    return keyPair.getAddress() === address
                                }
                            }
                        }).call(this, require("buffer").Buffer)
                    }, {
                        "./bufferutils": 23,
                        "./crypto": 24,
                        "./ecdsa": 25,
                        "./ecpair": 26,
                        "./ecsignature": 27,
                        "./networks": 31,
                        bigi: 18,
                        buffer: 45
                    }],
                    31: [function(require, module) {
                        module.exports = {
                            bitcoin: {
                                messagePrefix: "\x18Bitcoin Signed Message:\n",
                                bip32: {
                                    public: 76067358,
                                    private: 76066276
                                },
                                pubKeyHash: 0,
                                scriptHash: 5,
                                wif: 128,
                                dustThreshold: 546
                            },
                            testnet: {
                                messagePrefix: "\x18Bitcoin Signed Message:\n",
                                bip32: {
                                    public: 70617039,
                                    private: 70615956
                                },
                                pubKeyHash: 111,
                                scriptHash: 196,
                                wif: 239,
                                dustThreshold: 546
                            },
                            litecoin: {
                                messagePrefix: "\x19Litecoin Signed Message:\n",
                                bip32: {
                                    public: 27108450,
                                    private: 27106558
                                },
                                pubKeyHash: 48,
                                scriptHash: 5,
                                wif: 176,
                                dustThreshold: 0
                            },
                            dogecoin: {
                                messagePrefix: "\x19Dogecoin Signed Message:\n",
                                bip32: {
                                    public: 49990397,
                                    private: 49988504
                                },
                                pubKeyHash: 30,
                                scriptHash: 22,
                                wif: 158,
                                dustThreshold: 0
                            }
                        }
                    }, {}],
                    32: [function(require, module) {
                        module.exports = {
                            OP_FALSE: 0,
                            OP_0: 0,
                            OP_PUSHDATA1: 76,
                            OP_PUSHDATA2: 77,
                            OP_PUSHDATA4: 78,
                            OP_1NEGATE: 79,
                            OP_RESERVED: 80,
                            OP_1: 81,
                            OP_TRUE: 81,
                            OP_2: 82,
                            OP_3: 83,
                            OP_4: 84,
                            OP_5: 85,
                            OP_6: 86,
                            OP_7: 87,
                            OP_8: 88,
                            OP_9: 89,
                            OP_10: 90,
                            OP_11: 91,
                            OP_12: 92,
                            OP_13: 93,
                            OP_14: 94,
                            OP_15: 95,
                            OP_16: 96,
                            OP_NOP: 97,
                            OP_VER: 98,
                            OP_IF: 99,
                            OP_NOTIF: 100,
                            OP_VERIF: 101,
                            OP_VERNOTIF: 102,
                            OP_ELSE: 103,
                            OP_ENDIF: 104,
                            OP_VERIFY: 105,
                            OP_RETURN: 106,
                            OP_TOALTSTACK: 107,
                            OP_FROMALTSTACK: 108,
                            OP_2DROP: 109,
                            OP_2DUP: 110,
                            OP_3DUP: 111,
                            OP_2OVER: 112,
                            OP_2ROT: 113,
                            OP_2SWAP: 114,
                            OP_IFDUP: 115,
                            OP_DEPTH: 116,
                            OP_DROP: 117,
                            OP_DUP: 118,
                            OP_NIP: 119,
                            OP_OVER: 120,
                            OP_PICK: 121,
                            OP_ROLL: 122,
                            OP_ROT: 123,
                            OP_SWAP: 124,
                            OP_TUCK: 125,
                            OP_CAT: 126,
                            OP_SUBSTR: 127,
                            OP_LEFT: 128,
                            OP_RIGHT: 129,
                            OP_SIZE: 130,
                            OP_INVERT: 131,
                            OP_AND: 132,
                            OP_OR: 133,
                            OP_XOR: 134,
                            OP_EQUAL: 135,
                            OP_EQUALVERIFY: 136,
                            OP_RESERVED1: 137,
                            OP_RESERVED2: 138,
                            OP_1ADD: 139,
                            OP_1SUB: 140,
                            OP_2MUL: 141,
                            OP_2DIV: 142,
                            OP_NEGATE: 143,
                            OP_ABS: 144,
                            OP_NOT: 145,
                            OP_0NOTEQUAL: 146,
                            OP_ADD: 147,
                            OP_SUB: 148,
                            OP_MUL: 149,
                            OP_DIV: 150,
                            OP_MOD: 151,
                            OP_LSHIFT: 152,
                            OP_RSHIFT: 153,
                            OP_BOOLAND: 154,
                            OP_BOOLOR: 155,
                            OP_NUMEQUAL: 156,
                            OP_NUMEQUALVERIFY: 157,
                            OP_NUMNOTEQUAL: 158,
                            OP_LESSTHAN: 159,
                            OP_GREATERTHAN: 160,
                            OP_LESSTHANOREQUAL: 161,
                            OP_GREATERTHANOREQUAL: 162,
                            OP_MIN: 163,
                            OP_MAX: 164,
                            OP_WITHIN: 165,
                            OP_RIPEMD160: 166,
                            OP_SHA1: 167,
                            OP_SHA256: 168,
                            OP_HASH160: 169,
                            OP_HASH256: 170,
                            OP_CODESEPARATOR: 171,
                            OP_CHECKSIG: 172,
                            OP_CHECKSIGVERIFY: 173,
                            OP_CHECKMULTISIG: 174,
                            OP_CHECKMULTISIGVERIFY: 175,
                            OP_NOP1: 176,
                            OP_NOP2: 177,
                            OP_CHECKLOCKTIMEVERIFY: 177,
                            OP_NOP3: 178,
                            OP_NOP4: 179,
                            OP_NOP5: 180,
                            OP_NOP6: 181,
                            OP_NOP7: 182,
                            OP_NOP8: 183,
                            OP_NOP9: 184,
                            OP_NOP10: 185,
                            OP_PUBKEYHASH: 253,
                            OP_PUBKEY: 254,
                            OP_INVALIDOPCODE: 255
                        }
                    }, {}],
                    33: [function(require, module) {
                        (function(Buffer) {
                            var bip66 = require("bip66"),
                                bufferutils = require("./bufferutils"),
                                typeforce = require("typeforce"),
                                types = require("./types"),
                                OPS = require("./opcodes.json"),
                                REVERSE_OPS = function() {
                                    var result = {};
                                    for (var op in OPS) {
                                        var code = OPS[op];
                                        result[code] = op
                                    }
                                    return result
                                }(),
                                OP_INT_BASE = OPS.OP_RESERVED;

                            function compile(chunks) {
                                if (Buffer.isBuffer(chunks)) return chunks;
                                typeforce(types.Array, chunks);
                                var bufferSize = chunks.reduce(function(accum, chunk) {
                                        if (Buffer.isBuffer(chunk)) {
                                            return accum + bufferutils.pushDataSize(chunk.length) + chunk.length
                                        }
                                        return accum + 1
                                    }, 0),
                                    buffer = new Buffer(bufferSize),
                                    offset = 0;
                                chunks.forEach(function(chunk) {
                                    if (Buffer.isBuffer(chunk)) {
                                        offset += bufferutils.writePushDataInt(buffer, chunk.length, offset);
                                        chunk.copy(buffer, offset);
                                        offset += chunk.length
                                    } else {
                                        buffer.writeUInt8(chunk, offset);
                                        offset += 1
                                    }
                                });
                                if (offset !== buffer.length) throw new Error("Could not decode chunks");
                                return buffer
                            }

                            function decompile(buffer) {
                                if (types.Array(buffer)) return buffer;
                                typeforce(types.Buffer, buffer);
                                var chunks = [],
                                    i = 0;
                                while (i < buffer.length) {
                                    var opcode = buffer[i];
                                    if (opcode > OPS.OP_0 && opcode <= OPS.OP_PUSHDATA4) {
                                        var d = bufferutils.readPushDataInt(buffer, i);
                                        if (null === d) return [];
                                        i += d.size;
                                        if (i + d.number > buffer.length) return [];
                                        var data = buffer.slice(i, i + d.number);
                                        i += d.number;
                                        chunks.push(data)
                                    } else {
                                        chunks.push(opcode);
                                        i += 1
                                    }
                                }
                                return chunks
                            }

                            function isCanonicalPubKey(buffer) {
                                if (!Buffer.isBuffer(buffer)) return !1;
                                if (33 > buffer.length) return !1;
                                switch (buffer[0]) {
                                    case 2:
                                    case 3:
                                        return 33 === buffer.length;
                                    case 4:
                                        return 65 === buffer.length;
                                }
                                return !1
                            }

                            function isCanonicalSignature(buffer) {
                                if (!Buffer.isBuffer(buffer)) return !1;
                                if (!isDefinedHashType(buffer[buffer.length - 1])) return !1;
                                return bip66.check(buffer.slice(0, -1))
                            }

                            function isDefinedHashType(hashType) {
                                var hashTypeMod = ~128 & hashType;
                                return 0 < hashTypeMod && 4 > hashTypeMod
                            }

                            function isPubKeyHashInput(script) {
                                var chunks = decompile(script);
                                return 2 === chunks.length && isCanonicalSignature(chunks[0]) && isCanonicalPubKey(chunks[1])
                            }

                            function isPubKeyHashOutput(script) {
                                var buffer = compile(script);
                                return 25 === buffer.length && buffer[0] === OPS.OP_DUP && buffer[1] === OPS.OP_HASH160 && 20 === buffer[2] && buffer[23] === OPS.OP_EQUALVERIFY && buffer[24] === OPS.OP_CHECKSIG
                            }

                            function isPubKeyInput(script) {
                                var chunks = decompile(script);
                                return 1 === chunks.length && isCanonicalSignature(chunks[0])
                            }

                            function isPubKeyOutput(script) {
                                var chunks = decompile(script);
                                return 2 === chunks.length && isCanonicalPubKey(chunks[0]) && chunks[1] === OPS.OP_CHECKSIG
                            }

                            function isScriptHashInput(script, allowIncomplete) {
                                var chunks = decompile(script);
                                if (2 > chunks.length) return !1;
                                var lastChunk = chunks[chunks.length - 1];
                                if (!Buffer.isBuffer(lastChunk)) return !1;
                                var scriptSigChunks = chunks.slice(0, -1),
                                    redeemScriptChunks = decompile(lastChunk);
                                if (0 === redeemScriptChunks.length) return !1;
                                return classifyInput(scriptSigChunks, allowIncomplete) === classifyOutput(redeemScriptChunks)
                            }

                            function isScriptHashOutput(script) {
                                var buffer = compile(script);
                                return 23 === buffer.length && buffer[0] === OPS.OP_HASH160 && 20 === buffer[1] && buffer[22] === OPS.OP_EQUAL
                            }

                            function isWitnessPubKeyHashOutput(script) {
                                var buffer = compile(script);
                                return 22 === buffer.length && buffer[0] === OPS.OP_0 && 20 === buffer[1]
                            }

                            function isWitnessScriptHashOutput(script) {
                                var buffer = compile(script);
                                return 34 === buffer.length && buffer[0] === OPS.OP_0 && 32 === buffer[1]
                            }

                            function isMultisigInput(script, allowIncomplete) {
                                var chunks = decompile(script);
                                if (2 > chunks.length) return !1;
                                if (chunks[0] !== OPS.OP_0) return !1;
                                if (allowIncomplete) {
                                    return chunks.slice(1).every(function(chunk) {
                                        return chunk === OPS.OP_0 || isCanonicalSignature(chunk)
                                    })
                                }
                                return chunks.slice(1).every(isCanonicalSignature)
                            }

                            function isMultisigOutput(script) {
                                var chunks = decompile(script);
                                if (4 > chunks.length) return !1;
                                if (chunks[chunks.length - 1] !== OPS.OP_CHECKMULTISIG) return !1;
                                var mOp = chunks[0],
                                    nOp = chunks[chunks.length - 2];
                                if (!types.Number(mOp)) return !1;
                                if (!types.Number(nOp)) return !1;
                                var m = mOp - OP_INT_BASE,
                                    n = nOp - OP_INT_BASE;
                                if (0 >= m) return !1;
                                if (m > n) return !1;
                                if (16 < n) return !1;
                                if (n !== chunks.length - 3) return !1;
                                return chunks.slice(1, -2).every(isCanonicalPubKey)
                            }

                            function isNullDataOutput(script) {
                                var chunks = decompile(script);
                                return chunks[0] === OPS.OP_RETURN
                            }

                            function classifyOutput(script) {
                                var chunks = decompile(script);
                                if (isWitnessPubKeyHashOutput(chunks)) {
                                    return "witnesspubkeyhash"
                                } else if (isWitnessScriptHashOutput(chunks)) {
                                    return "witnessscripthash"
                                } else if (isPubKeyHashOutput(chunks)) {
                                    return "pubkeyhash"
                                } else if (isScriptHashOutput(chunks)) {
                                    return "scripthash"
                                } else if (isMultisigOutput(chunks)) {
                                    return "multisig"
                                } else if (isPubKeyOutput(chunks)) {
                                    return "pubkey"
                                } else if (isNullDataOutput(chunks)) {
                                    return "nulldata"
                                }
                                return "nonstandard"
                            }

                            function classifyInput(script, allowIncomplete) {
                                var chunks = decompile(script);
                                if (isPubKeyHashInput(chunks)) {
                                    return "pubkeyhash"
                                } else if (isMultisigInput(chunks, allowIncomplete)) {
                                    return "multisig"
                                } else if (isScriptHashInput(chunks, allowIncomplete)) {
                                    return "scripthash"
                                } else if (isPubKeyInput(chunks)) {
                                    return "pubkey"
                                }
                                return "nonstandard"
                            }

                            function scriptHashInput(scriptSig, scriptPubKey) {
                                var scriptSigChunks = decompile(scriptSig),
                                    serializedScriptPubKey = compile(scriptPubKey);
                                return compile([].concat(scriptSigChunks, serializedScriptPubKey))
                            }
                            module.exports = {
                                compile: compile,
                                decompile: decompile,
                                fromASM: function(asm) {
                                    typeforce(types.String, asm);
                                    return compile(asm.split(" ").map(function(chunkStr) {
                                        if (OPS[chunkStr] !== void 0) return OPS[chunkStr];
                                        return new Buffer(chunkStr, "hex")
                                    }))
                                },
                                toASM: function(chunks) {
                                    if (Buffer.isBuffer(chunks)) {
                                        chunks = decompile(chunks)
                                    }
                                    return chunks.map(function(chunk) {
                                        if (Buffer.isBuffer(chunk)) return chunk.toString("hex");
                                        return REVERSE_OPS[chunk]
                                    }).join(" ")
                                },
                                number: require("./script_number"),
                                isCanonicalPubKey: isCanonicalPubKey,
                                isCanonicalSignature: isCanonicalSignature,
                                isDefinedHashType: isDefinedHashType,
                                isPubKeyHashInput: isPubKeyHashInput,
                                isPubKeyHashOutput: isPubKeyHashOutput,
                                isPubKeyInput: isPubKeyInput,
                                isPubKeyOutput: isPubKeyOutput,
                                isScriptHashInput: isScriptHashInput,
                                isScriptHashOutput: isScriptHashOutput,
                                isWitnessPubKeyHashOutput: isWitnessPubKeyHashOutput,
                                isWitnessScriptHashOutput: isWitnessScriptHashOutput,
                                isMultisigInput: isMultisigInput,
                                isMultisigOutput: isMultisigOutput,
                                isNullDataOutput: isNullDataOutput,
                                classifyOutput: classifyOutput,
                                classifyInput: classifyInput,
                                pubKeyOutput: function(pubKey) {
                                    return compile([pubKey, OPS.OP_CHECKSIG])
                                },
                                pubKeyHashOutput: function(pubKeyHash) {
                                    typeforce(types.Hash160bit, pubKeyHash);
                                    return compile([OPS.OP_DUP, OPS.OP_HASH160, pubKeyHash, OPS.OP_EQUALVERIFY, OPS.OP_CHECKSIG])
                                },
                                scriptHashOutput: function(scriptHash) {
                                    typeforce(types.Hash160bit, scriptHash);
                                    return compile([OPS.OP_HASH160, scriptHash, OPS.OP_EQUAL])
                                },
                                witnessPubKeyHashOutput: function(pubKeyHash) {
                                    typeforce(types.Hash160bit, pubKeyHash);
                                    return compile([OPS.OP_0, pubKeyHash])
                                },
                                witnessScriptHashInput: function(scriptSig, scriptPubKey) {
                                    return scriptHashInput(scriptSig, scriptPubKey)
                                },
                                witnessScriptHashOutput: function(scriptHash) {
                                    typeforce(types.Hash256bit, scriptHash);
                                    return compile([OPS.OP_0, scriptHash])
                                },
                                multisigOutput: function(m, pubKeys) {
                                    typeforce(types.tuple(types.Number, [types.Buffer]), arguments);
                                    var n = pubKeys.length;
                                    if (n < m) throw new Error("Not enough pubKeys provided");
                                    return compile([].concat(OP_INT_BASE + m, pubKeys, OP_INT_BASE + n, OPS.OP_CHECKMULTISIG))
                                },
                                pubKeyInput: function(signature) {
                                    typeforce(types.Buffer, signature);
                                    return compile([signature])
                                },
                                pubKeyHashInput: function(signature, pubKey) {
                                    typeforce(types.tuple(types.Buffer, types.Buffer), arguments);
                                    return compile([signature, pubKey])
                                },
                                scriptHashInput: scriptHashInput,
                                multisigInput: function(signatures, scriptPubKey) {
                                    if (scriptPubKey) {
                                        var chunks = decompile(scriptPubKey);
                                        if (!isMultisigOutput(chunks)) throw new Error("Expected multisig scriptPubKey");
                                        var mOp = chunks[0],
                                            nOp = chunks[chunks.length - 2];
                                        if (signatures.length < mOp - OP_INT_BASE) throw new Error("Not enough signatures provided");
                                        if (signatures.length > nOp - OP_INT_BASE) throw new Error("Too many signatures provided")
                                    }
                                    return compile([].concat(OPS.OP_0, signatures))
                                },
                                nullDataOutput: function(data) {
                                    return compile([OPS.OP_RETURN, data])
                                }
                            }
                        }).call(this, require("buffer").Buffer)
                    }, {
                        "./bufferutils": 23,
                        "./opcodes.json": 32,
                        "./script_number": 34,
                        "./types": 37,
                        bip66: 20,
                        buffer: 45,
                        typeforce: 440
                    }],
                    34: [function(require, module) {
                        (function(Buffer) {
                            function scriptNumSize(i) {
                                return 2147483647 < i ? 5 : 8388607 < i ? 4 : 32767 < i ? 3 : 127 < i ? 2 : 0 < i ? 1 : 0
                            }
                            module.exports = {
                                decode: function(buffer, maxLength, minimal) {
                                    maxLength = maxLength || 4;
                                    minimal = minimal === void 0 ? !0 : minimal;
                                    var length = buffer.length;
                                    if (0 === length) return 0;
                                    if (length > maxLength) throw new TypeError("Script number overflow");
                                    if (minimal) {
                                        if (0 === (127 & buffer[length - 1])) {
                                            if (1 >= length || 0 === (128 & buffer[length - 2])) throw new Error("Non-minimally encoded script number")
                                        }
                                    }
                                    if (5 === length) {
                                        var a = buffer.readUInt32LE(0),
                                            b = buffer.readUInt8(4);
                                        if (128 & b) return -(4294967296 * (~128 & b) + a);
                                        return 4294967296 * b + a
                                    }
                                    for (var result = 0, i = 0; i < length; ++i) {
                                        result |= buffer[i] << 8 * i
                                    }
                                    if (128 & buffer[length - 1]) return -(result & ~(128 << 8 * (length - 1)));
                                    return result
                                },
                                encode: function(number) {
                                    for (var value = _Mathabs(number), size = scriptNumSize(value), buffer = new Buffer(size), negative = 0 > number, i = 0; i < size; ++i) {
                                        buffer.writeUInt8(255 & value, i);
                                        value >>= 8
                                    }
                                    if (128 & buffer[size - 1]) {
                                        buffer.writeUInt8(negative ? 128 : 0, size - 1)
                                    } else if (negative) {
                                        buffer[size - 1] |= 128
                                    }
                                    return buffer
                                }
                            }
                        }).call(this, require("buffer").Buffer)
                    }, {
                        buffer: 45
                    }],
                    35: [function(require, module) {
                        (function(Buffer) {
                            var bcrypto = require("./crypto"),
                                bscript = require("./script"),
                                bufferutils = require("./bufferutils"),
                                bufferReverse = require("buffer-reverse"),
                                opcodes = require("./opcodes.json"),
                                typeforce = require("typeforce"),
                                types = require("./types");

                            function Transaction() {
                                this.version = 1;
                                this.locktime = 0;
                                this.ins = [];
                                this.outs = []
                            }
                            Transaction.DEFAULT_SEQUENCE = 4294967295;
                            Transaction.SIGHASH_ALL = 1;
                            Transaction.SIGHASH_NONE = 2;
                            Transaction.SIGHASH_SINGLE = 3;
                            Transaction.SIGHASH_ANYONECANPAY = 128;
                            Transaction.fromBuffer = function(buffer, __noStrict) {
                                var offset = 0;

                                function readSlice(n) {
                                    offset += n;
                                    return buffer.slice(offset - n, offset)
                                }

                                function readUInt32() {
                                    var i = buffer.readUInt32LE(offset);
                                    offset += 4;
                                    return i
                                }

                                function readUInt64() {
                                    var i = bufferutils.readUInt64LE(buffer, offset);
                                    offset += 8;
                                    return i
                                }

                                function readVarInt() {
                                    var vi = bufferutils.readVarInt(buffer, offset);
                                    offset += vi.size;
                                    return vi.number
                                }

                                function readScript() {
                                    return readSlice(readVarInt())
                                }
                                var tx = new Transaction;
                                tx.version = readUInt32();
                                for (var vinLen = readVarInt(), i = 0; i < vinLen; ++i) {
                                    tx.ins.push({
                                        hash: readSlice(32),
                                        index: readUInt32(),
                                        script: readScript(),
                                        sequence: readUInt32()
                                    })
                                }
                                var voutLen = readVarInt();
                                for (i = 0; i < voutLen; ++i) {
                                    tx.outs.push({
                                        value: readUInt64(),
                                        script: readScript()
                                    })
                                }
                                tx.locktime = readUInt32();
                                if (__noStrict) return tx;
                                if (offset !== buffer.length) throw new Error("Transaction has unexpected data");
                                return tx
                            };
                            Transaction.fromHex = function(hex) {
                                return Transaction.fromBuffer(new Buffer(hex, "hex"))
                            };
                            Transaction.isCoinbaseHash = function(buffer) {
                                typeforce(types.Hash256bit, buffer);
                                for (var i = 0; 32 > i; ++i) {
                                    if (0 !== buffer[i]) return !1
                                }
                                return !0
                            };
                            Transaction.prototype.isCoinbase = function() {
                                return 1 === this.ins.length && Transaction.isCoinbaseHash(this.ins[0].hash)
                            };
                            var EMPTY_SCRIPT = new Buffer(0);
                            Transaction.prototype.addInput = function(hash, index, sequence, scriptSig) {
                                typeforce(types.tuple(types.Hash256bit, types.UInt32, types.maybe(types.UInt32), types.maybe(types.Buffer)), arguments);
                                if (types.Null(sequence)) {
                                    sequence = Transaction.DEFAULT_SEQUENCE
                                }
                                return this.ins.push({
                                    hash: hash,
                                    index: index,
                                    script: scriptSig || EMPTY_SCRIPT,
                                    sequence: sequence
                                }) - 1
                            };
                            Transaction.prototype.addOutput = function(scriptPubKey, value) {
                                typeforce(types.tuple(types.Buffer, types.UInt53), arguments);
                                return this.outs.push({
                                    script: scriptPubKey,
                                    value: value
                                }) - 1
                            };
                            Transaction.prototype.byteLength = function() {
                                function scriptSize(someScript) {
                                    var length = someScript.length;
                                    return bufferutils.varIntSize(length) + length
                                }
                                return 8 + bufferutils.varIntSize(this.ins.length) + bufferutils.varIntSize(this.outs.length) + this.ins.reduce(function(sum, input) {
                                    return sum + 40 + scriptSize(input.script)
                                }, 0) + this.outs.reduce(function(sum, output) {
                                    return sum + 8 + scriptSize(output.script)
                                }, 0)
                            };
                            Transaction.prototype.clone = function() {
                                var newTx = new Transaction;
                                newTx.version = this.version;
                                newTx.locktime = this.locktime;
                                newTx.ins = this.ins.map(function(txIn) {
                                    return {
                                        hash: txIn.hash,
                                        index: txIn.index,
                                        script: txIn.script,
                                        sequence: txIn.sequence
                                    }
                                });
                                newTx.outs = this.outs.map(function(txOut) {
                                    return {
                                        script: txOut.script,
                                        value: txOut.value
                                    }
                                });
                                return newTx
                            };
                            var ONE = new Buffer("0000000000000000000000000000000000000000000000000000000000000001", "hex"),
                                VALUE_UINT64_MAX = new Buffer("ffffffffffffffff", "hex"),
                                BLANK_OUTPUT = {
                                    script: EMPTY_SCRIPT,
                                    valueBuffer: VALUE_UINT64_MAX
                                };
                            Transaction.prototype.hashForSignature = function(inIndex, prevOutScript, hashType) {
                                typeforce(types.tuple(types.UInt32, types.Buffer, types.Number), arguments);
                                if (inIndex >= this.ins.length) return ONE;
                                var ourScript = bscript.compile(bscript.decompile(prevOutScript).filter(function(x) {
                                        return x !== opcodes.OP_CODESEPARATOR
                                    })),
                                    txTmp = this.clone();
                                if ((31 & hashType) === Transaction.SIGHASH_NONE) {
                                    txTmp.outs = [];
                                    txTmp.ins.forEach(function(input, i) {
                                        if (i === inIndex) return;
                                        input.sequence = 0
                                    })
                                } else if ((31 & hashType) === Transaction.SIGHASH_SINGLE) {
                                    if (inIndex >= this.outs.length) return ONE;
                                    txTmp.outs.length = inIndex + 1;
                                    for (var i = 0; i < inIndex; i++) {
                                        txTmp.outs[i] = BLANK_OUTPUT
                                    }
                                    txTmp.ins.forEach(function(input, i) {
                                        if (i === inIndex) return;
                                        input.sequence = 0
                                    })
                                }
                                if (hashType & Transaction.SIGHASH_ANYONECANPAY) {
                                    txTmp.ins = [txTmp.ins[inIndex]];
                                    txTmp.ins[0].script = ourScript
                                } else {
                                    txTmp.ins.forEach(function(input) {
                                        input.script = EMPTY_SCRIPT
                                    });
                                    txTmp.ins[inIndex].script = ourScript
                                }
                                var buffer = new Buffer(txTmp.byteLength() + 4);
                                buffer.writeInt32LE(hashType, buffer.length - 4);
                                txTmp.toBuffer(buffer, 0);
                                return bcrypto.hash256(buffer)
                            };
                            Transaction.prototype.getHash = function() {
                                return bcrypto.hash256(this.toBuffer())
                            };
                            Transaction.prototype.getId = function() {
                                return bufferReverse(this.getHash()).toString("hex")
                            };
                            Transaction.prototype.toBuffer = function(buffer, initialOffset) {
                                if (!buffer) buffer = new Buffer(this.byteLength());
                                var offset = initialOffset || 0;

                                function writeSlice(slice) {
                                    slice.copy(buffer, offset);
                                    offset += slice.length
                                }

                                function writeUInt32(i) {
                                    buffer.writeUInt32LE(i, offset);
                                    offset += 4
                                }

                                function writeUInt64(i) {
                                    bufferutils.writeUInt64LE(buffer, i, offset);
                                    offset += 8
                                }

                                function writeVarInt(i) {
                                    var n = bufferutils.writeVarInt(buffer, i, offset);
                                    offset += n
                                }
                                writeUInt32(this.version);
                                writeVarInt(this.ins.length);
                                this.ins.forEach(function(txIn) {
                                    writeSlice(txIn.hash);
                                    writeUInt32(txIn.index);
                                    writeVarInt(txIn.script.length);
                                    writeSlice(txIn.script);
                                    writeUInt32(txIn.sequence)
                                });
                                writeVarInt(this.outs.length);
                                this.outs.forEach(function(txOut) {
                                    if (!txOut.valueBuffer) {
                                        writeUInt64(txOut.value)
                                    } else {
                                        writeSlice(txOut.valueBuffer)
                                    }
                                    writeVarInt(txOut.script.length);
                                    writeSlice(txOut.script)
                                });
                                writeUInt32(this.locktime);
                                if (initialOffset !== void 0) return buffer.slice(initialOffset, offset);
                                return buffer
                            };
                            Transaction.prototype.toHex = function() {
                                return this.toBuffer().toString("hex")
                            };
                            Transaction.prototype.setInputScript = function(index, scriptSig) {
                                typeforce(types.tuple(types.Number, types.Buffer), arguments);
                                this.ins[index].script = scriptSig
                            };
                            module.exports = Transaction
                        }).call(this, require("buffer").Buffer)
                    }, {
                        "./bufferutils": 23,
                        "./crypto": 24,
                        "./opcodes.json": 32,
                        "./script": 33,
                        "./types": 37,
                        buffer: 45,
                        "buffer-reverse": 44,
                        typeforce: 440
                    }],
                    36: [function(require, module) {
                        (function(Buffer) {
                            var baddress = require("./address"),
                                bcrypto = require("./crypto"),
                                bscript = require("./script"),
                                bufferEquals = require("buffer-equals"),
                                bufferReverse = require("buffer-reverse"),
                                networks = require("./networks"),
                                ops = require("./opcodes.json"),
                                typeforce = require("typeforce"),
                                types = require("./types"),
                                ECPair = require("./ecpair"),
                                ECSignature = require("./ecsignature"),
                                Transaction = require("./transaction");

                            function fixMSSignatures(transaction, vin, pubKeys, signatures, prevOutScript, hashType, skipPubKey) {
                                var unmatched = signatures.slice(),
                                    cache = {};
                                return pubKeys.map(function(pubKey) {
                                    if (skipPubKey && bufferEquals(skipPubKey, pubKey)) return;
                                    var matched, keyPair2 = ECPair.fromPublicKeyBuffer(pubKey);
                                    unmatched.some(function(signature, i) {
                                        if (!signature) return !1;
                                        var signatureHash = cache[hashType] = cache[hashType] || transaction.hashForSignature(vin, prevOutScript, hashType);
                                        if (!keyPair2.verify(signatureHash, signature)) return !1;
                                        unmatched[i] = void 0;
                                        matched = signature;
                                        return !0
                                    });
                                    return matched || void 0
                                })
                            }

                            function extractInput(transaction, txIn, vin) {
                                if (0 === txIn.script.length) return {};
                                var scriptSigChunks = bscript.decompile(txIn.script),
                                    prevOutType = bscript.classifyInput(scriptSigChunks, !0);

                                function processScript(scriptType, scriptSigChunks, redeemScriptChunks) {
                                    scriptSigChunks = bscript.decompile(scriptSigChunks);
                                    redeemScriptChunks = redeemScriptChunks ? bscript.decompile(redeemScriptChunks) : void 0;
                                    var hashType, pubKeys, signatures, prevOutScript, redeemScript, redeemScriptType, result, parsed;
                                    switch (scriptType) {
                                        case "scripthash":
                                            redeemScript = scriptSigChunks.slice(-1)[0];
                                            scriptSigChunks = bscript.compile(scriptSigChunks.slice(0, -1));
                                            redeemScriptType = bscript.classifyInput(scriptSigChunks, !0);
                                            prevOutScript = bscript.scriptHashOutput(bcrypto.hash160(redeemScript));
                                            result = processScript(redeemScriptType, scriptSigChunks, bscript.decompile(redeemScript));
                                            result.prevOutScript = prevOutScript;
                                            result.redeemScript = redeemScript;
                                            result.redeemScriptType = redeemScriptType;
                                            return result;
                                        case "pubkeyhash":
                                            parsed = ECSignature.parseScriptSignature(scriptSigChunks[0]);
                                            hashType = parsed.hashType;
                                            pubKeys = scriptSigChunks.slice(1);
                                            signatures = [parsed.signature];
                                            prevOutScript = bscript.pubKeyHashOutput(bcrypto.hash160(pubKeys[0]));
                                            break;
                                        case "pubkey":
                                            parsed = ECSignature.parseScriptSignature(scriptSigChunks[0]);
                                            hashType = parsed.hashType;
                                            signatures = [parsed.signature];
                                            if (redeemScriptChunks) {
                                                pubKeys = redeemScriptChunks.slice(0, 1)
                                            }
                                            break;
                                        case "multisig":
                                            signatures = scriptSigChunks.slice(1).map(function(chunk) {
                                                if (chunk === ops.OP_0) return;
                                                parsed = ECSignature.parseScriptSignature(chunk);
                                                hashType = parsed.hashType;
                                                return parsed.signature
                                            });
                                            if (redeemScriptChunks) {
                                                pubKeys = redeemScriptChunks.slice(1, -2);
                                                if (pubKeys.length !== signatures.length) {
                                                    signatures = fixMSSignatures(transaction, vin, pubKeys, signatures, bscript.compile(redeemScriptChunks), hashType, redeemScript)
                                                }
                                            }
                                            break;
                                    }
                                    return {
                                        hashType: hashType,
                                        pubKeys: pubKeys,
                                        signatures: signatures,
                                        prevOutScript: prevOutScript,
                                        redeemScript: redeemScript,
                                        redeemScriptType: redeemScriptType
                                    }
                                }
                                var result = processScript(prevOutType, scriptSigChunks);
                                return {
                                    hashType: result.hashType,
                                    prevOutScript: result.prevOutScript,
                                    prevOutType: prevOutType,
                                    pubKeys: result.pubKeys,
                                    redeemScript: result.redeemScript,
                                    redeemScriptType: result.redeemScriptType,
                                    signatures: result.signatures
                                }
                            }

                            function TransactionBuilder(network) {
                                this.prevTxMap = {};
                                this.prevOutScripts = {};
                                this.prevOutTypes = {};
                                this.network = network || networks.bitcoin;
                                this.inputs = [];
                                this.tx = new Transaction
                            }
                            TransactionBuilder.prototype.setLockTime = function(locktime) {
                                typeforce(types.UInt32, locktime);
                                if (this.inputs.some(function(input) {
                                        if (!input.signatures) return !1;
                                        return input.signatures.some(function(s) {
                                            return s
                                        })
                                    })) {
                                    throw new Error("No, this would invalidate signatures")
                                }
                                this.tx.locktime = locktime
                            };
                            TransactionBuilder.prototype.setVersion = function(version) {
                                typeforce(types.UInt32, version);
                                this.tx.version = version
                            };
                            TransactionBuilder.fromTransaction = function(transaction, network) {
                                var txb = new TransactionBuilder(network);
                                txb.tx.version = transaction.version;
                                txb.tx.locktime = transaction.locktime;
                                transaction.ins.forEach(function(txIn) {
                                    txb.addInput(txIn.hash, txIn.index, txIn.sequence)
                                });
                                transaction.outs.forEach(function(txOut) {
                                    txb.addOutput(txOut.script, txOut.value)
                                });
                                txb.inputs = transaction.ins.map(function(txIn, vin) {
                                    if (Transaction.isCoinbaseHash(txIn.hash)) {
                                        throw new Error("coinbase inputs not supported")
                                    }
                                    return extractInput(transaction, txIn, vin)
                                });
                                return txb
                            };
                            TransactionBuilder.prototype.addInput = function(txHash, vout, sequence, prevOutScript) {
                                if ("string" === typeof txHash) {
                                    txHash = bufferReverse(new Buffer(txHash, "hex"))
                                } else if (txHash instanceof Transaction) {
                                    prevOutScript = txHash.outs[vout].script;
                                    txHash = txHash.getHash()
                                }
                                var input = {};
                                if (prevOutScript) {
                                    var prevOutScriptChunks = bscript.decompile(prevOutScript),
                                        prevOutType = bscript.classifyOutput(prevOutScriptChunks);
                                    switch (prevOutType) {
                                        case "multisig":
                                            input.pubKeys = prevOutScriptChunks.slice(1, -2);
                                            input.signatures = input.pubKeys.map(function() {});
                                            break;
                                        case "pubkey":
                                            input.pubKeys = prevOutScriptChunks.slice(0, 1);
                                            input.signatures = [void 0];
                                            break;
                                    }
                                    if ("scripthash" !== prevOutType) {
                                        input.scriptType = prevOutType
                                    }
                                    input.prevOutScript = prevOutScript;
                                    input.prevOutType = prevOutType
                                }
                                if (!this.inputs.every(function(otherInput) {
                                        if (otherInput.hashType === void 0) return !0;
                                        return otherInput.hashType & Transaction.SIGHASH_ANYONECANPAY
                                    })) {
                                    throw new Error("No, this would invalidate signatures")
                                }
                                var prevOut = txHash.toString("hex") + ":" + vout;
                                if (this.prevTxMap[prevOut]) throw new Error("Transaction is already an input");
                                var vin = this.tx.addInput(txHash, vout, sequence);
                                this.inputs[vin] = input;
                                this.prevTxMap[prevOut] = vin;
                                return vin
                            };
                            TransactionBuilder.prototype.addOutput = function(scriptPubKey, value) {
                                var nOutputs = this.tx.outs.length;
                                if (!this.inputs.every(function(input, index) {
                                        if (input.hashType === void 0) return !0;
                                        var hashTypeMod = 31 & input.hashType;
                                        if (hashTypeMod === Transaction.SIGHASH_NONE) return !0;
                                        if (hashTypeMod === Transaction.SIGHASH_SINGLE) {
                                            return index < nOutputs
                                        }
                                        return !1
                                    })) {
                                    throw new Error("No, this would invalidate signatures")
                                }
                                if ("string" === typeof scriptPubKey) {
                                    scriptPubKey = baddress.toOutputScript(scriptPubKey, this.network)
                                }
                                return this.tx.addOutput(scriptPubKey, value)
                            };
                            TransactionBuilder.prototype.build = function() {
                                return this.__build(!1)
                            };
                            TransactionBuilder.prototype.buildIncomplete = function() {
                                return this.__build(!0)
                            };
                            var canBuildTypes = {
                                multisig: !0,
                                pubkey: !0,
                                pubkeyhash: !0
                            };

                            function buildFromInputData(input, scriptType, parentType, redeemScript, allowIncomplete) {
                                var scriptSig;
                                switch (scriptType) {
                                    case "pubkeyhash":
                                        var pkhSignature = input.signatures[0].toScriptSignature(input.hashType);
                                        scriptSig = bscript.pubKeyHashInput(pkhSignature, input.pubKeys[0]);
                                        break;
                                    case "pubkey":
                                        var pkSignature = input.signatures[0].toScriptSignature(input.hashType);
                                        scriptSig = bscript.pubKeyInput(pkSignature);
                                        break;
                                    case "multisig":
                                        var msSignatures = input.signatures.map(function(signature) {
                                            return signature && signature.toScriptSignature(input.hashType)
                                        });
                                        if (allowIncomplete) {
                                            for (var i = 0; i < msSignatures.length; ++i) {
                                                msSignatures[i] = msSignatures[i] || ops.OP_0
                                            }
                                        } else {
                                            msSignatures = msSignatures.filter(function(x) {
                                                return x
                                            })
                                        }
                                        scriptSig = bscript.multisigInput(msSignatures, allowIncomplete ? void 0 : redeemScript);
                                        break;
                                }
                                if ("scripthash" === parentType) {
                                    scriptSig = bscript.scriptHashInput(scriptSig, redeemScript)
                                }
                                return scriptSig
                            }
                            TransactionBuilder.prototype.__build = function(allowIncomplete) {
                                if (!allowIncomplete) {
                                    if (!this.tx.ins.length) throw new Error("Transaction has no inputs");
                                    if (!this.tx.outs.length) throw new Error("Transaction has no outputs")
                                }
                                var tx = this.tx.clone();
                                this.inputs.forEach(function(input, index) {
                                    var scriptType = input.redeemScriptType || input.prevOutType,
                                        scriptSig;
                                    if (!allowIncomplete) {
                                        if (!scriptType) throw new Error("Transaction is not complete");
                                        if (!canBuildTypes[scriptType]) throw new Error(scriptType + " not supported");
                                        if (!input.signatures) throw new Error("Transaction is missing signatures")
                                    }
                                    if (input.signatures) {
                                        scriptSig = buildFromInputData(input, scriptType, input.prevOutType, input.redeemScript, allowIncomplete)
                                    }
                                    if (scriptSig) {
                                        tx.setInputScript(index, scriptSig)
                                    }
                                });
                                return tx
                            };

                            function extractFromOutputScript(outputScript, keyPair, kpPubKey) {
                                var scriptType = bscript.classifyOutput(outputScript),
                                    outputScriptChunks = bscript.decompile(outputScript);
                                switch (scriptType) {
                                    case "pubkeyhash":
                                        var pkh1 = outputScriptChunks[2],
                                            pkh2 = bcrypto.hash160(keyPair.getPublicKeyBuffer());
                                        if (!bufferEquals(pkh1, pkh2)) throw new Error("privateKey cannot sign for this input");
                                        return {
                                            pubKeys: [kpPubKey],
                                            scriptType: scriptType
                                        };
                                    case "pubkey":
                                        return {
                                            pubKeys: outputScriptChunks.slice(0, 1),
                                            scriptType: scriptType
                                        };
                                    case "multisig":
                                        return {
                                            pubKeys: outputScriptChunks.slice(1, -2),
                                            scriptType: scriptType
                                        };
                                }
                            }
                            TransactionBuilder.prototype.sign = function(index, keyPair, redeemScript, hashType) {
                                if (keyPair.network !== this.network) throw new Error("Inconsistent network");
                                if (!this.inputs[index]) throw new Error("No input at index: " + index);
                                hashType = hashType || Transaction.SIGHASH_ALL;
                                var input = this.inputs[index],
                                    canSign = input.hashType && input.prevOutScript && input.prevOutType && input.pubKeys && input.redeemScriptType && input.signatures && input.signatures.length === input.pubKeys.length,
                                    kpPubKey = keyPair.getPublicKeyBuffer(),
                                    signatureScript;
                                if (canSign) {
                                    if (redeemScript) {
                                        if (!bufferEquals(input.redeemScript, redeemScript)) throw new Error("Inconsistent redeemScript")
                                    }
                                    if (input.hashType !== hashType) throw new Error("Inconsistent hashType")
                                } else {
                                    if (redeemScript) {
                                        if (input.prevOutScript) {
                                            if ("scripthash" !== input.prevOutType) throw new Error("PrevOutScript must be P2SH");
                                            var scriptHash = bscript.decompile(input.prevOutScript)[1];
                                            if (!bufferEquals(scriptHash, bcrypto.hash160(redeemScript))) throw new Error("RedeemScript does not match " + scriptHash.toString("hex"))
                                        }
                                        var extracted = extractFromOutputScript(redeemScript, keyPair, kpPubKey);
                                        if (!extracted) throw new Error("RedeemScript not supported \"" + bscript.toASM(redeemScript) + "\"");
                                        if (!input.prevOutScript) {
                                            input.prevOutScript = bscript.scriptHashOutput(bcrypto.hash160(redeemScript));
                                            input.prevOutType = "scripthash"
                                        }
                                        input.pubKeys = extracted.pubKeys;
                                        input.redeemScript = redeemScript;
                                        input.redeemScriptType = extracted.scriptType;
                                        input.signatures = extracted.pubKeys.map(function() {})
                                    } else {
                                        if ("scripthash" === input.prevOutType) throw new Error("PrevOutScript is P2SH, missing redeemScript");
                                        if (!input.scriptType) {
                                            input.prevOutScript = bscript.pubKeyHashOutput(bcrypto.hash160(keyPair.getPublicKeyBuffer()));
                                            input.prevOutType = "pubkeyhash";
                                            input.pubKeys = [kpPubKey];
                                            input.scriptType = input.prevOutType;
                                            input.signatures = [void 0]
                                        } else {
                                            if (!input.pubKeys || !input.signatures) throw new Error(input.scriptType + " not supported")
                                        }
                                    }
                                    input.hashType = hashType
                                }
                                signatureScript = signatureScript || input.redeemScript || input.prevOutScript;
                                var signatureHash = this.tx.hashForSignature(index, signatureScript, hashType),
                                    valid = input.pubKeys.some(function(pubKey, i) {
                                        if (!bufferEquals(kpPubKey, pubKey)) return !1;
                                        if (input.signatures[i]) throw new Error("Signature already exists");
                                        input.signatures[i] = keyPair.sign(signatureHash);
                                        return !0
                                    });
                                if (!valid) throw new Error("Key pair cannot sign for this input")
                            };
                            module.exports = TransactionBuilder
                        }).call(this, require("buffer").Buffer)
                    }, {
                        "./address": 21,
                        "./crypto": 24,
                        "./ecpair": 26,
                        "./ecsignature": 27,
                        "./networks": 31,
                        "./opcodes.json": 32,
                        "./script": 33,
                        "./transaction": 35,
                        "./types": 37,
                        buffer: 45,
                        "buffer-equals": 43,
                        "buffer-reverse": 44,
                        typeforce: 440
                    }],
                    37: [function(require, module) {
                        var typeforce = require("typeforce");

                        function nBuffer(value, n) {
                            typeforce(types.Buffer, value);
                            if (value.length !== n) throw new typeforce.TfTypeError("Expected " + 8 * n + "-bit Buffer, got " + 8 * value.length + "-bit Buffer");
                            return !0
                        }

                        function UInt8(value) {
                            return (255 & value) === value
                        }

                        function UInt32(value) {
                            return value >>> 0 === value
                        }

                        function UInt53(value) {
                            return typeforce.Number(value) && 0 <= value && value <= 9007199254740992 - 1 && _Mathfloor(value) === value
                        }
                        var BigInt = typeforce.quacksLike("BigInteger"),
                            ECPoint = typeforce.quacksLike("Point"),
                            ECSignature = typeforce.compile({
                                r: BigInt,
                                s: BigInt
                            }),
                            Network = typeforce.compile({
                                messagePrefix: typeforce.oneOf(typeforce.Buffer, typeforce.String),
                                bip32: {
                                    public: UInt32,
                                    private: UInt32
                                },
                                pubKeyHash: UInt8,
                                scriptHash: UInt8,
                                wif: UInt8,
                                dustThreshold: UInt53
                            }),
                            types = {
                                BigInt: BigInt,
                                Buffer256bit: function(value) {
                                    return nBuffer(value, 32)
                                },
                                ECPoint: ECPoint,
                                ECSignature: ECSignature,
                                Hash160bit: function(value) {
                                    return nBuffer(value, 20)
                                },
                                Hash256bit: function(value) {
                                    return nBuffer(value, 32)
                                },
                                Network: Network,
                                UInt2: function(value) {
                                    return (3 & value) === value
                                },
                                UInt8: UInt8,
                                UInt31: function(value) {
                                    return UInt32(value) && value <= 2147483648 - 1
                                },
                                UInt32: UInt32,
                                UInt53: UInt53,
                                Bip32Path: function(value) {
                                    return typeforce.String(value) && value.match(/^(m\/)?(\d+'?\/)*\d+'?$/)
                                }
                            };
                        for (var typeName in typeforce) {
                            types[typeName] = typeforce[typeName]
                        }
                        module.exports = types
                    }, {
                        typeforce: 440
                    }],
                    38: [function() {}, {}],
                    39: [function(require, module, exports) {
                        arguments[4][38][0].apply(exports, arguments)
                    }, {
                        dup: 38
                    }],
                    40: [function(require, module) {
                        var basex = require("base-x");
                        module.exports = basex("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz")
                    }, {
                        "base-x": 14
                    }],
                    41: [function(require, module) {
                        (function(Buffer) {
                            "use strict";
                            var base58 = require("bs58"),
                                createHash = require("create-hash");

                            function sha256x2(buffer) {
                                var tmp = createHash("sha256").update(buffer).digest();
                                return createHash("sha256").update(tmp).digest()
                            }

                            function decodeRaw(buffer) {
                                var payload = buffer.slice(0, -4),
                                    checksum = buffer.slice(-4),
                                    newChecksum = sha256x2(payload);
                                if (checksum[0] ^ newChecksum[0] | checksum[1] ^ newChecksum[1] | checksum[2] ^ newChecksum[2] | checksum[3] ^ newChecksum[3]) return;
                                return payload
                            }

                            function decodeUnsafe(string) {
                                var array = base58.decodeUnsafe(string);
                                if (!array) return;
                                var buffer = new Buffer(array);
                                return decodeRaw(buffer)
                            }
                            module.exports = {
                                encode: function(payload) {
                                    var checksum = sha256x2(payload);
                                    return base58.encode(Buffer.concat([payload, checksum], payload.length + 4))
                                },
                                decode: function(string) {
                                    var array = base58.decode(string),
                                        buffer = new Buffer(array),
                                        payload = decodeRaw(buffer);
                                    if (!payload) throw new Error("Invalid checksum");
                                    return payload
                                },
                                decodeUnsafe: decodeUnsafe,
                                decodeRaw: decodeUnsafe
                            }
                        }).call(this, require("buffer").Buffer)
                    }, {
                        bs58: 40,
                        buffer: 45,
                        "create-hash": 375
                    }],
                    42: [function(require, module) {
                        module.exports = function(a, b) {
                            if ("function" === typeof a.compare) return a.compare(b);
                            if (a === b) return 0;
                            var x = a.length,
                                y = b.length,
                                i = 0,
                                len = _Mathmin(x, y);
                            while (i < len) {
                                if (a[i] !== b[i]) break;
                                ++i
                            }
                            if (i !== len) {
                                x = a[i];
                                y = b[i]
                            }
                            if (x < y) return -1;
                            if (y < x) return 1;
                            return 0
                        }
                    }, {}],
                    43: [function(require, module) {
                        (function(Buffer) {
                            "use strict";
                            module.exports = function(a, b) {
                                if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
                                    throw new TypeError("Arguments must be Buffers")
                                }
                                if (a === b) {
                                    return !0
                                }
                                if ("function" === typeof a.equals) {
                                    return a.equals(b)
                                }
                                if (a.length !== b.length) {
                                    return !1
                                }
                                for (var i = 0; i < a.length; i++) {
                                    if (a[i] !== b[i]) {
                                        return !1
                                    }
                                }
                                return !0
                            }
                        }).call(this, {
                            isBuffer: require("../is-buffer/index.js")
                        })
                    }, {
                        "../is-buffer/index.js": 393
                    }],
                    44: [function(require, module) {
                        (function(Buffer) {
                            module.exports = function(src) {
                                for (var buffer = new Buffer(src.length), i = 0, j = src.length - 1; i <= j; ++i, --j) {
                                    buffer[i] = src[j];
                                    buffer[j] = src[i]
                                }
                                return buffer
                            }
                        }).call(this, require("buffer").Buffer)
                    }, {
                        buffer: 45
                    }],
                    45: [function(require, module, exports) {
                        "use strict";
                        var base64 = require("base64-js"),
                            ieee754 = require("ieee754");
                        exports.Buffer = Buffer;
                        exports.SlowBuffer = function(length) {
                            if (+length != length) {
                                length = 0
                            }
                            return Buffer.alloc(+length)
                        };
                        exports.INSPECT_MAX_BYTES = 50;
                        var K_MAX_LENGTH = 2147483647;
                        exports.kMaxLength = K_MAX_LENGTH;
                        Buffer.TYPED_ARRAY_SUPPORT = function() {
                            try {
                                var arr = new Uint8Array(1);
                                arr.__proto__ = {
                                    __proto__: Uint8Array.prototype,
                                    foo: function() {
                                        return 42
                                    }
                                };
                                return 42 === arr.foo()
                            } catch (e) {
                                return !1
                            }
                        }();
                        if (!Buffer.TYPED_ARRAY_SUPPORT && "undefined" !== typeof console && "function" === typeof console.error) {
                            console.error("This browser lacks typed array (Uint8Array) support which is required by " + "`buffer` v5.x. Use `buffer` v4.x if you require old browser support.")
                        }
                        Object.defineProperty(Buffer.prototype, "parent", {
                            get: function() {
                                if (!(this instanceof Buffer)) {
                                    return
                                }
                                return this.buffer
                            }
                        });
                        Object.defineProperty(Buffer.prototype, "offset", {
                            get: function() {
                                if (!(this instanceof Buffer)) {
                                    return
                                }
                                return this.byteOffset
                            }
                        });

                        function createBuffer(length) {
                            if (length > K_MAX_LENGTH) {
                                throw new RangeError("Invalid typed array length")
                            }
                            var buf = new Uint8Array(length);
                            buf.__proto__ = Buffer.prototype;
                            return buf
                        }

                        function Buffer(arg, encodingOrOffset, length) {
                            if ("number" === typeof arg) {
                                if ("string" === typeof encodingOrOffset) {
                                    throw new Error("If encoding is specified then the first argument must be a string")
                                }
                                return allocUnsafe(arg)
                            }
                            return from(arg, encodingOrOffset, length)
                        }
                        if ("undefined" !== typeof Symbol && Symbol.species && Buffer[Symbol.species] === Buffer) {
                            Object.defineProperty(Buffer, Symbol.species, {
                                value: null,
                                configurable: !0,
                                enumerable: !1,
                                writable: !1
                            })
                        }
                        Buffer.poolSize = 8192;

                        function from(value, encodingOrOffset, length) {
                            if ("number" === typeof value) {
                                throw new TypeError("\"value\" argument must not be a number")
                            }
                            if (isArrayBuffer(value) || value && isArrayBuffer(value.buffer)) {
                                return fromArrayBuffer(value, encodingOrOffset, length)
                            }
                            if ("string" === typeof value) {
                                return fromString(value, encodingOrOffset)
                            }
                            return fromObject(value)
                        }
                        Buffer.from = function(value, encodingOrOffset, length) {
                            return from(value, encodingOrOffset, length)
                        };
                        Buffer.prototype.__proto__ = Uint8Array.prototype;
                        Buffer.__proto__ = Uint8Array;

                        function assertSize(size) {
                            if ("number" !== typeof size) {
                                throw new TypeError("\"size\" argument must be of type number")
                            } else if (0 > size) {
                                throw new RangeError("\"size\" argument must not be negative")
                            }
                        }

                        function alloc(size, fill, encoding) {
                            assertSize(size);
                            if (0 >= size) {
                                return createBuffer(size)
                            }
                            if (fill !== void 0) {
                                return "string" === typeof encoding ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill)
                            }
                            return createBuffer(size)
                        }
                        Buffer.alloc = function(size, fill, encoding) {
                            return alloc(size, fill, encoding)
                        };

                        function allocUnsafe(size) {
                            assertSize(size);
                            return createBuffer(0 > size ? 0 : 0 | checked(size))
                        }
                        Buffer.allocUnsafe = function(size) {
                            return allocUnsafe(size)
                        };
                        Buffer.allocUnsafeSlow = function(size) {
                            return allocUnsafe(size)
                        };

                        function fromString(string, encoding) {
                            if ("string" !== typeof encoding || "" === encoding) {
                                encoding = "utf8"
                            }
                            if (!Buffer.isEncoding(encoding)) {
                                throw new TypeError("Unknown encoding: " + encoding)
                            }
                            var length = 0 | byteLength(string, encoding),
                                buf = createBuffer(length),
                                actual = buf.write(string, encoding);
                            if (actual !== length) {
                                buf = buf.slice(0, actual)
                            }
                            return buf
                        }

                        function fromArrayLike(array) {
                            for (var length = 0 > array.length ? 0 : 0 | checked(array.length), buf = createBuffer(length), i = 0; i < length; i += 1) {
                                buf[i] = 255 & array[i]
                            }
                            return buf
                        }

                        function fromArrayBuffer(array, byteOffset, length) {
                            if (0 > byteOffset || array.byteLength < byteOffset) {
                                throw new RangeError("\"offset\" is outside of buffer bounds")
                            }
                            if (array.byteLength < byteOffset + (length || 0)) {
                                throw new RangeError("\"length\" is outside of buffer bounds")
                            }
                            var buf;
                            if (byteOffset === void 0 && length === void 0) {
                                buf = new Uint8Array(array)
                            } else if (length === void 0) {
                                buf = new Uint8Array(array, byteOffset)
                            } else {
                                buf = new Uint8Array(array, byteOffset, length)
                            }
                            buf.__proto__ = Buffer.prototype;
                            return buf
                        }

                        function fromObject(obj) {
                            if (Buffer.isBuffer(obj)) {
                                var len = 0 | checked(obj.length),
                                    buf = createBuffer(len);
                                if (0 === buf.length) {
                                    return buf
                                }
                                obj.copy(buf, 0, 0, len);
                                return buf
                            }
                            if (obj) {
                                if (ArrayBuffer.isView(obj) || "length" in obj) {
                                    if ("number" !== typeof obj.length || numberIsNaN(obj.length)) {
                                        return createBuffer(0)
                                    }
                                    return fromArrayLike(obj)
                                }
                                if ("Buffer" === obj.type && Array.isArray(obj.data)) {
                                    return fromArrayLike(obj.data)
                                }
                            }
                            throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object.")
                        }

                        function checked(length) {
                            if (length >= K_MAX_LENGTH) {
                                throw new RangeError("Attempt to allocate Buffer larger than maximum " + "size: 0x" + K_MAX_LENGTH.toString(16) + " bytes")
                            }
                            return 0 | length
                        }
                        Buffer.isBuffer = function(b) {
                            return null != b && !0 === b._isBuffer
                        };
                        Buffer.compare = function(a, b) {
                            if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
                                throw new TypeError("Arguments must be Buffers")
                            }
                            if (a === b) return 0;
                            for (var x = a.length, y = b.length, i = 0, len = _Mathmin(x, y); i < len; ++i) {
                                if (a[i] !== b[i]) {
                                    x = a[i];
                                    y = b[i];
                                    break
                                }
                            }
                            if (x < y) return -1;
                            if (y < x) return 1;
                            return 0
                        };
                        Buffer.isEncoding = function(encoding) {
                            switch ((encoding + "").toLowerCase()) {
                                case "hex":
                                case "utf8":
                                case "utf-8":
                                case "ascii":
                                case "latin1":
                                case "binary":
                                case "base64":
                                case "ucs2":
                                case "ucs-2":
                                case "utf16le":
                                case "utf-16le":
                                    return !0;
                                default:
                                    return !1;
                            }
                        };
                        Buffer.concat = function(list, length) {
                            if (!Array.isArray(list)) {
                                throw new TypeError("\"list\" argument must be an Array of Buffers")
                            }
                            if (0 === list.length) {
                                return Buffer.alloc(0)
                            }
                            var i;
                            if (length === void 0) {
                                length = 0;
                                for (i = 0; i < list.length; ++i) {
                                    length += list[i].length
                                }
                            }
                            var buffer = Buffer.allocUnsafe(length),
                                pos = 0;
                            for (i = 0; i < list.length; ++i) {
                                var buf = list[i];
                                if (ArrayBuffer.isView(buf)) {
                                    buf = Buffer.from(buf)
                                }
                                if (!Buffer.isBuffer(buf)) {
                                    throw new TypeError("\"list\" argument must be an Array of Buffers")
                                }
                                buf.copy(buffer, pos);
                                pos += buf.length
                            }
                            return buffer
                        };

                        function byteLength(string, encoding) {
                            if (Buffer.isBuffer(string)) {
                                return string.length
                            }
                            if (ArrayBuffer.isView(string) || isArrayBuffer(string)) {
                                return string.byteLength
                            }
                            if ("string" !== typeof string) {
                                string = "" + string
                            }
                            var len = string.length;
                            if (0 === len) return 0;
                            var loweredCase = !1;
                            for (;;) {
                                switch (encoding) {
                                    case "ascii":
                                    case "latin1":
                                    case "binary":
                                        return len;
                                    case "utf8":
                                    case "utf-8":
                                    case void 0:
                                        return utf8ToBytes(string).length;
                                    case "ucs2":
                                    case "ucs-2":
                                    case "utf16le":
                                    case "utf-16le":
                                        return 2 * len;
                                    case "hex":
                                        return len >>> 1;
                                    case "base64":
                                        return base64ToBytes(string).length;
                                    default:
                                        if (loweredCase) return utf8ToBytes(string).length;
                                        encoding = ("" + encoding).toLowerCase();
                                        loweredCase = !0;
                                }
                            }
                        }
                        Buffer.byteLength = byteLength;

                        function slowToString(encoding, start, end) {
                            var loweredCase = !1;
                            if (start === void 0 || 0 > start) {
                                start = 0
                            }
                            if (start > this.length) {
                                return ""
                            }
                            if (end === void 0 || end > this.length) {
                                end = this.length
                            }
                            if (0 >= end) {
                                return ""
                            }
                            end >>>= 0;
                            start >>>= 0;
                            if (end <= start) {
                                return ""
                            }
                            if (!encoding) encoding = "utf8";
                            while (!0) {
                                switch (encoding) {
                                    case "hex":
                                        return hexSlice(this, start, end);
                                    case "utf8":
                                    case "utf-8":
                                        return utf8Slice(this, start, end);
                                    case "ascii":
                                        return asciiSlice(this, start, end);
                                    case "latin1":
                                    case "binary":
                                        return latin1Slice(this, start, end);
                                    case "base64":
                                        return base64Slice(this, start, end);
                                    case "ucs2":
                                    case "ucs-2":
                                    case "utf16le":
                                    case "utf-16le":
                                        return utf16leSlice(this, start, end);
                                    default:
                                        if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
                                        encoding = (encoding + "").toLowerCase();
                                        loweredCase = !0;
                                }
                            }
                        }
                        Buffer.prototype._isBuffer = !0;

                        function swap(b, n, m) {
                            var i = b[n];
                            b[n] = b[m];
                            b[m] = i
                        }
                        Buffer.prototype.swap16 = function() {
                            var len = this.length;
                            if (0 !== len % 2) {
                                throw new RangeError("Buffer size must be a multiple of 16-bits")
                            }
                            for (var i = 0; i < len; i += 2) {
                                swap(this, i, i + 1)
                            }
                            return this
                        };
                        Buffer.prototype.swap32 = function() {
                            var len = this.length;
                            if (0 !== len % 4) {
                                throw new RangeError("Buffer size must be a multiple of 32-bits")
                            }
                            for (var i = 0; i < len; i += 4) {
                                swap(this, i, i + 3);
                                swap(this, i + 1, i + 2)
                            }
                            return this
                        };
                        Buffer.prototype.swap64 = function() {
                            var len = this.length;
                            if (0 !== len % 8) {
                                throw new RangeError("Buffer size must be a multiple of 64-bits")
                            }
                            for (var i = 0; i < len; i += 8) {
                                swap(this, i, i + 7);
                                swap(this, i + 1, i + 6);
                                swap(this, i + 2, i + 5);
                                swap(this, i + 3, i + 4)
                            }
                            return this
                        };
                        Buffer.prototype.toString = function() {
                            var length = this.length;
                            if (0 === length) return "";
                            if (0 === arguments.length) return utf8Slice(this, 0, length);
                            return slowToString.apply(this, arguments)
                        };
                        Buffer.prototype.toLocaleString = Buffer.prototype.toString;
                        Buffer.prototype.equals = function(b) {
                            if (!Buffer.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
                            if (this === b) return !0;
                            return 0 === Buffer.compare(this, b)
                        };
                        Buffer.prototype.inspect = function() {
                            var str = "",
                                max = exports.INSPECT_MAX_BYTES;
                            if (0 < this.length) {
                                str = this.toString("hex", 0, max).match(/.{2}/g).join(" ");
                                if (this.length > max) str += " ... "
                            }
                            return "<Buffer " + str + ">"
                        };
                        Buffer.prototype.compare = function(target, start, end, thisStart, thisEnd) {
                            if (!Buffer.isBuffer(target)) {
                                throw new TypeError("Argument must be a Buffer")
                            }
                            if (start === void 0) {
                                start = 0
                            }
                            if (end === void 0) {
                                end = target ? target.length : 0
                            }
                            if (thisStart === void 0) {
                                thisStart = 0
                            }
                            if (thisEnd === void 0) {
                                thisEnd = this.length
                            }
                            if (0 > start || end > target.length || 0 > thisStart || thisEnd > this.length) {
                                throw new RangeError("out of range index")
                            }
                            if (thisStart >= thisEnd && start >= end) {
                                return 0
                            }
                            if (thisStart >= thisEnd) {
                                return -1
                            }
                            if (start >= end) {
                                return 1
                            }
                            start >>>= 0;
                            end >>>= 0;
                            thisStart >>>= 0;
                            thisEnd >>>= 0;
                            if (this === target) return 0;
                            for (var x = thisEnd - thisStart, y = end - start, len = _Mathmin(x, y), thisCopy = this.slice(thisStart, thisEnd), targetCopy = target.slice(start, end), i = 0; i < len; ++i) {
                                if (thisCopy[i] !== targetCopy[i]) {
                                    x = thisCopy[i];
                                    y = targetCopy[i];
                                    break
                                }
                            }
                            if (x < y) return -1;
                            if (y < x) return 1;
                            return 0
                        };

                        function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
                            if (0 === buffer.length) return -1;
                            if ("string" === typeof byteOffset) {
                                encoding = byteOffset;
                                byteOffset = 0
                            } else if (2147483647 < byteOffset) {
                                byteOffset = 2147483647
                            } else if (-2147483648 > byteOffset) {
                                byteOffset = -2147483648
                            }
                            byteOffset = +byteOffset;
                            if (numberIsNaN(byteOffset)) {
                                byteOffset = dir ? 0 : buffer.length - 1
                            }
                            if (0 > byteOffset) byteOffset = buffer.length + byteOffset;
                            if (byteOffset >= buffer.length) {
                                if (dir) return -1;
                                else byteOffset = buffer.length - 1
                            } else if (0 > byteOffset) {
                                if (dir) byteOffset = 0;
                                else return -1
                            }
                            if ("string" === typeof val) {
                                val = Buffer.from(val, encoding)
                            }
                            if (Buffer.isBuffer(val)) {
                                if (0 === val.length) {
                                    return -1
                                }
                                return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
                            } else if ("number" === typeof val) {
                                val = 255 & val;
                                if ("function" === typeof Uint8Array.prototype.indexOf) {
                                    if (dir) {
                                        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
                                    } else {
                                        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
                                    }
                                }
                                return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
                            }
                            throw new TypeError("val must be string, number or Buffer")
                        }

                        function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
                            var indexSize = 1,
                                arrLength = arr.length,
                                valLength = val.length;
                            if (encoding !== void 0) {
                                encoding = (encoding + "").toLowerCase();
                                if ("ucs2" === encoding || "ucs-2" === encoding || "utf16le" === encoding || "utf-16le" === encoding) {
                                    if (2 > arr.length || 2 > val.length) {
                                        return -1
                                    }
                                    indexSize = 2;
                                    arrLength /= 2;
                                    valLength /= 2;
                                    byteOffset /= 2
                                }
                            }

                            function read(buf, i) {
                                if (1 === indexSize) {
                                    return buf[i]
                                } else {
                                    return buf.readUInt16BE(i * indexSize)
                                }
                            }
                            var i;
                            if (dir) {
                                var foundIndex = -1;
                                for (i = byteOffset; i < arrLength; i++) {
                                    if (read(arr, i) === read(val, -1 === foundIndex ? 0 : i - foundIndex)) {
                                        if (-1 === foundIndex) foundIndex = i;
                                        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
                                    } else {
                                        if (-1 !== foundIndex) i -= i - foundIndex;
                                        foundIndex = -1
                                    }
                                }
                            } else {
                                if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
                                for (i = byteOffset; 0 <= i; i--) {
                                    for (var found = !0, j = 0; j < valLength; j++) {
                                        if (read(arr, i + j) !== read(val, j)) {
                                            found = !1;
                                            break
                                        }
                                    }
                                    if (found) return i
                                }
                            }
                            return -1
                        }
                        Buffer.prototype.includes = function(val, byteOffset, encoding) {
                            return -1 !== this.indexOf(val, byteOffset, encoding)
                        };
                        Buffer.prototype.indexOf = function(val, byteOffset, encoding) {
                            return bidirectionalIndexOf(this, val, byteOffset, encoding, !0)
                        };
                        Buffer.prototype.lastIndexOf = function(val, byteOffset, encoding) {
                            return bidirectionalIndexOf(this, val, byteOffset, encoding, !1)
                        };

                        function hexWrite(buf, string, offset, length) {
                            offset = +offset || 0;
                            var remaining = buf.length - offset;
                            if (!length) {
                                length = remaining
                            } else {
                                length = +length;
                                if (length > remaining) {
                                    length = remaining
                                }
                            }
                            var strLen = string.length;
                            if (length > strLen / 2) {
                                length = strLen / 2
                            }
                            for (var i = 0, parsed; i < length; ++i) {
                                parsed = parseInt(string.substr(2 * i, 2), 16);
                                if (numberIsNaN(parsed)) return i;
                                buf[offset + i] = parsed
                            }
                            return i
                        }

                        function utf8Write(buf, string, offset, length) {
                            return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
                        }

                        function asciiWrite(buf, string, offset, length) {
                            return blitBuffer(asciiToBytes(string), buf, offset, length)
                        }

                        function latin1Write(buf, string, offset, length) {
                            return asciiWrite(buf, string, offset, length)
                        }

                        function base64Write(buf, string, offset, length) {
                            return blitBuffer(base64ToBytes(string), buf, offset, length)
                        }

                        function ucs2Write(buf, string, offset, length) {
                            return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
                        }
                        Buffer.prototype.write = function(string, offset, length, encoding) {
                            if (offset === void 0) {
                                encoding = "utf8";
                                length = this.length;
                                offset = 0
                            } else if (length === void 0 && "string" === typeof offset) {
                                encoding = offset;
                                length = this.length;
                                offset = 0
                            } else if (isFinite(offset)) {
                                offset = offset >>> 0;
                                if (isFinite(length)) {
                                    length = length >>> 0;
                                    if (encoding === void 0) encoding = "utf8"
                                } else {
                                    encoding = length;
                                    length = void 0
                                }
                            } else {
                                throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported")
                            }
                            var remaining = this.length - offset;
                            if (length === void 0 || length > remaining) length = remaining;
                            if (0 < string.length && (0 > length || 0 > offset) || offset > this.length) {
                                throw new RangeError("Attempt to write outside buffer bounds")
                            }
                            if (!encoding) encoding = "utf8";
                            var loweredCase = !1;
                            for (;;) {
                                switch (encoding) {
                                    case "hex":
                                        return hexWrite(this, string, offset, length);
                                    case "utf8":
                                    case "utf-8":
                                        return utf8Write(this, string, offset, length);
                                    case "ascii":
                                        return asciiWrite(this, string, offset, length);
                                    case "latin1":
                                    case "binary":
                                        return latin1Write(this, string, offset, length);
                                    case "base64":
                                        return base64Write(this, string, offset, length);
                                    case "ucs2":
                                    case "ucs-2":
                                    case "utf16le":
                                    case "utf-16le":
                                        return ucs2Write(this, string, offset, length);
                                    default:
                                        if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
                                        encoding = ("" + encoding).toLowerCase();
                                        loweredCase = !0;
                                }
                            }
                        };
                        Buffer.prototype.toJSON = function() {
                            return {
                                type: "Buffer",
                                data: Array.prototype.slice.call(this._arr || this, 0)
                            }
                        };

                        function base64Slice(buf, start, end) {
                            if (0 === start && end === buf.length) {
                                return base64.fromByteArray(buf)
                            } else {
                                return base64.fromByteArray(buf.slice(start, end))
                            }
                        }

                        function utf8Slice(buf, start, end) {
                            end = _Mathmin(buf.length, end);
                            var res = [],
                                i = start;
                            while (i < end) {
                                var firstByte = buf[i],
                                    codePoint = null,
                                    bytesPerSequence = 239 < firstByte ? 4 : 223 < firstByte ? 3 : 191 < firstByte ? 2 : 1;
                                if (i + bytesPerSequence <= end) {
                                    var secondByte, thirdByte, fourthByte, tempCodePoint;
                                    switch (bytesPerSequence) {
                                        case 1:
                                            if (128 > firstByte) {
                                                codePoint = firstByte
                                            }
                                            break;
                                        case 2:
                                            secondByte = buf[i + 1];
                                            if (128 === (192 & secondByte)) {
                                                tempCodePoint = (31 & firstByte) << 6 | 63 & secondByte;
                                                if (127 < tempCodePoint) {
                                                    codePoint = tempCodePoint
                                                }
                                            }
                                            break;
                                        case 3:
                                            secondByte = buf[i + 1];
                                            thirdByte = buf[i + 2];
                                            if (128 === (192 & secondByte) && 128 === (192 & thirdByte)) {
                                                tempCodePoint = (15 & firstByte) << 12 | (63 & secondByte) << 6 | 63 & thirdByte;
                                                if (2047 < tempCodePoint && (55296 > tempCodePoint || 57343 < tempCodePoint)) {
                                                    codePoint = tempCodePoint
                                                }
                                            }
                                            break;
                                        case 4:
                                            secondByte = buf[i + 1];
                                            thirdByte = buf[i + 2];
                                            fourthByte = buf[i + 3];
                                            if (128 === (192 & secondByte) && 128 === (192 & thirdByte) && 128 === (192 & fourthByte)) {
                                                tempCodePoint = (15 & firstByte) << 18 | (63 & secondByte) << 12 | (63 & thirdByte) << 6 | 63 & fourthByte;
                                                if (65535 < tempCodePoint && 1114112 > tempCodePoint) {
                                                    codePoint = tempCodePoint
                                                }
                                            }
                                    }
                                }
                                if (null === codePoint) {
                                    codePoint = 65533;
                                    bytesPerSequence = 1
                                } else if (65535 < codePoint) {
                                    codePoint -= 65536;
                                    res.push(55296 | 1023 & codePoint >>> 10);
                                    codePoint = 56320 | 1023 & codePoint
                                }
                                res.push(codePoint);
                                i += bytesPerSequence
                            }
                            return decodeCodePointsArray(res)
                        }
                        var MAX_ARGUMENTS_LENGTH = 4096;

                        function decodeCodePointsArray(codePoints) {
                            var len = codePoints.length;
                            if (len <= MAX_ARGUMENTS_LENGTH) {
                                return _StringfromCharCode.apply(String, codePoints)
                            }
                            var res = "",
                                i = 0;
                            while (i < len) {
                                res += _StringfromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH))
                            }
                            return res
                        }

                        function asciiSlice(buf, start, end) {
                            var ret = "";
                            end = _Mathmin(buf.length, end);
                            for (var i = start; i < end; ++i) {
                                ret += _StringfromCharCode(127 & buf[i])
                            }
                            return ret
                        }

                        function latin1Slice(buf, start, end) {
                            var ret = "";
                            end = _Mathmin(buf.length, end);
                            for (var i = start; i < end; ++i) {
                                ret += _StringfromCharCode(buf[i])
                            }
                            return ret
                        }

                        function hexSlice(buf, start, end) {
                            var len = buf.length;
                            if (!start || 0 > start) start = 0;
                            if (!end || 0 > end || end > len) end = len;
                            for (var out = "", i = start; i < end; ++i) {
                                out += toHex(buf[i])
                            }
                            return out
                        }

                        function utf16leSlice(buf, start, end) {
                            for (var bytes = buf.slice(start, end), res = "", i = 0; i < bytes.length; i += 2) {
                                res += _StringfromCharCode(bytes[i] + 256 * bytes[i + 1])
                            }
                            return res
                        }
                        Buffer.prototype.slice = function(start, end) {
                            var len = this.length;
                            start = ~~start;
                            end = end === void 0 ? len : ~~end;
                            if (0 > start) {
                                start += len;
                                if (0 > start) start = 0
                            } else if (start > len) {
                                start = len
                            }
                            if (0 > end) {
                                end += len;
                                if (0 > end) end = 0
                            } else if (end > len) {
                                end = len
                            }
                            if (end < start) end = start;
                            var newBuf = this.subarray(start, end);
                            newBuf.__proto__ = Buffer.prototype;
                            return newBuf
                        };

                        function checkOffset(offset, ext, length) {
                            if (0 !== offset % 1 || 0 > offset) throw new RangeError("offset is not uint");
                            if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length")
                        }
                        Buffer.prototype.readUIntLE = function(offset, byteLength, noAssert) {
                            offset = offset >>> 0;
                            byteLength = byteLength >>> 0;
                            if (!noAssert) checkOffset(offset, byteLength, this.length);
                            var val = this[offset],
                                mul = 1,
                                i = 0;
                            while (++i < byteLength && (mul *= 256)) {
                                val += this[offset + i] * mul
                            }
                            return val
                        };
                        Buffer.prototype.readUIntBE = function(offset, byteLength, noAssert) {
                            offset = offset >>> 0;
                            byteLength = byteLength >>> 0;
                            if (!noAssert) {
                                checkOffset(offset, byteLength, this.length)
                            }
                            var val = this[offset + --byteLength],
                                mul = 1;
                            while (0 < byteLength && (mul *= 256)) {
                                val += this[offset + --byteLength] * mul
                            }
                            return val
                        };
                        Buffer.prototype.readUInt8 = function(offset, noAssert) {
                            offset = offset >>> 0;
                            if (!noAssert) checkOffset(offset, 1, this.length);
                            return this[offset]
                        };
                        Buffer.prototype.readUInt16LE = function(offset, noAssert) {
                            offset = offset >>> 0;
                            if (!noAssert) checkOffset(offset, 2, this.length);
                            return this[offset] | this[offset + 1] << 8
                        };
                        Buffer.prototype.readUInt16BE = function(offset, noAssert) {
                            offset = offset >>> 0;
                            if (!noAssert) checkOffset(offset, 2, this.length);
                            return this[offset] << 8 | this[offset + 1]
                        };
                        Buffer.prototype.readUInt32LE = function(offset, noAssert) {
                            offset = offset >>> 0;
                            if (!noAssert) checkOffset(offset, 4, this.length);
                            return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + 16777216 * this[offset + 3]
                        };
                        Buffer.prototype.readUInt32BE = function(offset, noAssert) {
                            offset = offset >>> 0;
                            if (!noAssert) checkOffset(offset, 4, this.length);
                            return 16777216 * this[offset] + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3])
                        };
                        Buffer.prototype.readIntLE = function(offset, byteLength, noAssert) {
                            offset = offset >>> 0;
                            byteLength = byteLength >>> 0;
                            if (!noAssert) checkOffset(offset, byteLength, this.length);
                            var val = this[offset],
                                mul = 1,
                                i = 0;
                            while (++i < byteLength && (mul *= 256)) {
                                val += this[offset + i] * mul
                            }
                            mul *= 128;
                            if (val >= mul) val -= _Mathpow(2, 8 * byteLength);
                            return val
                        };
                        Buffer.prototype.readIntBE = function(offset, byteLength, noAssert) {
                            offset = offset >>> 0;
                            byteLength = byteLength >>> 0;
                            if (!noAssert) checkOffset(offset, byteLength, this.length);
                            var i = byteLength,
                                mul = 1,
                                val = this[offset + --i];
                            while (0 < i && (mul *= 256)) {
                                val += this[offset + --i] * mul
                            }
                            mul *= 128;
                            if (val >= mul) val -= _Mathpow(2, 8 * byteLength);
                            return val
                        };
                        Buffer.prototype.readInt8 = function(offset, noAssert) {
                            offset = offset >>> 0;
                            if (!noAssert) checkOffset(offset, 1, this.length);
                            if (!(128 & this[offset])) return this[offset];
                            return -1 * (255 - this[offset] + 1)
                        };
                        Buffer.prototype.readInt16LE = function(offset, noAssert) {
                            offset = offset >>> 0;
                            if (!noAssert) checkOffset(offset, 2, this.length);
                            var val = this[offset] | this[offset + 1] << 8;
                            return 32768 & val ? 4294901760 | val : val
                        };
                        Buffer.prototype.readInt16BE = function(offset, noAssert) {
                            offset = offset >>> 0;
                            if (!noAssert) checkOffset(offset, 2, this.length);
                            var val = this[offset + 1] | this[offset] << 8;
                            return 32768 & val ? 4294901760 | val : val
                        };
                        Buffer.prototype.readInt32LE = function(offset, noAssert) {
                            offset = offset >>> 0;
                            if (!noAssert) checkOffset(offset, 4, this.length);
                            return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24
                        };
                        Buffer.prototype.readInt32BE = function(offset, noAssert) {
                            offset = offset >>> 0;
                            if (!noAssert) checkOffset(offset, 4, this.length);
                            return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]
                        };
                        Buffer.prototype.readFloatLE = function(offset, noAssert) {
                            offset = offset >>> 0;
                            if (!noAssert) checkOffset(offset, 4, this.length);
                            return ieee754.read(this, offset, !0, 23, 4)
                        };
                        Buffer.prototype.readFloatBE = function(offset, noAssert) {
                            offset = offset >>> 0;
                            if (!noAssert) checkOffset(offset, 4, this.length);
                            return ieee754.read(this, offset, !1, 23, 4)
                        };
                        Buffer.prototype.readDoubleLE = function(offset, noAssert) {
                            offset = offset >>> 0;
                            if (!noAssert) checkOffset(offset, 8, this.length);
                            return ieee754.read(this, offset, !0, 52, 8)
                        };
                        Buffer.prototype.readDoubleBE = function(offset, noAssert) {
                            offset = offset >>> 0;
                            if (!noAssert) checkOffset(offset, 8, this.length);
                            return ieee754.read(this, offset, !1, 52, 8)
                        };

                        function checkInt(buf, value, offset, ext, max, min) {
                            if (!Buffer.isBuffer(buf)) throw new TypeError("\"buffer\" argument must be a Buffer instance");
                            if (value > max || value < min) throw new RangeError("\"value\" argument is out of bounds");
                            if (offset + ext > buf.length) throw new RangeError("Index out of range")
                        }
                        Buffer.prototype.writeUIntLE = function(value, offset, byteLength, noAssert) {
                            value = +value;
                            offset = offset >>> 0;
                            byteLength = byteLength >>> 0;
                            if (!noAssert) {
                                var maxBytes = _Mathpow(2, 8 * byteLength) - 1;
                                checkInt(this, value, offset, byteLength, maxBytes, 0)
                            }
                            var mul = 1,
                                i = 0;
                            this[offset] = 255 & value;
                            while (++i < byteLength && (mul *= 256)) {
                                this[offset + i] = 255 & value / mul
                            }
                            return offset + byteLength
                        };
                        Buffer.prototype.writeUIntBE = function(value, offset, byteLength, noAssert) {
                            value = +value;
                            offset = offset >>> 0;
                            byteLength = byteLength >>> 0;
                            if (!noAssert) {
                                var maxBytes = _Mathpow(2, 8 * byteLength) - 1;
                                checkInt(this, value, offset, byteLength, maxBytes, 0)
                            }
                            var i = byteLength - 1,
                                mul = 1;
                            this[offset + i] = 255 & value;
                            while (0 <= --i && (mul *= 256)) {
                                this[offset + i] = 255 & value / mul
                            }
                            return offset + byteLength
                        };
                        Buffer.prototype.writeUInt8 = function(value, offset, noAssert) {
                            value = +value;
                            offset = offset >>> 0;
                            if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
                            this[offset] = 255 & value;
                            return offset + 1
                        };
                        Buffer.prototype.writeUInt16LE = function(value, offset, noAssert) {
                            value = +value;
                            offset = offset >>> 0;
                            if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
                            this[offset] = 255 & value;
                            this[offset + 1] = value >>> 8;
                            return offset + 2
                        };
                        Buffer.prototype.writeUInt16BE = function(value, offset, noAssert) {
                            value = +value;
                            offset = offset >>> 0;
                            if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
                            this[offset] = value >>> 8;
                            this[offset + 1] = 255 & value;
                            return offset + 2
                        };
                        Buffer.prototype.writeUInt32LE = function(value, offset, noAssert) {
                            value = +value;
                            offset = offset >>> 0;
                            if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
                            this[offset + 3] = value >>> 24;
                            this[offset + 2] = value >>> 16;
                            this[offset + 1] = value >>> 8;
                            this[offset] = 255 & value;
                            return offset + 4
                        };
                        Buffer.prototype.writeUInt32BE = function(value, offset, noAssert) {
                            value = +value;
                            offset = offset >>> 0;
                            if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
                            this[offset] = value >>> 24;
                            this[offset + 1] = value >>> 16;
                            this[offset + 2] = value >>> 8;
                            this[offset + 3] = 255 & value;
                            return offset + 4
                        };
                        Buffer.prototype.writeIntLE = function(value, offset, byteLength, noAssert) {
                            value = +value;
                            offset = offset >>> 0;
                            if (!noAssert) {
                                var limit = _Mathpow(2, 8 * byteLength - 1);
                                checkInt(this, value, offset, byteLength, limit - 1, -limit)
                            }
                            var i = 0,
                                mul = 1,
                                sub = 0;
                            this[offset] = 255 & value;
                            while (++i < byteLength && (mul *= 256)) {
                                if (0 > value && 0 === sub && 0 !== this[offset + i - 1]) {
                                    sub = 1
                                }
                                this[offset + i] = 255 & (value / mul >> 0) - sub
                            }
                            return offset + byteLength
                        };
                        Buffer.prototype.writeIntBE = function(value, offset, byteLength, noAssert) {
                            value = +value;
                            offset = offset >>> 0;
                            if (!noAssert) {
                                var limit = _Mathpow(2, 8 * byteLength - 1);
                                checkInt(this, value, offset, byteLength, limit - 1, -limit)
                            }
                            var i = byteLength - 1,
                                mul = 1,
                                sub = 0;
                            this[offset + i] = 255 & value;
                            while (0 <= --i && (mul *= 256)) {
                                if (0 > value && 0 === sub && 0 !== this[offset + i + 1]) {
                                    sub = 1
                                }
                                this[offset + i] = 255 & (value / mul >> 0) - sub
                            }
                            return offset + byteLength
                        };
                        Buffer.prototype.writeInt8 = function(value, offset, noAssert) {
                            value = +value;
                            offset = offset >>> 0;
                            if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
                            if (0 > value) value = 255 + value + 1;
                            this[offset] = 255 & value;
                            return offset + 1
                        };
                        Buffer.prototype.writeInt16LE = function(value, offset, noAssert) {
                            value = +value;
                            offset = offset >>> 0;
                            if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
                            this[offset] = 255 & value;
                            this[offset + 1] = value >>> 8;
                            return offset + 2
                        };
                        Buffer.prototype.writeInt16BE = function(value, offset, noAssert) {
                            value = +value;
                            offset = offset >>> 0;
                            if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
                            this[offset] = value >>> 8;
                            this[offset + 1] = 255 & value;
                            return offset + 2
                        };
                        Buffer.prototype.writeInt32LE = function(value, offset, noAssert) {
                            value = +value;
                            offset = offset >>> 0;
                            if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
                            this[offset] = 255 & value;
                            this[offset + 1] = value >>> 8;
                            this[offset + 2] = value >>> 16;
                            this[offset + 3] = value >>> 24;
                            return offset + 4
                        };
                        Buffer.prototype.writeInt32BE = function(value, offset, noAssert) {
                            value = +value;
                            offset = offset >>> 0;
                            if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
                            if (0 > value) value = 4294967295 + value + 1;
                            this[offset] = value >>> 24;
                            this[offset + 1] = value >>> 16;
                            this[offset + 2] = value >>> 8;
                            this[offset + 3] = 255 & value;
                            return offset + 4
                        };

                        function checkIEEE754(buf, value, offset, ext) {
                            if (offset + ext > buf.length) throw new RangeError("Index out of range");
                            if (0 > offset) throw new RangeError("Index out of range")
                        }

                        function writeFloat(buf, value, offset, littleEndian, noAssert) {
                            value = +value;
                            offset = offset >>> 0;
                            if (!noAssert) {
                                checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22)
                            }
                            ieee754.write(buf, value, offset, littleEndian, 23, 4);
                            return offset + 4
                        }
                        Buffer.prototype.writeFloatLE = function(value, offset, noAssert) {
                            return writeFloat(this, value, offset, !0, noAssert)
                        };
                        Buffer.prototype.writeFloatBE = function(value, offset, noAssert) {
                            return writeFloat(this, value, offset, !1, noAssert)
                        };

                        function writeDouble(buf, value, offset, littleEndian, noAssert) {
                            value = +value;
                            offset = offset >>> 0;
                            if (!noAssert) {
                                checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292)
                            }
                            ieee754.write(buf, value, offset, littleEndian, 52, 8);
                            return offset + 8
                        }
                        Buffer.prototype.writeDoubleLE = function(value, offset, noAssert) {
                            return writeDouble(this, value, offset, !0, noAssert)
                        };
                        Buffer.prototype.writeDoubleBE = function(value, offset, noAssert) {
                            return writeDouble(this, value, offset, !1, noAssert)
                        };
                        Buffer.prototype.copy = function(target, targetStart, start, end) {
                            if (!Buffer.isBuffer(target)) throw new TypeError("argument should be a Buffer");
                            if (!start) start = 0;
                            if (!end && 0 !== end) end = this.length;
                            if (targetStart >= target.length) targetStart = target.length;
                            if (!targetStart) targetStart = 0;
                            if (0 < end && end < start) end = start;
                            if (end === start) return 0;
                            if (0 === target.length || 0 === this.length) return 0;
                            if (0 > targetStart) {
                                throw new RangeError("targetStart out of bounds")
                            }
                            if (0 > start || start >= this.length) throw new RangeError("Index out of range");
                            if (0 > end) throw new RangeError("sourceEnd out of bounds");
                            if (end > this.length) end = this.length;
                            if (target.length - targetStart < end - start) {
                                end = target.length - targetStart + start
                            }
                            var len = end - start;
                            if (this === target && "function" === typeof Uint8Array.prototype.copyWithin) {
                                this.copyWithin(targetStart, start, end)
                            } else if (this === target && start < targetStart && targetStart < end) {
                                for (var i = len - 1; 0 <= i; --i) {
                                    target[i + targetStart] = this[i + start]
                                }
                            } else {
                                Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart)
                            }
                            return len
                        };
                        Buffer.prototype.fill = function(val, start, end, encoding) {
                            if ("string" === typeof val) {
                                if ("string" === typeof start) {
                                    encoding = start;
                                    start = 0;
                                    end = this.length
                                } else if ("string" === typeof end) {
                                    encoding = end;
                                    end = this.length
                                }
                                if (encoding !== void 0 && "string" !== typeof encoding) {
                                    throw new TypeError("encoding must be a string")
                                }
                                if ("string" === typeof encoding && !Buffer.isEncoding(encoding)) {
                                    throw new TypeError("Unknown encoding: " + encoding)
                                }
                                if (1 === val.length) {
                                    var code = val.charCodeAt(0);
                                    if ("utf8" === encoding && 128 > code || "latin1" === encoding) {
                                        val = code
                                    }
                                }
                            } else if ("number" === typeof val) {
                                val = 255 & val
                            }
                            if (0 > start || this.length < start || this.length < end) {
                                throw new RangeError("Out of range index")
                            }
                            if (end <= start) {
                                return this
                            }
                            start = start >>> 0;
                            end = end === void 0 ? this.length : end >>> 0;
                            if (!val) val = 0;
                            var i;
                            if ("number" === typeof val) {
                                for (i = start; i < end; ++i) {
                                    this[i] = val
                                }
                            } else {
                                var bytes = Buffer.isBuffer(val) ? val : new Buffer(val, encoding),
                                    len = bytes.length;
                                if (0 === len) {
                                    throw new TypeError("The value \"" + val + "\" is invalid for argument \"value\"")
                                }
                                for (i = 0; i < end - start; ++i) {
                                    this[i + start] = bytes[i % len]
                                }
                            }
                            return this
                        };
                        var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;

                        function base64clean(str) {
                            str = str.split("=")[0];
                            str = str.trim().replace(INVALID_BASE64_RE, "");
                            if (2 > str.length) return "";
                            while (0 !== str.length % 4) {
                                str = str + "="
                            }
                            return str
                        }

                        function toHex(n) {
                            if (16 > n) return "0" + n.toString(16);
                            return n.toString(16)
                        }

                        function utf8ToBytes(string, units) {
                            units = units || 1 / 0;
                            for (var codePoint, length = string.length, leadSurrogate = null, bytes = [], i = 0; i < length; ++i) {
                                codePoint = string.charCodeAt(i);
                                if (55295 < codePoint && 57344 > codePoint) {
                                    if (!leadSurrogate) {
                                        if (56319 < codePoint) {
                                            if (-1 < (units -= 3)) bytes.push(239, 191, 189);
                                            continue
                                        } else if (i + 1 === length) {
                                            if (-1 < (units -= 3)) bytes.push(239, 191, 189);
                                            continue
                                        }
                                        leadSurrogate = codePoint;
                                        continue
                                    }
                                    if (56320 > codePoint) {
                                        if (-1 < (units -= 3)) bytes.push(239, 191, 189);
                                        leadSurrogate = codePoint;
                                        continue
                                    }
                                    codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536
                                } else if (leadSurrogate) {
                                    if (-1 < (units -= 3)) bytes.push(239, 191, 189)
                                }
                                leadSurrogate = null;
                                if (128 > codePoint) {
                                    if (0 > (units -= 1)) break;
                                    bytes.push(codePoint)
                                } else if (2048 > codePoint) {
                                    if (0 > (units -= 2)) break;
                                    bytes.push(192 | codePoint >> 6, 128 | 63 & codePoint)
                                } else if (65536 > codePoint) {
                                    if (0 > (units -= 3)) break;
                                    bytes.push(224 | codePoint >> 12, 128 | 63 & codePoint >> 6, 128 | 63 & codePoint)
                                } else if (1114112 > codePoint) {
                                    if (0 > (units -= 4)) break;
                                    bytes.push(240 | codePoint >> 18, 128 | 63 & codePoint >> 12, 128 | 63 & codePoint >> 6, 128 | 63 & codePoint)
                                } else {
                                    throw new Error("Invalid code point")
                                }
                            }
                            return bytes
                        }

                        function asciiToBytes(str) {
                            for (var byteArray = [], i = 0; i < str.length; ++i) {
                                byteArray.push(255 & str.charCodeAt(i))
                            }
                            return byteArray
                        }

                        function utf16leToBytes(str, units) {
                            for (var c, hi, lo, byteArray = [], i = 0; i < str.length; ++i) {
                                if (0 > (units -= 2)) break;
                                c = str.charCodeAt(i);
                                hi = c >> 8;
                                lo = c % 256;
                                byteArray.push(lo);
                                byteArray.push(hi)
                            }
                            return byteArray
                        }

                        function base64ToBytes(str) {
                            return base64.toByteArray(base64clean(str))
                        }

                        function blitBuffer(src, dst, offset, length) {
                            for (var i = 0; i < length; ++i) {
                                if (i + offset >= dst.length || i >= src.length) break;
                                dst[i + offset] = src[i]
                            }
                            return i
                        }

                        function isArrayBuffer(obj) {
                            return obj instanceof ArrayBuffer || null != obj && null != obj.constructor && "ArrayBuffer" === obj.constructor.name && "number" === typeof obj.byteLength
                        }

                        function numberIsNaN(obj) {
                            return obj !== obj
                        }
                    }, {
                        "base64-js": 15,
                        ieee754: 391
                    }],
                    46: [function(require, module) {
                        module.exports = {
                            100: "Continue",
                            101: "Switching Protocols",
                            102: "Processing",
                            200: "OK",
                            201: "Created",
                            202: "Accepted",
                            203: "Non-Authoritative Information",
                            204: "No Content",
                            205: "Reset Content",
                            206: "Partial Content",
                            207: "Multi-Status",
                            208: "Already Reported",
                            226: "IM Used",
                            300: "Multiple Choices",
                            301: "Moved Permanently",
                            302: "Found",
                            303: "See Other",
                            304: "Not Modified",
                            305: "Use Proxy",
                            307: "Temporary Redirect",
                            308: "Permanent Redirect",
                            400: "Bad Request",
                            401: "Unauthorized",
                            402: "Payment Required",
                            403: "Forbidden",
                            404: "Not Found",
                            405: "Method Not Allowed",
                            406: "Not Acceptable",
                            407: "Proxy Authentication Required",
                            408: "Request Timeout",
                            409: "Conflict",
                            410: "Gone",
                            411: "Length Required",
                            412: "Precondition Failed",
                            413: "Payload Too Large",
                            414: "URI Too Long",
                            415: "Unsupported Media Type",
                            416: "Range Not Satisfiable",
                            417: "Expectation Failed",
                            418: "I'm a teapot",
                            421: "Misdirected Request",
                            422: "Unprocessable Entity",
                            423: "Locked",
                            424: "Failed Dependency",
                            425: "Unordered Collection",
                            426: "Upgrade Required",
                            428: "Precondition Required",
                            429: "Too Many Requests",
                            431: "Request Header Fields Too Large",
                            451: "Unavailable For Legal Reasons",
                            500: "Internal Server Error",
                            501: "Not Implemented",
                            502: "Bad Gateway",
                            503: "Service Unavailable",
                            504: "Gateway Timeout",
                            505: "HTTP Version Not Supported",
                            506: "Variant Also Negotiates",
                            507: "Insufficient Storage",
                            508: "Loop Detected",
                            509: "Bandwidth Limit Exceeded",
                            510: "Not Extended",
                            511: "Network Authentication Required"
                        }
                    }, {}],
                    47: [function(require, module) {
                        var Buffer = require("safe-buffer").Buffer,
                            Transform = require("stream").Transform,
                            StringDecoder = require("string_decoder").StringDecoder,
                            inherits = require("inherits");

                        function CipherBase(hashMode) {
                            Transform.call(this);
                            this.hashMode = "string" === typeof hashMode;
                            if (this.hashMode) {
                                this[hashMode] = this._finalOrDigest
                            } else {
                                this.final = this._finalOrDigest
                            }
                            if (this._final) {
                                this.__final = this._final;
                                this._final = null
                            }
                            this._decoder = null;
                            this._encoding = null
                        }
                        inherits(CipherBase, Transform);
                        CipherBase.prototype.update = function(data, inputEnc, outputEnc) {
                            if ("string" === typeof data) {
                                data = Buffer.from(data, inputEnc)
                            }
                            var outData = this._update(data);
                            if (this.hashMode) return this;
                            if (outputEnc) {
                                outData = this._toString(outData, outputEnc)
                            }
                            return outData
                        };
                        CipherBase.prototype.setAutoPadding = function() {};
                        CipherBase.prototype.getAuthTag = function() {
                            throw new Error("trying to get auth tag in unsupported state")
                        };
                        CipherBase.prototype.setAuthTag = function() {
                            throw new Error("trying to set auth tag in unsupported state")
                        };
                        CipherBase.prototype.setAAD = function() {
                            throw new Error("trying to set aad in unsupported state")
                        };
                        CipherBase.prototype._transform = function(data, _, next) {
                            var err;
                            try {
                                if (this.hashMode) {
                                    this._update(data)
                                } else {
                                    this.push(this._update(data))
                                }
                            } catch (e) {
                                err = e
                            } finally {
                                next(err)
                            }
                        };
                        CipherBase.prototype._flush = function(done) {
                            var err;
                            try {
                                this.push(this.__final())
                            } catch (e) {
                                err = e
                            }
                            done(err)
                        };
                        CipherBase.prototype._finalOrDigest = function(outputEnc) {
                            var outData = this.__final() || Buffer.alloc(0);
                            if (outputEnc) {
                                outData = this._toString(outData, outputEnc, !0)
                            }
                            return outData
                        };
                        CipherBase.prototype._toString = function(value, enc, fin) {
                            if (!this._decoder) {
                                this._decoder = new StringDecoder(enc);
                                this._encoding = enc
                            }
                            if (this._encoding !== enc) throw new Error("can't switch encodings");
                            var out = this._decoder.write(value);
                            if (fin) {
                                out += this._decoder.end()
                            }
                            return out
                        };
                        module.exports = CipherBase
                    }, {
                        inherits: 392,
                        "safe-buffer": 420,
                        stream: 430,
                        string_decoder: 436
                    }],
                    48: [function(require, module) {
                        ! function(globals) {
                            "use strict";
                            var convertHex = {
                                bytesToHex: function(bytes) {
                                    return arrBytesToHex(bytes)
                                },
                                hexToBytes: function(hex) {
                                    if (1 === hex.length % 2) throw new Error("hexToBytes can't have a string with an odd number of characters.");
                                    if (0 === hex.indexOf("0x")) hex = hex.slice(2);
                                    return hex.match(/../g).map(function(x) {
                                        return parseInt(x, 16)
                                    })
                                }
                            };

                            function arrBytesToHex(bytes) {
                                return bytes.map(function(x) {
                                    return padLeft(x.toString(16), 2)
                                }).join("")
                            }

                            function padLeft(orig, len) {
                                if (orig.length > len) return orig;
                                return Array(len - orig.length + 1).join("0") + orig
                            }
                            if ("undefined" !== typeof module && module.exports) {
                                module.exports = convertHex
                            } else {
                                globals.convertHex = convertHex
                            }
                        }(this)
                    }, {}],
                    49: [function(require, module) {
                        ! function(globals) {
                            "use strict";
                            var convertString = {
                                bytesToString: function(bytes) {
                                    return bytes.map(function(x) {
                                        return _StringfromCharCode(x)
                                    }).join("")
                                },
                                stringToBytes: function(str) {
                                    return str.split("").map(function(x) {
                                        return x.charCodeAt(0)
                                    })
                                }
                            };
                            convertString.UTF8 = {
                                bytesToString: function(bytes) {
                                    return decodeURIComponent(escape(convertString.bytesToString(bytes)))
                                },
                                stringToBytes: function(str) {
                                    return convertString.stringToBytes(unescape(encodeURIComponent(str)))
                                }
                            };
                            if ("undefined" !== typeof module && module.exports) {
                                module.exports = convertString
                            } else {
                                globals.convertString = convertString
                            }
                        }(this)
                    }, {}],
                    50: [function(require, module) {
                        require("../../modules/core.regexp.escape");
                        module.exports = require("../../modules/_core").RegExp.escape
                    }, {
                        "../../modules/_core": 71,
                        "../../modules/core.regexp.escape": 176
                    }],
                    51: [function(require, module) {
                        module.exports = function(it) {
                            if ("function" != typeof it) throw TypeError(it + " is not a function!");
                            return it
                        }
                    }, {}],
                    52: [function(require, module) {
                        var cof = require("./_cof");
                        module.exports = function(it, msg) {
                            if ("number" != typeof it && "Number" != cof(it)) throw TypeError(msg);
                            return +it
                        }
                    }, {
                        "./_cof": 66
                    }],
                    53: [function(require, module) {
                        var UNSCOPABLES = require("./_wks")("unscopables"),
                            ArrayProto = Array.prototype;
                        if (ArrayProto[UNSCOPABLES] == void 0) require("./_hide")(ArrayProto, UNSCOPABLES, {});
                        module.exports = function(key) {
                            ArrayProto[UNSCOPABLES][key] = !0
                        }
                    }, {
                        "./_hide": 90,
                        "./_wks": 174
                    }],
                    54: [function(require, module) {
                        module.exports = function(it, Constructor, name, forbiddenField) {
                            if (!(it instanceof Constructor) || forbiddenField !== void 0 && forbiddenField in it) {
                                throw TypeError(name + ": incorrect invocation!")
                            }
                            return it
                        }
                    }, {}],
                    55: [function(require, module) {
                        var isObject = require("./_is-object");
                        module.exports = function(it) {
                            if (!isObject(it)) throw TypeError(it + " is not an object!");
                            return it
                        }
                    }, {
                        "./_is-object": 99
                    }],
                    56: [function(require, module) {
                        "use strict";
                        var toObject = require("./_to-object"),
                            toAbsoluteIndex = require("./_to-absolute-index"),
                            toLength = require("./_to-length");
                        module.exports = [].copyWithin || function(target, start) {
                            var O = toObject(this),
                                len = toLength(O.length),
                                to = toAbsoluteIndex(target, len),
                                from = toAbsoluteIndex(start, len),
                                end = 2 < arguments.length ? arguments[2] : void 0,
                                count = _Mathmin((end === void 0 ? len : toAbsoluteIndex(end, len)) - from, len - to),
                                inc = 1;
                            if (from < to && to < from + count) {
                                inc = -1;
                                from += count - 1;
                                to += count - 1
                            }
                            while (0 < count--) {
                                if (from in O) O[to] = O[from];
                                else delete O[to];
                                to += inc;
                                from += inc
                            }
                            return O
                        }
                    }, {
                        "./_to-absolute-index": 159,
                        "./_to-length": 163,
                        "./_to-object": 164
                    }],
                    57: [function(require, module) {
                        "use strict";
                        var toObject = require("./_to-object"),
                            toAbsoluteIndex = require("./_to-absolute-index"),
                            toLength = require("./_to-length");
                        module.exports = function(value) {
                            var O = toObject(this),
                                length = toLength(O.length),
                                aLen = arguments.length,
                                index = toAbsoluteIndex(1 < aLen ? arguments[1] : void 0, length),
                                end = 2 < aLen ? arguments[2] : void 0,
                                endPos = end === void 0 ? length : toAbsoluteIndex(end, length);
                            while (endPos > index) O[index++] = value;
                            return O
                        }
                    }, {
                        "./_to-absolute-index": 159,
                        "./_to-length": 163,
                        "./_to-object": 164
                    }],
                    58: [function(require, module) {
                        var forOf = require("./_for-of");
                        module.exports = function(iter, ITERATOR) {
                            var result = [];
                            forOf(iter, !1, result.push, result, ITERATOR);
                            return result
                        }
                    }, {
                        "./_for-of": 87
                    }],
                    59: [function(require, module) {
                        var toIObject = require("./_to-iobject"),
                            toLength = require("./_to-length"),
                            toAbsoluteIndex = require("./_to-absolute-index");
                        module.exports = function(IS_INCLUDES) {
                            return function($this, el, fromIndex) {
                                var O = toIObject($this),
                                    length = toLength(O.length),
                                    index = toAbsoluteIndex(fromIndex, length),
                                    value;
                                if (IS_INCLUDES && el != el)
                                    while (length > index) {
                                        value = O[index++];
                                        if (value != value) return !0
                                    } else
                                        for (; length > index; index++)
                                            if (IS_INCLUDES || index in O) {
                                                if (O[index] === el) return IS_INCLUDES || index || 0
                                            }
                                return !IS_INCLUDES && -1
                            }
                        }
                    }, {
                        "./_to-absolute-index": 159,
                        "./_to-iobject": 162,
                        "./_to-length": 163
                    }],
                    60: [function(require, module) {
                        var ctx = require("./_ctx"),
                            IObject = require("./_iobject"),
                            toObject = require("./_to-object"),
                            toLength = require("./_to-length"),
                            asc = require("./_array-species-create");
                        module.exports = function(TYPE, $create) {
                            var IS_MAP = 1 == TYPE,
                                IS_EVERY = 4 == TYPE,
                                IS_FIND_INDEX = 6 == TYPE,
                                create = $create || asc;
                            return function($this, callbackfn, that) {
                                var O = toObject($this),
                                    self = IObject(O),
                                    f = ctx(callbackfn, that, 3),
                                    length = toLength(self.length),
                                    index = 0,
                                    result = IS_MAP ? create($this, length) : 2 == TYPE ? create($this, 0) : void 0,
                                    val, res;
                                for (; length > index; index++)
                                    if (5 == TYPE || IS_FIND_INDEX || index in self) {
                                        val = self[index];
                                        res = f(val, index, O);
                                        if (TYPE) {
                                            if (IS_MAP) result[index] = res;
                                            else if (res) switch (TYPE) {
                                                case 3:
                                                    return !0;
                                                case 5:
                                                    return val;
                                                case 6:
                                                    return index;
                                                case 2:
                                                    result.push(val);
                                            } else if (IS_EVERY) return !1
                                        }
                                    }
                                return IS_FIND_INDEX ? -1 : 3 == TYPE || IS_EVERY ? IS_EVERY : result
                            }
                        }
                    }, {
                        "./_array-species-create": 63,
                        "./_ctx": 73,
                        "./_iobject": 95,
                        "./_to-length": 163,
                        "./_to-object": 164
                    }],
                    61: [function(require, module) {
                        var aFunction = require("./_a-function"),
                            toObject = require("./_to-object"),
                            IObject = require("./_iobject"),
                            toLength = require("./_to-length");
                        module.exports = function(that, callbackfn, aLen, memo, isRight) {
                            aFunction(callbackfn);
                            var O = toObject(that),
                                self = IObject(O),
                                length = toLength(O.length),
                                index = isRight ? length - 1 : 0,
                                i = isRight ? -1 : 1;
                            if (2 > aLen)
                                for (;;) {
                                    if (index in self) {
                                        memo = self[index];
                                        index += i;
                                        break
                                    }
                                    index += i;
                                    if (isRight ? 0 > index : length <= index) {
                                        throw TypeError("Reduce of empty array with no initial value")
                                    }
                                }
                            for (; isRight ? 0 <= index : length > index; index += i)
                                if (index in self) {
                                    memo = callbackfn(memo, self[index], index, O)
                                }
                            return memo
                        }
                    }, {
                        "./_a-function": 51,
                        "./_iobject": 95,
                        "./_to-length": 163,
                        "./_to-object": 164
                    }],
                    62: [function(require, module) {
                        var isObject = require("./_is-object"),
                            isArray = require("./_is-array"),
                            SPECIES = require("./_wks")("species");
                        module.exports = function(original) {
                            var C;
                            if (isArray(original)) {
                                C = original.constructor;
                                if ("function" == typeof C && (C === Array || isArray(C.prototype))) C = void 0;
                                if (isObject(C)) {
                                    C = C[SPECIES];
                                    if (null === C) C = void 0
                                }
                            }
                            return C === void 0 ? Array : C
                        }
                    }, {
                        "./_is-array": 97,
                        "./_is-object": 99,
                        "./_wks": 174
                    }],
                    63: [function(require, module) {
                        var speciesConstructor = require("./_array-species-constructor");
                        module.exports = function(original, length) {
                            return new(speciesConstructor(original))(length)
                        }
                    }, {
                        "./_array-species-constructor": 62
                    }],
                    64: [function(require, module) {
                        "use strict";
                        var aFunction = require("./_a-function"),
                            isObject = require("./_is-object"),
                            invoke = require("./_invoke"),
                            arraySlice = [].slice,
                            factories = {},
                            construct = function(F, len, args) {
                                if (!(len in factories)) {
                                    for (var n = [], i = 0; i < len; i++) n[i] = "a[" + i + "]";
                                    factories[len] = Function("F,a", "return new F(" + n.join(",") + ")")
                                }
                                return factories[len](F, args)
                            };
                        module.exports = Function.bind || function(that) {
                            var fn = aFunction(this),
                                partArgs = arraySlice.call(arguments, 1),
                                bound = function() {
                                    var args = partArgs.concat(arraySlice.call(arguments));
                                    return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that)
                                };
                            if (isObject(fn.prototype)) bound.prototype = fn.prototype;
                            return bound
                        }
                    }, {
                        "./_a-function": 51,
                        "./_invoke": 94,
                        "./_is-object": 99
                    }],
                    65: [function(require, module) {
                        var cof = require("./_cof"),
                            TAG = require("./_wks")("toStringTag"),
                            ARG = "Arguments" == cof(function() {
                                return arguments
                            }()),
                            tryGet = function(it, key) {
                                try {
                                    return it[key]
                                } catch (e) {}
                            };
                        module.exports = function(it) {
                            var O, T, B;
                            return it === void 0 ? "Undefined" : null === it ? "Null" : "string" == typeof(T = tryGet(O = Object(it), TAG)) ? T : ARG ? cof(O) : "Object" == (B = cof(O)) && "function" == typeof O.callee ? "Arguments" : B
                        }
                    }, {
                        "./_cof": 66,
                        "./_wks": 174
                    }],
                    66: [function(require, module) {
                        var toString = {}.toString;
                        module.exports = function(it) {
                            return toString.call(it).slice(8, -1)
                        }
                    }, {}],
                    67: [function(require, module) {
                        "use strict";
                        var dP = require("./_object-dp").f,
                            create = require("./_object-create"),
                            redefineAll = require("./_redefine-all"),
                            ctx = require("./_ctx"),
                            anInstance = require("./_an-instance"),
                            forOf = require("./_for-of"),
                            $iterDefine = require("./_iter-define"),
                            step = require("./_iter-step"),
                            setSpecies = require("./_set-species"),
                            DESCRIPTORS = require("./_descriptors"),
                            fastKey = require("./_meta").fastKey,
                            validate = require("./_validate-collection"),
                            SIZE = DESCRIPTORS ? "_s" : "size",
                            getEntry = function(that, key) {
                                var index = fastKey(key),
                                    entry;
                                if ("F" !== index) return that._i[index];
                                for (entry = that._f; entry; entry = entry.n) {
                                    if (entry.k == key) return entry
                                }
                            };
                        module.exports = {
                            getConstructor: function(wrapper, NAME, IS_MAP, ADDER) {
                                var C = wrapper(function(that, iterable) {
                                    anInstance(that, C, NAME, "_i");
                                    that._t = NAME;
                                    that._i = create(null);
                                    that._f = void 0;
                                    that._l = void 0;
                                    that[SIZE] = 0;
                                    if (iterable != void 0) forOf(iterable, IS_MAP, that[ADDER], that)
                                });
                                redefineAll(C.prototype, {
                                    clear: function() {
                                        for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
                                            entry.r = !0;
                                            if (entry.p) entry.p = entry.p.n = void 0;
                                            delete data[entry.i]
                                        }
                                        that._f = that._l = void 0;
                                        that[SIZE] = 0
                                    },
                                    delete: function(key) {
                                        var that = validate(this, NAME),
                                            entry = getEntry(that, key);
                                        if (entry) {
                                            var next = entry.n,
                                                prev = entry.p;
                                            delete that._i[entry.i];
                                            entry.r = !0;
                                            if (prev) prev.n = next;
                                            if (next) next.p = prev;
                                            if (that._f == entry) that._f = next;
                                            if (that._l == entry) that._l = prev;
                                            that[SIZE]--
                                        }
                                        return !!entry
                                    },
                                    forEach: function(callbackfn) {
                                        validate(this, NAME);
                                        var f = ctx(callbackfn, 1 < arguments.length ? arguments[1] : void 0, 3),
                                            entry;
                                        while (entry = entry ? entry.n : this._f) {
                                            f(entry.v, entry.k, this);
                                            while (entry && entry.r) entry = entry.p
                                        }
                                    },
                                    has: function(key) {
                                        return !!getEntry(validate(this, NAME), key)
                                    }
                                });
                                if (DESCRIPTORS) dP(C.prototype, "size", {
                                    get: function() {
                                        return validate(this, NAME)[SIZE]
                                    }
                                });
                                return C
                            },
                            def: function(that, key, value) {
                                var entry = getEntry(that, key),
                                    prev, index;
                                if (entry) {
                                    entry.v = value
                                } else {
                                    that._l = entry = {
                                        i: index = fastKey(key, !0),
                                        k: key,
                                        v: value,
                                        p: prev = that._l,
                                        n: void 0,
                                        r: !1
                                    };
                                    if (!that._f) that._f = entry;
                                    if (prev) prev.n = entry;
                                    that[SIZE]++;
                                    if ("F" !== index) that._i[index] = entry
                                }
                                return that
                            },
                            getEntry: getEntry,
                            setStrong: function(C, NAME, IS_MAP) {
                                $iterDefine(C, NAME, function(iterated, kind) {
                                    this._t = validate(iterated, NAME);
                                    this._k = kind;
                                    this._l = void 0
                                }, function() {
                                    var that = this,
                                        kind = that._k,
                                        entry = that._l;
                                    while (entry && entry.r) entry = entry.p;
                                    if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
                                        that._t = void 0;
                                        return step(1)
                                    }
                                    if ("keys" == kind) return step(0, entry.k);
                                    if ("values" == kind) return step(0, entry.v);
                                    return step(0, [entry.k, entry.v])
                                }, IS_MAP ? "entries" : "values", !IS_MAP, !0);
                                setSpecies(NAME)
                            }
                        }
                    }, {
                        "./_an-instance": 54,
                        "./_ctx": 73,
                        "./_descriptors": 77,
                        "./_for-of": 87,
                        "./_iter-define": 103,
                        "./_iter-step": 105,
                        "./_meta": 113,
                        "./_object-create": 118,
                        "./_object-dp": 119,
                        "./_redefine-all": 138,
                        "./_set-species": 145,
                        "./_validate-collection": 171
                    }],
                    68: [function(require, module) {
                        var classof = require("./_classof"),
                            from = require("./_array-from-iterable");
                        module.exports = function(NAME) {
                            return function() {
                                if (classof(this) != NAME) throw TypeError(NAME + "#toJSON isn't generic");
                                return from(this)
                            }
                        }
                    }, {
                        "./_array-from-iterable": 58,
                        "./_classof": 65
                    }],
                    69: [function(require, module) {
                        "use strict";
                        var redefineAll = require("./_redefine-all"),
                            getWeak = require("./_meta").getWeak,
                            anObject = require("./_an-object"),
                            isObject = require("./_is-object"),
                            anInstance = require("./_an-instance"),
                            forOf = require("./_for-of"),
                            createArrayMethod = require("./_array-methods"),
                            $has = require("./_has"),
                            validate = require("./_validate-collection"),
                            arrayFind = createArrayMethod(5),
                            arrayFindIndex = createArrayMethod(6),
                            id = 0,
                            uncaughtFrozenStore = function(that) {
                                return that._l || (that._l = new UncaughtFrozenStore)
                            },
                            UncaughtFrozenStore = function() {
                                this.a = []
                            },
                            findUncaughtFrozen = function(store, key) {
                                return arrayFind(store.a, function(it) {
                                    return it[0] === key
                                })
                            };
                        UncaughtFrozenStore.prototype = {
                            get: function(key) {
                                var entry = findUncaughtFrozen(this, key);
                                if (entry) return entry[1]
                            },
                            has: function(key) {
                                return !!findUncaughtFrozen(this, key)
                            },
                            set: function(key, value) {
                                var entry = findUncaughtFrozen(this, key);
                                if (entry) entry[1] = value;
                                else this.a.push([key, value])
                            },
                            delete: function(key) {
                                var index = arrayFindIndex(this.a, function(it) {
                                    return it[0] === key
                                });
                                if (~index) this.a.splice(index, 1);
                                return !!~index
                            }
                        };
                        module.exports = {
                            getConstructor: function(wrapper, NAME, IS_MAP, ADDER) {
                                var C = wrapper(function(that, iterable) {
                                    anInstance(that, C, NAME, "_i");
                                    that._t = NAME;
                                    that._i = id++;
                                    that._l = void 0;
                                    if (iterable != void 0) forOf(iterable, IS_MAP, that[ADDER], that)
                                });
                                redefineAll(C.prototype, {
                                    delete: function(key) {
                                        if (!isObject(key)) return !1;
                                        var data = getWeak(key);
                                        if (!0 === data) return uncaughtFrozenStore(validate(this, NAME))["delete"](key);
                                        return data && $has(data, this._i) && delete data[this._i]
                                    },
                                    has: function(key) {
                                        if (!isObject(key)) return !1;
                                        var data = getWeak(key);
                                        if (!0 === data) return uncaughtFrozenStore(validate(this, NAME)).has(key);
                                        return data && $has(data, this._i)
                                    }
                                });
                                return C
                            },
                            def: function(that, key, value) {
                                var data = getWeak(anObject(key), !0);
                                if (!0 === data) uncaughtFrozenStore(that).set(key, value);
                                else data[that._i] = value;
                                return that
                            },
                            ufstore: uncaughtFrozenStore
                        }
                    }, {
                        "./_an-instance": 54,
                        "./_an-object": 55,
                        "./_array-methods": 60,
                        "./_for-of": 87,
                        "./_has": 89,
                        "./_is-object": 99,
                        "./_meta": 113,
                        "./_redefine-all": 138,
                        "./_validate-collection": 171
                    }],
                    70: [function(require, module) {
                        "use strict";
                        var global = require("./_global"),
                            $export = require("./_export"),
                            redefine = require("./_redefine"),
                            redefineAll = require("./_redefine-all"),
                            meta = require("./_meta"),
                            forOf = require("./_for-of"),
                            anInstance = require("./_an-instance"),
                            isObject = require("./_is-object"),
                            fails = require("./_fails"),
                            $iterDetect = require("./_iter-detect"),
                            setToStringTag = require("./_set-to-string-tag"),
                            inheritIfRequired = require("./_inherit-if-required");
                        module.exports = function(NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
                            var Base = global[NAME],
                                C = Base,
                                ADDER = IS_MAP ? "set" : "add",
                                proto = C && C.prototype,
                                O = {},
                                fixMethod = function(KEY) {
                                    var fn = proto[KEY];
                                    redefine(proto, KEY, "delete" == KEY ? function(a) {
                                        return IS_WEAK && !isObject(a) ? !1 : fn.call(this, 0 === a ? 0 : a)
                                    } : "has" == KEY ? function(a) {
                                        return IS_WEAK && !isObject(a) ? !1 : fn.call(this, 0 === a ? 0 : a)
                                    } : "get" == KEY ? function(a) {
                                        return IS_WEAK && !isObject(a) ? void 0 : fn.call(this, 0 === a ? 0 : a)
                                    } : "add" == KEY ? function(a) {
                                        fn.call(this, 0 === a ? 0 : a);
                                        return this
                                    } : function(a, b) {
                                        fn.call(this, 0 === a ? 0 : a, b);
                                        return this
                                    })
                                };
                            if ("function" != typeof C || !(IS_WEAK || proto.forEach && !fails(function() {
                                    new C().entries().next()
                                }))) {
                                C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
                                redefineAll(C.prototype, methods);
                                meta.NEED = !0
                            } else {
                                var instance = new C,
                                    HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance,
                                    THROWS_ON_PRIMITIVES = fails(function() {
                                        instance.has(1)
                                    }),
                                    ACCEPT_ITERABLES = $iterDetect(function(iter) {
                                        new C(iter)
                                    }),
                                    BUGGY_ZERO = !IS_WEAK && fails(function() {
                                        var $instance = new C,
                                            index = 5;
                                        while (index--) $instance[ADDER](index, index);
                                        return !$instance.has(-0)
                                    });
                                if (!ACCEPT_ITERABLES) {
                                    C = wrapper(function(target, iterable) {
                                        anInstance(target, C, NAME);
                                        var that = inheritIfRequired(new Base, target, C);
                                        if (iterable != void 0) forOf(iterable, IS_MAP, that[ADDER], that);
                                        return that
                                    });
                                    C.prototype = proto;
                                    proto.constructor = C
                                }
                                if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
                                    fixMethod("delete");
                                    fixMethod("has");
                                    IS_MAP && fixMethod("get")
                                }
                                if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);
                                if (IS_WEAK && proto.clear) delete proto.clear
                            }
                            setToStringTag(C, NAME);
                            O[NAME] = C;
                            $export($export.G + $export.W + $export.F * (C != Base), O);
                            if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);
                            return C
                        }
                    }, {
                        "./_an-instance": 54,
                        "./_export": 81,
                        "./_fails": 83,
                        "./_for-of": 87,
                        "./_global": 88,
                        "./_inherit-if-required": 93,
                        "./_is-object": 99,
                        "./_iter-detect": 104,
                        "./_meta": 113,
                        "./_redefine": 139,
                        "./_redefine-all": 138,
                        "./_set-to-string-tag": 146
                    }],
                    71: [function(require, module) {
                        var core = module.exports = {
                            version: "2.5.3"
                        };
                        if ("number" == typeof __e) __e = core
                    }, {}],
                    72: [function(require, module) {
                        "use strict";
                        var $defineProperty = require("./_object-dp"),
                            createDesc = require("./_property-desc");
                        module.exports = function(object, index, value) {
                            if (index in object) $defineProperty.f(object, index, createDesc(0, value));
                            else object[index] = value
                        }
                    }, {
                        "./_object-dp": 119,
                        "./_property-desc": 137
                    }],
                    73: [function(require, module) {
                        var aFunction = require("./_a-function");
                        module.exports = function(fn, that, length) {
                            aFunction(fn);
                            if (that === void 0) return fn;
                            switch (length) {
                                case 1:
                                    return function(a) {
                                        return fn.call(that, a)
                                    };
                                case 2:
                                    return function(a, b) {
                                        return fn.call(that, a, b)
                                    };
                                case 3:
                                    return function(a, b, c) {
                                        return fn.call(that, a, b, c)
                                    };
                            }
                            return function() {
                                return fn.apply(that, arguments)
                            }
                        }
                    }, {
                        "./_a-function": 51
                    }],
                    74: [function(require, module) {
                        "use strict";
                        var fails = require("./_fails"),
                            getTime = Date.prototype.getTime,
                            $toISOString = Date.prototype.toISOString,
                            lz = function(num) {
                                return 9 < num ? num : "0" + num
                            };
                        module.exports = fails(function() {
                            return "0385-07-25T07:06:39.999Z" != $toISOString.call(new Date(-5e13 - 1))
                        }) || !fails(function() {
                            $toISOString.call(new Date(NaN))
                        }) ? function() {
                            if (!isFinite(getTime.call(this))) throw RangeError("Invalid time value");
                            var d = this,
                                y = d.getUTCFullYear(),
                                m = d.getUTCMilliseconds(),
                                s = 0 > y ? "-" : 9999 < y ? "+" : "";
                            return s + ("00000" + _Mathabs(y)).slice(s ? -6 : -4) + "-" + lz(d.getUTCMonth() + 1) + "-" + lz(d.getUTCDate()) + "T" + lz(d.getUTCHours()) + ":" + lz(d.getUTCMinutes()) + ":" + lz(d.getUTCSeconds()) + "." + (99 < m ? m : "0" + lz(m)) + "Z"
                        } : $toISOString
                    }, {
                        "./_fails": 83
                    }],
                    75: [function(require, module) {
                        "use strict";
                        var anObject = require("./_an-object"),
                            toPrimitive = require("./_to-primitive"),
                            NUMBER = "number";
                        module.exports = function(hint) {
                            if ("string" !== hint && hint !== NUMBER && "default" !== hint) throw TypeError("Incorrect hint");
                            return toPrimitive(anObject(this), hint != NUMBER)
                        }
                    }, {
                        "./_an-object": 55,
                        "./_to-primitive": 165
                    }],
                    76: [function(require, module) {
                        module.exports = function(it) {
                            if (it == void 0) throw TypeError("Can't call method on  " + it);
                            return it
                        }
                    }, {}],
                    77: [function(require, module) {
                        module.exports = !require("./_fails")(function() {
                            return 7 != Object.defineProperty({}, "a", {
                                get: function() {
                                    return 7
                                }
                            }).a
                        })
                    }, {
                        "./_fails": 83
                    }],
                    78: [function(require, module) {
                        var isObject = require("./_is-object"),
                            document = require("./_global").document,
                            is = isObject(document) && isObject(document.createElement);
                        module.exports = function(it) {
                            return is ? document.createElement(it) : {}
                        }
                    }, {
                        "./_global": 88,
                        "./_is-object": 99
                    }],
                    79: [function(require, module) {
                        module.exports = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")
                    }, {}],
                    80: [function(require, module) {
                        var getKeys = require("./_object-keys"),
                            gOPS = require("./_object-gops"),
                            pIE = require("./_object-pie");
                        module.exports = function(it) {
                            var result = getKeys(it),
                                getSymbols = gOPS.f;
                            if (getSymbols) {
                                var symbols = getSymbols(it),
                                    isEnum = pIE.f,
                                    i = 0,
                                    key;
                                while (symbols.length > i)
                                    if (isEnum.call(it, key = symbols[i++])) result.push(key)
                            }
                            return result
                        }
                    }, {
                        "./_object-gops": 125,
                        "./_object-keys": 128,
                        "./_object-pie": 129
                    }],
                    81: [function(require, module) {
                        var global = require("./_global"),
                            core = require("./_core"),
                            hide = require("./_hide"),
                            redefine = require("./_redefine"),
                            ctx = require("./_ctx"),
                            PROTOTYPE = "prototype",
                            $export = function(type, name, source) {
                                var IS_FORCED = type & $export.F,
                                    IS_GLOBAL = type & $export.G,
                                    IS_STATIC = type & $export.S,
                                    IS_PROTO = type & $export.P,
                                    IS_BIND = type & $export.B,
                                    target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE],
                                    exports = IS_GLOBAL ? core : core[name] || (core[name] = {}),
                                    expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {}),
                                    key, own, out, exp;
                                if (IS_GLOBAL) source = name;
                                for (key in source) {
                                    own = !IS_FORCED && target && target[key] !== void 0;
                                    out = (own ? target : source)[key];
                                    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && "function" == typeof out ? ctx(Function.call, out) : out;
                                    if (target) redefine(target, key, out, type & $export.U);
                                    if (exports[key] != out) hide(exports, key, exp);
                                    if (IS_PROTO && expProto[key] != out) expProto[key] = out
                                }
                            };
                        global.core = core;
                        $export.F = 1;
                        $export.G = 2;
                        $export.S = 4;
                        $export.P = 8;
                        $export.B = 16;
                        $export.W = 32;
                        $export.U = 64;
                        $export.R = 128;
                        module.exports = $export
                    }, {
                        "./_core": 71,
                        "./_ctx": 73,
                        "./_global": 88,
                        "./_hide": 90,
                        "./_redefine": 139
                    }],
                    82: [function(require, module) {
                        var MATCH = require("./_wks")("match");
                        module.exports = function(KEY) {
                            var re = /./;
                            try {
                                "/./" [KEY](re)
                            } catch (e) {
                                try {
                                    re[MATCH] = !1;
                                    return !"/./" [KEY](re)
                                } catch (f) {}
                            }
                            return !0
                        }
                    }, {
                        "./_wks": 174
                    }],
                    83: [function(require, module) {
                        module.exports = function(exec) {
                            try {
                                return !!exec()
                            } catch (e) {
                                return !0
                            }
                        }
                    }, {}],
                    84: [function(require, module) {
                        "use strict";
                        var hide = require("./_hide"),
                            redefine = require("./_redefine"),
                            fails = require("./_fails"),
                            defined = require("./_defined"),
                            wks = require("./_wks");
                        module.exports = function(KEY, length, exec) {
                            var SYMBOL = wks(KEY),
                                fns = exec(defined, SYMBOL, "" [KEY]),
                                strfn = fns[0],
                                rxfn = fns[1];
                            if (fails(function() {
                                    var O = {};
                                    O[SYMBOL] = function() {
                                        return 7
                                    };
                                    return 7 != "" [KEY](O)
                                })) {
                                redefine(String.prototype, KEY, strfn);
                                hide(RegExp.prototype, SYMBOL, 2 == length ? function(string, arg) {
                                    return rxfn.call(string, this, arg)
                                } : function(string) {
                                    return rxfn.call(string, this)
                                })
                            }
                        }
                    }, {
                        "./_defined": 76,
                        "./_fails": 83,
                        "./_hide": 90,
                        "./_redefine": 139,
                        "./_wks": 174
                    }],
                    85: [function(require, module) {
                        "use strict";
                        var anObject = require("./_an-object");
                        module.exports = function() {
                            var that = anObject(this),
                                result = "";
                            if (that.global) result += "g";
                            if (that.ignoreCase) result += "i";
                            if (that.multiline) result += "m";
                            if (that.unicode) result += "u";
                            if (that.sticky) result += "y";
                            return result
                        }
                    }, {
                        "./_an-object": 55
                    }],
                    86: [function(require, module) {
                        "use strict";
                        var isArray = require("./_is-array"),
                            isObject = require("./_is-object"),
                            toLength = require("./_to-length"),
                            ctx = require("./_ctx"),
                            IS_CONCAT_SPREADABLE = require("./_wks")("isConcatSpreadable");

                        function flattenIntoArray(target, original, source, sourceLen, start, depth, mapper, thisArg) {
                            var targetIndex = start,
                                sourceIndex = 0,
                                mapFn = mapper ? ctx(mapper, thisArg, 3) : !1,
                                element, spreadable;
                            while (sourceIndex < sourceLen) {
                                if (sourceIndex in source) {
                                    element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];
                                    spreadable = !1;
                                    if (isObject(element)) {
                                        spreadable = element[IS_CONCAT_SPREADABLE];
                                        spreadable = spreadable !== void 0 ? !!spreadable : isArray(element)
                                    }
                                    if (spreadable && 0 < depth) {
                                        targetIndex = flattenIntoArray(target, original, element, toLength(element.length), targetIndex, depth - 1) - 1
                                    } else {
                                        if (9007199254740991 <= targetIndex) throw TypeError();
                                        target[targetIndex] = element
                                    }
                                    targetIndex++
                                }
                                sourceIndex++
                            }
                            return targetIndex
                        }
                        module.exports = flattenIntoArray
                    }, {
                        "./_ctx": 73,
                        "./_is-array": 97,
                        "./_is-object": 99,
                        "./_to-length": 163,
                        "./_wks": 174
                    }],
                    87: [function(require, module, exports) {
                        var ctx = require("./_ctx"),
                            call = require("./_iter-call"),
                            isArrayIter = require("./_is-array-iter"),
                            anObject = require("./_an-object"),
                            toLength = require("./_to-length"),
                            getIterFn = require("./core.get-iterator-method"),
                            BREAK = {},
                            RETURN = {},
                            exports = module.exports = function(iterable, entries, fn, that, ITERATOR) {
                                var iterFn = ITERATOR ? function() {
                                        return iterable
                                    } : getIterFn(iterable),
                                    f = ctx(fn, that, entries ? 2 : 1),
                                    index = 0,
                                    length, step, iterator, result;
                                if ("function" != typeof iterFn) throw TypeError(iterable + " is not iterable!");
                                if (isArrayIter(iterFn))
                                    for (length = toLength(iterable.length); length > index; index++) {
                                        result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
                                        if (result === BREAK || result === RETURN) return result
                                    } else
                                        for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
                                            result = call(iterator, f, step.value, entries);
                                            if (result === BREAK || result === RETURN) return result
                                        }
                            };
                        exports.BREAK = BREAK;
                        exports.RETURN = RETURN
                    }, {
                        "./_an-object": 55,
                        "./_ctx": 73,
                        "./_is-array-iter": 96,
                        "./_iter-call": 101,
                        "./_to-length": 163,
                        "./core.get-iterator-method": 175
                    }],
                    88: [function(require, module) {
                        var global = module.exports = "undefined" != typeof window && window.Math == Math ? window : "undefined" != typeof self && self.Math == Math ? self : Function("return this")();
                        if ("number" == typeof __g) __g = global
                    }, {}],
                    89: [function(require, module) {
                        var hasOwnProperty = {}.hasOwnProperty;
                        module.exports = function(it, key) {
                            return hasOwnProperty.call(it, key)
                        }
                    }, {}],
                    90: [function(require, module) {
                        var dP = require("./_object-dp"),
                            createDesc = require("./_property-desc");
                        module.exports = require("./_descriptors") ? function(object, key, value) {
                            return dP.f(object, key, createDesc(1, value))
                        } : function(object, key, value) {
                            object[key] = value;
                            return object
                        }
                    }, {
                        "./_descriptors": 77,
                        "./_object-dp": 119,
                        "./_property-desc": 137
                    }],
                    91: [function(require, module) {
                        var document = require("./_global").document;
                        module.exports = document && document.documentElement
                    }, {
                        "./_global": 88
                    }],
                    92: [function(require, module) {
                        module.exports = !require("./_descriptors") && !require("./_fails")(function() {
                            return 7 != Object.defineProperty(require("./_dom-create")("div"), "a", {
                                get: function() {
                                    return 7
                                }
                            }).a
                        })
                    }, {
                        "./_descriptors": 77,
                        "./_dom-create": 78,
                        "./_fails": 83
                    }],
                    93: [function(require, module) {
                        var isObject = require("./_is-object"),
                            setPrototypeOf = require("./_set-proto").set;
                        module.exports = function(that, target, C) {
                            var S = target.constructor,
                                P;
                            if (S !== C && "function" == typeof S && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf) {
                                setPrototypeOf(that, P)
                            }
                            return that
                        }
                    }, {
                        "./_is-object": 99,
                        "./_set-proto": 144
                    }],
                    94: [function(require, module) {
                        module.exports = function(fn, args, that) {
                            var un = that === void 0;
                            switch (args.length) {
                                case 0:
                                    return un ? fn() : fn.call(that);
                                case 1:
                                    return un ? fn(args[0]) : fn.call(that, args[0]);
                                case 2:
                                    return un ? fn(args[0], args[1]) : fn.call(that, args[0], args[1]);
                                case 3:
                                    return un ? fn(args[0], args[1], args[2]) : fn.call(that, args[0], args[1], args[2]);
                                case 4:
                                    return un ? fn(args[0], args[1], args[2], args[3]) : fn.call(that, args[0], args[1], args[2], args[3]);
                            }
                            return fn.apply(that, args)
                        }
                    }, {}],
                    95: [function(require, module) {
                        var cof = require("./_cof");
                        module.exports = Object("z").propertyIsEnumerable(0) ? Object : function(it) {
                            return "String" == cof(it) ? it.split("") : Object(it)
                        }
                    }, {
                        "./_cof": 66
                    }],
                    96: [function(require, module) {
                        var Iterators = require("./_iterators"),
                            ITERATOR = require("./_wks")("iterator"),
                            ArrayProto = Array.prototype;
                        module.exports = function(it) {
                            return it !== void 0 && (Iterators.Array === it || ArrayProto[ITERATOR] === it)
                        }
                    }, {
                        "./_iterators": 106,
                        "./_wks": 174
                    }],
                    97: [function(require, module) {
                        var cof = require("./_cof");
                        module.exports = Array.isArray || function(arg) {
                            return "Array" == cof(arg)
                        }
                    }, {
                        "./_cof": 66
                    }],
                    98: [function(require, module) {
                        var isObject = require("./_is-object");
                        module.exports = function(it) {
                            return !isObject(it) && isFinite(it) && _Mathfloor(it) === it
                        }
                    }, {
                        "./_is-object": 99
                    }],
                    99: [function(require, module) {
                        module.exports = function(it) {
                            return "object" === typeof it ? null !== it : "function" === typeof it
                        }
                    }, {}],
                    100: [function(require, module) {
                        var isObject = require("./_is-object"),
                            cof = require("./_cof"),
                            MATCH = require("./_wks")("match");
                        module.exports = function(it) {
                            var isRegExp;
                            return isObject(it) && ((isRegExp = it[MATCH]) !== void 0 ? !!isRegExp : "RegExp" == cof(it))
                        }
                    }, {
                        "./_cof": 66,
                        "./_is-object": 99,
                        "./_wks": 174
                    }],
                    101: [function(require, module) {
                        var anObject = require("./_an-object");
                        module.exports = function(iterator, fn, value, entries) {
                            try {
                                return entries ? fn(anObject(value)[0], value[1]) : fn(value)
                            } catch (e) {
                                var ret = iterator["return"];
                                if (ret !== void 0) anObject(ret.call(iterator));
                                throw e
                            }
                        }
                    }, {
                        "./_an-object": 55
                    }],
                    102: [function(require, module) {
                        "use strict";
                        var create = require("./_object-create"),
                            descriptor = require("./_property-desc"),
                            setToStringTag = require("./_set-to-string-tag"),
                            IteratorPrototype = {};
                        require("./_hide")(IteratorPrototype, require("./_wks")("iterator"), function() {
                            return this
                        });
                        module.exports = function(Constructor, NAME, next) {
                            Constructor.prototype = create(IteratorPrototype, {
                                next: descriptor(1, next)
                            });
                            setToStringTag(Constructor, NAME + " Iterator")
                        }
                    }, {
                        "./_hide": 90,
                        "./_object-create": 118,
                        "./_property-desc": 137,
                        "./_set-to-string-tag": 146,
                        "./_wks": 174
                    }],
                    103: [function(require, module) {
                        "use strict";
                        var LIBRARY = require("./_library"),
                            $export = require("./_export"),
                            redefine = require("./_redefine"),
                            hide = require("./_hide"),
                            has = require("./_has"),
                            Iterators = require("./_iterators"),
                            $iterCreate = require("./_iter-create"),
                            setToStringTag = require("./_set-to-string-tag"),
                            getPrototypeOf = require("./_object-gpo"),
                            ITERATOR = require("./_wks")("iterator"),
                            BUGGY = !([].keys && "next" in [].keys()),
                            KEYS = "keys",
                            VALUES = "values",
                            returnThis = function() {
                                return this
                            };
                        module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
                            $iterCreate(Constructor, NAME, next);
                            var getMethod = function(kind) {
                                    if (!BUGGY && kind in proto) return proto[kind];
                                    switch (kind) {
                                        case KEYS:
                                            return function() {
                                                return new Constructor(this, kind)
                                            };
                                        case VALUES:
                                            return function() {
                                                return new Constructor(this, kind)
                                            };
                                    }
                                    return function() {
                                        return new Constructor(this, kind)
                                    }
                                },
                                TAG = NAME + " Iterator",
                                DEF_VALUES = DEFAULT == VALUES,
                                VALUES_BUG = !1,
                                proto = Base.prototype,
                                $native = proto[ITERATOR] || proto["@@iterator"] || DEFAULT && proto[DEFAULT],
                                $default = !BUGGY && $native || getMethod(DEFAULT),
                                $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod("entries") : void 0,
                                $anyNative = "Array" == NAME ? proto.entries || $native : $native,
                                methods, key, IteratorPrototype;
                            if ($anyNative) {
                                IteratorPrototype = getPrototypeOf($anyNative.call(new Base));
                                if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
                                    setToStringTag(IteratorPrototype, TAG, !0);
                                    if (!LIBRARY && !has(IteratorPrototype, ITERATOR)) hide(IteratorPrototype, ITERATOR, returnThis)
                                }
                            }
                            if (DEF_VALUES && $native && $native.name !== VALUES) {
                                VALUES_BUG = !0;
                                $default = function() {
                                    return $native.call(this)
                                }
                            }
                            if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
                                hide(proto, ITERATOR, $default)
                            }
                            Iterators[NAME] = $default;
                            Iterators[TAG] = returnThis;
                            if (DEFAULT) {
                                methods = {
                                    values: DEF_VALUES ? $default : getMethod(VALUES),
                                    keys: IS_SET ? $default : getMethod(KEYS),
                                    entries: $entries
                                };
                                if (FORCED)
                                    for (key in methods) {
                                        if (!(key in proto)) redefine(proto, key, methods[key])
                                    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods)
                            }
                            return methods
                        }
                    }, {
                        "./_export": 81,
                        "./_has": 89,
                        "./_hide": 90,
                        "./_iter-create": 102,
                        "./_iterators": 106,
                        "./_library": 107,
                        "./_object-gpo": 126,
                        "./_redefine": 139,
                        "./_set-to-string-tag": 146,
                        "./_wks": 174
                    }],
                    104: [function(require, module) {
                        var ITERATOR = require("./_wks")("iterator"),
                            SAFE_CLOSING = !1;
                        try {
                            var riter = [7][ITERATOR]();
                            riter["return"] = function() {
                                SAFE_CLOSING = !0
                            };
                            Array.from(riter, function() {
                                throw 2
                            })
                        } catch (e) {}
                        module.exports = function(exec, skipClosing) {
                            if (!skipClosing && !SAFE_CLOSING) return !1;
                            var safe = !1;
                            try {
                                var arr = [7],
                                    iter = arr[ITERATOR]();
                                iter.next = function() {
                                    return {
                                        done: safe = !0
                                    }
                                };
                                arr[ITERATOR] = function() {
                                    return iter
                                };
                                exec(arr)
                            } catch (e) {}
                            return safe
                        }
                    }, {
                        "./_wks": 174
                    }],
                    105: [function(require, module) {
                        module.exports = function(done, value) {
                            return {
                                value: value,
                                done: !!done
                            }
                        }
                    }, {}],
                    106: [function(require, module) {
                        module.exports = {}
                    }, {}],
                    107: [function(require, module) {
                        module.exports = !1
                    }, {}],
                    108: [function(require, module) {
                        var $expm1 = _Mathexpm;
                        module.exports = !$expm1 || 22025.465794806718 < $expm1(10) || 22025.465794806718 > $expm1(10) || -2e-17 != $expm1(-2e-17) ? function(x) {
                            return 0 == (x = +x) ? x : -1e-6 < x && 1e-6 > x ? x + x * x / 2 : _Mathexp(x) - 1
                        } : $expm1
                    }, {}],
                    109: [function(require, module) {
                        var sign = require("./_math-sign"),
                            pow = _Mathpow,
                            EPSILON = pow(2, -52),
                            EPSILON32 = pow(2, -23),
                            MAX32 = pow(2, 127) * (2 - EPSILON32),
                            MIN32 = pow(2, -126),
                            roundTiesToEven = function(n) {
                                return n + 1 / EPSILON - 1 / EPSILON
                            };
                        module.exports = Math.fround || function(x) {
                            var $abs = _Mathabs(x),
                                $sign = sign(x),
                                a, result;
                            if ($abs < MIN32) return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
                            a = (1 + EPSILON32 / EPSILON) * $abs;
                            result = a - (a - $abs);
                            if (result > MAX32 || result != result) return $sign * (1 / 0);
                            return $sign * result
                        }
                    }, {
                        "./_math-sign": 112
                    }],
                    110: [function(require, module) {
                        module.exports = Math.log1p || function(x) {
                            return -1e-8 < (x = +x) && 1e-8 > x ? x - x * x / 2 : _Mathlog(1 + x)
                        }
                    }, {}],
                    111: [function(require, module) {
                        module.exports = Math.scale || function(x, inLow, inHigh, outLow, outHigh) {
                            if (0 === arguments.length || x != x || inLow != inLow || inHigh != inHigh || outLow != outLow || outHigh != outHigh) return NaN;
                            if (x === 1 / 0 || x === -Infinity) return x;
                            return (x - inLow) * (outHigh - outLow) / (inHigh - inLow) + outLow
                        }
                    }, {}],
                    112: [function(require, module) {
                        module.exports = Math.sign || function(x) {
                            return 0 == (x = +x) || x != x ? x : 0 > x ? -1 : 1
                        }
                    }, {}],
                    113: [function(require, module) {
                        var META = require("./_uid")("meta"),
                            isObject = require("./_is-object"),
                            has = require("./_has"),
                            setDesc = require("./_object-dp").f,
                            id = 0,
                            isExtensible = Object.isExtensible || function() {
                                return !0
                            },
                            FREEZE = !require("./_fails")(function() {
                                return isExtensible(Object.preventExtensions({}))
                            }),
                            setMeta = function(it) {
                                setDesc(it, META, {
                                    value: {
                                        i: "O" + ++id,
                                        w: {}
                                    }
                                })
                            },
                            meta = module.exports = {
                                KEY: META,
                                NEED: !1,
                                fastKey: function(it, create) {
                                    if (!isObject(it)) return "symbol" == typeof it ? it : ("string" == typeof it ? "S" : "P") + it;
                                    if (!has(it, META)) {
                                        if (!isExtensible(it)) return "F";
                                        if (!create) return "E";
                                        setMeta(it)
                                    }
                                    return it[META].i
                                },
                                getWeak: function(it, create) {
                                    if (!has(it, META)) {
                                        if (!isExtensible(it)) return !0;
                                        if (!create) return !1;
                                        setMeta(it)
                                    }
                                    return it[META].w
                                },
                                onFreeze: function(it) {
                                    if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
                                    return it
                                }
                            }
                    }, {
                        "./_fails": 83,
                        "./_has": 89,
                        "./_is-object": 99,
                        "./_object-dp": 119,
                        "./_uid": 169
                    }],
                    114: [function(require, module) {
                        var Map = require("./es6.map"),
                            $export = require("./_export"),
                            shared = require("./_shared")("metadata"),
                            store = shared.store || (shared.store = new(require("./es6.weak-map"))),
                            getOrCreateMetadataMap = function(target, targetKey, create) {
                                var targetMetadata = store.get(target);
                                if (!targetMetadata) {
                                    if (!create) return;
                                    store.set(target, targetMetadata = new Map)
                                }
                                var keyMetadata = targetMetadata.get(targetKey);
                                if (!keyMetadata) {
                                    if (!create) return;
                                    targetMetadata.set(targetKey, keyMetadata = new Map)
                                }
                                return keyMetadata
                            };
                        module.exports = {
                            store: store,
                            map: getOrCreateMetadataMap,
                            has: function(MetadataKey, O, P) {
                                var metadataMap = getOrCreateMetadataMap(O, P, !1);
                                return metadataMap === void 0 ? !1 : metadataMap.has(MetadataKey)
                            },
                            get: function(MetadataKey, O, P) {
                                var metadataMap = getOrCreateMetadataMap(O, P, !1);
                                return metadataMap === void 0 ? void 0 : metadataMap.get(MetadataKey)
                            },
                            set: function(MetadataKey, MetadataValue, O, P) {
                                getOrCreateMetadataMap(O, P, !0).set(MetadataKey, MetadataValue)
                            },
                            keys: function(target, targetKey) {
                                var metadataMap = getOrCreateMetadataMap(target, targetKey, !1),
                                    keys = [];
                                if (metadataMap) metadataMap.forEach(function(_, key) {
                                    keys.push(key)
                                });
                                return keys
                            },
                            key: function(it) {
                                return it === void 0 || "symbol" == typeof it ? it : it + ""
                            },
                            exp: function(O) {
                                $export($export.S, "Reflect", O)
                            }
                        }
                    }, {
                        "./_export": 81,
                        "./_shared": 148,
                        "./es6.map": 206,
                        "./es6.weak-map": 312
                    }],
                    115: [function(require, module) {
                        var global = require("./_global"),
                            macrotask = require("./_task").set,
                            Observer = global.MutationObserver || global.WebKitMutationObserver,
                            process = global.process,
                            Promise = global.Promise,
                            isNode = "process" == require("./_cof")(process);
                        module.exports = function() {
                            var head, last, notify, flush = function() {
                                var parent, fn;
                                if (isNode && (parent = process.domain)) parent.exit();
                                while (head) {
                                    fn = head.fn;
                                    head = head.next;
                                    try {
                                        fn()
                                    } catch (e) {
                                        if (head) notify();
                                        else last = void 0;
                                        throw e
                                    }
                                }
                                last = void 0;
                                if (parent) parent.enter()
                            };
                            if (isNode) {
                                notify = function() {
                                    process.nextTick(flush)
                                }
                            } else if (Observer && !(global.navigator && global.navigator.standalone)) {
                                var toggle = !0,
                                    node = document.createTextNode("");
                                new Observer(flush).observe(node, {
                                    characterData: !0
                                });
                                notify = function() {
                                    node.data = toggle = !toggle
                                }
                            } else if (Promise && Promise.resolve) {
                                var promise = Promise.resolve();
                                notify = function() {
                                    promise.then(flush)
                                }
                            } else {
                                notify = function() {
                                    macrotask.call(global, flush)
                                }
                            }
                            return function(fn) {
                                var task = {
                                    fn: fn,
                                    next: void 0
                                };
                                if (last) last.next = task;
                                if (!head) {
                                    head = task;
                                    notify()
                                }
                                last = task
                            }
                        }
                    }, {
                        "./_cof": 66,
                        "./_global": 88,
                        "./_task": 158
                    }],
                    116: [function(require, module) {
                        "use strict";
                        var aFunction = require("./_a-function");

                        function PromiseCapability(C) {
                            var resolve, reject;
                            this.promise = new C(function($$resolve, $$reject) {
                                if (resolve !== void 0 || reject !== void 0) throw TypeError("Bad Promise constructor");
                                resolve = $$resolve;
                                reject = $$reject
                            });
                            this.resolve = aFunction(resolve);
                            this.reject = aFunction(reject)
                        }
                        module.exports.f = function(C) {
                            return new PromiseCapability(C)
                        }
                    }, {
                        "./_a-function": 51
                    }],
                    117: [function(require, module) {
                        "use strict";
                        var getKeys = require("./_object-keys"),
                            gOPS = require("./_object-gops"),
                            pIE = require("./_object-pie"),
                            toObject = require("./_to-object"),
                            IObject = require("./_iobject"),
                            $assign = Object.assign;
                        module.exports = !$assign || require("./_fails")(function() {
                            var A = {},
                                B = {},
                                S = Symbol(),
                                K = "abcdefghijklmnopqrst";
                            A[S] = 7;
                            K.split("").forEach(function(k) {
                                B[k] = k
                            });
                            return 7 != $assign({}, A)[S] || Object.keys($assign({}, B)).join("") != K
                        }) ? function(target) {
                            var T = toObject(target),
                                aLen = arguments.length,
                                index = 1,
                                getSymbols = gOPS.f,
                                isEnum = pIE.f;
                            while (aLen > index) {
                                var S = IObject(arguments[index++]),
                                    keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S),
                                    length = keys.length,
                                    j = 0,
                                    key;
                                while (length > j)
                                    if (isEnum.call(S, key = keys[j++])) T[key] = S[key]
                            }
                            return T
                        } : $assign
                    }, {
                        "./_fails": 83,
                        "./_iobject": 95,
                        "./_object-gops": 125,
                        "./_object-keys": 128,
                        "./_object-pie": 129,
                        "./_to-object": 164
                    }],
                    118: [function(require, module) {
                        var anObject = require("./_an-object"),
                            dPs = require("./_object-dps"),
                            enumBugKeys = require("./_enum-bug-keys"),
                            IE_PROTO = require("./_shared-key")("IE_PROTO"),
                            Empty = function() {},
                            PROTOTYPE = "prototype",
                            createDict = function() {
                                var iframe = require("./_dom-create")("iframe"),
                                    i = enumBugKeys.length,
                                    lt = "<",
                                    gt = ">",
                                    iframeDocument;
                                iframe.style.display = "none";
                                require("./_html").appendChild(iframe);
                                iframe.src = "javascript:";
                                iframeDocument = iframe.contentWindow.document;
                                iframeDocument.open();
                                iframeDocument.write(lt + "script" + gt + "document.F=Object" + lt + "/script" + gt);
                                iframeDocument.close();
                                createDict = iframeDocument.F;
                                while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
                                return createDict()
                            };
                        module.exports = Object.create || function(O, Properties) {
                            var result;
                            if (null !== O) {
                                Empty[PROTOTYPE] = anObject(O);
                                result = new Empty;
                                Empty[PROTOTYPE] = null;
                                result[IE_PROTO] = O
                            } else result = createDict();
                            return Properties === void 0 ? result : dPs(result, Properties)
                        }
                    }, {
                        "./_an-object": 55,
                        "./_dom-create": 78,
                        "./_enum-bug-keys": 79,
                        "./_html": 91,
                        "./_object-dps": 120,
                        "./_shared-key": 147
                    }],
                    119: [function(require, module, exports) {
                        var anObject = require("./_an-object"),
                            IE8_DOM_DEFINE = require("./_ie8-dom-define"),
                            toPrimitive = require("./_to-primitive"),
                            dP = Object.defineProperty;
                        exports.f = require("./_descriptors") ? Object.defineProperty : function(O, P, Attributes) {
                            anObject(O);
                            P = toPrimitive(P, !0);
                            anObject(Attributes);
                            if (IE8_DOM_DEFINE) try {
                                return dP(O, P, Attributes)
                            } catch (e) {}
                            if ("get" in Attributes || "set" in Attributes) throw TypeError("Accessors not supported!");
                            if ("value" in Attributes) O[P] = Attributes.value;
                            return O
                        }
                    }, {
                        "./_an-object": 55,
                        "./_descriptors": 77,
                        "./_ie8-dom-define": 92,
                        "./_to-primitive": 165
                    }],
                    120: [function(require, module) {
                        var dP = require("./_object-dp"),
                            anObject = require("./_an-object"),
                            getKeys = require("./_object-keys");
                        module.exports = require("./_descriptors") ? Object.defineProperties : function(O, Properties) {
                            anObject(O);
                            var keys = getKeys(Properties),
                                length = keys.length,
                                i = 0,
                                P;
                            while (length > i) dP.f(O, P = keys[i++], Properties[P]);
                            return O
                        }
                    }, {
                        "./_an-object": 55,
                        "./_descriptors": 77,
                        "./_object-dp": 119,
                        "./_object-keys": 128
                    }],
                    121: [function(require, module) {
                        "use strict";
                        module.exports = require("./_library") || !require("./_fails")(function() {
                            var K = Math.random();
                            __defineSetter__.call(null, K, function() {});
                            delete require("./_global")[K]
                        })
                    }, {
                        "./_fails": 83,
                        "./_global": 88,
                        "./_library": 107
                    }],
                    122: [function(require, module, exports) {
                        var pIE = require("./_object-pie"),
                            createDesc = require("./_property-desc"),
                            toIObject = require("./_to-iobject"),
                            toPrimitive = require("./_to-primitive"),
                            has = require("./_has"),
                            IE8_DOM_DEFINE = require("./_ie8-dom-define"),
                            gOPD = Object.getOwnPropertyDescriptor;
                        exports.f = require("./_descriptors") ? gOPD : function(O, P) {
                            O = toIObject(O);
                            P = toPrimitive(P, !0);
                            if (IE8_DOM_DEFINE) try {
                                return gOPD(O, P)
                            } catch (e) {}
                            if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P])
                        }
                    }, {
                        "./_descriptors": 77,
                        "./_has": 89,
                        "./_ie8-dom-define": 92,
                        "./_object-pie": 129,
                        "./_property-desc": 137,
                        "./_to-iobject": 162,
                        "./_to-primitive": 165
                    }],
                    123: [function(require, module) {
                        var toIObject = require("./_to-iobject"),
                            gOPN = require("./_object-gopn").f,
                            toString = {}.toString,
                            windowNames = "object" == typeof window && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [],
                            getWindowNames = function(it) {
                                try {
                                    return gOPN(it)
                                } catch (e) {
                                    return windowNames.slice()
                                }
                            };
                        module.exports.f = function(it) {
                            return windowNames && "[object Window]" == toString.call(it) ? getWindowNames(it) : gOPN(toIObject(it))
                        }
                    }, {
                        "./_object-gopn": 124,
                        "./_to-iobject": 162
                    }],
                    124: [function(require, module, exports) {
                        var $keys = require("./_object-keys-internal"),
                            hiddenKeys = require("./_enum-bug-keys").concat("length", "prototype");
                        exports.f = Object.getOwnPropertyNames || function(O) {
                            return $keys(O, hiddenKeys)
                        }
                    }, {
                        "./_enum-bug-keys": 79,
                        "./_object-keys-internal": 127
                    }],
                    125: [function(require, module, exports) {
                        exports.f = Object.getOwnPropertySymbols
                    }, {}],
                    126: [function(require, module) {
                        var has = require("./_has"),
                            toObject = require("./_to-object"),
                            IE_PROTO = require("./_shared-key")("IE_PROTO"),
                            ObjectProto = Object.prototype;
                        module.exports = Object.getPrototypeOf || function(O) {
                            O = toObject(O);
                            if (has(O, IE_PROTO)) return O[IE_PROTO];
                            if ("function" == typeof O.constructor && O instanceof O.constructor) {
                                return O.constructor.prototype
                            }
                            return O instanceof Object ? ObjectProto : null
                        }
                    }, {
                        "./_has": 89,
                        "./_shared-key": 147,
                        "./_to-object": 164
                    }],
                    127: [function(require, module) {
                        var has = require("./_has"),
                            toIObject = require("./_to-iobject"),
                            arrayIndexOf = require("./_array-includes")(!1),
                            IE_PROTO = require("./_shared-key")("IE_PROTO");
                        module.exports = function(object, names) {
                            var O = toIObject(object),
                                i = 0,
                                result = [],
                                key;
                            for (key in O)
                                if (key != IE_PROTO) has(O, key) && result.push(key);
                            while (names.length > i)
                                if (has(O, key = names[i++])) {
                                    ~arrayIndexOf(result, key) || result.push(key)
                                }
                            return result
                        }
                    }, {
                        "./_array-includes": 59,
                        "./_has": 89,
                        "./_shared-key": 147,
                        "./_to-iobject": 162
                    }],
                    128: [function(require, module) {
                        var $keys = require("./_object-keys-internal"),
                            enumBugKeys = require("./_enum-bug-keys");
                        module.exports = Object.keys || function(O) {
                            return $keys(O, enumBugKeys)
                        }
                    }, {
                        "./_enum-bug-keys": 79,
                        "./_object-keys-internal": 127
                    }],
                    129: [function(require, module, exports) {
                        exports.f = {}.propertyIsEnumerable
                    }, {}],
                    130: [function(require, module) {
                        var $export = require("./_export"),
                            core = require("./_core"),
                            fails = require("./_fails");
                        module.exports = function(KEY, exec) {
                            var fn = (core.Object || {})[KEY] || Object[KEY],
                                exp = {};
                            exp[KEY] = exec(fn);
                            $export($export.S + $export.F * fails(function() {
                                fn(1)
                            }), "Object", exp)
                        }
                    }, {
                        "./_core": 71,
                        "./_export": 81,
                        "./_fails": 83
                    }],
                    131: [function(require, module) {
                        var getKeys = require("./_object-keys"),
                            toIObject = require("./_to-iobject"),
                            isEnum = require("./_object-pie").f;
                        module.exports = function(isEntries) {
                            return function(it) {
                                var O = toIObject(it),
                                    keys = getKeys(O),
                                    length = keys.length,
                                    i = 0,
                                    result = [],
                                    key;
                                while (length > i)
                                    if (isEnum.call(O, key = keys[i++])) {
                                        result.push(isEntries ? [key, O[key]] : O[key])
                                    }
                                return result
                            }
                        }
                    }, {
                        "./_object-keys": 128,
                        "./_object-pie": 129,
                        "./_to-iobject": 162
                    }],
                    132: [function(require, module) {
                        var gOPN = require("./_object-gopn"),
                            gOPS = require("./_object-gops"),
                            anObject = require("./_an-object"),
                            Reflect = require("./_global").Reflect;
                        module.exports = Reflect && Reflect.ownKeys || function(it) {
                            var keys = gOPN.f(anObject(it)),
                                getSymbols = gOPS.f;
                            return getSymbols ? keys.concat(getSymbols(it)) : keys
                        }
                    }, {
                        "./_an-object": 55,
                        "./_global": 88,
                        "./_object-gopn": 124,
                        "./_object-gops": 125
                    }],
                    133: [function(require, module) {
                        var $parseFloat = require("./_global").parseFloat,
                            $trim = require("./_string-trim").trim;
                        module.exports = 1 / $parseFloat(require("./_string-ws") + "-0") !== -Infinity ? function(str) {
                            var string = $trim(str + "", 3),
                                result = $parseFloat(string);
                            return 0 === result && "-" == string.charAt(0) ? -0 : result
                        } : $parseFloat
                    }, {
                        "./_global": 88,
                        "./_string-trim": 156,
                        "./_string-ws": 157
                    }],
                    134: [function(require, module) {
                        var $parseInt = require("./_global").parseInt,
                            $trim = require("./_string-trim").trim,
                            ws = require("./_string-ws"),
                            hex = /^[-+]?0[xX]/;
                        module.exports = 8 !== $parseInt(ws + "08") || 22 !== $parseInt(ws + "0x16") ? function(str, radix) {
                            var string = $trim(str + "", 3);
                            return $parseInt(string, radix >>> 0 || (hex.test(string) ? 16 : 10))
                        } : $parseInt
                    }, {
                        "./_global": 88,
                        "./_string-trim": 156,
                        "./_string-ws": 157
                    }],
                    135: [function(require, module) {
                        module.exports = function(exec) {
                            try {
                                return {
                                    e: !1,
                                    v: exec()
                                }
                            } catch (e) {
                                return {
                                    e: !0,
                                    v: e
                                }
                            }
                        }
                    }, {}],
                    136: [function(require, module) {
                        var anObject = require("./_an-object"),
                            isObject = require("./_is-object"),
                            newPromiseCapability = require("./_new-promise-capability");
                        module.exports = function(C, x) {
                            anObject(C);
                            if (isObject(x) && x.constructor === C) return x;
                            var promiseCapability = newPromiseCapability.f(C),
                                resolve = promiseCapability.resolve;
                            resolve(x);
                            return promiseCapability.promise
                        }
                    }, {
                        "./_an-object": 55,
                        "./_is-object": 99,
                        "./_new-promise-capability": 116
                    }],
                    137: [function(require, module) {
                        module.exports = function(bitmap, value) {
                            return {
                                enumerable: !(1 & bitmap),
                                configurable: !(2 & bitmap),
                                writable: !(4 & bitmap),
                                value: value
                            }
                        }
                    }, {}],
                    138: [function(require, module) {
                        var redefine = require("./_redefine");
                        module.exports = function(target, src, safe) {
                            for (var key in src) redefine(target, key, src[key], safe);
                            return target
                        }
                    }, {
                        "./_redefine": 139
                    }],
                    139: [function(require, module) {
                        var global = require("./_global"),
                            hide = require("./_hide"),
                            has = require("./_has"),
                            SRC = require("./_uid")("src"),
                            TO_STRING = "toString",
                            $toString = Function[TO_STRING],
                            TPL = ("" + $toString).split(TO_STRING);
                        require("./_core").inspectSource = function(it) {
                            return $toString.call(it)
                        };
                        (module.exports = function(O, key, val, safe) {
                            var isFunction = "function" == typeof val;
                            if (isFunction) has(val, "name") || hide(val, "name", key);
                            if (O[key] === val) return;
                            if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? "" + O[key] : TPL.join(key + ""));
                            if (O === global) {
                                O[key] = val
                            } else if (!safe) {
                                delete O[key];
                                hide(O, key, val)
                            } else if (O[key]) {
                                O[key] = val
                            } else {
                                hide(O, key, val)
                            }
                        })(Function.prototype, TO_STRING, function() {
                            return "function" == typeof this && this[SRC] || $toString.call(this)
                        })
                    }, {
                        "./_core": 71,
                        "./_global": 88,
                        "./_has": 89,
                        "./_hide": 90,
                        "./_uid": 169
                    }],
                    140: [function(require, module) {
                        module.exports = function(regExp, replace) {
                            var replacer = replace === Object(replace) ? function(part) {
                                return replace[part]
                            } : replace;
                            return function(it) {
                                return (it + "").replace(regExp, replacer)
                            }
                        }
                    }, {}],
                    141: [function(require, module) {
                        module.exports = Object.is || function(x, y) {
                            return x === y ? 0 !== x || 1 / x === 1 / y : x != x && y != y
                        }
                    }, {}],
                    142: [function(require, module) {
                        "use strict";
                        var $export = require("./_export"),
                            aFunction = require("./_a-function"),
                            ctx = require("./_ctx"),
                            forOf = require("./_for-of");
                        module.exports = function(COLLECTION) {
                            $export($export.S, COLLECTION, {
                                from: function(source) {
                                    var mapFn = arguments[1],
                                        mapping, A, n, cb;
                                    aFunction(this);
                                    mapping = mapFn !== void 0;
                                    if (mapping) aFunction(mapFn);
                                    if (source == void 0) return new this;
                                    A = [];
                                    if (mapping) {
                                        n = 0;
                                        cb = ctx(mapFn, arguments[2], 2);
                                        forOf(source, !1, function(nextItem) {
                                            A.push(cb(nextItem, n++))
                                        })
                                    } else {
                                        forOf(source, !1, A.push, A)
                                    }
                                    return new this(A)
                                }
                            })
                        }
                    }, {
                        "./_a-function": 51,
                        "./_ctx": 73,
                        "./_export": 81,
                        "./_for-of": 87
                    }],
                    143: [function(require, module) {
                        "use strict";
                        var $export = require("./_export");
                        module.exports = function(COLLECTION) {
                            $export($export.S, COLLECTION, { of: function() {
                                    var length = arguments.length,
                                        A = Array(length);
                                    while (length--) A[length] = arguments[length];
                                    return new this(A)
                                }
                            })
                        }
                    }, {
                        "./_export": 81
                    }],
                    144: [function(require, module) {
                        var isObject = require("./_is-object"),
                            anObject = require("./_an-object"),
                            check = function(O, proto) {
                                anObject(O);
                                if (!isObject(proto) && null !== proto) throw TypeError(proto + ": can't set as prototype!")
                            };
                        module.exports = {
                            set: Object.setPrototypeOf || ("__proto__" in {} ? function(test, buggy, set) {
                                try {
                                    set = require("./_ctx")(Function.call, require("./_object-gopd").f(Object.prototype, "__proto__").set, 2);
                                    set(test, []);
                                    buggy = !(test instanceof Array)
                                } catch (e) {
                                    buggy = !0
                                }
                                return function(O, proto) {
                                    check(O, proto);
                                    if (buggy) O.__proto__ = proto;
                                    else set(O, proto);
                                    return O
                                }
                            }({}, !1) : void 0),
                            check: check
                        }
                    }, {
                        "./_an-object": 55,
                        "./_ctx": 73,
                        "./_is-object": 99,
                        "./_object-gopd": 122
                    }],
                    145: [function(require, module) {
                        "use strict";
                        var global = require("./_global"),
                            dP = require("./_object-dp"),
                            DESCRIPTORS = require("./_descriptors"),
                            SPECIES = require("./_wks")("species");
                        module.exports = function(KEY) {
                            var C = global[KEY];
                            if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
                                configurable: !0,
                                get: function() {
                                    return this
                                }
                            })
                        }
                    }, {
                        "./_descriptors": 77,
                        "./_global": 88,
                        "./_object-dp": 119,
                        "./_wks": 174
                    }],
                    146: [function(require, module) {
                        var def = require("./_object-dp").f,
                            has = require("./_has"),
                            TAG = require("./_wks")("toStringTag");
                        module.exports = function(it, tag, stat) {
                            if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, {
                                configurable: !0,
                                value: tag
                            })
                        }
                    }, {
                        "./_has": 89,
                        "./_object-dp": 119,
                        "./_wks": 174
                    }],
                    147: [function(require, module) {
                        var shared = require("./_shared")("keys"),
                            uid = require("./_uid");
                        module.exports = function(key) {
                            return shared[key] || (shared[key] = uid(key))
                        }
                    }, {
                        "./_shared": 148,
                        "./_uid": 169
                    }],
                    148: [function(require, module) {
                        var global = require("./_global"),
                            SHARED = "__core-js_shared__",
                            store = global[SHARED] || (global[SHARED] = {});
                        module.exports = function(key) {
                            return store[key] || (store[key] = {})
                        }
                    }, {
                        "./_global": 88
                    }],
                    149: [function(require, module) {
                        var anObject = require("./_an-object"),
                            aFunction = require("./_a-function"),
                            SPECIES = require("./_wks")("species");
                        module.exports = function(O, D) {
                            var C = anObject(O).constructor,
                                S;
                            return C === void 0 || (S = anObject(C)[SPECIES]) == void 0 ? D : aFunction(S)
                        }
                    }, {
                        "./_a-function": 51,
                        "./_an-object": 55,
                        "./_wks": 174
                    }],
                    150: [function(require, module) {
                        "use strict";
                        var fails = require("./_fails");
                        module.exports = function(method, arg) {
                            return !!method && fails(function() {
                                arg ? method.call(null, function() {}, 1) : method.call(null)
                            })
                        }
                    }, {
                        "./_fails": 83
                    }],
                    151: [function(require, module) {
                        var toInteger = require("./_to-integer"),
                            defined = require("./_defined");
                        module.exports = function(TO_STRING) {
                            return function(that, pos) {
                                var s = defined(that) + "",
                                    i = toInteger(pos),
                                    l = s.length,
                                    a, b;
                                if (0 > i || i >= l) return TO_STRING ? "" : void 0;
                                a = s.charCodeAt(i);
                                return 55296 > a || 56319 < a || i + 1 === l || 56320 > (b = s.charCodeAt(i + 1)) || 57343 < b ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 55296 << 10) + (b - 56320) + 65536
                            }
                        }
                    }, {
                        "./_defined": 76,
                        "./_to-integer": 161
                    }],
                    152: [function(require, module) {
                        var isRegExp = require("./_is-regexp"),
                            defined = require("./_defined");
                        module.exports = function(that, searchString, NAME) {
                            if (isRegExp(searchString)) throw TypeError("String#" + NAME + " doesn't accept regex!");
                            return defined(that) + ""
                        }
                    }, {
                        "./_defined": 76,
                        "./_is-regexp": 100
                    }],
                    153: [function(require, module) {
                        var $export = require("./_export"),
                            fails = require("./_fails"),
                            defined = require("./_defined"),
                            quot = /"/g,
                            createHTML = function(string, tag, attribute, value) {
                                var S = defined(string) + "",
                                    p1 = "<" + tag;
                                if ("" !== attribute) p1 += " " + attribute + "=\"" + (value + "").replace(quot, "&quot;") + "\"";
                                return p1 + ">" + S + "</" + tag + ">"
                            };
                        module.exports = function(NAME, exec) {
                            var O = {};
                            O[NAME] = exec(createHTML);
                            $export($export.P + $export.F * fails(function() {
                                var test = "" [NAME]("\"");
                                return test !== test.toLowerCase() || 3 < test.split("\"").length
                            }), "String", O)
                        }
                    }, {
                        "./_defined": 76,
                        "./_export": 81,
                        "./_fails": 83
                    }],
                    154: [function(require, module) {
                        var toLength = require("./_to-length"),
                            repeat = require("./_string-repeat"),
                            defined = require("./_defined");
                        module.exports = function(that, maxLength, fillString, left) {
                            var S = defined(that) + "",
                                stringLength = S.length,
                                fillStr = fillString === void 0 ? " " : fillString + "",
                                intMaxLength = toLength(maxLength);
                            if (intMaxLength <= stringLength || "" == fillStr) return S;
                            var fillLen = intMaxLength - stringLength,
                                stringFiller = repeat.call(fillStr, _Mathceil(fillLen / fillStr.length));
                            if (stringFiller.length > fillLen) stringFiller = stringFiller.slice(0, fillLen);
                            return left ? stringFiller + S : S + stringFiller
                        }
                    }, {
                        "./_defined": 76,
                        "./_string-repeat": 155,
                        "./_to-length": 163
                    }],
                    155: [function(require, module) {
                        "use strict";
                        var toInteger = require("./_to-integer"),
                            defined = require("./_defined");
                        module.exports = function(count) {
                            var str = defined(this) + "",
                                res = "",
                                n = toInteger(count);
                            if (0 > n || n == 1 / 0) throw RangeError("Count can't be negative");
                            for (; 0 < n;
                                (n >>>= 1) && (str += str))
                                if (1 & n) res += str;
                            return res
                        }
                    }, {
                        "./_defined": 76,
                        "./_to-integer": 161
                    }],
                    156: [function(require, module) {
                        var $export = require("./_export"),
                            defined = require("./_defined"),
                            fails = require("./_fails"),
                            spaces = require("./_string-ws"),
                            space = "[" + spaces + "]",
                            non = "\u200B\x85",
                            ltrim = RegExp("^" + space + space + "*"),
                            rtrim = RegExp(space + space + "*$"),
                            exporter = function(KEY, exec, ALIAS) {
                                var exp = {},
                                    FORCE = fails(function() {
                                        return !!spaces[KEY]() || non[KEY]() != non
                                    }),
                                    fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];
                                if (ALIAS) exp[ALIAS] = fn;
                                $export($export.P + $export.F * FORCE, "String", exp)
                            },
                            trim = exporter.trim = function(string, TYPE) {
                                string = defined(string) + "";
                                if (1 & TYPE) string = string.replace(ltrim, "");
                                if (2 & TYPE) string = string.replace(rtrim, "");
                                return string
                            };
                        module.exports = exporter
                    }, {
                        "./_defined": 76,
                        "./_export": 81,
                        "./_fails": 83,
                        "./_string-ws": 157
                    }],
                    157: [function(require, module) {
                        module.exports = "\t\n\x0B\f\r \xA0\u1680\u180E\u2000\u2001\u2002\u2003" + "\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF"
                    }, {}],
                    158: [function(require, module) {
                        var ctx = require("./_ctx"),
                            invoke = require("./_invoke"),
                            html = require("./_html"),
                            cel = require("./_dom-create"),
                            global = require("./_global"),
                            process = global.process,
                            setTask = global.setImmediate,
                            clearTask = global.clearImmediate,
                            MessageChannel = global.MessageChannel,
                            Dispatch = global.Dispatch,
                            counter = 0,
                            queue = {},
                            ONREADYSTATECHANGE = "onreadystatechange",
                            defer, channel, port, run = function() {
                                var id = +this;
                                if (queue.hasOwnProperty(id)) {
                                    var fn = queue[id];
                                    delete queue[id];
                                    fn()
                                }
                            },
                            listener = function(event) {
                                run.call(event.data)
                            };
                        if (!setTask || !clearTask) {
                            setTask = function(fn) {
                                var args = [],
                                    i = 1;
                                while (arguments.length > i) args.push(arguments[i++]);
                                queue[++counter] = function() {
                                    invoke("function" == typeof fn ? fn : Function(fn), args)
                                };
                                defer(counter);
                                return counter
                            };
                            clearTask = function(id) {
                                delete queue[id]
                            };
                            if ("process" == require("./_cof")(process)) {
                                defer = function(id) {
                                    process.nextTick(ctx(run, id, 1))
                                }
                            } else if (Dispatch && Dispatch.now) {
                                defer = function(id) {
                                    Dispatch.now(ctx(run, id, 1))
                                }
                            } else if (MessageChannel) {
                                channel = new MessageChannel;
                                port = channel.port2;
                                channel.port1.onmessage = listener;
                                defer = ctx(port.postMessage, port, 1)
                            } else if (global.addEventListener && "function" == typeof postMessage && !global.importScripts) {
                                defer = function(id) {
                                    global.postMessage(id + "", "*")
                                };
                                global.addEventListener("message", listener, !1)
                            } else if (ONREADYSTATECHANGE in cel("script")) {
                                defer = function(id) {
                                    html.appendChild(cel("script"))[ONREADYSTATECHANGE] = function() {
                                        html.removeChild(this);
                                        run.call(id)
                                    }
                                }
                            } else {
                                defer = function(id) {
                                    setTimeout(ctx(run, id, 1), 0)
                                }
                            }
                        }
                        module.exports = {
                            set: setTask,
                            clear: clearTask
                        }
                    }, {
                        "./_cof": 66,
                        "./_ctx": 73,
                        "./_dom-create": 78,
                        "./_global": 88,
                        "./_html": 91,
                        "./_invoke": 94
                    }],
                    159: [function(require, module) {
                        var toInteger = require("./_to-integer");
                        module.exports = function(index, length) {
                            index = toInteger(index);
                            return 0 > index ? _Mathmax(index + length, 0) : _Mathmin(index, length)
                        }
                    }, {
                        "./_to-integer": 161
                    }],
                    160: [function(require, module) {
                        var toInteger = require("./_to-integer"),
                            toLength = require("./_to-length");
                        module.exports = function(it) {
                            if (it === void 0) return 0;
                            var number = toInteger(it),
                                length = toLength(number);
                            if (number !== length) throw RangeError("Wrong length!");
                            return length
                        }
                    }, {
                        "./_to-integer": 161,
                        "./_to-length": 163
                    }],
                    161: [function(require, module) {
                        module.exports = function(it) {
                            return isNaN(it = +it) ? 0 : (0 < it ? _Mathfloor : _Mathceil)(it)
                        }
                    }, {}],
                    162: [function(require, module) {
                        var IObject = require("./_iobject"),
                            defined = require("./_defined");
                        module.exports = function(it) {
                            return IObject(defined(it))
                        }
                    }, {
                        "./_defined": 76,
                        "./_iobject": 95
                    }],
                    163: [function(require, module) {
                        var toInteger = require("./_to-integer");
                        module.exports = function(it) {
                            return 0 < it ? _Mathmin(toInteger(it), 9007199254740991) : 0
                        }
                    }, {
                        "./_to-integer": 161
                    }],
                    164: [function(require, module) {
                        var defined = require("./_defined");
                        module.exports = function(it) {
                            return Object(defined(it))
                        }
                    }, {
                        "./_defined": 76
                    }],
                    165: [function(require, module) {
                        var isObject = require("./_is-object");
                        module.exports = function(it, S) {
                            if (!isObject(it)) return it;
                            var fn, val;
                            if (S && "function" == typeof(fn = it.toString) && !isObject(val = fn.call(it))) return val;
                            if ("function" == typeof(fn = it.valueOf) && !isObject(val = fn.call(it))) return val;
                            if (!S && "function" == typeof(fn = it.toString) && !isObject(val = fn.call(it))) return val;
                            throw TypeError("Can't convert object to primitive value")
                        }
                    }, {
                        "./_is-object": 99
                    }],
                    166: [function(require, module) {
                        "use strict";
                        if (require("./_descriptors")) {
                            var LIBRARY = require("./_library"),
                                global = require("./_global"),
                                fails = require("./_fails"),
                                $export = require("./_export"),
                                $typed = require("./_typed"),
                                $buffer = require("./_typed-buffer"),
                                ctx = require("./_ctx"),
                                anInstance = require("./_an-instance"),
                                propertyDesc = require("./_property-desc"),
                                hide = require("./_hide"),
                                redefineAll = require("./_redefine-all"),
                                toInteger = require("./_to-integer"),
                                toLength = require("./_to-length"),
                                toIndex = require("./_to-index"),
                                toAbsoluteIndex = require("./_to-absolute-index"),
                                toPrimitive = require("./_to-primitive"),
                                has = require("./_has"),
                                classof = require("./_classof"),
                                isObject = require("./_is-object"),
                                toObject = require("./_to-object"),
                                isArrayIter = require("./_is-array-iter"),
                                create = require("./_object-create"),
                                getPrototypeOf = require("./_object-gpo"),
                                gOPN = require("./_object-gopn").f,
                                getIterFn = require("./core.get-iterator-method"),
                                uid = require("./_uid"),
                                wks = require("./_wks"),
                                createArrayMethod = require("./_array-methods"),
                                createArrayIncludes = require("./_array-includes"),
                                speciesConstructor = require("./_species-constructor"),
                                ArrayIterators = require("./es6.array.iterator"),
                                Iterators = require("./_iterators"),
                                $iterDetect = require("./_iter-detect"),
                                setSpecies = require("./_set-species"),
                                arrayFill = require("./_array-fill"),
                                arrayCopyWithin = require("./_array-copy-within"),
                                $DP = require("./_object-dp"),
                                $GOPD = require("./_object-gopd"),
                                dP = $DP.f,
                                gOPD = $GOPD.f,
                                RangeError = global.RangeError,
                                TypeError = global.TypeError,
                                Uint8Array = global.Uint8Array,
                                ARRAY_BUFFER = "ArrayBuffer",
                                SHARED_BUFFER = "Shared" + ARRAY_BUFFER,
                                BYTES_PER_ELEMENT = "BYTES_PER_ELEMENT",
                                PROTOTYPE = "prototype",
                                ArrayProto = Array[PROTOTYPE],
                                $ArrayBuffer = $buffer.ArrayBuffer,
                                $DataView = $buffer.DataView,
                                arrayForEach = createArrayMethod(0),
                                arrayFilter = createArrayMethod(2),
                                arraySome = createArrayMethod(3),
                                arrayEvery = createArrayMethod(4),
                                arrayFind = createArrayMethod(5),
                                arrayFindIndex = createArrayMethod(6),
                                arrayIncludes = createArrayIncludes(!0),
                                arrayIndexOf = createArrayIncludes(!1),
                                arrayValues = ArrayIterators.values,
                                arrayKeys = ArrayIterators.keys,
                                arrayEntries = ArrayIterators.entries,
                                arrayLastIndexOf = ArrayProto.lastIndexOf,
                                arrayReduce = ArrayProto.reduce,
                                arrayReduceRight = ArrayProto.reduceRight,
                                arrayJoin = ArrayProto.join,
                                arraySort = ArrayProto.sort,
                                arraySlice = ArrayProto.slice,
                                arrayToString = ArrayProto.toString,
                                arrayToLocaleString = ArrayProto.toLocaleString,
                                ITERATOR = wks("iterator"),
                                TAG = wks("toStringTag"),
                                TYPED_CONSTRUCTOR = uid("typed_constructor"),
                                DEF_CONSTRUCTOR = uid("def_constructor"),
                                ALL_CONSTRUCTORS = $typed.CONSTR,
                                TYPED_ARRAY = $typed.TYPED,
                                VIEW = $typed.VIEW,
                                WRONG_LENGTH = "Wrong length!",
                                $map = createArrayMethod(1, function(O, length) {
                                    return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length)
                                }),
                                LITTLE_ENDIAN = fails(function() {
                                    return 1 === new Uint8Array(new Uint16Array([1]).buffer)[0]
                                }),
                                FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function() {
                                    new Uint8Array(1).set({})
                                }),
                                toOffset = function(it, BYTES) {
                                    var offset = toInteger(it);
                                    if (0 > offset || offset % BYTES) throw RangeError("Wrong offset!");
                                    return offset
                                },
                                validate = function(it) {
                                    if (isObject(it) && TYPED_ARRAY in it) return it;
                                    throw TypeError(it + " is not a typed array!")
                                },
                                allocate = function(C, length) {
                                    if (!(isObject(C) && TYPED_CONSTRUCTOR in C)) {
                                        throw TypeError("It is not a typed array constructor!")
                                    }
                                    return new C(length)
                                },
                                speciesFromList = function(O, list) {
                                    return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list)
                                },
                                fromList = function(C, list) {
                                    var index = 0,
                                        length = list.length,
                                        result = allocate(C, length);
                                    while (length > index) result[index] = list[index++];
                                    return result
                                },
                                addGetter = function(it, key, internal) {
                                    dP(it, key, {
                                        get: function() {
                                            return this._d[internal]
                                        }
                                    })
                                },
                                $from = function(source) {
                                    var O = toObject(source),
                                        aLen = arguments.length,
                                        mapfn = 1 < aLen ? arguments[1] : void 0,
                                        mapping = mapfn !== void 0,
                                        iterFn = getIterFn(O),
                                        i, length, values, result, step, iterator;
                                    if (iterFn != void 0 && !isArrayIter(iterFn)) {
                                        for (iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++) {
                                            values.push(step.value)
                                        }
                                        O = values
                                    }
                                    if (mapping && 2 < aLen) mapfn = ctx(mapfn, arguments[2], 2);
                                    for (i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++) {
                                        result[i] = mapping ? mapfn(O[i], i) : O[i]
                                    }
                                    return result
                                },
                                $of = function() {
                                    var index = 0,
                                        length = arguments.length,
                                        result = allocate(this, length);
                                    while (length > index) result[index] = arguments[index++];
                                    return result
                                },
                                TO_LOCALE_BUG = !!Uint8Array && fails(function() {
                                    arrayToLocaleString.call(new Uint8Array(1))
                                }),
                                $toLocaleString = function() {
                                    return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments)
                                },
                                proto = {
                                    copyWithin: function(target, start) {
                                        return arrayCopyWithin.call(validate(this), target, start, 2 < arguments.length ? arguments[2] : void 0)
                                    },
                                    every: function(callbackfn) {
                                        return arrayEvery(validate(this), callbackfn, 1 < arguments.length ? arguments[1] : void 0)
                                    },
                                    fill: function() {
                                        return arrayFill.apply(validate(this), arguments)
                                    },
                                    filter: function(callbackfn) {
                                        return speciesFromList(this, arrayFilter(validate(this), callbackfn, 1 < arguments.length ? arguments[1] : void 0))
                                    },
                                    find: function(predicate) {
                                        return arrayFind(validate(this), predicate, 1 < arguments.length ? arguments[1] : void 0)
                                    },
                                    findIndex: function(predicate) {
                                        return arrayFindIndex(validate(this), predicate, 1 < arguments.length ? arguments[1] : void 0)
                                    },
                                    forEach: function(callbackfn) {
                                        arrayForEach(validate(this), callbackfn, 1 < arguments.length ? arguments[1] : void 0)
                                    },
                                    indexOf: function(searchElement) {
                                        return arrayIndexOf(validate(this), searchElement, 1 < arguments.length ? arguments[1] : void 0)
                                    },
                                    includes: function(searchElement) {
                                        return arrayIncludes(validate(this), searchElement, 1 < arguments.length ? arguments[1] : void 0)
                                    },
                                    join: function() {
                                        return arrayJoin.apply(validate(this), arguments)
                                    },
                                    lastIndexOf: function() {
                                        return arrayLastIndexOf.apply(validate(this), arguments)
                                    },
                                    map: function(mapfn) {
                                        return $map(validate(this), mapfn, 1 < arguments.length ? arguments[1] : void 0)
                                    },
                                    reduce: function() {
                                        return arrayReduce.apply(validate(this), arguments)
                                    },
                                    reduceRight: function() {
                                        return arrayReduceRight.apply(validate(this), arguments)
                                    },
                                    reverse: function() {
                                        var that = this,
                                            length = validate(that).length,
                                            middle = _Mathfloor(length / 2),
                                            index = 0,
                                            value;
                                        while (index < middle) {
                                            value = that[index];
                                            that[index++] = that[--length];
                                            that[length] = value
                                        }
                                        return that
                                    },
                                    some: function(callbackfn) {
                                        return arraySome(validate(this), callbackfn, 1 < arguments.length ? arguments[1] : void 0)
                                    },
                                    sort: function(comparefn) {
                                        return arraySort.call(validate(this), comparefn)
                                    },
                                    subarray: function(begin, end) {
                                        var O = validate(this),
                                            length = O.length,
                                            $begin = toAbsoluteIndex(begin, length);
                                        return new(speciesConstructor(O, O[DEF_CONSTRUCTOR]))(O.buffer, O.byteOffset + $begin * O.BYTES_PER_ELEMENT, toLength((end === void 0 ? length : toAbsoluteIndex(end, length)) - $begin))
                                    }
                                },
                                $slice = function(start, end) {
                                    return speciesFromList(this, arraySlice.call(validate(this), start, end))
                                },
                                $set = function(arrayLike) {
                                    validate(this);
                                    var offset = toOffset(arguments[1], 1),
                                        length = this.length,
                                        src = toObject(arrayLike),
                                        len = toLength(src.length),
                                        index = 0;
                                    if (len + offset > length) throw RangeError(WRONG_LENGTH);
                                    while (index < len) this[offset + index] = src[index++]
                                },
                                $iterators = {
                                    entries: function() {
                                        return arrayEntries.call(validate(this))
                                    },
                                    keys: function() {
                                        return arrayKeys.call(validate(this))
                                    },
                                    values: function() {
                                        return arrayValues.call(validate(this))
                                    }
                                },
                                isTAIndex = function(target, key) {
                                    return isObject(target) && target[TYPED_ARRAY] && "symbol" != typeof key && key in target && +key + "" == key + ""
                                },
                                $getDesc = function(target, key) {
                                    return isTAIndex(target, key = toPrimitive(key, !0)) ? propertyDesc(2, target[key]) : gOPD(target, key)
                                },
                                $setDesc = function(target, key, desc) {
                                    if (isTAIndex(target, key = toPrimitive(key, !0)) && isObject(desc) && has(desc, "value") && !has(desc, "get") && !has(desc, "set") && !desc.configurable && (!has(desc, "writable") || desc.writable) && (!has(desc, "enumerable") || desc.enumerable)) {
                                        target[key] = desc.value;
                                        return target
                                    }
                                    return dP(target, key, desc)
                                };
                            if (!ALL_CONSTRUCTORS) {
                                $GOPD.f = $getDesc;
                                $DP.f = $setDesc
                            }
                            $export($export.S + $export.F * !ALL_CONSTRUCTORS, "Object", {
                                getOwnPropertyDescriptor: $getDesc,
                                defineProperty: $setDesc
                            });
                            if (fails(function() {
                                    arrayToString.call({})
                                })) {
                                arrayToString = arrayToLocaleString = function() {
                                    return arrayJoin.call(this)
                                }
                            }
                            var $TypedArrayPrototype$ = redefineAll({}, proto);
                            redefineAll($TypedArrayPrototype$, $iterators);
                            hide($TypedArrayPrototype$, ITERATOR, $iterators.values);
                            redefineAll($TypedArrayPrototype$, {
                                slice: $slice,
                                set: $set,
                                constructor: function() {},
                                toString: arrayToString,
                                toLocaleString: $toLocaleString
                            });
                            addGetter($TypedArrayPrototype$, "buffer", "b");
                            addGetter($TypedArrayPrototype$, "byteOffset", "o");
                            addGetter($TypedArrayPrototype$, "byteLength", "l");
                            addGetter($TypedArrayPrototype$, "length", "e");
                            dP($TypedArrayPrototype$, TAG, {
                                get: function() {
                                    return this[TYPED_ARRAY]
                                }
                            });
                            module.exports = function(KEY, BYTES, wrapper, CLAMPED) {
                                CLAMPED = !!CLAMPED;
                                var NAME = KEY + (CLAMPED ? "Clamped" : "") + "Array",
                                    TypedArray = global[NAME],
                                    Base = TypedArray || {},
                                    TAC = TypedArray && getPrototypeOf(TypedArray),
                                    FORCED = !TypedArray || !$typed.ABV,
                                    O = {},
                                    TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE],
                                    getter = function(that, index) {
                                        var data = that._d;
                                        return data.v["get" + KEY](index * BYTES + data.o, LITTLE_ENDIAN)
                                    },
                                    setter = function(that, index, value) {
                                        var data = that._d;
                                        if (CLAMPED) value = 0 > (value = _Mathround(value)) ? 0 : 255 < value ? 255 : 255 & value;
                                        data.v["set" + KEY](index * BYTES + data.o, value, LITTLE_ENDIAN)
                                    },
                                    addElement = function(that, index) {
                                        dP(that, index, {
                                            get: function() {
                                                return getter(this, index)
                                            },
                                            set: function(value) {
                                                return setter(this, index, value)
                                            },
                                            enumerable: !0
                                        })
                                    };
                                if (FORCED) {
                                    TypedArray = wrapper(function(that, data, $offset, $length) {
                                        anInstance(that, TypedArray, NAME, "_d");
                                        var index = 0,
                                            offset = 0,
                                            buffer, byteLength, length, klass;
                                        if (!isObject(data)) {
                                            length = toIndex(data);
                                            byteLength = length * BYTES;
                                            buffer = new $ArrayBuffer(byteLength)
                                        } else if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
                                            buffer = data;
                                            offset = toOffset($offset, BYTES);
                                            var $len = data.byteLength;
                                            if ($length === void 0) {
                                                if ($len % BYTES) throw RangeError(WRONG_LENGTH);
                                                byteLength = $len - offset;
                                                if (0 > byteLength) throw RangeError(WRONG_LENGTH)
                                            } else {
                                                byteLength = toLength($length) * BYTES;
                                                if (byteLength + offset > $len) throw RangeError(WRONG_LENGTH)
                                            }
                                            length = byteLength / BYTES
                                        } else if (TYPED_ARRAY in data) {
                                            return fromList(TypedArray, data)
                                        } else {
                                            return $from.call(TypedArray, data)
                                        }
                                        hide(that, "_d", {
                                            b: buffer,
                                            o: offset,
                                            l: byteLength,
                                            e: length,
                                            v: new $DataView(buffer)
                                        });
                                        while (index < length) addElement(that, index++)
                                    });
                                    TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);
                                    hide(TypedArrayPrototype, "constructor", TypedArray)
                                } else if (!fails(function() {
                                        TypedArray(1)
                                    }) || !fails(function() {
                                        new TypedArray(-1)
                                    }) || !$iterDetect(function(iter) {
                                        new TypedArray;
                                        new TypedArray(null);
                                        new TypedArray(1.5);
                                        new TypedArray(iter)
                                    }, !0)) {
                                    TypedArray = wrapper(function(that, data, $offset, $length) {
                                        anInstance(that, TypedArray, NAME);
                                        var klass;
                                        if (!isObject(data)) return new Base(toIndex(data));
                                        if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
                                            return $length !== void 0 ? new Base(data, toOffset($offset, BYTES), $length) : $offset !== void 0 ? new Base(data, toOffset($offset, BYTES)) : new Base(data)
                                        }
                                        if (TYPED_ARRAY in data) return fromList(TypedArray, data);
                                        return $from.call(TypedArray, data)
                                    });
                                    arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function(key) {
                                        if (!(key in TypedArray)) hide(TypedArray, key, Base[key])
                                    });
                                    TypedArray[PROTOTYPE] = TypedArrayPrototype;
                                    if (!LIBRARY) TypedArrayPrototype.constructor = TypedArray
                                }
                                var $nativeIterator = TypedArrayPrototype[ITERATOR],
                                    CORRECT_ITER_NAME = !!$nativeIterator && ("values" == $nativeIterator.name || $nativeIterator.name == void 0),
                                    $iterator = $iterators.values;
                                hide(TypedArray, TYPED_CONSTRUCTOR, !0);
                                hide(TypedArrayPrototype, TYPED_ARRAY, NAME);
                                hide(TypedArrayPrototype, VIEW, !0);
                                hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);
                                if (CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)) {
                                    dP(TypedArrayPrototype, TAG, {
                                        get: function() {
                                            return NAME
                                        }
                                    })
                                }
                                O[NAME] = TypedArray;
                                $export($export.G + $export.W + $export.F * (TypedArray != Base), O);
                                $export($export.S, NAME, {
                                    BYTES_PER_ELEMENT: BYTES
                                });
                                $export($export.S + $export.F * fails(function() {
                                    Base.of.call(TypedArray, 1)
                                }), NAME, {
                                    from: $from,
                                    of: $of
                                });
                                if (!(BYTES_PER_ELEMENT in TypedArrayPrototype)) hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);
                                $export($export.P, NAME, proto);
                                setSpecies(NAME);
                                $export($export.P + $export.F * FORCED_SET, NAME, {
                                    set: $set
                                });
                                $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);
                                if (!LIBRARY && TypedArrayPrototype.toString != arrayToString) TypedArrayPrototype.toString = arrayToString;
                                $export($export.P + $export.F * fails(function() {
                                    new TypedArray(1).slice()
                                }), NAME, {
                                    slice: $slice
                                });
                                $export($export.P + $export.F * (fails(function() {
                                    return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString()
                                }) || !fails(function() {
                                    TypedArrayPrototype.toLocaleString.call([1, 2])
                                })), NAME, {
                                    toLocaleString: $toLocaleString
                                });
                                Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;
                                if (!LIBRARY && !CORRECT_ITER_NAME) hide(TypedArrayPrototype, ITERATOR, $iterator)
                            }
                        } else module.exports = function() {}
                    }, {
                        "./_an-instance": 54,
                        "./_array-copy-within": 56,
                        "./_array-fill": 57,
                        "./_array-includes": 59,
                        "./_array-methods": 60,
                        "./_classof": 65,
                        "./_ctx": 73,
                        "./_descriptors": 77,
                        "./_export": 81,
                        "./_fails": 83,
                        "./_global": 88,
                        "./_has": 89,
                        "./_hide": 90,
                        "./_is-array-iter": 96,
                        "./_is-object": 99,
                        "./_iter-detect": 104,
                        "./_iterators": 106,
                        "./_library": 107,
                        "./_object-create": 118,
                        "./_object-dp": 119,
                        "./_object-gopd": 122,
                        "./_object-gopn": 124,
                        "./_object-gpo": 126,
                        "./_property-desc": 137,
                        "./_redefine-all": 138,
                        "./_set-species": 145,
                        "./_species-constructor": 149,
                        "./_to-absolute-index": 159,
                        "./_to-index": 160,
                        "./_to-integer": 161,
                        "./_to-length": 163,
                        "./_to-object": 164,
                        "./_to-primitive": 165,
                        "./_typed": 168,
                        "./_typed-buffer": 167,
                        "./_uid": 169,
                        "./_wks": 174,
                        "./core.get-iterator-method": 175,
                        "./es6.array.iterator": 187
                    }],
                    167: [function(require, module, exports) {
                        "use strict";
                        var global = require("./_global"),
                            DESCRIPTORS = require("./_descriptors"),
                            LIBRARY = require("./_library"),
                            $typed = require("./_typed"),
                            hide = require("./_hide"),
                            redefineAll = require("./_redefine-all"),
                            fails = require("./_fails"),
                            anInstance = require("./_an-instance"),
                            toInteger = require("./_to-integer"),
                            toLength = require("./_to-length"),
                            toIndex = require("./_to-index"),
                            gOPN = require("./_object-gopn").f,
                            dP = require("./_object-dp").f,
                            arrayFill = require("./_array-fill"),
                            setToStringTag = require("./_set-to-string-tag"),
                            ARRAY_BUFFER = "ArrayBuffer",
                            DATA_VIEW = "DataView",
                            PROTOTYPE = "prototype",
                            WRONG_INDEX = "Wrong index!",
                            $ArrayBuffer = global[ARRAY_BUFFER],
                            $DataView = global[DATA_VIEW],
                            Math = global.Math,
                            RangeError = global.RangeError,
                            Infinity = global.Infinity,
                            BaseBuffer = $ArrayBuffer,
                            pow = _Mathpow,
                            BUFFER = "buffer",
                            BYTE_LENGTH = "byteLength",
                            BYTE_OFFSET = "byteOffset",
                            $BUFFER = DESCRIPTORS ? "_b" : BUFFER,
                            $LENGTH = DESCRIPTORS ? "_l" : BYTE_LENGTH,
                            $OFFSET = DESCRIPTORS ? "_o" : BYTE_OFFSET;

                        function packIEEE754(value, mLen, nBytes) {
                            var buffer = Array(nBytes),
                                eLen = 8 * nBytes - mLen - 1,
                                eMax = (1 << eLen) - 1,
                                eBias = eMax >> 1,
                                rt = 23 === mLen ? pow(2, -24) - pow(2, -77) : 0,
                                i = 0,
                                s = 0 > value || 0 === value && 0 > 1 / value ? 1 : 0,
                                e, m, c;
                            value = _Mathabs(value);
                            if (value != value || value === 1 / 0) {
                                m = value != value ? 1 : 0;
                                e = eMax
                            } else {
                                e = _Mathfloor(_Mathlog(value) / _MathLN);
                                if (1 > value * (c = pow(2, -e))) {
                                    e--;
                                    c *= 2
                                }
                                if (1 <= e + eBias) {
                                    value += rt / c
                                } else {
                                    value += rt * pow(2, 1 - eBias)
                                }
                                if (2 <= value * c) {
                                    e++;
                                    c /= 2
                                }
                                if (e + eBias >= eMax) {
                                    m = 0;
                                    e = eMax
                                } else if (1 <= e + eBias) {
                                    m = (value * c - 1) * pow(2, mLen);
                                    e = e + eBias
                                } else {
                                    m = value * pow(2, eBias - 1) * pow(2, mLen);
                                    e = 0
                                }
                            }
                            for (; 8 <= mLen; buffer[i++] = 255 & m, m /= 256, mLen -= 8);
                            e = e << mLen | m;
                            eLen += mLen;
                            for (; 0 < eLen; buffer[i++] = 255 & e, e /= 256, eLen -= 8);
                            buffer[--i] |= 128 * s;
                            return buffer
                        }

                        function unpackIEEE754(buffer, mLen, nBytes) {
                            var eLen = 8 * nBytes - mLen - 1,
                                eMax = (1 << eLen) - 1,
                                eBias = eMax >> 1,
                                nBits = eLen - 7,
                                i = nBytes - 1,
                                s = buffer[i--],
                                e = 127 & s,
                                m;
                            s >>= 7;
                            for (; 0 < nBits; e = 256 * e + buffer[i], i--, nBits -= 8);
                            m = e & (1 << -nBits) - 1;
                            e >>= -nBits;
                            nBits += mLen;
                            for (; 0 < nBits; m = 256 * m + buffer[i], i--, nBits -= 8);
                            if (0 === e) {
                                e = 1 - eBias
                            } else if (e === eMax) {
                                return m ? NaN : s ? -Infinity : 1 / 0
                            } else {
                                m = m + pow(2, mLen);
                                e = e - eBias
                            }
                            return (s ? -1 : 1) * m * pow(2, e - mLen)
                        }

                        function unpackI32(bytes) {
                            return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0]
                        }

                        function packI8(it) {
                            return [255 & it]
                        }

                        function packI16(it) {
                            return [255 & it, 255 & it >> 8]
                        }

                        function packI32(it) {
                            return [255 & it, 255 & it >> 8, 255 & it >> 16, 255 & it >> 24]
                        }

                        function packF64(it) {
                            return packIEEE754(it, 52, 8)
                        }

                        function packF32(it) {
                            return packIEEE754(it, 23, 4)
                        }

                        function addGetter(C, key, internal) {
                            dP(C[PROTOTYPE], key, {
                                get: function() {
                                    return this[internal]
                                }
                            })
                        }

                        function get(view, bytes, index, isLittleEndian) {
                            var intIndex = toIndex(+index);
                            if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
                            var store = view[$BUFFER]._b,
                                start = intIndex + view[$OFFSET],
                                pack = store.slice(start, start + bytes);
                            return isLittleEndian ? pack : pack.reverse()
                        }

                        function set(view, bytes, index, conversion, value, isLittleEndian) {
                            var intIndex = toIndex(+index);
                            if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
                            for (var store = view[$BUFFER]._b, start = intIndex + view[$OFFSET], pack = conversion(+value), i = 0; i < bytes; i++) store[start + i] = pack[isLittleEndian ? i : bytes - i - 1]
                        }
                        if (!$typed.ABV) {
                            $ArrayBuffer = function(length) {
                                anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
                                var byteLength = toIndex(length);
                                this._b = arrayFill.call(Array(byteLength), 0);
                                this[$LENGTH] = byteLength
                            };
                            $DataView = function(buffer, byteOffset, byteLength) {
                                anInstance(this, $DataView, DATA_VIEW);
                                anInstance(buffer, $ArrayBuffer, DATA_VIEW);
                                var bufferLength = buffer[$LENGTH],
                                    offset = toInteger(byteOffset);
                                if (0 > offset || offset > bufferLength) throw RangeError("Wrong offset!");
                                byteLength = byteLength === void 0 ? bufferLength - offset : toLength(byteLength);
                                if (offset + byteLength > bufferLength) throw RangeError("Wrong length!");
                                this[$BUFFER] = buffer;
                                this[$OFFSET] = offset;
                                this[$LENGTH] = byteLength
                            };
                            if (DESCRIPTORS) {
                                addGetter($ArrayBuffer, BYTE_LENGTH, "_l");
                                addGetter($DataView, BUFFER, "_b");
                                addGetter($DataView, BYTE_LENGTH, "_l");
                                addGetter($DataView, BYTE_OFFSET, "_o")
                            }
                            redefineAll($DataView[PROTOTYPE], {
                                getInt8: function(byteOffset) {
                                    return get(this, 1, byteOffset)[0] << 24 >> 24
                                },
                                getUint8: function(byteOffset) {
                                    return get(this, 1, byteOffset)[0]
                                },
                                getInt16: function(byteOffset) {
                                    var bytes = get(this, 2, byteOffset, arguments[1]);
                                    return (bytes[1] << 8 | bytes[0]) << 16 >> 16
                                },
                                getUint16: function(byteOffset) {
                                    var bytes = get(this, 2, byteOffset, arguments[1]);
                                    return bytes[1] << 8 | bytes[0]
                                },
                                getInt32: function(byteOffset) {
                                    return unpackI32(get(this, 4, byteOffset, arguments[1]))
                                },
                                getUint32: function(byteOffset) {
                                    return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0
                                },
                                getFloat32: function(byteOffset) {
                                    return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4)
                                },
                                getFloat64: function(byteOffset) {
                                    return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8)
                                },
                                setInt8: function(byteOffset, value) {
                                    set(this, 1, byteOffset, packI8, value)
                                },
                                setUint8: function(byteOffset, value) {
                                    set(this, 1, byteOffset, packI8, value)
                                },
                                setInt16: function(byteOffset, value) {
                                    set(this, 2, byteOffset, packI16, value, arguments[2])
                                },
                                setUint16: function(byteOffset, value) {
                                    set(this, 2, byteOffset, packI16, value, arguments[2])
                                },
                                setInt32: function(byteOffset, value) {
                                    set(this, 4, byteOffset, packI32, value, arguments[2])
                                },
                                setUint32: function(byteOffset, value) {
                                    set(this, 4, byteOffset, packI32, value, arguments[2])
                                },
                                setFloat32: function(byteOffset, value) {
                                    set(this, 4, byteOffset, packF32, value, arguments[2])
                                },
                                setFloat64: function(byteOffset, value) {
                                    set(this, 8, byteOffset, packF64, value, arguments[2])
                                }
                            })
                        } else {
                            if (!fails(function() {
                                    $ArrayBuffer(1)
                                }) || !fails(function() {
                                    new $ArrayBuffer(-1)
                                }) || fails(function() {
                                    new $ArrayBuffer;
                                    new $ArrayBuffer(1.5);
                                    new $ArrayBuffer(NaN);
                                    return $ArrayBuffer.name != ARRAY_BUFFER
                                })) {
                                $ArrayBuffer = function(length) {
                                    anInstance(this, $ArrayBuffer);
                                    return new BaseBuffer(toIndex(length))
                                };
                                for (var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE], keys = gOPN(BaseBuffer), j = 0, key; keys.length > j;) {
                                    if (!((key = keys[j++]) in $ArrayBuffer)) hide($ArrayBuffer, key, BaseBuffer[key])
                                }
                                if (!LIBRARY) ArrayBufferProto.constructor = $ArrayBuffer
                            }
                            var view = new $DataView(new $ArrayBuffer(2)),
                                $setInt8 = $DataView[PROTOTYPE].setInt8;
                            view.setInt8(0, 2147483648);
                            view.setInt8(1, 2147483649);
                            if (view.getInt8(0) || !view.getInt8(1)) redefineAll($DataView[PROTOTYPE], {
                                setInt8: function(byteOffset, value) {
                                    $setInt8.call(this, byteOffset, value << 24 >> 24)
                                },
                                setUint8: function(byteOffset, value) {
                                    $setInt8.call(this, byteOffset, value << 24 >> 24)
                                }
                            }, !0)
                        }
                        setToStringTag($ArrayBuffer, ARRAY_BUFFER);
                        setToStringTag($DataView, DATA_VIEW);
                        hide($DataView[PROTOTYPE], $typed.VIEW, !0);
                        exports[ARRAY_BUFFER] = $ArrayBuffer;
                        exports[DATA_VIEW] = $DataView
                    }, {
                        "./_an-instance": 54,
                        "./_array-fill": 57,
                        "./_descriptors": 77,
                        "./_fails": 83,
                        "./_global": 88,
                        "./_hide": 90,
                        "./_library": 107,
                        "./_object-dp": 119,
                        "./_object-gopn": 124,
                        "./_redefine-all": 138,
                        "./_set-to-string-tag": 146,
                        "./_to-index": 160,
                        "./_to-integer": 161,
                        "./_to-length": 163,
                        "./_typed": 168
                    }],
                    168: [function(require, module) {
                        var global = require("./_global"),
                            hide = require("./_hide"),
                            uid = require("./_uid"),
                            TYPED = uid("typed_array"),
                            VIEW = uid("view"),
                            ABV = !!(global.ArrayBuffer && global.DataView),
                            CONSTR = ABV,
                            i = 0,
                            Typed, TypedArrayConstructors = "Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array".split(",");
                        while (i < 9) {
                            if (Typed = global[TypedArrayConstructors[i++]]) {
                                hide(Typed.prototype, TYPED, !0);
                                hide(Typed.prototype, VIEW, !0)
                            } else CONSTR = !1
                        }
                        module.exports = {
                            ABV: ABV,
                            CONSTR: CONSTR,
                            TYPED: TYPED,
                            VIEW: VIEW
                        }
                    }, {
                        "./_global": 88,
                        "./_hide": 90,
                        "./_uid": 169
                    }],
                    169: [function(require, module) {
                        var id = 0,
                            px = Math.random();
                        module.exports = function(key) {
                            return "Symbol(".concat(key === void 0 ? "" : key, ")_", (++id + px).toString(36))
                        }
                    }, {}],
                    170: [function(require, module) {
                        var global = require("./_global"),
                            navigator = global.navigator;
                        module.exports = navigator && navigator.userAgent || ""
                    }, {
                        "./_global": 88
                    }],
                    171: [function(require, module) {
                        var isObject = require("./_is-object");
                        module.exports = function(it, TYPE) {
                            if (!isObject(it) || it._t !== TYPE) throw TypeError("Incompatible receiver, " + TYPE + " required!");
                            return it
                        }
                    }, {
                        "./_is-object": 99
                    }],
                    172: [function(require, module) {
                        var global = require("./_global"),
                            core = require("./_core"),
                            LIBRARY = require("./_library"),
                            wksExt = require("./_wks-ext"),
                            defineProperty = require("./_object-dp").f;
                        module.exports = function(name) {
                            var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
                            if ("_" != name.charAt(0) && !(name in $Symbol)) defineProperty($Symbol, name, {
                                value: wksExt.f(name)
                            })
                        }
                    }, {
                        "./_core": 71,
                        "./_global": 88,
                        "./_library": 107,
                        "./_object-dp": 119,
                        "./_wks-ext": 173
                    }],
                    173: [function(require, module, exports) {
                        exports.f = require("./_wks")
                    }, {
                        "./_wks": 174
                    }],
                    174: [function(require, module) {
                        var store = require("./_shared")("wks"),
                            uid = require("./_uid"),
                            Symbol = require("./_global").Symbol,
                            USE_SYMBOL = "function" == typeof Symbol,
                            $exports = module.exports = function(name) {
                                return store[name] || (store[name] = USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)("Symbol." + name))
                            };
                        $exports.store = store
                    }, {
                        "./_global": 88,
                        "./_shared": 148,
                        "./_uid": 169
                    }],
                    175: [function(require, module) {
                        var classof = require("./_classof"),
                            ITERATOR = require("./_wks")("iterator"),
                            Iterators = require("./_iterators");
                        module.exports = require("./_core").getIteratorMethod = function(it) {
                            if (it != void 0) return it[ITERATOR] || it["@@iterator"] || Iterators[classof(it)]
                        }
                    }, {
                        "./_classof": 65,
                        "./_core": 71,
                        "./_iterators": 106,
                        "./_wks": 174
                    }],
                    176: [function(require) {
                        var $export = require("./_export"),
                            $re = require("./_replacer")(/[\\^$*+?.()|[\]{}]/g, "\\$&");
                        $export($export.S, "RegExp", {
                            escape: function(it) {
                                return $re(it)
                            }
                        })
                    }, {
                        "./_export": 81,
                        "./_replacer": 140
                    }],
                    177: [function(require) {
                        var $export = require("./_export");
                        $export($export.P, "Array", {
                            copyWithin: require("./_array-copy-within")
                        });
                        require("./_add-to-unscopables")("copyWithin")
                    }, {
                        "./_add-to-unscopables": 53,
                        "./_array-copy-within": 56,
                        "./_export": 81
                    }],
                    178: [function(require) {
                        "use strict";
                        var $export = require("./_export"),
                            $every = require("./_array-methods")(4);
                        $export($export.P + $export.F * !require("./_strict-method")([].every, !0), "Array", {
                            every: function(callbackfn) {
                                return $every(this, callbackfn, arguments[1])
                            }
                        })
                    }, {
                        "./_array-methods": 60,
                        "./_export": 81,
                        "./_strict-method": 150
                    }],
                    179: [function(require) {
                        var $export = require("./_export");
                        $export($export.P, "Array", {
                            fill: require("./_array-fill")
                        });
                        require("./_add-to-unscopables")("fill")
                    }, {
                        "./_add-to-unscopables": 53,
                        "./_array-fill": 57,
                        "./_export": 81
                    }],
                    180: [function(require) {
                        "use strict";
                        var $export = require("./_export"),
                            $filter = require("./_array-methods")(2);
                        $export($export.P + $export.F * !require("./_strict-method")([].filter, !0), "Array", {
                            filter: function(callbackfn) {
                                return $filter(this, callbackfn, arguments[1])
                            }
                        })
                    }, {
                        "./_array-methods": 60,
                        "./_export": 81,
                        "./_strict-method": 150
                    }],
                    181: [function(require) {
                        "use strict";
                        var $export = require("./_export"),
                            $find = require("./_array-methods")(6),
                            KEY = "findIndex",
                            forced = !0;
                        if (KEY in [])[, ][KEY](function() {
                            forced = !1
                        });
                        $export($export.P + $export.F * forced, "Array", {
                            findIndex: function(callbackfn) {
                                return $find(this, callbackfn, 1 < arguments.length ? arguments[1] : void 0)
                            }
                        });
                        require("./_add-to-unscopables")(KEY)
                    }, {
                        "./_add-to-unscopables": 53,
                        "./_array-methods": 60,
                        "./_export": 81
                    }],
                    182: [function(require) {
                        "use strict";
                        var $export = require("./_export"),
                            $find = require("./_array-methods")(5),
                            KEY = "find",
                            forced = !0;
                        if (KEY in [])[, ][KEY](function() {
                            forced = !1
                        });
                        $export($export.P + $export.F * forced, "Array", {
                            find: function(callbackfn) {
                                return $find(this, callbackfn, 1 < arguments.length ? arguments[1] : void 0)
                            }
                        });
                        require("./_add-to-unscopables")(KEY)
                    }, {
                        "./_add-to-unscopables": 53,
                        "./_array-methods": 60,
                        "./_export": 81
                    }],
                    183: [function(require) {
                        "use strict";
                        var $export = require("./_export"),
                            $forEach = require("./_array-methods")(0),
                            STRICT = require("./_strict-method")([].forEach, !0);
                        $export($export.P + $export.F * !STRICT, "Array", {
                            forEach: function(callbackfn) {
                                return $forEach(this, callbackfn, arguments[1])
                            }
                        })
                    }, {
                        "./_array-methods": 60,
                        "./_export": 81,
                        "./_strict-method": 150
                    }],
                    184: [function(require) {
                        "use strict";
                        var ctx = require("./_ctx"),
                            $export = require("./_export"),
                            toObject = require("./_to-object"),
                            call = require("./_iter-call"),
                            isArrayIter = require("./_is-array-iter"),
                            toLength = require("./_to-length"),
                            createProperty = require("./_create-property"),
                            getIterFn = require("./core.get-iterator-method");
                        $export($export.S + $export.F * !require("./_iter-detect")(function(iter) {
                            Array.from(iter)
                        }), "Array", {
                            from: function(arrayLike) {
                                var O = toObject(arrayLike),
                                    C = "function" == typeof this ? this : Array,
                                    aLen = arguments.length,
                                    mapfn = 1 < aLen ? arguments[1] : void 0,
                                    mapping = mapfn !== void 0,
                                    index = 0,
                                    iterFn = getIterFn(O),
                                    length, result, step, iterator;
                                if (mapping) mapfn = ctx(mapfn, 2 < aLen ? arguments[2] : void 0, 2);
                                if (iterFn != void 0 && !(C == Array && isArrayIter(iterFn))) {
                                    for (iterator = iterFn.call(O), result = new C; !(step = iterator.next()).done; index++) {
                                        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], !0) : step.value)
                                    }
                                } else {
                                    length = toLength(O.length);
                                    for (result = new C(length); length > index; index++) {
                                        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index])
                                    }
                                }
                                result.length = index;
                                return result
                            }
                        })
                    }, {
                        "./_create-property": 72,
                        "./_ctx": 73,
                        "./_export": 81,
                        "./_is-array-iter": 96,
                        "./_iter-call": 101,
                        "./_iter-detect": 104,
                        "./_to-length": 163,
                        "./_to-object": 164,
                        "./core.get-iterator-method": 175
                    }],
                    185: [function(require) {
                        "use strict";
                        var $export = require("./_export"),
                            $indexOf = require("./_array-includes")(!1),
                            $native = [].indexOf,
                            NEGATIVE_ZERO = !!$native && 0 > 1 / [1].indexOf(1, -0);
                        $export($export.P + $export.F * (NEGATIVE_ZERO || !require("./_strict-method")($native)), "Array", {
                            indexOf: function(searchElement) {
                                return NEGATIVE_ZERO ? $native.apply(this, arguments) || 0 : $indexOf(this, searchElement, arguments[1])
                            }
                        })
                    }, {
                        "./_array-includes": 59,
                        "./_export": 81,
                        "./_strict-method": 150
                    }],
                    186: [function(require) {
                        var $export = require("./_export");
                        $export($export.S, "Array", {
                            isArray: require("./_is-array")
                        })
                    }, {
                        "./_export": 81,
                        "./_is-array": 97
                    }],
                    187: [function(require, module) {
                        "use strict";
                        var addToUnscopables = require("./_add-to-unscopables"),
                            step = require("./_iter-step"),
                            Iterators = require("./_iterators"),
                            toIObject = require("./_to-iobject");
                        module.exports = require("./_iter-define")(Array, "Array", function(iterated, kind) {
                            this._t = toIObject(iterated);
                            this._i = 0;
                            this._k = kind
                        }, function() {
                            var O = this._t,
                                kind = this._k,
                                index = this._i++;
                            if (!O || index >= O.length) {
                                this._t = void 0;
                                return step(1)
                            }
                            if ("keys" == kind) return step(0, index);
                            if ("values" == kind) return step(0, O[index]);
                            return step(0, [index, O[index]])
                        }, "values");
                        Iterators.Arguments = Iterators.Array;
                        addToUnscopables("keys");
                        addToUnscopables("values");
                        addToUnscopables("entries")
                    }, {
                        "./_add-to-unscopables": 53,
                        "./_iter-define": 103,
                        "./_iter-step": 105,
                        "./_iterators": 106,
                        "./_to-iobject": 162
                    }],
                    188: [function(require) {
                        "use strict";
                        var $export = require("./_export"),
                            toIObject = require("./_to-iobject"),
                            arrayJoin = [].join;
                        $export($export.P + $export.F * (require("./_iobject") != Object || !require("./_strict-method")(arrayJoin)), "Array", {
                            join: function(separator) {
                                return arrayJoin.call(toIObject(this), separator === void 0 ? "," : separator)
                            }
                        })
                    }, {
                        "./_export": 81,
                        "./_iobject": 95,
                        "./_strict-method": 150,
                        "./_to-iobject": 162
                    }],
                    189: [function(require) {
                        "use strict";
                        var $export = require("./_export"),
                            toIObject = require("./_to-iobject"),
                            toInteger = require("./_to-integer"),
                            toLength = require("./_to-length"),
                            $native = [].lastIndexOf,
                            NEGATIVE_ZERO = !!$native && 0 > 1 / [1].lastIndexOf(1, -0);
                        $export($export.P + $export.F * (NEGATIVE_ZERO || !require("./_strict-method")($native)), "Array", {
                            lastIndexOf: function(searchElement) {
                                if (NEGATIVE_ZERO) return $native.apply(this, arguments) || 0;
                                var O = toIObject(this),
                                    length = toLength(O.length),
                                    index = length - 1;
                                if (1 < arguments.length) index = _Mathmin(index, toInteger(arguments[1]));
                                if (0 > index) index = length + index;
                                for (; 0 <= index; index--)
                                    if (index in O)
                                        if (O[index] === searchElement) return index || 0;
                                return -1
                            }
                        })
                    }, {
                        "./_export": 81,
                        "./_strict-method": 150,
                        "./_to-integer": 161,
                        "./_to-iobject": 162,
                        "./_to-length": 163
                    }],
                    190: [function(require) {
                        "use strict";
                        var $export = require("./_export"),
                            $map = require("./_array-methods")(1);
                        $export($export.P + $export.F * !require("./_strict-method")([].map, !0), "Array", {
                            map: function(callbackfn) {
                                return $map(this, callbackfn, arguments[1])
                            }
                        })
                    }, {
                        "./_array-methods": 60,
                        "./_export": 81,
                        "./_strict-method": 150
                    }],
                    191: [function(require) {
                        "use strict";
                        var $export = require("./_export"),
                            createProperty = require("./_create-property");
                        $export($export.S + $export.F * require("./_fails")(function() {
                            function F() {}
                            return !(Array.of.call(F) instanceof F)
                        }), "Array", { of: function() {
                                var index = 0,
                                    aLen = arguments.length,
                                    result = new("function" == typeof this ? this : Array)(aLen);
                                while (aLen > index) createProperty(result, index, arguments[index++]);
                                result.length = aLen;
                                return result
                            }
                        })
                    }, {
                        "./_create-property": 72,
                        "./_export": 81,
                        "./_fails": 83
                    }],
                    192: [function(require) {
                        "use strict";
                        var $export = require("./_export"),
                            $reduce = require("./_array-reduce");
                        $export($export.P + $export.F * !require("./_strict-method")([].reduceRight, !0), "Array", {
                            reduceRight: function(callbackfn) {
                                return $reduce(this, callbackfn, arguments.length, arguments[1], !0)
                            }
                        })
                    }, {
                        "./_array-reduce": 61,
                        "./_export": 81,
                        "./_strict-method": 150
                    }],
                    193: [function(require) {
                        "use strict";
                        var $export = require("./_export"),
                            $reduce = require("./_array-reduce");
                        $export($export.P + $export.F * !require("./_strict-method")([].reduce, !0), "Array", {
                            reduce: function(callbackfn) {
                                return $reduce(this, callbackfn, arguments.length, arguments[1], !1)
                            }
                        })
                    }, {
                        "./_array-reduce": 61,
                        "./_export": 81,
                        "./_strict-method": 150
                    }],
                    194: [function(require) {
                        "use strict";
                        var $export = require("./_export"),
                            html = require("./_html"),
                            cof = require("./_cof"),
                            toAbsoluteIndex = require("./_to-absolute-index"),
                            toLength = require("./_to-length"),
                            arraySlice = [].slice;
                        $export($export.P + $export.F * require("./_fails")(function() {
                            if (html) arraySlice.call(html)
                        }), "Array", {
                            slice: function(begin, end) {
                                var len = toLength(this.length),
                                    klass = cof(this);
                                end = end === void 0 ? len : end;
                                if ("Array" == klass) return arraySlice.call(this, begin, end);
                                var start = toAbsoluteIndex(begin, len),
                                    upTo = toAbsoluteIndex(end, len),
                                    size = toLength(upTo - start),
                                    cloned = Array(size),
                                    i = 0;
                                for (; i < size; i++) cloned[i] = "String" == klass ? this.charAt(start + i) : this[start + i];
                                return cloned
                            }
                        })
                    }, {
                        "./_cof": 66,
                        "./_export": 81,
                        "./_fails": 83,
                        "./_html": 91,
                        "./_to-absolute-index": 159,
                        "./_to-length": 163
                    }],
                    195: [function(require) {
                        "use strict";
                        var $export = require("./_export"),
                            $some = require("./_array-methods")(3);
                        $export($export.P + $export.F * !require("./_strict-method")([].some, !0), "Array", {
                            some: function(callbackfn) {
                                return $some(this, callbackfn, arguments[1])
                            }
                        })
                    }, {
                        "./_array-methods": 60,
                        "./_export": 81,
                        "./_strict-method": 150
                    }],
                    196: [function(require) {
                        "use strict";
                        var $export = require("./_export"),
                            aFunction = require("./_a-function"),
                            toObject = require("./_to-object"),
                            fails = require("./_fails"),
                            $sort = [].sort,
                            test = [1, 2, 3];
                        $export($export.P + $export.F * (fails(function() {
                            test.sort(void 0)
                        }) || !fails(function() {
                            test.sort(null)
                        }) || !require("./_strict-method")($sort)), "Array", {
                            sort: function(comparefn) {
                                return comparefn === void 0 ? $sort.call(toObject(this)) : $sort.call(toObject(this), aFunction(comparefn))
                            }
                        })
                    }, {
                        "./_a-function": 51,
                        "./_export": 81,
                        "./_fails": 83,
                        "./_strict-method": 150,
                        "./_to-object": 164
                    }],
                    197: [function(require) {
                        require("./_set-species")("Array")
                    }, {
                        "./_set-species": 145
                    }],
                    198: [function(require) {
                        var $export = require("./_export");
                        $export($export.S, "Date", {
                            now: function() {
                                return new Date().getTime()
                            }
                        })
                    }, {
                        "./_export": 81
                    }],
                    199: [function(require) {
                        var $export = require("./_export"),
                            toISOString = require("./_date-to-iso-string");
                        $export($export.P + $export.F * (Date.prototype.toISOString !== toISOString), "Date", {
                            toISOString: toISOString
                        })
                    }, {
                        "./_date-to-iso-string": 74,
                        "./_export": 81
                    }],
                    200: [function(require) {
                        "use strict";
                        var $export = require("./_export"),
                            toObject = require("./_to-object"),
                            toPrimitive = require("./_to-primitive");
                        $export($export.P + $export.F * require("./_fails")(function() {
                            return null !== new Date(NaN).toJSON() || 1 !== Date.prototype.toJSON.call({
                                toISOString: function() {
                                    return 1
                                }
                            })
                        }), "Date", {
                            toJSON: function() {
                                var O = toObject(this),
                                    pv = toPrimitive(O);
                                return "number" == typeof pv && !isFinite(pv) ? null : O.toISOString()
                            }
                        })
                    }, {
                        "./_export": 81,
                        "./_fails": 83,
                        "./_to-object": 164,
                        "./_to-primitive": 165
                    }],
                    201: [function(require) {
                        var TO_PRIMITIVE = require("./_wks")("toPrimitive"),
                            proto = Date.prototype;
                        if (!(TO_PRIMITIVE in proto)) require("./_hide")(proto, TO_PRIMITIVE, require("./_date-to-primitive"))
                    }, {
                        "./_date-to-primitive": 75,
                        "./_hide": 90,
                        "./_wks": 174
                    }],
                    202: [function(require) {
                        var DateProto = Date.prototype,
                            INVALID_DATE = "Invalid Date",
                            TO_STRING = "toString",
                            $toString = DateProto[TO_STRING],
                            getTime = DateProto.getTime;
                        if (new Date(NaN) + "" != INVALID_DATE) {
                            require("./_redefine")(DateProto, TO_STRING, function() {
                                var value = getTime.call(this);
                                return value === value ? $toString.call(this) : INVALID_DATE
                            })
                        }
                    }, {
                        "./_redefine": 139
                    }],
                    203: [function(require) {
                        var $export = require("./_export");
                        $export($export.P, "Function", {
                            bind: require("./_bind")
                        })
                    }, {
                        "./_bind": 64,
                        "./_export": 81
                    }],
                    204: [function(require) {
                        "use strict";
                        var isObject = require("./_is-object"),
                            getPrototypeOf = require("./_object-gpo"),
                            HAS_INSTANCE = require("./_wks")("hasInstance"),
                            FunctionProto = Function.prototype;
                        if (!(HAS_INSTANCE in FunctionProto)) require("./_object-dp").f(FunctionProto, HAS_INSTANCE, {
                            value: function(O) {
                                if ("function" != typeof this || !isObject(O)) return !1;
                                if (!isObject(this.prototype)) return O instanceof this;
                                while (O = getPrototypeOf(O))
                                    if (this.prototype === O) return !0;
                                return !1
                            }
                        })
                    }, {
                        "./_is-object": 99,
                        "./_object-dp": 119,
                        "./_object-gpo": 126,
                        "./_wks": 174
                    }],
                    205: [function(require) {
                        var dP = require("./_object-dp").f,
                            FProto = Function.prototype,
                            nameRE = /^\s*function ([^ (]*)/,
                            NAME = "name";
                        NAME in FProto || require("./_descriptors") && dP(FProto, NAME, {
                            configurable: !0,
                            get: function() {
                                try {
                                    return ("" + this).match(nameRE)[1]
                                } catch (e) {
                                    return ""
                                }
                            }
                        })
                    }, {
                        "./_descriptors": 77,
                        "./_object-dp": 119
                    }],
                    206: [function(require, module) {
                        "use strict";
                        var strong = require("./_collection-strong"),
                            validate = require("./_validate-collection"),
                            MAP = "Map";
                        module.exports = require("./_collection")(MAP, function(get) {
                            return function() {
                                return get(this, 0 < arguments.length ? arguments[0] : void 0)
                            }
                        }, {
                            get: function(key) {
                                var entry = strong.getEntry(validate(this, MAP), key);
                                return entry && entry.v
                            },
                            set: function(key, value) {
                                return strong.def(validate(this, MAP), 0 === key ? 0 : key, value)
                            }
                        }, strong, !0)
                    }, {
                        "./_collection": 70,
                        "./_collection-strong": 67,
                        "./_validate-collection": 171
                    }],
                    207: [function(require) {
                        var $export = require("./_export"),
                            log1p = require("./_math-log1p"),
                            sqrt = _Mathsqrt,
                            $acosh = Math.acosh;
                        $export($export.S + $export.F * !($acosh && 710 == _Mathfloor($acosh(Number.MAX_VALUE)) && $acosh(1 / 0) == 1 / 0), "Math", {
                            acosh: function(x) {
                                return 1 > (x = +x) ? NaN : 94906265.62425156 < x ? _Mathlog(x) + _MathLN : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1))
                            }
                        })
                    }, {
                        "./_export": 81,
                        "./_math-log1p": 110
                    }],
                    208: [function(require) {
                        var $export = require("./_export"),
                            $asinh = Math.asinh;

                        function asinh(x) {
                            return !isFinite(x = +x) || 0 == x ? x : 0 > x ? -asinh(-x) : _Mathlog(x + _Mathsqrt(x * x + 1))
                        }
                        $export($export.S + $export.F * !($asinh && 0 < 1 / $asinh(0)), "Math", {
                            asinh: asinh
                        })
                    }, {
                        "./_export": 81
                    }],
                    209: [function(require) {
                        var $export = require("./_export"),
                            $atanh = Math.atanh;
                        $export($export.S + $export.F * !($atanh && 0 > 1 / $atanh(-0)), "Math", {
                            atanh: function(x) {
                                return 0 == (x = +x) ? x : _Mathlog((1 + x) / (1 - x)) / 2
                            }
                        })
                    }, {
                        "./_export": 81
                    }],
                    210: [function(require) {
                        var $export = require("./_export"),
                            sign = require("./_math-sign");
                        $export($export.S, "Math", {
                            cbrt: function(x) {
                                return sign(x = +x) * _Mathpow(_Mathabs(x), 1 / 3)
                            }
                        })
                    }, {
                        "./_export": 81,
                        "./_math-sign": 112
                    }],
                    211: [function(require) {
                        var $export = require("./_export");
                        $export($export.S, "Math", {
                            clz32: function(x) {
                                return (x >>>= 0) ? 31 - _Mathfloor(_Mathlog(x + .5) * Math.LOG2E) : 32
                            }
                        })
                    }, {
                        "./_export": 81
                    }],
                    212: [function(require) {
                        var $export = require("./_export"),
                            exp = _Mathexp;
                        $export($export.S, "Math", {
                            cosh: function(x) {
                                return (exp(x = +x) + exp(-x)) / 2
                            }
                        })
                    }, {
                        "./_export": 81
                    }],
                    213: [function(require) {
                        var $export = require("./_export"),
                            $expm1 = require("./_math-expm1");
                        $export($export.S + $export.F * ($expm1 != _Mathexpm), "Math", {
                            expm1: $expm1
                        })
                    }, {
                        "./_export": 81,
                        "./_math-expm1": 108
                    }],
                    214: [function(require) {
                        var $export = require("./_export");
                        $export($export.S, "Math", {
                            fround: require("./_math-fround")
                        })
                    }, {
                        "./_export": 81,
                        "./_math-fround": 109
                    }],
                    215: [function(require) {
                        var $export = require("./_export");
                        $export($export.S, "Math", {
                            hypot: function() {
                                var sum = 0,
                                    i = 0,
                                    aLen = arguments.length,
                                    larg = 0,
                                    arg, div;
                                while (i < aLen) {
                                    arg = _Mathabs(arguments[i++]);
                                    if (larg < arg) {
                                        div = larg / arg;
                                        sum = sum * div * div + 1;
                                        larg = arg
                                    } else if (0 < arg) {
                                        div = arg / larg;
                                        sum += div * div
                                    } else sum += arg
                                }
                                return larg === 1 / 0 ? 1 / 0 : larg * _Mathsqrt(sum)
                            }
                        })
                    }, {
                        "./_export": 81
                    }],
                    216: [function(require) {
                        var $export = require("./_export"),
                            $imul = Math.imul;
                        $export($export.S + $export.F * require("./_fails")(function() {
                            return -5 != $imul(4294967295, 5) || 2 != $imul.length
                        }), "Math", {
                            imul: function(x, y) {
                                var UINT16 = 65535,
                                    xn = +x,
                                    yn = +y,
                                    xl = UINT16 & xn,
                                    yl = UINT16 & yn;
                                return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0)
                            }
                        })
                    }, {
                        "./_export": 81,
                        "./_fails": 83
                    }],
                    217: [function(require) {
                        var $export = require("./_export");
                        $export($export.S, "Math", {
                            log10: function(x) {
                                return _Mathlog(x) * Math.LOG10E
                            }
                        })
                    }, {
                        "./_export": 81
                    }],
                    218: [function(require) {
                        var $export = require("./_export");
                        $export($export.S, "Math", {
                            log1p: require("./_math-log1p")
                        })
                    }, {
                        "./_export": 81,
                        "./_math-log1p": 110
                    }],
                    219: [function(require) {
                        var $export = require("./_export");
                        $export($export.S, "Math", {
                            log2: function(x) {
                                return _Mathlog(x) / _MathLN
                            }
                        })
                    }, {
                        "./_export": 81
                    }],
                    220: [function(require) {
                        var $export = require("./_export");
                        $export($export.S, "Math", {
                            sign: require("./_math-sign")
                        })
                    }, {
                        "./_export": 81,
                        "./_math-sign": 112
                    }],
                    221: [function(require) {
                        var $export = require("./_export"),
                            expm1 = require("./_math-expm1"),
                            exp = _Mathexp;
                        $export($export.S + $export.F * require("./_fails")(function() {
                            return -2e-17 != !-2e-17
                        }), "Math", {
                            sinh: function(x) {
                                return 1 > _Mathabs(x = +x) ? (expm1(x) - expm1(-x)) / 2 : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2)
                            }
                        })
                    }, {
                        "./_export": 81,
                        "./_fails": 83,
                        "./_math-expm1": 108
                    }],
                    222: [function(require) {
                        var $export = require("./_export"),
                            expm1 = require("./_math-expm1"),
                            exp = _Mathexp;
                        $export($export.S, "Math", {
                            tanh: function(x) {
                                var a = expm1(x = +x),
                                    b = expm1(-x);
                                return a == 1 / 0 ? 1 : b == 1 / 0 ? -1 : (a - b) / (exp(x) + exp(-x))
                            }
                        })
                    }, {
                        "./_export": 81,
                        "./_math-expm1": 108
                    }],
                    223: [function(require) {
                        var $export = require("./_export");
                        $export($export.S, "Math", {
                            trunc: function(it) {
                                return (0 < it ? _Mathfloor : _Mathceil)(it)
                            }
                        })
                    }, {
                        "./_export": 81
                    }],
                    224: [function(require) {
                        "use strict";
                        var global = require("./_global"),
                            has = require("./_has"),
                            cof = require("./_cof"),
                            inheritIfRequired = require("./_inherit-if-required"),
                            toPrimitive = require("./_to-primitive"),
                            fails = require("./_fails"),
                            gOPN = require("./_object-gopn").f,
                            gOPD = require("./_object-gopd").f,
                            dP = require("./_object-dp").f,
                            $trim = require("./_string-trim").trim,
                            NUMBER = "Number",
                            $Number = global[NUMBER],
                            Base = $Number,
                            proto = $Number.prototype,
                            BROKEN_COF = cof(require("./_object-create")(proto)) == NUMBER,
                            TRIM = "trim" in _Stringprototype,
                            toNumber = function(argument) {
                                var it = toPrimitive(argument, !1);
                                if ("string" == typeof it && 2 < it.length) {
                                    it = TRIM ? it.trim() : $trim(it, 3);
                                    var first = it.charCodeAt(0),
                                        third, radix, maxCode;
                                    if (43 === first || 45 === first) {
                                        third = it.charCodeAt(2);
                                        if (88 === third || 120 === third) return NaN
                                    } else if (48 === first) {
                                        switch (it.charCodeAt(1)) {
                                            case 66:
                                            case 98:
                                                radix = 2;
                                                maxCode = 49;
                                                break;
                                            case 79:
                                            case 111:
                                                radix = 8;
                                                maxCode = 55;
                                                break;
                                            default:
                                                return +it;
                                        }
                                        for (var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++) {
                                            code = digits.charCodeAt(i);
                                            if (48 > code || code > maxCode) return NaN
                                        }
                                        return parseInt(digits, radix)
                                    }
                                }
                                return +it
                            };
                        if (!$Number(" 0o1") || !$Number("0b1") || $Number("+0x1")) {
                            $Number = function(value) {
                                var it = 1 > arguments.length ? 0 : value,
                                    that = this;
                                return that instanceof $Number && (BROKEN_COF ? fails(function() {
                                    proto.valueOf.call(that)
                                }) : cof(that) != NUMBER) ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it)
                            };
                            for (var keys = require("./_descriptors") ? gOPN(Base) : ("MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY," + "EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER," + "MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger").split(","), j = 0, key; keys.length > j; j++) {
                                if (has(Base, key = keys[j]) && !has($Number, key)) {
                                    dP($Number, key, gOPD(Base, key))
                                }
                            }
                            $Number.prototype = proto;
                            proto.constructor = $Number;
                            require("./_redefine")(global, NUMBER, $Number)
                        }
                    }, {
                        "./_cof": 66,
                        "./_descriptors": 77,
                        "./_fails": 83,
                        "./_global": 88,
                        "./_has": 89,
                        "./_inherit-if-required": 93,
                        "./_object-create": 118,
                        "./_object-dp": 119,
                        "./_object-gopd": 122,
                        "./_object-gopn": 124,
                        "./_redefine": 139,
                        "./_string-trim": 156,
                        "./_to-primitive": 165
                    }],
                    225: [function(require) {
                        var $export = require("./_export");
                        $export($export.S, "Number", {
                            EPSILON: 2.220446049250313e-16
                        })
                    }, {
                        "./_export": 81
                    }],
                    226: [function(require) {
                        var $export = require("./_export"),
                            _isFinite = require("./_global").isFinite;
                        $export($export.S, "Number", {
                            isFinite: function(it) {
                                return "number" == typeof it && _isFinite(it)
                            }
                        })
                    }, {
                        "./_export": 81,
                        "./_global": 88
                    }],
                    227: [function(require) {
                        var $export = require("./_export");
                        $export($export.S, "Number", {
                            isInteger: require("./_is-integer")
                        })
                    }, {
                        "./_export": 81,
                        "./_is-integer": 98
                    }],
                    228: [function(require) {
                        var $export = require("./_export");
                        $export($export.S, "Number", {
                            isNaN: function(number) {
                                return number != number
                            }
                        })
                    }, {
                        "./_export": 81
                    }],
                    229: [function(require) {
                        var $export = require("./_export"),
                            isInteger = require("./_is-integer");
                        $export($export.S, "Number", {
                            isSafeInteger: function(number) {
                                return isInteger(number) && 9007199254740991 >= _Mathabs(number)
                            }
                        })
                    }, {
                        "./_export": 81,
                        "./_is-integer": 98
                    }],
                    230: [function(require) {
                        var $export = require("./_export");
                        $export($export.S, "Number", {
                            MAX_SAFE_INTEGER: 9007199254740991
                        })
                    }, {
                        "./_export": 81
                    }],
                    231: [function(require) {
                        var $export = require("./_export");
                        $export($export.S, "Number", {
                            MIN_SAFE_INTEGER: -9007199254740991
                        })
                    }, {
                        "./_export": 81
                    }],
                    232: [function(require) {
                        var $export = require("./_export"),
                            $parseFloat = require("./_parse-float");
                        $export($export.S + $export.F * (Number.parseFloat != $parseFloat), "Number", {
                            parseFloat: $parseFloat
                        })
                    }, {
                        "./_export": 81,
                        "./_parse-float": 133
                    }],
                    233: [function(require) {
                        var $export = require("./_export"),
                            $parseInt = require("./_parse-int");
                        $export($export.S + $export.F * (Number.parseInt != $parseInt), "Number", {
                            parseInt: $parseInt
                        })
                    }, {
                        "./_export": 81,
                        "./_parse-int": 134
                    }],
                    234: [function(require) {
                        "use strict";
                        var $export = require("./_export"),
                            toInteger = require("./_to-integer"),
                            aNumberValue = require("./_a-number-value"),
                            repeat = require("./_string-repeat"),
                            $toFixed = 1.toFixed,
                            floor = _Mathfloor,
                            data = [0, 0, 0, 0, 0, 0],
                            ERROR = "Number.toFixed: incorrect invocation!",
                            ZERO = "0",
                            multiply = function(n, c) {
                                var i = -1,
                                    c2 = c;
                                while (6 > ++i) {
                                    c2 += n * data[i];
                                    data[i] = c2 % 1e7;
                                    c2 = floor(c2 / 1e7)
                                }
                            },
                            divide = function(n) {
                                var i = 6,
                                    c = 0;
                                while (0 <= --i) {
                                    c += data[i];
                                    data[i] = floor(c / n);
                                    c = 1e7 * (c % n)
                                }
                            },
                            numToString = function() {
                                var i = 6,
                                    s = "";
                                while (0 <= --i) {
                                    if ("" !== s || 0 === i || 0 !== data[i]) {
                                        var t = data[i] + "";
                                        s = "" === s ? t : s + repeat.call(ZERO, 7 - t.length) + t
                                    }
                                }
                                return s
                            },
                            pow = function(x, n, acc) {
                                return 0 === n ? acc : 1 === n % 2 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc)
                            },
                            log = function(x) {
                                var n = 0,
                                    x2 = x;
                                while (4096 <= x2) {
                                    n += 12;
                                    x2 /= 4096
                                }
                                while (2 <= x2) {
                                    n += 1;
                                    x2 /= 2
                                }
                                return n
                            };
                        $export($export.P + $export.F * (!!$toFixed && ("0.000" !== 8e-5.toFixed(3) || "1" !== .9.toFixed(0) || "1.25" !== 1.255.toFixed(2) || "1000000000000000128" !== 1000000000000000100.toFixed(0)) || !require("./_fails")(function() {
                            $toFixed.call({})
                        })), "Number", {
                            toFixed: function(fractionDigits) {
                                var x = aNumberValue(this, ERROR),
                                    f = toInteger(fractionDigits),
                                    s = "",
                                    m = ZERO,
                                    e, z, j, k;
                                if (0 > f || 20 < f) throw RangeError(ERROR);
                                if (x != x) return "NaN";
                                if (-1e21 >= x || 1e21 <= x) return x + "";
                                if (0 > x) {
                                    s = "-";
                                    x = -x
                                }
                                if (1e-21 < x) {
                                    e = log(x * pow(2, 69, 1)) - 69;
                                    z = 0 > e ? x * pow(2, -e, 1) : x / pow(2, e, 1);
                                    z *= 4503599627370496;
                                    e = 52 - e;
                                    if (0 < e) {
                                        multiply(0, z);
                                        j = f;
                                        while (7 <= j) {
                                            multiply(1e7, 0);
                                            j -= 7
                                        }
                                        multiply(pow(10, j, 1), 0);
                                        j = e - 1;
                                        while (23 <= j) {
                                            divide(1 << 23);
                                            j -= 23
                                        }
                                        divide(1 << j);
                                        multiply(1, 1);
                                        divide(2);
                                        m = numToString()
                                    } else {
                                        multiply(0, z);
                                        multiply(1 << -e, 0);
                                        m = numToString() + repeat.call(ZERO, f)
                                    }
                                }
                                if (0 < f) {
                                    k = m.length;
                                    m = s + (k <= f ? "0." + repeat.call(ZERO, f - k) + m : m.slice(0, k - f) + "." + m.slice(k - f))
                                } else {
                                    m = s + m
                                }
                                return m
                            }
                        })
                    }, {
                        "./_a-number-value": 52,
                        "./_export": 81,
                        "./_fails": 83,
                        "./_string-repeat": 155,
                        "./_to-integer": 161
                    }],
                    235: [function(require) {
                        "use strict";
                        var $export = require("./_export"),
                            $fails = require("./_fails"),
                            aNumberValue = require("./_a-number-value"),
                            $toPrecision = 1.toPrecision;
                        $export($export.P + $export.F * ($fails(function() {
                            return "1" !== $toPrecision.call(1, void 0)
                        }) || !$fails(function() {
                            $toPrecision.call({})
                        })), "Number", {
                            toPrecision: function(precision) {
                                var that = aNumberValue(this, "Number#toPrecision: incorrect invocation!");
                                return precision === void 0 ? $toPrecision.call(that) : $toPrecision.call(that, precision)
                            }
                        })
                    }, {
                        "./_a-number-value": 52,
                        "./_export": 81,
                        "./_fails": 83
                    }],
                    236: [function(require) {
                        var $export = require("./_export");
                        $export($export.S + $export.F, "Object", {
                            assign: require("./_object-assign")
                        })
                    }, {
                        "./_export": 81,
                        "./_object-assign": 117
                    }],
                    237: [function(require) {
                        var $export = require("./_export");
                        $export($export.S, "Object", {
                            create: require("./_object-create")
                        })
                    }, {
                        "./_export": 81,
                        "./_object-create": 118
                    }],
                    238: [function(require) {
                        var $export = require("./_export");
                        $export($export.S + $export.F * !require("./_descriptors"), "Object", {
                            defineProperties: require("./_object-dps")
                        })
                    }, {
                        "./_descriptors": 77,
                        "./_export": 81,
                        "./_object-dps": 120
                    }],
                    239: [function(require) {
                        var $export = require("./_export");
                        $export($export.S + $export.F * !require("./_descriptors"), "Object", {
                            defineProperty: require("./_object-dp").f
                        })
                    }, {
                        "./_descriptors": 77,
                        "./_export": 81,
                        "./_object-dp": 119
                    }],
                    240: [function(require) {
                        var isObject = require("./_is-object"),
                            meta = require("./_meta").onFreeze;
                        require("./_object-sap")("freeze", function($freeze) {
                            return function(it) {
                                return $freeze && isObject(it) ? $freeze(meta(it)) : it
                            }
                        })
                    }, {
                        "./_is-object": 99,
                        "./_meta": 113,
                        "./_object-sap": 130
                    }],
                    241: [function(require) {
                        var toIObject = require("./_to-iobject"),
                            $getOwnPropertyDescriptor = require("./_object-gopd").f;
                        require("./_object-sap")("getOwnPropertyDescriptor", function() {
                            return function(it, key) {
                                return $getOwnPropertyDescriptor(toIObject(it), key)
                            }
                        })
                    }, {
                        "./_object-gopd": 122,
                        "./_object-sap": 130,
                        "./_to-iobject": 162
                    }],
                    242: [function(require) {
                        require("./_object-sap")("getOwnPropertyNames", function() {
                            return require("./_object-gopn-ext").f
                        })
                    }, {
                        "./_object-gopn-ext": 123,
                        "./_object-sap": 130
                    }],
                    243: [function(require) {
                        var toObject = require("./_to-object"),
                            $getPrototypeOf = require("./_object-gpo");
                        require("./_object-sap")("getPrototypeOf", function() {
                            return function(it) {
                                return $getPrototypeOf(toObject(it))
                            }
                        })
                    }, {
                        "./_object-gpo": 126,
                        "./_object-sap": 130,
                        "./_to-object": 164
                    }],
                    244: [function(require) {
                        var isObject = require("./_is-object");
                        require("./_object-sap")("isExtensible", function($isExtensible) {
                            return function(it) {
                                return isObject(it) ? $isExtensible ? $isExtensible(it) : !0 : !1
                            }
                        })
                    }, {
                        "./_is-object": 99,
                        "./_object-sap": 130
                    }],
                    245: [function(require) {
                        var isObject = require("./_is-object");
                        require("./_object-sap")("isFrozen", function($isFrozen) {
                            return function(it) {
                                return isObject(it) ? $isFrozen ? $isFrozen(it) : !1 : !0
                            }
                        })
                    }, {
                        "./_is-object": 99,
                        "./_object-sap": 130
                    }],
                    246: [function(require) {
                        var isObject = require("./_is-object");
                        require("./_object-sap")("isSealed", function($isSealed) {
                            return function(it) {
                                return isObject(it) ? $isSealed ? $isSealed(it) : !1 : !0
                            }
                        })
                    }, {
                        "./_is-object": 99,
                        "./_object-sap": 130
                    }],
                    247: [function(require) {
                        var $export = require("./_export");
                        $export($export.S, "Object", {
                            is: require("./_same-value")
                        })
                    }, {
                        "./_export": 81,
                        "./_same-value": 141
                    }],
                    248: [function(require) {
                        var toObject = require("./_to-object"),
                            $keys = require("./_object-keys");
                        require("./_object-sap")("keys", function() {
                            return function(it) {
                                return $keys(toObject(it))
                            }
                        })
                    }, {
                        "./_object-keys": 128,
                        "./_object-sap": 130,
                        "./_to-object": 164
                    }],
                    249: [function(require) {
                        var isObject = require("./_is-object"),
                            meta = require("./_meta").onFreeze;
                        require("./_object-sap")("preventExtensions", function($preventExtensions) {
                            return function(it) {
                                return $preventExtensions && isObject(it) ? $preventExtensions(meta(it)) : it
                            }
                        })
                    }, {
                        "./_is-object": 99,
                        "./_meta": 113,
                        "./_object-sap": 130
                    }],
                    250: [function(require) {
                        var isObject = require("./_is-object"),
                            meta = require("./_meta").onFreeze;
                        require("./_object-sap")("seal", function($seal) {
                            return function(it) {
                                return $seal && isObject(it) ? $seal(meta(it)) : it
                            }
                        })
                    }, {
                        "./_is-object": 99,
                        "./_meta": 113,
                        "./_object-sap": 130
                    }],
                    251: [function(require) {
                        var $export = require("./_export");
                        $export($export.S, "Object", {
                            setPrototypeOf: require("./_set-proto").set
                        })
                    }, {
                        "./_export": 81,
                        "./_set-proto": 144
                    }],
                    252: [function(require) {
                        "use strict";
                        var classof = require("./_classof"),
                            test = {};
                        test[require("./_wks")("toStringTag")] = "z";
                        if ("[object z]" != test + "") {
                            require("./_redefine")(Object.prototype, "toString", function() {
                                return "[object " + classof(this) + "]"
                            }, !0)
                        }
                    }, {
                        "./_classof": 65,
                        "./_redefine": 139,
                        "./_wks": 174
                    }],
                    253: [function(require) {
                        var $export = require("./_export"),
                            $parseFloat = require("./_parse-float");
                        $export($export.G + $export.F * (parseFloat != $parseFloat), {
                            parseFloat: $parseFloat
                        })
                    }, {
                        "./_export": 81,
                        "./_parse-float": 133
                    }],
                    254: [function(require) {
                        var $export = require("./_export"),
                            $parseInt = require("./_parse-int");
                        $export($export.G + $export.F * (parseInt != $parseInt), {
                            parseInt: $parseInt
                        })
                    }, {
                        "./_export": 81,
                        "./_parse-int": 134
                    }],
                    255: [function(require) {
                        "use strict";
                        var LIBRARY = require("./_library"),
                            global = require("./_global"),
                            ctx = require("./_ctx"),
                            classof = require("./_classof"),
                            $export = require("./_export"),
                            isObject = require("./_is-object"),
                            aFunction = require("./_a-function"),
                            anInstance = require("./_an-instance"),
                            forOf = require("./_for-of"),
                            speciesConstructor = require("./_species-constructor"),
                            task = require("./_task").set,
                            microtask = require("./_microtask")(),
                            newPromiseCapabilityModule = require("./_new-promise-capability"),
                            perform = require("./_perform"),
                            promiseResolve = require("./_promise-resolve"),
                            PROMISE = "Promise",
                            TypeError = global.TypeError,
                            process = global.process,
                            $Promise = global[PROMISE],
                            isNode = "process" == classof(process),
                            empty = function() {},
                            Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper, newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f,
                            USE_NATIVE = !! function() {
                                try {
                                    var promise = $Promise.resolve(1),
                                        FakePromise = (promise.constructor = {})[require("./_wks")("species")] = function(exec) {
                                            exec(empty, empty)
                                        };
                                    return (isNode || "function" == typeof PromiseRejectionEvent) && promise.then(empty) instanceof FakePromise
                                } catch (e) {}
                            }(),
                            isThenable = function(it) {
                                var then;
                                return isObject(it) && "function" == typeof(then = it.then) ? then : !1
                            },
                            notify = function(promise, isReject) {
                                if (promise._n) return;
                                promise._n = !0;
                                var chain = promise._c;
                                microtask(function() {
                                    var value = promise._v,
                                        ok = 1 == promise._s,
                                        i = 0,
                                        run = function(reaction) {
                                            var handler = ok ? reaction.ok : reaction.fail,
                                                resolve = reaction.resolve,
                                                reject = reaction.reject,
                                                domain = reaction.domain,
                                                result, then;
                                            try {
                                                if (handler) {
                                                    if (!ok) {
                                                        if (2 == promise._h) onHandleUnhandled(promise);
                                                        promise._h = 1
                                                    }
                                                    if (!0 === handler) result = value;
                                                    else {
                                                        if (domain) domain.enter();
                                                        result = handler(value);
                                                        if (domain) domain.exit()
                                                    }
                                                    if (result === reaction.promise) {
                                                        reject(TypeError("Promise-chain cycle"))
                                                    } else if (then = isThenable(result)) {
                                                        then.call(result, resolve, reject)
                                                    } else resolve(result)
                                                } else reject(value)
                                            } catch (e) {
                                                reject(e)
                                            }
                                        };
                                    while (chain.length > i) run(chain[i++]);
                                    promise._c = [];
                                    promise._n = !1;
                                    if (isReject && !promise._h) onUnhandled(promise)
                                })
                            },
                            onUnhandled = function(promise) {
                                task.call(global, function() {
                                    var value = promise._v,
                                        unhandled = isUnhandled(promise),
                                        result, handler, console;
                                    if (unhandled) {
                                        result = perform(function() {
                                            if (isNode) {
                                                process.emit("unhandledRejection", value, promise)
                                            } else if (handler = global.onunhandledrejection) {
                                                handler({
                                                    promise: promise,
                                                    reason: value
                                                })
                                            } else if ((console = global.console) && console.error) {
                                                console.error("Unhandled promise rejection", value)
                                            }
                                        });
                                        promise._h = isNode || isUnhandled(promise) ? 2 : 1
                                    }
                                    promise._a = void 0;
                                    if (unhandled && result.e) throw result.v
                                })
                            },
                            isUnhandled = function(promise) {
                                return 1 !== promise._h && 0 === (promise._a || promise._c).length
                            },
                            onHandleUnhandled = function(promise) {
                                task.call(global, function() {
                                    var handler;
                                    if (isNode) {
                                        process.emit("rejectionHandled", promise)
                                    } else if (handler = global.onrejectionhandled) {
                                        handler({
                                            promise: promise,
                                            reason: promise._v
                                        })
                                    }
                                })
                            },
                            $reject = function(value) {
                                var promise = this;
                                if (promise._d) return;
                                promise._d = !0;
                                promise = promise._w || promise;
                                promise._v = value;
                                promise._s = 2;
                                if (!promise._a) promise._a = promise._c.slice();
                                notify(promise, !0)
                            },
                            $resolve = function(value) {
                                var promise = this,
                                    then;
                                if (promise._d) return;
                                promise._d = !0;
                                promise = promise._w || promise;
                                try {
                                    if (promise === value) throw TypeError("Promise can't be resolved itself");
                                    if (then = isThenable(value)) {
                                        microtask(function() {
                                            var wrapper = {
                                                _w: promise,
                                                _d: !1
                                            };
                                            try {
                                                then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1))
                                            } catch (e) {
                                                $reject.call(wrapper, e)
                                            }
                                        })
                                    } else {
                                        promise._v = value;
                                        promise._s = 1;
                                        notify(promise, !1)
                                    }
                                } catch (e) {
                                    $reject.call({
                                        _w: promise,
                                        _d: !1
                                    }, e)
                                }
                            };
                        if (!USE_NATIVE) {
                            $Promise = function(executor) {
                                anInstance(this, $Promise, PROMISE, "_h");
                                aFunction(executor);
                                Internal.call(this);
                                try {
                                    executor(ctx($resolve, this, 1), ctx($reject, this, 1))
                                } catch (err) {
                                    $reject.call(this, err)
                                }
                            };
                            Internal = function() {
                                this._c = [];
                                this._a = void 0;
                                this._s = 0;
                                this._d = !1;
                                this._v = void 0;
                                this._h = 0;
                                this._n = !1
                            };
                            Internal.prototype = require("./_redefine-all")($Promise.prototype, {
                                then: function(onFulfilled, onRejected) {
                                    var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
                                    reaction.ok = "function" == typeof onFulfilled ? onFulfilled : !0;
                                    reaction.fail = "function" == typeof onRejected && onRejected;
                                    reaction.domain = isNode ? process.domain : void 0;
                                    this._c.push(reaction);
                                    if (this._a) this._a.push(reaction);
                                    if (this._s) notify(this, !1);
                                    return reaction.promise
                                },
                                catch: function(onRejected) {
                                    return this.then(void 0, onRejected)
                                }
                            });
                            OwnPromiseCapability = function() {
                                var promise = new Internal;
                                this.promise = promise;
                                this.resolve = ctx($resolve, promise, 1);
                                this.reject = ctx($reject, promise, 1)
                            };
                            newPromiseCapabilityModule.f = newPromiseCapability = function(C) {
                                return C === $Promise || C === Wrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C)
                            }
                        }
                        $export($export.G + $export.W + $export.F * !USE_NATIVE, {
                            Promise: $Promise
                        });
                        require("./_set-to-string-tag")($Promise, PROMISE);
                        require("./_set-species")(PROMISE);
                        Wrapper = require("./_core")[PROMISE];
                        $export($export.S + $export.F * !USE_NATIVE, PROMISE, {
                            reject: function(r) {
                                var capability = newPromiseCapability(this),
                                    $$reject = capability.reject;
                                $$reject(r);
                                return capability.promise
                            }
                        });
                        $export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
                            resolve: function(x) {
                                return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x)
                            }
                        });
                        $export($export.S + $export.F * !(USE_NATIVE && require("./_iter-detect")(function(iter) {
                            $Promise.all(iter)["catch"](empty)
                        })), PROMISE, {
                            all: function(iterable) {
                                var C = this,
                                    capability = newPromiseCapability(C),
                                    resolve = capability.resolve,
                                    reject = capability.reject,
                                    result = perform(function() {
                                        var values = [],
                                            index = 0,
                                            remaining = 1;
                                        forOf(iterable, !1, function(promise) {
                                            var $index = index++,
                                                alreadyCalled = !1;
                                            values.push(void 0);
                                            remaining++;
                                            C.resolve(promise).then(function(value) {
                                                if (alreadyCalled) return;
                                                alreadyCalled = !0;
                                                values[$index] = value;
                                                --remaining || resolve(values)
                                            }, reject)
                                        });
                                        --remaining || resolve(values)
                                    });
                                if (result.e) reject(result.v);
                                return capability.promise
                            },
                            race: function(iterable) {
                                var C = this,
                                    capability = newPromiseCapability(C),
                                    reject = capability.reject,
                                    result = perform(function() {
                                        forOf(iterable, !1, function(promise) {
                                            C.resolve(promise).then(capability.resolve, reject)
                                        })
                                    });
                                if (result.e) reject(result.v);
                                return capability.promise
                            }
                        })
                    }, {
                        "./_a-function": 51,
                        "./_an-instance": 54,
                        "./_classof": 65,
                        "./_core": 71,
                        "./_ctx": 73,
                        "./_export": 81,
                        "./_for-of": 87,
                        "./_global": 88,
                        "./_is-object": 99,
                        "./_iter-detect": 104,
                        "./_library": 107,
                        "./_microtask": 115,
                        "./_new-promise-capability": 116,
                        "./_perform": 135,
                        "./_promise-resolve": 136,
                        "./_redefine-all": 138,
                        "./_set-species": 145,
                        "./_set-to-string-tag": 146,
                        "./_species-constructor": 149,
                        "./_task": 158,
                        "./_wks": 174
                    }],
                    256: [function(require) {
                        var $export = require("./_export"),
                            aFunction = require("./_a-function"),
                            anObject = require("./_an-object"),
                            rApply = (require("./_global").Reflect || {}).apply,
                            fApply = Function.apply;
                        $export($export.S + $export.F * !require("./_fails")(function() {
                            rApply(function() {})
                        }), "Reflect", {
                            apply: function(target, thisArgument, argumentsList) {
                                var T = aFunction(target),
                                    L = anObject(argumentsList);
                                return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L)
                            }
                        })
                    }, {
                        "./_a-function": 51,
                        "./_an-object": 55,
                        "./_export": 81,
                        "./_fails": 83,
                        "./_global": 88
                    }],
                    257: [function(require) {
                        var $export = require("./_export"),
                            create = require("./_object-create"),
                            aFunction = require("./_a-function"),
                            anObject = require("./_an-object"),
                            isObject = require("./_is-object"),
                            fails = require("./_fails"),
                            bind = require("./_bind"),
                            rConstruct = (require("./_global").Reflect || {}).construct,
                            NEW_TARGET_BUG = fails(function() {
                                function F() {}
                                return !(rConstruct(function() {}, [], F) instanceof F)
                            }),
                            ARGS_BUG = !fails(function() {
                                rConstruct(function() {})
                            });
                        $export($export.S + $export.F * (NEW_TARGET_BUG || ARGS_BUG), "Reflect", {
                            construct: function(Target, args) {
                                aFunction(Target);
                                anObject(args);
                                var newTarget = 3 > arguments.length ? Target : aFunction(arguments[2]);
                                if (ARGS_BUG && !NEW_TARGET_BUG) return rConstruct(Target, args, newTarget);
                                if (Target == newTarget) {
                                    switch (args.length) {
                                        case 0:
                                            return new Target;
                                        case 1:
                                            return new Target(args[0]);
                                        case 2:
                                            return new Target(args[0], args[1]);
                                        case 3:
                                            return new Target(args[0], args[1], args[2]);
                                        case 4:
                                            return new Target(args[0], args[1], args[2], args[3]);
                                    }
                                    var $args = [null];
                                    $args.push.apply($args, args);
                                    return new(bind.apply(Target, $args))
                                }
                                var proto = newTarget.prototype,
                                    instance = create(isObject(proto) ? proto : Object.prototype),
                                    result = Function.apply.call(Target, instance, args);
                                return isObject(result) ? result : instance
                            }
                        })
                    }, {
                        "./_a-function": 51,
                        "./_an-object": 55,
                        "./_bind": 64,
                        "./_export": 81,
                        "./_fails": 83,
                        "./_global": 88,
                        "./_is-object": 99,
                        "./_object-create": 118
                    }],
                    258: [function(require) {
                        var dP = require("./_object-dp"),
                            $export = require("./_export"),
                            anObject = require("./_an-object"),
                            toPrimitive = require("./_to-primitive");
                        $export($export.S + $export.F * require("./_fails")(function() {
                            Reflect.defineProperty(dP.f({}, 1, {
                                value: 1
                            }), 1, {
                                value: 2
                            })
                        }), "Reflect", {
                            defineProperty: function(target, propertyKey, attributes) {
                                anObject(target);
                                propertyKey = toPrimitive(propertyKey, !0);
                                anObject(attributes);
                                try {
                                    dP.f(target, propertyKey, attributes);
                                    return !0
                                } catch (e) {
                                    return !1
                                }
                            }
                        })
                    }, {
                        "./_an-object": 55,
                        "./_export": 81,
                        "./_fails": 83,
                        "./_object-dp": 119,
                        "./_to-primitive": 165
                    }],
                    259: [function(require) {
                        var $export = require("./_export"),
                            gOPD = require("./_object-gopd").f,
                            anObject = require("./_an-object");
                        $export($export.S, "Reflect", {
                            deleteProperty: function(target, propertyKey) {
                                var desc = gOPD(anObject(target), propertyKey);
                                return desc && !desc.configurable ? !1 : delete target[propertyKey]
                            }
                        })
                    }, {
                        "./_an-object": 55,
                        "./_export": 81,
                        "./_object-gopd": 122
                    }],
                    260: [function(require) {
                        "use strict";
                        var $export = require("./_export"),
                            anObject = require("./_an-object"),
                            Enumerate = function(iterated) {
                                this._t = anObject(iterated);
                                this._i = 0;
                                var keys = this._k = [],
                                    key;
                                for (key in iterated) keys.push(key)
                            };
                        require("./_iter-create")(Enumerate, "Object", function() {
                            var that = this,
                                keys = that._k,
                                key;
                            do {
                                if (that._i >= keys.length) return {
                                    value: void 0,
                                    done: !0
                                }
                            } while (!((key = keys[that._i++]) in that._t));
                            return {
                                value: key,
                                done: !1
                            }
                        });
                        $export($export.S, "Reflect", {
                            enumerate: function(target) {
                                return new Enumerate(target)
                            }
                        })
                    }, {
                        "./_an-object": 55,
                        "./_export": 81,
                        "./_iter-create": 102
                    }],
                    261: [function(require) {
                        var gOPD = require("./_object-gopd"),
                            $export = require("./_export"),
                            anObject = require("./_an-object");
                        $export($export.S, "Reflect", {
                            getOwnPropertyDescriptor: function(target, propertyKey) {
                                return gOPD.f(anObject(target), propertyKey)
                            }
                        })
                    }, {
                        "./_an-object": 55,
                        "./_export": 81,
                        "./_object-gopd": 122
                    }],
                    262: [function(require) {
                        var $export = require("./_export"),
                            getProto = require("./_object-gpo"),
                            anObject = require("./_an-object");
                        $export($export.S, "Reflect", {
                            getPrototypeOf: function(target) {
                                return getProto(anObject(target))
                            }
                        })
                    }, {
                        "./_an-object": 55,
                        "./_export": 81,
                        "./_object-gpo": 126
                    }],
                    263: [function(require) {
                        var gOPD = require("./_object-gopd"),
                            getPrototypeOf = require("./_object-gpo"),
                            has = require("./_has"),
                            $export = require("./_export"),
                            isObject = require("./_is-object"),
                            anObject = require("./_an-object");

                        function get(target, propertyKey) {
                            var receiver = 3 > arguments.length ? target : arguments[2],
                                desc, proto;
                            if (anObject(target) === receiver) return target[propertyKey];
                            if (desc = gOPD.f(target, propertyKey)) return has(desc, "value") ? desc.value : desc.get !== void 0 ? desc.get.call(receiver) : void 0;
                            if (isObject(proto = getPrototypeOf(target))) return get(proto, propertyKey, receiver)
                        }
                        $export($export.S, "Reflect", {
                            get: get
                        })
                    }, {
                        "./_an-object": 55,
                        "./_export": 81,
                        "./_has": 89,
                        "./_is-object": 99,
                        "./_object-gopd": 122,
                        "./_object-gpo": 126
                    }],
                    264: [function(require) {
                        var $export = require("./_export");
                        $export($export.S, "Reflect", {
                            has: function(target, propertyKey) {
                                return propertyKey in target
                            }
                        })
                    }, {
                        "./_export": 81
                    }],
                    265: [function(require) {
                        var $export = require("./_export"),
                            anObject = require("./_an-object"),
                            $isExtensible = Object.isExtensible;
                        $export($export.S, "Reflect", {
                            isExtensible: function(target) {
                                anObject(target);
                                return $isExtensible ? $isExtensible(target) : !0
                            }
                        })
                    }, {
                        "./_an-object": 55,
                        "./_export": 81
                    }],
                    266: [function(require) {
                        var $export = require("./_export");
                        $export($export.S, "Reflect", {
                            ownKeys: require("./_own-keys")
                        })
                    }, {
                        "./_export": 81,
                        "./_own-keys": 132
                    }],
                    267: [function(require) {
                        var $export = require("./_export"),
                            anObject = require("./_an-object"),
                            $preventExtensions = Object.preventExtensions;
                        $export($export.S, "Reflect", {
                            preventExtensions: function(target) {
                                anObject(target);
                                try {
                                    if ($preventExtensions) $preventExtensions(target);
                                    return !0
                                } catch (e) {
                                    return !1
                                }
                            }
                        })
                    }, {
                        "./_an-object": 55,
                        "./_export": 81
                    }],
                    268: [function(require) {
                        var $export = require("./_export"),
                            setProto = require("./_set-proto");
                        if (setProto) $export($export.S, "Reflect", {
                            setPrototypeOf: function(target, proto) {
                                setProto.check(target, proto);
                                try {
                                    setProto.set(target, proto);
                                    return !0
                                } catch (e) {
                                    return !1
                                }
                            }
                        })
                    }, {
                        "./_export": 81,
                        "./_set-proto": 144
                    }],
                    269: [function(require) {
                        var dP = require("./_object-dp"),
                            gOPD = require("./_object-gopd"),
                            getPrototypeOf = require("./_object-gpo"),
                            has = require("./_has"),
                            $export = require("./_export"),
                            createDesc = require("./_property-desc"),
                            anObject = require("./_an-object"),
                            isObject = require("./_is-object");

                        function set(target, propertyKey, V) {
                            var receiver = 4 > arguments.length ? target : arguments[3],
                                ownDesc = gOPD.f(anObject(target), propertyKey),
                                existingDescriptor, proto;
                            if (!ownDesc) {
                                if (isObject(proto = getPrototypeOf(target))) {
                                    return set(proto, propertyKey, V, receiver)
                                }
                                ownDesc = createDesc(0)
                            }
                            if (has(ownDesc, "value")) {
                                if (!1 === ownDesc.writable || !isObject(receiver)) return !1;
                                existingDescriptor = gOPD.f(receiver, propertyKey) || createDesc(0);
                                existingDescriptor.value = V;
                                dP.f(receiver, propertyKey, existingDescriptor);
                                return !0
                            }
                            return ownDesc.set === void 0 ? !1 : (ownDesc.set.call(receiver, V), !0)
                        }
                        $export($export.S, "Reflect", {
                            set: set
                        })
                    }, {
                        "./_an-object": 55,
                        "./_export": 81,
                        "./_has": 89,
                        "./_is-object": 99,
                        "./_object-dp": 119,
                        "./_object-gopd": 122,
                        "./_object-gpo": 126,
                        "./_property-desc": 137
                    }],
                    270: [function(require) {
                        var global = require("./_global"),
                            inheritIfRequired = require("./_inherit-if-required"),
                            dP = require("./_object-dp").f,
                            gOPN = require("./_object-gopn").f,
                            isRegExp = require("./_is-regexp"),
                            $flags = require("./_flags"),
                            $RegExp = global.RegExp,
                            Base = $RegExp,
                            proto = $RegExp.prototype,
                            re1 = /a/g,
                            re2 = /a/g,
                            CORRECT_NEW = new $RegExp(re1) !== re1;
                        if (require("./_descriptors") && (!CORRECT_NEW || require("./_fails")(function() {
                                re2[require("./_wks")("match")] = !1;
                                return $RegExp(re1) != re1 || $RegExp(re2) == re2 || "/a/i" != $RegExp(re1, "i")
                            }))) {
                            $RegExp = function(p, f) {
                                var tiRE = this instanceof $RegExp,
                                    piRE = isRegExp(p),
                                    fiU = f === void 0;
                                return !tiRE && piRE && p.constructor === $RegExp && fiU ? p : inheritIfRequired(CORRECT_NEW ? new Base(piRE && !fiU ? p.source : p, f) : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? $flags.call(p) : f), tiRE ? this : proto, $RegExp)
                            };
                            for (var proxy = function(key) {
                                    (key in $RegExp) || dP($RegExp, key, {
                                        configurable: !0,
                                        get: function() {
                                            return Base[key]
                                        },
                                        set: function(it) {
                                            Base[key] = it
                                        }
                                    })
                                }, keys = gOPN(Base), i = 0; keys.length > i;) proxy(keys[i++]);
                            proto.constructor = $RegExp;
                            $RegExp.prototype = proto;
                            require("./_redefine")(global, "RegExp", $RegExp)
                        }
                        require("./_set-species")("RegExp")
                    }, {
                        "./_descriptors": 77,
                        "./_fails": 83,
                        "./_flags": 85,
                        "./_global": 88,
                        "./_inherit-if-required": 93,
                        "./_is-regexp": 100,
                        "./_object-dp": 119,
                        "./_object-gopn": 124,
                        "./_redefine": 139,
                        "./_set-species": 145,
                        "./_wks": 174
                    }],
                    271: [function(require) {
                        if (require("./_descriptors") && "g" != /./g.flags) require("./_object-dp").f(RegExp.prototype, "flags", {
                            configurable: !0,
                            get: require("./_flags")
                        })
                    }, {
                        "./_descriptors": 77,
                        "./_flags": 85,
                        "./_object-dp": 119
                    }],
                    272: [function(require) {
                        require("./_fix-re-wks")("match", 1, function(defined, MATCH, $match) {
                            return [function(regexp) {
                                "use strict";
                                var O = defined(this),
                                    fn = regexp == void 0 ? void 0 : regexp[MATCH];
                                return fn !== void 0 ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](O + "")
                            }, $match]
                        })
                    }, {
                        "./_fix-re-wks": 84
                    }],
                    273: [function(require) {
                        require("./_fix-re-wks")("replace", 2, function(defined, REPLACE, $replace) {
                            return [function(searchValue, replaceValue) {
                                "use strict";
                                var O = defined(this),
                                    fn = searchValue == void 0 ? void 0 : searchValue[REPLACE];
                                return fn !== void 0 ? fn.call(searchValue, O, replaceValue) : $replace.call(O + "", searchValue, replaceValue)
                            }, $replace]
                        })
                    }, {
                        "./_fix-re-wks": 84
                    }],
                    274: [function(require) {
                        require("./_fix-re-wks")("search", 1, function(defined, SEARCH, $search) {
                            return [function(regexp) {
                                "use strict";
                                var O = defined(this),
                                    fn = regexp == void 0 ? void 0 : regexp[SEARCH];
                                return fn !== void 0 ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](O + "")
                            }, $search]
                        })
                    }, {
                        "./_fix-re-wks": 84
                    }],
                    275: [function(require) {
                        require("./_fix-re-wks")("split", 2, function(defined, SPLIT, $split) {
                            "use strict";
                            var isRegExp = require("./_is-regexp"),
                                _split = $split,
                                $push = [].push,
                                $SPLIT = "split",
                                LENGTH = "length",
                                LAST_INDEX = "lastIndex";
                            if ("c" == "abbc" [$SPLIT](/(b)*/)[1] || 4 != "test" [$SPLIT](/(?:)/, -1)[LENGTH] || 2 != "ab" [$SPLIT](/(?:ab)*/)[LENGTH] || 4 != "." [$SPLIT](/(.?)(.?)/)[LENGTH] || 1 < "." [$SPLIT](/()()/)[LENGTH] || "" [$SPLIT](/.?/)[LENGTH]) {
                                var NPCG = /()??/.exec("")[1] === void 0;
                                $split = function(separator, limit) {
                                    var string = this + "";
                                    if (separator === void 0 && 0 === limit) return [];
                                    if (!isRegExp(separator)) return _split.call(string, separator, limit);
                                    var output = [],
                                        flags = (separator.ignoreCase ? "i" : "") + (separator.multiline ? "m" : "") + (separator.unicode ? "u" : "") + (separator.sticky ? "y" : ""),
                                        lastLastIndex = 0,
                                        splitLimit = limit === void 0 ? 4294967295 : limit >>> 0,
                                        separatorCopy = new RegExp(separator.source, flags + "g"),
                                        separator2, match, lastIndex, lastLength, i;
                                    if (!NPCG) separator2 = new RegExp("^" + separatorCopy.source + "$(?!\\s)", flags);
                                    while (match = separatorCopy.exec(string)) {
                                        lastIndex = match.index + match[0][LENGTH];
                                        if (lastIndex > lastLastIndex) {
                                            output.push(string.slice(lastLastIndex, match.index));
                                            if (!NPCG && 1 < match[LENGTH]) match[0].replace(separator2, function() {
                                                for (i = 1; i < arguments[LENGTH] - 2; i++)
                                                    if (arguments[i] === void 0) match[i] = void 0
                                            });
                                            if (1 < match[LENGTH] && match.index < string[LENGTH]) $push.apply(output, match.slice(1));
                                            lastLength = match[0][LENGTH];
                                            lastLastIndex = lastIndex;
                                            if (output[LENGTH] >= splitLimit) break
                                        }
                                        if (separatorCopy[LAST_INDEX] === match.index) separatorCopy[LAST_INDEX]++
                                    }
                                    if (lastLastIndex === string[LENGTH]) {
                                        if (lastLength || !separatorCopy.test("")) output.push("")
                                    } else output.push(string.slice(lastLastIndex));
                                    return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output
                                }
                            } else if ("0" [$SPLIT](void 0, 0)[LENGTH]) {
                                $split = function(separator, limit) {
                                    return separator === void 0 && 0 === limit ? [] : _split.call(this, separator, limit)
                                }
                            }
                            return [function(separator, limit) {
                                var O = defined(this),
                                    fn = separator == void 0 ? void 0 : separator[SPLIT];
                                return fn !== void 0 ? fn.call(separator, O, limit) : $split.call(O + "", separator, limit)
                            }, $split]
                        })
                    }, {
                        "./_fix-re-wks": 84,
                        "./_is-regexp": 100
                    }],
                    276: [function(require) {
                        "use strict";
                        require("./es6.regexp.flags");
                        var anObject = require("./_an-object"),
                            $flags = require("./_flags"),
                            DESCRIPTORS = require("./_descriptors"),
                            TO_STRING = "toString",
                            $toString = /./ [TO_STRING],
                            define = function(fn) {
                                require("./_redefine")(RegExp.prototype, TO_STRING, fn, !0)
                            };
                        if (require("./_fails")(function() {
                                return "/a/b" != $toString.call({
                                    source: "a",
                                    flags: "b"
                                })
                            })) {
                            define(function() {
                                var R = anObject(this);
                                return "/".concat(R.source, "/", "flags" in R ? R.flags : !DESCRIPTORS && R instanceof RegExp ? $flags.call(R) : void 0)
                            })
                        } else if ($toString.name != TO_STRING) {
                            define(function() {
                                return $toString.call(this)
                            })
                        }
                    }, {
                        "./_an-object": 55,
                        "./_descriptors": 77,
                        "./_fails": 83,
                        "./_flags": 85,
                        "./_redefine": 139,
                        "./es6.regexp.flags": 271
                    }],
                    277: [function(require, module) {
                        "use strict";
                        var strong = require("./_collection-strong"),
                            validate = require("./_validate-collection"),
                            SET = "Set";
                        module.exports = require("./_collection")(SET, function(get) {
                            return function() {
                                return get(this, 0 < arguments.length ? arguments[0] : void 0)
                            }
                        }, {
                            add: function(value) {
                                return strong.def(validate(this, SET), value = 0 === value ? 0 : value, value)
                            }
                        }, strong)
                    }, {
                        "./_collection": 70,
                        "./_collection-strong": 67,
                        "./_validate-collection": 171
                    }],
                    278: [function(require) {
                        "use strict";
                        require("./_string-html")("anchor", function(createHTML) {
                            return function(name) {
                                return createHTML(this, "a", "name", name)
                            }
                        })
                    }, {
                        "./_string-html": 153
                    }],
                    279: [function(require) {
                        "use strict";
                        require("./_string-html")("big", function(createHTML) {
                            return function() {
                                return createHTML(this, "big", "", "")
                            }
                        })
                    }, {
                        "./_string-html": 153
                    }],
                    280: [function(require) {
                        "use strict";
                        require("./_string-html")("blink", function(createHTML) {
                            return function() {
                                return createHTML(this, "blink", "", "")
                            }
                        })
                    }, {
                        "./_string-html": 153
                    }],
                    281: [function(require) {
                        "use strict";
                        require("./_string-html")("bold", function(createHTML) {
                            return function() {
                                return createHTML(this, "b", "", "")
                            }
                        })
                    }, {
                        "./_string-html": 153
                    }],
                    282: [function(require) {
                        "use strict";
                        var $export = require("./_export"),
                            $at = require("./_string-at")(!1);
                        $export($export.P, "String", {
                            codePointAt: function(pos) {
                                return $at(this, pos)
                            }
                        })
                    }, {
                        "./_export": 81,
                        "./_string-at": 151
                    }],
                    283: [function(require) {
                        "use strict";
                        var $export = require("./_export"),
                            toLength = require("./_to-length"),
                            context = require("./_string-context"),
                            ENDS_WITH = "endsWith",
                            $endsWith = "" [ENDS_WITH];
                        $export($export.P + $export.F * require("./_fails-is-regexp")(ENDS_WITH), "String", {
                            endsWith: function(searchString) {
                                var that = context(this, searchString, ENDS_WITH),
                                    endPosition = 1 < arguments.length ? arguments[1] : void 0,
                                    len = toLength(that.length),
                                    end = endPosition === void 0 ? len : _Mathmin(toLength(endPosition), len),
                                    search = searchString + "";
                                return that.slice(end - search.length, end) === search
                            }
                        })
                    }, {
                        "./_export": 81,
                        "./_fails-is-regexp": 82,
                        "./_string-context": 152,
                        "./_to-length": 163
                    }],
                    284: [function(require) {
                        "use strict";
                        require("./_string-html")("fixed", function(createHTML) {
                            return function() {
                                return createHTML(this, "tt", "", "")
                            }
                        })
                    }, {
                        "./_string-html": 153
                    }],
                    285: [function(require) {
                        "use strict";
                        require("./_string-html")("fontcolor", function(createHTML) {
                            return function(color) {
                                return createHTML(this, "font", "color", color)
                            }
                        })
                    }, {
                        "./_string-html": 153
                    }],
                    286: [function(require) {
                        "use strict";
                        require("./_string-html")("fontsize", function(createHTML) {
                            return function(size) {
                                return createHTML(this, "font", "size", size)
                            }
                        })
                    }, {
                        "./_string-html": 153
                    }],
                    287: [function(require) {
                        var $export = require("./_export"),
                            toAbsoluteIndex = require("./_to-absolute-index"),
                            fromCharCode = _StringfromCharCode,
                            $fromCodePoint = String.fromCodePoint;
                        $export($export.S + $export.F * (!!$fromCodePoint && 1 != $fromCodePoint.length), "String", {
                            fromCodePoint: function() {
                                var res = [],
                                    aLen = arguments.length,
                                    i = 0,
                                    code;
                                while (aLen > i) {
                                    code = +arguments[i++];
                                    if (toAbsoluteIndex(code, 1114111) !== code) throw RangeError(code + " is not a valid code point");
                                    res.push(65536 > code ? fromCharCode(code) : fromCharCode(((code -= 65536) >> 10) + 55296, code % 1024 + 56320))
                                }
                                return res.join("")
                            }
                        })
                    }, {
                        "./_export": 81,
                        "./_to-absolute-index": 159
                    }],
                    288: [function(require) {
                        "use strict";
                        var $export = require("./_export"),
                            context = require("./_string-context"),
                            INCLUDES = "includes";
                        $export($export.P + $export.F * require("./_fails-is-regexp")(INCLUDES), "String", {
                            includes: function(searchString) {
                                return !!~context(this, searchString, INCLUDES).indexOf(searchString, 1 < arguments.length ? arguments[1] : void 0)
                            }
                        })
                    }, {
                        "./_export": 81,
                        "./_fails-is-regexp": 82,
                        "./_string-context": 152
                    }],
                    289: [function(require) {
                        "use strict";
                        require("./_string-html")("italics", function(createHTML) {
                            return function() {
                                return createHTML(this, "i", "", "")
                            }
                        })
                    }, {
                        "./_string-html": 153
                    }],
                    290: [function(require) {
                        "use strict";
                        var $at = require("./_string-at")(!0);
                        require("./_iter-define")(String, "String", function(iterated) {
                            this._t = iterated + "";
                            this._i = 0
                        }, function() {
                            var O = this._t,
                                index = this._i,
                                point;
                            if (index >= O.length) return {
                                value: void 0,
                                done: !0
                            };
                            point = $at(O, index);
                            this._i += point.length;
                            return {
                                value: point,
                                done: !1
                            }
                        })
                    }, {
                        "./_iter-define": 103,
                        "./_string-at": 151
                    }],
                    291: [function(require) {
                        "use strict";
                        require("./_string-html")("link", function(createHTML) {
                            return function(url) {
                                return createHTML(this, "a", "href", url)
                            }
                        })
                    }, {
                        "./_string-html": 153
                    }],
                    292: [function(require) {
                        var $export = require("./_export"),
                            toIObject = require("./_to-iobject"),
                            toLength = require("./_to-length");
                        $export($export.S, "String", {
                            raw: function(callSite) {
                                var tpl = toIObject(callSite.raw),
                                    len = toLength(tpl.length),
                                    aLen = arguments.length,
                                    res = [],
                                    i = 0;
                                while (len > i) {
                                    res.push(tpl[i++] + "");
                                    if (i < aLen) res.push(arguments[i] + "")
                                }
                                return res.join("")
                            }
                        })
                    }, {
                        "./_export": 81,
                        "./_to-iobject": 162,
                        "./_to-length": 163
                    }],
                    293: [function(require) {
                        var $export = require("./_export");
                        $export($export.P, "String", {
                            repeat: require("./_string-repeat")
                        })
                    }, {
                        "./_export": 81,
                        "./_string-repeat": 155
                    }],
                    294: [function(require) {
                        "use strict";
                        require("./_string-html")("small", function(createHTML) {
                            return function() {
                                return createHTML(this, "small", "", "")
                            }
                        })
                    }, {
                        "./_string-html": 153
                    }],
                    295: [function(require) {
                        "use strict";
                        var $export = require("./_export"),
                            toLength = require("./_to-length"),
                            context = require("./_string-context"),
                            STARTS_WITH = "startsWith",
                            $startsWith = "" [STARTS_WITH];
                        $export($export.P + $export.F * require("./_fails-is-regexp")(STARTS_WITH), "String", {
                            startsWith: function(searchString) {
                                var that = context(this, searchString, STARTS_WITH),
                                    index = toLength(_Mathmin(1 < arguments.length ? arguments[1] : void 0, that.length)),
                                    search = searchString + "";
                                return that.slice(index, index + search.length) === search
                            }
                        })
                    }, {
                        "./_export": 81,
                        "./_fails-is-regexp": 82,
                        "./_string-context": 152,
                        "./_to-length": 163
                    }],
                    296: [function(require) {
                        "use strict";
                        require("./_string-html")("strike", function(createHTML) {
                            return function() {
                                return createHTML(this, "strike", "", "")
                            }
                        })
                    }, {
                        "./_string-html": 153
                    }],
                    297: [function(require) {
                        "use strict";
                        require("./_string-html")("sub", function(createHTML) {
                            return function() {
                                return createHTML(this, "sub", "", "")
                            }
                        })
                    }, {
                        "./_string-html": 153
                    }],
                    298: [function(require) {
                        "use strict";
                        require("./_string-html")("sup", function(createHTML) {
                            return function() {
                                return createHTML(this, "sup", "", "")
                            }
                        })
                    }, {
                        "./_string-html": 153
                    }],
                    299: [function(require) {
                        "use strict";
                        require("./_string-trim")("trim", function($trim) {
                            return function() {
                                return $trim(this, 3)
                            }
                        })
                    }, {
                        "./_string-trim": 156
                    }],
                    300: [function(require) {
                        "use strict";
                        var global = require("./_global"),
                            has = require("./_has"),
                            DESCRIPTORS = require("./_descriptors"),
                            $export = require("./_export"),
                            redefine = require("./_redefine"),
                            META = require("./_meta").KEY,
                            $fails = require("./_fails"),
                            shared = require("./_shared"),
                            setToStringTag = require("./_set-to-string-tag"),
                            uid = require("./_uid"),
                            wks = require("./_wks"),
                            wksExt = require("./_wks-ext"),
                            wksDefine = require("./_wks-define"),
                            enumKeys = require("./_enum-keys"),
                            isArray = require("./_is-array"),
                            anObject = require("./_an-object"),
                            isObject = require("./_is-object"),
                            toIObject = require("./_to-iobject"),
                            toPrimitive = require("./_to-primitive"),
                            createDesc = require("./_property-desc"),
                            _create = require("./_object-create"),
                            gOPNExt = require("./_object-gopn-ext"),
                            $GOPD = require("./_object-gopd"),
                            $DP = require("./_object-dp"),
                            $keys = require("./_object-keys"),
                            gOPD = $GOPD.f,
                            dP = $DP.f,
                            gOPN = gOPNExt.f,
                            $Symbol = global.Symbol,
                            $JSON = global.JSON,
                            _stringify = $JSON && $JSON.stringify,
                            PROTOTYPE = "prototype",
                            HIDDEN = wks("_hidden"),
                            TO_PRIMITIVE = wks("toPrimitive"),
                            isEnum = {}.propertyIsEnumerable,
                            SymbolRegistry = shared("symbol-registry"),
                            AllSymbols = shared("symbols"),
                            OPSymbols = shared("op-symbols"),
                            ObjectProto = Object[PROTOTYPE],
                            USE_NATIVE = "function" == typeof $Symbol,
                            QObject = global.QObject,
                            setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild,
                            setSymbolDesc = DESCRIPTORS && $fails(function() {
                                return 7 != _create(dP({}, "a", {
                                    get: function() {
                                        return dP(this, "a", {
                                            value: 7
                                        }).a
                                    }
                                })).a
                            }) ? function(it, key, D) {
                                var protoDesc = gOPD(ObjectProto, key);
                                if (protoDesc) delete ObjectProto[key];
                                dP(it, key, D);
                                if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc)
                            } : dP,
                            wrap = function(tag) {
                                var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
                                sym._k = tag;
                                return sym
                            },
                            isSymbol = USE_NATIVE && "symbol" == typeof $Symbol.iterator ? function(it) {
                                return "symbol" == typeof it
                            } : function(it) {
                                return it instanceof $Symbol
                            },
                            $defineProperty = function(it, key, D) {
                                if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
                                anObject(it);
                                key = toPrimitive(key, !0);
                                anObject(D);
                                if (has(AllSymbols, key)) {
                                    if (!D.enumerable) {
                                        if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
                                        it[HIDDEN][key] = !0
                                    } else {
                                        if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = !1;
                                        D = _create(D, {
                                            enumerable: createDesc(0, !1)
                                        })
                                    }
                                    return setSymbolDesc(it, key, D)
                                }
                                return dP(it, key, D)
                            },
                            $defineProperties = function(it, P) {
                                anObject(it);
                                var keys = enumKeys(P = toIObject(P)),
                                    i = 0,
                                    l = keys.length,
                                    key;
                                while (l > i) $defineProperty(it, key = keys[i++], P[key]);
                                return it
                            },
                            $propertyIsEnumerable = function(key) {
                                var E = isEnum.call(this, key = toPrimitive(key, !0));
                                if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return !1;
                                return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : !0
                            },
                            $getOwnPropertyDescriptor = function(it, key) {
                                it = toIObject(it);
                                key = toPrimitive(key, !0);
                                if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
                                var D = gOPD(it, key);
                                if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = !0;
                                return D
                            },
                            $getOwnPropertyNames = function(it) {
                                var names = gOPN(toIObject(it)),
                                    result = [],
                                    i = 0,
                                    key;
                                while (names.length > i) {
                                    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key)
                                }
                                return result
                            },
                            $getOwnPropertySymbols = function(it) {
                                var IS_OP = it === ObjectProto,
                                    names = gOPN(IS_OP ? OPSymbols : toIObject(it)),
                                    result = [],
                                    i = 0,
                                    key;
                                while (names.length > i) {
                                    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : !0)) result.push(AllSymbols[key])
                                }
                                return result
                            };
                        if (!USE_NATIVE) {
                            $Symbol = function() {
                                if (this instanceof $Symbol) throw TypeError("Symbol is not a constructor!");
                                var tag = uid(0 < arguments.length ? arguments[0] : void 0),
                                    $set = function(value) {
                                        if (this === ObjectProto) $set.call(OPSymbols, value);
                                        if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = !1;
                                        setSymbolDesc(this, tag, createDesc(1, value))
                                    };
                                if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, {
                                    configurable: !0,
                                    set: $set
                                });
                                return wrap(tag)
                            };
                            redefine($Symbol[PROTOTYPE], "toString", function() {
                                return this._k
                            });
                            $GOPD.f = $getOwnPropertyDescriptor;
                            $DP.f = $defineProperty;
                            require("./_object-gopn").f = gOPNExt.f = $getOwnPropertyNames;
                            require("./_object-pie").f = $propertyIsEnumerable;
                            require("./_object-gops").f = $getOwnPropertySymbols;
                            if (DESCRIPTORS && !require("./_library")) {
                                redefine(ObjectProto, "propertyIsEnumerable", $propertyIsEnumerable, !0)
                            }
                            wksExt.f = function(name) {
                                return wrap(wks(name))
                            }
                        }
                        $export($export.G + $export.W + $export.F * !USE_NATIVE, {
                            Symbol: $Symbol
                        });
                        for (var es6Symbols = "hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","), j = 0; es6Symbols.length > j;) wks(es6Symbols[j++]);
                        for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);
                        $export($export.S + $export.F * !USE_NATIVE, "Symbol", {
                            for: function(key) {
                                return has(SymbolRegistry, key += "") ? SymbolRegistry[key] : SymbolRegistry[key] = $Symbol(key)
                            },
                            keyFor: function(sym) {
                                if (!isSymbol(sym)) throw TypeError(sym + " is not a symbol!");
                                for (var key in SymbolRegistry)
                                    if (SymbolRegistry[key] === sym) return key
                            },
                            useSetter: function() {
                                setter = !0
                            },
                            useSimple: function() {
                                setter = !1
                            }
                        });
                        $export($export.S + $export.F * !USE_NATIVE, "Object", {
                            create: function(it, P) {
                                return P === void 0 ? _create(it) : $defineProperties(_create(it), P)
                            },
                            defineProperty: $defineProperty,
                            defineProperties: $defineProperties,
                            getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
                            getOwnPropertyNames: $getOwnPropertyNames,
                            getOwnPropertySymbols: $getOwnPropertySymbols
                        });
                        $JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function() {
                            var S = $Symbol();
                            return "[null]" != _stringify([S]) || "{}" != _stringify({
                                a: S
                            }) || "{}" != _stringify(Object(S))
                        })), "JSON", {
                            stringify: function(it) {
                                var args = [it],
                                    i = 1,
                                    replacer, $replacer;
                                while (arguments.length > i) args.push(arguments[i++]);
                                $replacer = replacer = args[1];
                                if (!isObject(replacer) && it === void 0 || isSymbol(it)) return;
                                if (!isArray(replacer)) replacer = function(key, value) {
                                    if ("function" == typeof $replacer) value = $replacer.call(this, key, value);
                                    if (!isSymbol(value)) return value
                                };
                                args[1] = replacer;
                                return _stringify.apply($JSON, args)
                            }
                        });
                        $Symbol[PROTOTYPE][TO_PRIMITIVE] || require("./_hide")($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
                        setToStringTag($Symbol, "Symbol");
                        setToStringTag(Math, "Math", !0);
                        setToStringTag(global.JSON, "JSON", !0)
                    }, {
                        "./_an-object": 55,
                        "./_descriptors": 77,
                        "./_enum-keys": 80,
                        "./_export": 81,
                        "./_fails": 83,
                        "./_global": 88,
                        "./_has": 89,
                        "./_hide": 90,
                        "./_is-array": 97,
                        "./_is-object": 99,
                        "./_library": 107,
                        "./_meta": 113,
                        "./_object-create": 118,
                        "./_object-dp": 119,
                        "./_object-gopd": 122,
                        "./_object-gopn": 124,
                        "./_object-gopn-ext": 123,
                        "./_object-gops": 125,
                        "./_object-keys": 128,
                        "./_object-pie": 129,
                        "./_property-desc": 137,
                        "./_redefine": 139,
                        "./_set-to-string-tag": 146,
                        "./_shared": 148,
                        "./_to-iobject": 162,
                        "./_to-primitive": 165,
                        "./_uid": 169,
                        "./_wks": 174,
                        "./_wks-define": 172,
                        "./_wks-ext": 173
                    }],
                    301: [function(require) {
                        "use strict";
                        var $export = require("./_export"),
                            $typed = require("./_typed"),
                            buffer = require("./_typed-buffer"),
                            anObject = require("./_an-object"),
                            toAbsoluteIndex = require("./_to-absolute-index"),
                            toLength = require("./_to-length"),
                            isObject = require("./_is-object"),
                            ArrayBuffer = require("./_global").ArrayBuffer,
                            speciesConstructor = require("./_species-constructor"),
                            $ArrayBuffer = buffer.ArrayBuffer,
                            $DataView = buffer.DataView,
                            $isView = $typed.ABV && ArrayBuffer.isView,
                            $slice = $ArrayBuffer.prototype.slice,
                            VIEW = $typed.VIEW,
                            ARRAY_BUFFER = "ArrayBuffer";
                        $export($export.G + $export.W + $export.F * (ArrayBuffer !== $ArrayBuffer), {
                            ArrayBuffer: $ArrayBuffer
                        });
                        $export($export.S + $export.F * !$typed.CONSTR, ARRAY_BUFFER, {
                            isView: function(it) {
                                return $isView && $isView(it) || isObject(it) && VIEW in it
                            }
                        });
                        $export($export.P + $export.U + $export.F * require("./_fails")(function() {
                            return !new $ArrayBuffer(2).slice(1, void 0).byteLength
                        }), ARRAY_BUFFER, {
                            slice: function(start, end) {
                                if ($slice !== void 0 && end === void 0) return $slice.call(anObject(this), start);
                                var len = anObject(this).byteLength,
                                    first = toAbsoluteIndex(start, len),
                                    final = toAbsoluteIndex(end === void 0 ? len : end, len),
                                    result = new(speciesConstructor(this, $ArrayBuffer))(toLength(final - first)),
                                    viewS = new $DataView(this),
                                    viewT = new $DataView(result),
                                    index = 0;
                                while (first < final) {
                                    viewT.setUint8(index++, viewS.getUint8(first++))
                                }
                                return result
                            }
                        });
                        require("./_set-species")(ARRAY_BUFFER)
                    }, {
                        "./_an-object": 55,
                        "./_export": 81,
                        "./_fails": 83,
                        "./_global": 88,
                        "./_is-object": 99,
                        "./_set-species": 145,
                        "./_species-constructor": 149,
                        "./_to-absolute-index": 159,
                        "./_to-length": 163,
                        "./_typed": 168,
                        "./_typed-buffer": 167
                    }],
                    302: [function(require) {
                        var $export = require("./_export");
                        $export($export.G + $export.W + $export.F * !require("./_typed").ABV, {
                            DataView: require("./_typed-buffer").DataView
                        })
                    }, {
                        "./_export": 81,
                        "./_typed": 168,
                        "./_typed-buffer": 167
                    }],
                    303: [function(require) {
                        require("./_typed-array")("Float32", 4, function(init) {
                            return function(data, byteOffset, length) {
                                return init(this, data, byteOffset, length)
                            }
                        })
                    }, {
                        "./_typed-array": 166
                    }],
                    304: [function(require) {
                        require("./_typed-array")("Float64", 8, function(init) {
                            return function(data, byteOffset, length) {
                                return init(this, data, byteOffset, length)
                            }
                        })
                    }, {
                        "./_typed-array": 166
                    }],
                    305: [function(require) {
                        require("./_typed-array")("Int16", 2, function(init) {
                            return function(data, byteOffset, length) {
                                return init(this, data, byteOffset, length)
                            }
                        })
                    }, {
                        "./_typed-array": 166
                    }],
                    306: [function(require) {
                        require("./_typed-array")("Int32", 4, function(init) {
                            return function(data, byteOffset, length) {
                                return init(this, data, byteOffset, length)
                            }
                        })
                    }, {
                        "./_typed-array": 166
                    }],
                    307: [function(require) {
                        require("./_typed-array")("Int8", 1, function(init) {
                            return function(data, byteOffset, length) {
                                return init(this, data, byteOffset, length)
                            }
                        })
                    }, {
                        "./_typed-array": 166
                    }],
                    308: [function(require) {
                        require("./_typed-array")("Uint16", 2, function(init) {
                            return function(data, byteOffset, length) {
                                return init(this, data, byteOffset, length)
                            }
                        })
                    }, {
                        "./_typed-array": 166
                    }],
                    309: [function(require) {
                        require("./_typed-array")("Uint32", 4, function(init) {
                            return function(data, byteOffset, length) {
                                return init(this, data, byteOffset, length)
                            }
                        })
                    }, {
                        "./_typed-array": 166
                    }],
                    310: [function(require) {
                        require("./_typed-array")("Uint8", 1, function(init) {
                            return function(data, byteOffset, length) {
                                return init(this, data, byteOffset, length)
                            }
                        })
                    }, {
                        "./_typed-array": 166
                    }],
                    311: [function(require) {
                        require("./_typed-array")("Uint8", 1, function(init) {
                            return function(data, byteOffset, length) {
                                return init(this, data, byteOffset, length)
                            }
                        }, !0)
                    }, {
                        "./_typed-array": 166
                    }],
                    312: [function(require, module) {
                        "use strict";
                        var each = require("./_array-methods")(0),
                            redefine = require("./_redefine"),
                            meta = require("./_meta"),
                            assign = require("./_object-assign"),
                            weak = require("./_collection-weak"),
                            isObject = require("./_is-object"),
                            fails = require("./_fails"),
                            validate = require("./_validate-collection"),
                            WEAK_MAP = "WeakMap",
                            getWeak = meta.getWeak,
                            isExtensible = Object.isExtensible,
                            uncaughtFrozenStore = weak.ufstore,
                            tmp = {},
                            InternalMap, wrapper = function(get) {
                                return function() {
                                    return get(this, 0 < arguments.length ? arguments[0] : void 0)
                                }
                            },
                            methods = {
                                get: function(key) {
                                    if (isObject(key)) {
                                        var data = getWeak(key);
                                        if (!0 === data) return uncaughtFrozenStore(validate(this, WEAK_MAP)).get(key);
                                        return data ? data[this._i] : void 0
                                    }
                                },
                                set: function(key, value) {
                                    return weak.def(validate(this, WEAK_MAP), key, value)
                                }
                            },
                            $WeakMap = module.exports = require("./_collection")(WEAK_MAP, wrapper, methods, weak, !0, !0);
                        if (fails(function() {
                                return 7 != new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp)
                            })) {
                            InternalMap = weak.getConstructor(wrapper, WEAK_MAP);
                            assign(InternalMap.prototype, methods);
                            meta.NEED = !0;
                            each(["delete", "has", "get", "set"], function(key) {
                                var proto = $WeakMap.prototype,
                                    method = proto[key];
                                redefine(proto, key, function(a, b) {
                                    if (isObject(a) && !isExtensible(a)) {
                                        if (!this._f) this._f = new InternalMap;
                                        var result = this._f[key](a, b);
                                        return "set" == key ? this : result
                                    }
                                    return method.call(this, a, b)
                                })
                            })
                        }
                    }, {
                        "./_array-methods": 60,
                        "./_collection": 70,
                        "./_collection-weak": 69,
                        "./_fails": 83,
                        "./_is-object": 99,
                        "./_meta": 113,
                        "./_object-assign": 117,
                        "./_redefine": 139,
                        "./_validate-collection": 171
                    }],
                    313: [function(require) {
                        "use strict";
                        var weak = require("./_collection-weak"),
                            validate = require("./_validate-collection"),
                            WEAK_SET = "WeakSet";
                        require("./_collection")(WEAK_SET, function(get) {
                            return function() {
                                return get(this, 0 < arguments.length ? arguments[0] : void 0)
                            }
                        }, {
                            add: function(value) {
                                return weak.def(validate(this, WEAK_SET), value, !0)
                            }
                        }, weak, !1, !0)
                    }, {
                        "./_collection": 70,
                        "./_collection-weak": 69,
                        "./_validate-collection": 171
                    }],
                    314: [function(require) {
                        "use strict";
                        var $export = require("./_export"),
                            flattenIntoArray = require("./_flatten-into-array"),
                            toObject = require("./_to-object"),
                            toLength = require("./_to-length"),
                            aFunction = require("./_a-function"),
                            arraySpeciesCreate = require("./_array-species-create");
                        $export($export.P, "Array", {
                            flatMap: function(callbackfn) {
                                var O = toObject(this),
                                    sourceLen, A;
                                aFunction(callbackfn);
                                sourceLen = toLength(O.length);
                                A = arraySpeciesCreate(O, 0);
                                flattenIntoArray(A, O, O, sourceLen, 0, 1, callbackfn, arguments[1]);
                                return A
                            }
                        });
                        require("./_add-to-unscopables")("flatMap")
                    }, {
                        "./_a-function": 51,
                        "./_add-to-unscopables": 53,
                        "./_array-species-create": 63,
                        "./_export": 81,
                        "./_flatten-into-array": 86,
                        "./_to-length": 163,
                        "./_to-object": 164
                    }],
                    315: [function(require) {
                        "use strict";
                        var $export = require("./_export"),
                            flattenIntoArray = require("./_flatten-into-array"),
                            toObject = require("./_to-object"),
                            toLength = require("./_to-length"),
                            toInteger = require("./_to-integer"),
                            arraySpeciesCreate = require("./_array-species-create");
                        $export($export.P, "Array", {
                            flatten: function() {
                                var depthArg = arguments[0],
                                    O = toObject(this),
                                    sourceLen = toLength(O.length),
                                    A = arraySpeciesCreate(O, 0);
                                flattenIntoArray(A, O, O, sourceLen, 0, depthArg === void 0 ? 1 : toInteger(depthArg));
                                return A
                            }
                        });
                        require("./_add-to-unscopables")("flatten")
                    }, {
                        "./_add-to-unscopables": 53,
                        "./_array-species-create": 63,
                        "./_export": 81,
                        "./_flatten-into-array": 86,
                        "./_to-integer": 161,
                        "./_to-length": 163,
                        "./_to-object": 164
                    }],
                    316: [function(require) {
                        "use strict";
                        var $export = require("./_export"),
                            $includes = require("./_array-includes")(!0);
                        $export($export.P, "Array", {
                            includes: function(el) {
                                return $includes(this, el, 1 < arguments.length ? arguments[1] : void 0)
                            }
                        });
                        require("./_add-to-unscopables")("includes")
                    }, {
                        "./_add-to-unscopables": 53,
                        "./_array-includes": 59,
                        "./_export": 81
                    }],
                    317: [function(require) {
                        var $export = require("./_export"),
                            microtask = require("./_microtask")(),
                            process = require("./_global").process,
                            isNode = "process" == require("./_cof")(process);
                        $export($export.G, {
                            asap: function(fn) {
                                var domain = isNode && process.domain;
                                microtask(domain ? domain.bind(fn) : fn)
                            }
                        })
                    }, {
                        "./_cof": 66,
                        "./_export": 81,
                        "./_global": 88,
                        "./_microtask": 115
                    }],
                    318: [function(require) {
                        var $export = require("./_export"),
                            cof = require("./_cof");
                        $export($export.S, "Error", {
                            isError: function(it) {
                                return "Error" === cof(it)
                            }
                        })
                    }, {
                        "./_cof": 66,
                        "./_export": 81
                    }],
                    319: [function(require) {
                        var $export = require("./_export");
                        $export($export.G, {
                            global: require("./_global")
                        })
                    }, {
                        "./_export": 81,
                        "./_global": 88
                    }],
                    320: [function(require) {
                        require("./_set-collection-from")("Map")
                    }, {
                        "./_set-collection-from": 142
                    }],
                    321: [function(require) {
                        require("./_set-collection-of")("Map")
                    }, {
                        "./_set-collection-of": 143
                    }],
                    322: [function(require) {
                        var $export = require("./_export");
                        $export($export.P + $export.R, "Map", {
                            toJSON: require("./_collection-to-json")("Map")
                        })
                    }, {
                        "./_collection-to-json": 68,
                        "./_export": 81
                    }],
                    323: [function(require) {
                        var $export = require("./_export");
                        $export($export.S, "Math", {
                            clamp: function(x, lower, upper) {
                                return _Mathmin(upper, _Mathmax(lower, x))
                            }
                        })
                    }, {
                        "./_export": 81
                    }],
                    324: [function(require) {
                        var $export = require("./_export");
                        $export($export.S, "Math", {
                            DEG_PER_RAD: _MathPI / 180
                        })
                    }, {
                        "./_export": 81
                    }],
                    325: [function(require) {
                        var $export = require("./_export");
                        $export($export.S, "Math", {
                            degrees: function(radians) {
                                return radians * (180 / _MathPI)
                            }
                        })
                    }, {
                        "./_export": 81
                    }],
                    326: [function(require) {
                        var $export = require("./_export"),
                            scale = require("./_math-scale"),
                            fround = require("./_math-fround");
                        $export($export.S, "Math", {
                            fscale: function(x, inLow, inHigh, outLow, outHigh) {
                                return fround(scale(x, inLow, inHigh, outLow, outHigh))
                            }
                        })
                    }, {
                        "./_export": 81,
                        "./_math-fround": 109,
                        "./_math-scale": 111
                    }],
                    327: [function(require) {
                        var $export = require("./_export");
                        $export($export.S, "Math", {
                            iaddh: function(x0, x1, y0, y1) {
                                var $x0 = x0 >>> 0,
                                    $y0 = y0 >>> 0;
                                return 0 | (x1 >>> 0) + (y1 >>> 0) + (($x0 & $y0 | ($x0 | $y0) & ~($x0 + $y0 >>> 0)) >>> 31)
                            }
                        })
                    }, {
                        "./_export": 81
                    }],
                    328: [function(require) {
                        var $export = require("./_export");
                        $export($export.S, "Math", {
                            imulh: function(u, v) {
                                var UINT16 = 65535,
                                    $u = +u,
                                    $v = +v,
                                    u0 = $u & UINT16,
                                    v0 = $v & UINT16,
                                    u1 = $u >> 16,
                                    v1 = $v >> 16,
                                    t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
                                return u1 * v1 + (t >> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >> 16)
                            }
                        })
                    }, {
                        "./_export": 81
                    }],
                    329: [function(require) {
                        var $export = require("./_export");
                        $export($export.S, "Math", {
                            isubh: function(x0, x1, y0, y1) {
                                var $x0 = x0 >>> 0,
                                    $y0 = y0 >>> 0;
                                return 0 | (x1 >>> 0) - (y1 >>> 0) - ((~$x0 & $y0 | ~($x0 ^ $y0) & $x0 - $y0 >>> 0) >>> 31)
                            }
                        })
                    }, {
                        "./_export": 81
                    }],
                    330: [function(require) {
                        var $export = require("./_export");
                        $export($export.S, "Math", {
                            RAD_PER_DEG: 180 / _MathPI
                        })
                    }, {
                        "./_export": 81
                    }],
                    331: [function(require) {
                        var $export = require("./_export");
                        $export($export.S, "Math", {
                            radians: function(degrees) {
                                return degrees * (_MathPI / 180)
                            }
                        })
                    }, {
                        "./_export": 81
                    }],
                    332: [function(require) {
                        var $export = require("./_export");
                        $export($export.S, "Math", {
                            scale: require("./_math-scale")
                        })
                    }, {
                        "./_export": 81,
                        "./_math-scale": 111
                    }],
                    333: [function(require) {
                        var $export = require("./_export");
                        $export($export.S, "Math", {
                            signbit: function(x) {
                                return (x = +x) != x ? x : 0 == x ? 1 / x == 1 / 0 : 0 < x
                            }
                        })
                    }, {
                        "./_export": 81
                    }],
                    334: [function(require) {
                        var $export = require("./_export");
                        $export($export.S, "Math", {
                            umulh: function(u, v) {
                                var UINT16 = 65535,
                                    $u = +u,
                                    $v = +v,
                                    u0 = $u & UINT16,
                                    v0 = $v & UINT16,
                                    u1 = $u >>> 16,
                                    v1 = $v >>> 16,
                                    t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
                                return u1 * v1 + (t >>> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >>> 16)
                            }
                        })
                    }, {
                        "./_export": 81
                    }],
                    335: [function(require) {
                        "use strict";
                        var $export = require("./_export"),
                            toObject = require("./_to-object"),
                            aFunction = require("./_a-function"),
                            $defineProperty = require("./_object-dp");
                        require("./_descriptors") && $export($export.P + require("./_object-forced-pam"), "Object", {
                            __defineGetter__: function(P, getter) {
                                $defineProperty.f(toObject(this), P, {
                                    get: aFunction(getter),
                                    enumerable: !0,
                                    configurable: !0
                                })
                            }
                        })
                    }, {
                        "./_a-function": 51,
                        "./_descriptors": 77,
                        "./_export": 81,
                        "./_object-dp": 119,
                        "./_object-forced-pam": 121,
                        "./_to-object": 164
                    }],
                    336: [function(require) {
                        "use strict";
                        var $export = require("./_export"),
                            toObject = require("./_to-object"),
                            aFunction = require("./_a-function"),
                            $defineProperty = require("./_object-dp");
                        require("./_descriptors") && $export($export.P + require("./_object-forced-pam"), "Object", {
                            __defineSetter__: function(P, setter) {
                                $defineProperty.f(toObject(this), P, {
                                    set: aFunction(setter),
                                    enumerable: !0,
                                    configurable: !0
                                })
                            }
                        })
                    }, {
                        "./_a-function": 51,
                        "./_descriptors": 77,
                        "./_export": 81,
                        "./_object-dp": 119,
                        "./_object-forced-pam": 121,
                        "./_to-object": 164
                    }],
                    337: [function(require) {
                        var $export = require("./_export"),
                            $entries = require("./_object-to-array")(!0);
                        $export($export.S, "Object", {
                            entries: function(it) {
                                return $entries(it)
                            }
                        })
                    }, {
                        "./_export": 81,
                        "./_object-to-array": 131
                    }],
                    338: [function(require) {
                        var $export = require("./_export"),
                            ownKeys = require("./_own-keys"),
                            toIObject = require("./_to-iobject"),
                            gOPD = require("./_object-gopd"),
                            createProperty = require("./_create-property");
                        $export($export.S, "Object", {
                            getOwnPropertyDescriptors: function(object) {
                                var O = toIObject(object),
                                    getDesc = gOPD.f,
                                    keys = ownKeys(O),
                                    result = {},
                                    i = 0,
                                    key, desc;
                                while (keys.length > i) {
                                    desc = getDesc(O, key = keys[i++]);
                                    if (desc !== void 0) createProperty(result, key, desc)
                                }
                                return result
                            }
                        })
                    }, {
                        "./_create-property": 72,
                        "./_export": 81,
                        "./_object-gopd": 122,
                        "./_own-keys": 132,
                        "./_to-iobject": 162
                    }],
                    339: [function(require) {
                        "use strict";
                        var $export = require("./_export"),
                            toObject = require("./_to-object"),
                            toPrimitive = require("./_to-primitive"),
                            getPrototypeOf = require("./_object-gpo"),
                            getOwnPropertyDescriptor = require("./_object-gopd").f;
                        require("./_descriptors") && $export($export.P + require("./_object-forced-pam"), "Object", {
                            __lookupGetter__: function(P) {
                                var O = toObject(this),
                                    K = toPrimitive(P, !0),
                                    D;
                                do {
                                    if (D = getOwnPropertyDescriptor(O, K)) return D.get
                                } while (O = getPrototypeOf(O))
                            }
                        })
                    }, {
                        "./_descriptors": 77,
                        "./_export": 81,
                        "./_object-forced-pam": 121,
                        "./_object-gopd": 122,
                        "./_object-gpo": 126,
                        "./_to-object": 164,
                        "./_to-primitive": 165
                    }],
                    340: [function(require) {
                        "use strict";
                        var $export = require("./_export"),
                            toObject = require("./_to-object"),
                            toPrimitive = require("./_to-primitive"),
                            getPrototypeOf = require("./_object-gpo"),
                            getOwnPropertyDescriptor = require("./_object-gopd").f;
                        require("./_descriptors") && $export($export.P + require("./_object-forced-pam"), "Object", {
                            __lookupSetter__: function(P) {
                                var O = toObject(this),
                                    K = toPrimitive(P, !0),
                                    D;
                                do {
                                    if (D = getOwnPropertyDescriptor(O, K)) return D.set
                                } while (O = getPrototypeOf(O))
                            }
                        })
                    }, {
                        "./_descriptors": 77,
                        "./_export": 81,
                        "./_object-forced-pam": 121,
                        "./_object-gopd": 122,
                        "./_object-gpo": 126,
                        "./_to-object": 164,
                        "./_to-primitive": 165
                    }],
                    341: [function(require) {
                        var $export = require("./_export"),
                            $values = require("./_object-to-array")(!1);
                        $export($export.S, "Object", {
                            values: function(it) {
                                return $values(it)
                            }
                        })
                    }, {
                        "./_export": 81,
                        "./_object-to-array": 131
                    }],
                    342: [function(require) {
                        "use strict";
                        var $export = require("./_export"),
                            global = require("./_global"),
                            core = require("./_core"),
                            microtask = require("./_microtask")(),
                            OBSERVABLE = require("./_wks")("observable"),
                            aFunction = require("./_a-function"),
                            anObject = require("./_an-object"),
                            anInstance = require("./_an-instance"),
                            redefineAll = require("./_redefine-all"),
                            hide = require("./_hide"),
                            forOf = require("./_for-of"),
                            RETURN = forOf.RETURN,
                            getMethod = function(fn) {
                                return null == fn ? void 0 : aFunction(fn)
                            },
                            cleanupSubscription = function(subscription) {
                                var cleanup = subscription._c;
                                if (cleanup) {
                                    subscription._c = void 0;
                                    cleanup()
                                }
                            },
                            subscriptionClosed = function(subscription) {
                                return subscription._o === void 0
                            },
                            closeSubscription = function(subscription) {
                                if (!subscriptionClosed(subscription)) {
                                    subscription._o = void 0;
                                    cleanupSubscription(subscription)
                                }
                            },
                            Subscription = function(observer, subscriber) {
                                anObject(observer);
                                this._c = void 0;
                                this._o = observer;
                                observer = new SubscriptionObserver(this);
                                try {
                                    var cleanup = subscriber(observer),
                                        subscription = cleanup;
                                    if (null != cleanup) {
                                        if ("function" === typeof cleanup.unsubscribe) cleanup = function() {
                                            subscription.unsubscribe()
                                        };
                                        else aFunction(cleanup);
                                        this._c = cleanup
                                    }
                                } catch (e) {
                                    observer.error(e);
                                    return
                                }
                                if (subscriptionClosed(this)) cleanupSubscription(this)
                            };
                        Subscription.prototype = redefineAll({}, {
                            unsubscribe: function() {
                                closeSubscription(this)
                            }
                        });
                        var SubscriptionObserver = function(subscription) {
                            this._s = subscription
                        };
                        SubscriptionObserver.prototype = redefineAll({}, {
                            next: function(value) {
                                var subscription = this._s;
                                if (!subscriptionClosed(subscription)) {
                                    var observer = subscription._o;
                                    try {
                                        var m = getMethod(observer.next);
                                        if (m) return m.call(observer, value)
                                    } catch (e) {
                                        try {
                                            closeSubscription(subscription)
                                        } finally {
                                            throw e
                                        }
                                    }
                                }
                            },
                            error: function(value) {
                                var subscription = this._s;
                                if (subscriptionClosed(subscription)) throw value;
                                var observer = subscription._o;
                                subscription._o = void 0;
                                try {
                                    var m = getMethod(observer.error);
                                    if (!m) throw value;
                                    value = m.call(observer, value)
                                } catch (e) {
                                    try {
                                        cleanupSubscription(subscription)
                                    } finally {
                                        throw e
                                    }
                                }
                                cleanupSubscription(subscription);
                                return value
                            },
                            complete: function(value) {
                                var subscription = this._s;
                                if (!subscriptionClosed(subscription)) {
                                    var observer = subscription._o;
                                    subscription._o = void 0;
                                    try {
                                        var m = getMethod(observer.complete);
                                        value = m ? m.call(observer, value) : void 0
                                    } catch (e) {
                                        try {
                                            cleanupSubscription(subscription)
                                        } finally {
                                            throw e
                                        }
                                    }
                                    cleanupSubscription(subscription);
                                    return value
                                }
                            }
                        });
                        var $Observable = function(subscriber) {
                            anInstance(this, $Observable, "Observable", "_f")._f = aFunction(subscriber)
                        };
                        redefineAll($Observable.prototype, {
                            subscribe: function(observer) {
                                return new Subscription(observer, this._f)
                            },
                            forEach: function(fn) {
                                var that = this;
                                return new(core.Promise || global.Promise)(function(resolve, reject) {
                                    aFunction(fn);
                                    var subscription = that.subscribe({
                                        next: function(value) {
                                            try {
                                                return fn(value)
                                            } catch (e) {
                                                reject(e);
                                                subscription.unsubscribe()
                                            }
                                        },
                                        error: reject,
                                        complete: resolve
                                    })
                                })
                            }
                        });
                        redefineAll($Observable, {
                            from: function(x) {
                                var C = "function" === typeof this ? this : $Observable,
                                    method = getMethod(anObject(x)[OBSERVABLE]);
                                if (method) {
                                    var observable = anObject(method.call(x));
                                    return observable.constructor === C ? observable : new C(function(observer) {
                                        return observable.subscribe(observer)
                                    })
                                }
                                return new C(function(observer) {
                                    var done = !1;
                                    microtask(function() {
                                        if (!done) {
                                            try {
                                                if (forOf(x, !1, function(it) {
                                                        observer.next(it);
                                                        if (done) return RETURN
                                                    }) === RETURN) return
                                            } catch (e) {
                                                if (done) throw e;
                                                observer.error(e);
                                                return
                                            }
                                            observer.complete()
                                        }
                                    });
                                    return function() {
                                        done = !0
                                    }
                                })
                            },
                            of: function() {
                                for (var i = 0, l = arguments.length, items = Array(l); i < l;) items[i] = arguments[i++];
                                return new("function" === typeof this ? this : $Observable)(function(observer) {
                                    var done = !1;
                                    microtask(function() {
                                        if (!done) {
                                            for (var j = 0; j < items.length; ++j) {
                                                observer.next(items[j]);
                                                if (done) return
                                            }
                                            observer.complete()
                                        }
                                    });
                                    return function() {
                                        done = !0
                                    }
                                })
                            }
                        });
                        hide($Observable.prototype, OBSERVABLE, function() {
                            return this
                        });
                        $export($export.G, {
                            Observable: $Observable
                        });
                        require("./_set-species")("Observable")
                    }, {
                        "./_a-function": 51,
                        "./_an-instance": 54,
                        "./_an-object": 55,
                        "./_core": 71,
                        "./_export": 81,
                        "./_for-of": 87,
                        "./_global": 88,
                        "./_hide": 90,
                        "./_microtask": 115,
                        "./_redefine-all": 138,
                        "./_set-species": 145,
                        "./_wks": 174
                    }],
                    343: [function(require) {
                        "use strict";
                        var $export = require("./_export"),
                            core = require("./_core"),
                            global = require("./_global"),
                            speciesConstructor = require("./_species-constructor"),
                            promiseResolve = require("./_promise-resolve");
                        $export($export.P + $export.R, "Promise", {
                            finally: function(onFinally) {
                                var C = speciesConstructor(this, core.Promise || global.Promise),
                                    isFunction = "function" == typeof onFinally;
                                return this.then(isFunction ? function(x) {
                                    return promiseResolve(C, onFinally()).then(function() {
                                        return x
                                    })
                                } : onFinally, isFunction ? function(e) {
                                    return promiseResolve(C, onFinally()).then(function() {
                                        throw e
                                    })
                                } : onFinally)
                            }
                        })
                    }, {
                        "./_core": 71,
                        "./_export": 81,
                        "./_global": 88,
                        "./_promise-resolve": 136,
                        "./_species-constructor": 149
                    }],
                    344: [function(require) {
                        "use strict";
                        var $export = require("./_export"),
                            newPromiseCapability = require("./_new-promise-capability"),
                            perform = require("./_perform");
                        $export($export.S, "Promise", {
                            try: function(callbackfn) {
                                var promiseCapability = newPromiseCapability.f(this),
                                    result = perform(callbackfn);
                                (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);
                                return promiseCapability.promise
                            }
                        })
                    }, {
                        "./_export": 81,
                        "./_new-promise-capability": 116,
                        "./_perform": 135
                    }],
                    345: [function(require) {
                        var metadata = require("./_metadata"),
                            anObject = require("./_an-object"),
                            toMetaKey = metadata.key,
                            ordinaryDefineOwnMetadata = metadata.set;
                        metadata.exp({
                            defineMetadata: function(metadataKey, metadataValue, target, targetKey) {
                                ordinaryDefineOwnMetadata(metadataKey, metadataValue, anObject(target), toMetaKey(targetKey))
                            }
                        })
                    }, {
                        "./_an-object": 55,
                        "./_metadata": 114
                    }],
                    346: [function(require) {
                        var metadata = require("./_metadata"),
                            anObject = require("./_an-object"),
                            toMetaKey = metadata.key,
                            getOrCreateMetadataMap = metadata.map,
                            store = metadata.store;
                        metadata.exp({
                            deleteMetadata: function(metadataKey, target) {
                                var targetKey = 3 > arguments.length ? void 0 : toMetaKey(arguments[2]),
                                    metadataMap = getOrCreateMetadataMap(anObject(target), targetKey, !1);
                                if (metadataMap === void 0 || !metadataMap["delete"](metadataKey)) return !1;
                                if (metadataMap.size) return !0;
                                var targetMetadata = store.get(target);
                                targetMetadata["delete"](targetKey);
                                return !!targetMetadata.size || store["delete"](target)
                            }
                        })
                    }, {
                        "./_an-object": 55,
                        "./_metadata": 114
                    }],
                    347: [function(require) {
                        var Set = require("./es6.set"),
                            from = require("./_array-from-iterable"),
                            metadata = require("./_metadata"),
                            anObject = require("./_an-object"),
                            getPrototypeOf = require("./_object-gpo"),
                            ordinaryOwnMetadataKeys = metadata.keys,
                            toMetaKey = metadata.key,
                            ordinaryMetadataKeys = function(O, P) {
                                var oKeys = ordinaryOwnMetadataKeys(O, P),
                                    parent = getPrototypeOf(O);
                                if (null === parent) return oKeys;
                                var pKeys = ordinaryMetadataKeys(parent, P);
                                return pKeys.length ? oKeys.length ? from(new Set(oKeys.concat(pKeys))) : pKeys : oKeys
                            };
                        metadata.exp({
                            getMetadataKeys: function(target) {
                                return ordinaryMetadataKeys(anObject(target), 2 > arguments.length ? void 0 : toMetaKey(arguments[1]))
                            }
                        })
                    }, {
                        "./_an-object": 55,
                        "./_array-from-iterable": 58,
                        "./_metadata": 114,
                        "./_object-gpo": 126,
                        "./es6.set": 277
                    }],
                    348: [function(require) {
                        var metadata = require("./_metadata"),
                            anObject = require("./_an-object"),
                            getPrototypeOf = require("./_object-gpo"),
                            ordinaryHasOwnMetadata = metadata.has,
                            ordinaryGetOwnMetadata = metadata.get,
                            toMetaKey = metadata.key,
                            ordinaryGetMetadata = function(MetadataKey, O, P) {
                                var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
                                if (hasOwn) return ordinaryGetOwnMetadata(MetadataKey, O, P);
                                var parent = getPrototypeOf(O);
                                return null !== parent ? ordinaryGetMetadata(MetadataKey, parent, P) : void 0
                            };
                        metadata.exp({
                            getMetadata: function(metadataKey, target) {
                                return ordinaryGetMetadata(metadataKey, anObject(target), 3 > arguments.length ? void 0 : toMetaKey(arguments[2]))
                            }
                        })
                    }, {
                        "./_an-object": 55,
                        "./_metadata": 114,
                        "./_object-gpo": 126
                    }],
                    349: [function(require) {
                        var metadata = require("./_metadata"),
                            anObject = require("./_an-object"),
                            ordinaryOwnMetadataKeys = metadata.keys,
                            toMetaKey = metadata.key;
                        metadata.exp({
                            getOwnMetadataKeys: function(target) {
                                return ordinaryOwnMetadataKeys(anObject(target), 2 > arguments.length ? void 0 : toMetaKey(arguments[1]))
                            }
                        })
                    }, {
                        "./_an-object": 55,
                        "./_metadata": 114
                    }],
                    350: [function(require) {
                        var metadata = require("./_metadata"),
                            anObject = require("./_an-object"),
                            ordinaryGetOwnMetadata = metadata.get,
                            toMetaKey = metadata.key;
                        metadata.exp({
                            getOwnMetadata: function(metadataKey, target) {
                                return ordinaryGetOwnMetadata(metadataKey, anObject(target), 3 > arguments.length ? void 0 : toMetaKey(arguments[2]))
                            }
                        })
                    }, {
                        "./_an-object": 55,
                        "./_metadata": 114
                    }],
                    351: [function(require) {
                        var metadata = require("./_metadata"),
                            anObject = require("./_an-object"),
                            getPrototypeOf = require("./_object-gpo"),
                            ordinaryHasOwnMetadata = metadata.has,
                            toMetaKey = metadata.key,
                            ordinaryHasMetadata = function(MetadataKey, O, P) {
                                var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
                                if (hasOwn) return !0;
                                var parent = getPrototypeOf(O);
                                return null !== parent ? ordinaryHasMetadata(MetadataKey, parent, P) : !1
                            };
                        metadata.exp({
                            hasMetadata: function(metadataKey, target) {
                                return ordinaryHasMetadata(metadataKey, anObject(target), 3 > arguments.length ? void 0 : toMetaKey(arguments[2]))
                            }
                        })
                    }, {
                        "./_an-object": 55,
                        "./_metadata": 114,
                        "./_object-gpo": 126
                    }],
                    352: [function(require) {
                        var metadata = require("./_metadata"),
                            anObject = require("./_an-object"),
                            ordinaryHasOwnMetadata = metadata.has,
                            toMetaKey = metadata.key;
                        metadata.exp({
                            hasOwnMetadata: function(metadataKey, target) {
                                return ordinaryHasOwnMetadata(metadataKey, anObject(target), 3 > arguments.length ? void 0 : toMetaKey(arguments[2]))
                            }
                        })
                    }, {
                        "./_an-object": 55,
                        "./_metadata": 114
                    }],
                    353: [function(require) {
                        var $metadata = require("./_metadata"),
                            anObject = require("./_an-object"),
                            aFunction = require("./_a-function"),
                            toMetaKey = $metadata.key,
                            ordinaryDefineOwnMetadata = $metadata.set;
                        $metadata.exp({
                            metadata: function(metadataKey, metadataValue) {
                                return function(target, targetKey) {
                                    ordinaryDefineOwnMetadata(metadataKey, metadataValue, (targetKey !== void 0 ? anObject : aFunction)(target), toMetaKey(targetKey))
                                }
                            }
                        })
                    }, {
                        "./_a-function": 51,
                        "./_an-object": 55,
                        "./_metadata": 114
                    }],
                    354: [function(require) {
                        require("./_set-collection-from")("Set")
                    }, {
                        "./_set-collection-from": 142
                    }],
                    355: [function(require) {
                        require("./_set-collection-of")("Set")
                    }, {
                        "./_set-collection-of": 143
                    }],
                    356: [function(require) {
                        var $export = require("./_export");
                        $export($export.P + $export.R, "Set", {
                            toJSON: require("./_collection-to-json")("Set")
                        })
                    }, {
                        "./_collection-to-json": 68,
                        "./_export": 81
                    }],
                    357: [function(require) {
                        "use strict";
                        var $export = require("./_export"),
                            $at = require("./_string-at")(!0);
                        $export($export.P, "String", {
                            at: function(pos) {
                                return $at(this, pos)
                            }
                        })
                    }, {
                        "./_export": 81,
                        "./_string-at": 151
                    }],
                    358: [function(require) {
                        "use strict";
                        var $export = require("./_export"),
                            defined = require("./_defined"),
                            toLength = require("./_to-length"),
                            isRegExp = require("./_is-regexp"),
                            getFlags = require("./_flags"),
                            RegExpProto = RegExp.prototype,
                            $RegExpStringIterator = function(regexp, string) {
                                this._r = regexp;
                                this._s = string
                            };
                        require("./_iter-create")($RegExpStringIterator, "RegExp String", function() {
                            var match = this._r.exec(this._s);
                            return {
                                value: match,
                                done: null === match
                            }
                        });
                        $export($export.P, "String", {
                            matchAll: function(regexp) {
                                defined(this);
                                if (!isRegExp(regexp)) throw TypeError(regexp + " is not a regexp!");
                                var S = this + "",
                                    flags = "flags" in RegExpProto ? regexp.flags + "" : getFlags.call(regexp),
                                    rx = new RegExp(regexp.source, ~flags.indexOf("g") ? flags : "g" + flags);
                                rx.lastIndex = toLength(regexp.lastIndex);
                                return new $RegExpStringIterator(rx, S)
                            }
                        })
                    }, {
                        "./_defined": 76,
                        "./_export": 81,
                        "./_flags": 85,
                        "./_is-regexp": 100,
                        "./_iter-create": 102,
                        "./_to-length": 163
                    }],
                    359: [function(require) {
                        "use strict";
                        var $export = require("./_export"),
                            $pad = require("./_string-pad"),
                            userAgent = require("./_user-agent");
                        $export($export.P + $export.F * /Version\/10\.\d+(\.\d+)? Safari\//.test(userAgent), "String", {
                            padEnd: function(maxLength) {
                                return $pad(this, maxLength, 1 < arguments.length ? arguments[1] : void 0, !1)
                            }
                        })
                    }, {
                        "./_export": 81,
                        "./_string-pad": 154,
                        "./_user-agent": 170
                    }],
                    360: [function(require) {
                        "use strict";
                        var $export = require("./_export"),
                            $pad = require("./_string-pad"),
                            userAgent = require("./_user-agent");
                        $export($export.P + $export.F * /Version\/10\.\d+(\.\d+)? Safari\//.test(userAgent), "String", {
                            padStart: function(maxLength) {
                                return $pad(this, maxLength, 1 < arguments.length ? arguments[1] : void 0, !0)
                            }
                        })
                    }, {
                        "./_export": 81,
                        "./_string-pad": 154,
                        "./_user-agent": 170
                    }],
                    361: [function(require) {
                        "use strict";
                        require("./_string-trim")("trimLeft", function($trim) {
                            return function() {
                                return $trim(this, 1)
                            }
                        }, "trimStart")
                    }, {
                        "./_string-trim": 156
                    }],
                    362: [function(require) {
                        "use strict";
                        require("./_string-trim")("trimRight", function($trim) {
                            return function() {
                                return $trim(this, 2)
                            }
                        }, "trimEnd")
                    }, {
                        "./_string-trim": 156
                    }],
                    363: [function(require) {
                        require("./_wks-define")("asyncIterator")
                    }, {
                        "./_wks-define": 172
                    }],
                    364: [function(require) {
                        require("./_wks-define")("observable")
                    }, {
                        "./_wks-define": 172
                    }],
                    365: [function(require) {
                        var $export = require("./_export");
                        $export($export.S, "System", {
                            global: require("./_global")
                        })
                    }, {
                        "./_export": 81,
                        "./_global": 88
                    }],
                    366: [function(require) {
                        require("./_set-collection-from")("WeakMap")
                    }, {
                        "./_set-collection-from": 142
                    }],
                    367: [function(require) {
                        require("./_set-collection-of")("WeakMap")
                    }, {
                        "./_set-collection-of": 143
                    }],
                    368: [function(require) {
                        require("./_set-collection-from")("WeakSet")
                    }, {
                        "./_set-collection-from": 142
                    }],
                    369: [function(require) {
                        require("./_set-collection-of")("WeakSet")
                    }, {
                        "./_set-collection-of": 143
                    }],
                    370: [function(require) {
                        for (var $iterators = require("./es6.array.iterator"), getKeys = require("./_object-keys"), redefine = require("./_redefine"), global = require("./_global"), hide = require("./_hide"), Iterators = require("./_iterators"), wks = require("./_wks"), ITERATOR = wks("iterator"), TO_STRING_TAG = wks("toStringTag"), ArrayValues = Iterators.Array, DOMIterables = {
                                CSSRuleList: !0,
                                CSSStyleDeclaration: !1,
                                CSSValueList: !1,
                                ClientRectList: !1,
                                DOMRectList: !1,
                                DOMStringList: !1,
                                DOMTokenList: !0,
                                DataTransferItemList: !1,
                                FileList: !1,
                                HTMLAllCollection: !1,
                                HTMLCollection: !1,
                                HTMLFormElement: !1,
                                HTMLSelectElement: !1,
                                MediaList: !0,
                                MimeTypeArray: !1,
                                NamedNodeMap: !1,
                                NodeList: !0,
                                PaintRequestList: !1,
                                Plugin: !1,
                                PluginArray: !1,
                                SVGLengthList: !1,
                                SVGNumberList: !1,
                                SVGPathSegList: !1,
                                SVGPointList: !1,
                                SVGStringList: !1,
                                SVGTransformList: !1,
                                SourceBufferList: !1,
                                StyleSheetList: !0,
                                TextTrackCueList: !1,
                                TextTrackList: !1,
                                TouchList: !1
                            }, collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) {
                            var NAME = collections[i],
                                explicit = DOMIterables[NAME],
                                Collection = global[NAME],
                                proto = Collection && Collection.prototype,
                                key;
                            if (proto) {
                                if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);
                                if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
                                Iterators[NAME] = ArrayValues;
                                if (explicit)
                                    for (key in $iterators)
                                        if (!proto[key]) redefine(proto, key, $iterators[key], !0)
                            }
                        }
                    }, {
                        "./_global": 88,
                        "./_hide": 90,
                        "./_iterators": 106,
                        "./_object-keys": 128,
                        "./_redefine": 139,
                        "./_wks": 174,
                        "./es6.array.iterator": 187
                    }],
                    371: [function(require) {
                        var $export = require("./_export"),
                            $task = require("./_task");
                        $export($export.G + $export.B, {
                            setImmediate: $task.set,
                            clearImmediate: $task.clear
                        })
                    }, {
                        "./_export": 81,
                        "./_task": 158
                    }],
                    372: [function(require) {
                        var global = require("./_global"),
                            $export = require("./_export"),
                            userAgent = require("./_user-agent"),
                            slice = [].slice,
                            MSIE = /MSIE .\./.test(userAgent),
                            wrap = function(set) {
                                return function(fn, time) {
                                    var boundArgs = 2 < arguments.length,
                                        args = boundArgs ? slice.call(arguments, 2) : !1;
                                    return set(boundArgs ? function() {
                                        ("function" == typeof fn ? fn : Function(fn)).apply(this, args)
                                    } : fn, time)
                                }
                            };
                        $export($export.G + $export.B + $export.F * MSIE, {
                            setTimeout: wrap(global.setTimeout),
                            setInterval: wrap(global.setInterval)
                        })
                    }, {
                        "./_export": 81,
                        "./_global": 88,
                        "./_user-agent": 170
                    }],
                    373: [function(require, module) {
                        require("./modules/es6.symbol");
                        require("./modules/es6.object.create");
                        require("./modules/es6.object.define-property");
                        require("./modules/es6.object.define-properties");
                        require("./modules/es6.object.get-own-property-descriptor");
                        require("./modules/es6.object.get-prototype-of");
                        require("./modules/es6.object.keys");
                        require("./modules/es6.object.get-own-property-names");
                        require("./modules/es6.object.freeze");
                        require("./modules/es6.object.seal");
                        require("./modules/es6.object.prevent-extensions");
                        require("./modules/es6.object.is-frozen");
                        require("./modules/es6.object.is-sealed");
                        require("./modules/es6.object.is-extensible");
                        require("./modules/es6.object.assign");
                        require("./modules/es6.object.is");
                        require("./modules/es6.object.set-prototype-of");
                        require("./modules/es6.object.to-string");
                        require("./modules/es6.function.bind");
                        require("./modules/es6.function.name");
                        require("./modules/es6.function.has-instance");
                        require("./modules/es6.parse-int");
                        require("./modules/es6.parse-float");
                        require("./modules/es6.number.constructor");
                        require("./modules/es6.number.to-fixed");
                        require("./modules/es6.number.to-precision");
                        require("./modules/es6.number.epsilon");
                        require("./modules/es6.number.is-finite");
                        require("./modules/es6.number.is-integer");
                        require("./modules/es6.number.is-nan");
                        require("./modules/es6.number.is-safe-integer");
                        require("./modules/es6.number.max-safe-integer");
                        require("./modules/es6.number.min-safe-integer");
                        require("./modules/es6.number.parse-float");
                        require("./modules/es6.number.parse-int");
                        require("./modules/es6.math.acosh");
                        require("./modules/es6.math.asinh");
                        require("./modules/es6.math.atanh");
                        require("./modules/es6.math.cbrt");
                        require("./modules/es6.math.clz32");
                        require("./modules/es6.math.cosh");
                        require("./modules/es6.math.expm1");
                        require("./modules/es6.math.fround");
                        require("./modules/es6.math.hypot");
                        require("./modules/es6.math.imul");
                        require("./modules/es6.math.log10");
                        require("./modules/es6.math.log1p");
                        require("./modules/es6.math.log2");
                        require("./modules/es6.math.sign");
                        require("./modules/es6.math.sinh");
                        require("./modules/es6.math.tanh");
                        require("./modules/es6.math.trunc");
                        require("./modules/es6.string.from-code-point");
                        require("./modules/es6.string.raw");
                        require("./modules/es6.string.trim");
                        require("./modules/es6.string.iterator");
                        require("./modules/es6.string.code-point-at");
                        require("./modules/es6.string.ends-with");
                        require("./modules/es6.string.includes");
                        require("./modules/es6.string.repeat");
                        require("./modules/es6.string.starts-with");
                        require("./modules/es6.string.anchor");
                        require("./modules/es6.string.big");
                        require("./modules/es6.string.blink");
                        require("./modules/es6.string.bold");
                        require("./modules/es6.string.fixed");
                        require("./modules/es6.string.fontcolor");
                        require("./modules/es6.string.fontsize");
                        require("./modules/es6.string.italics");
                        require("./modules/es6.string.link");
                        require("./modules/es6.string.small");
                        require("./modules/es6.string.strike");
                        require("./modules/es6.string.sub");
                        require("./modules/es6.string.sup");
                        require("./modules/es6.date.now");
                        require("./modules/es6.date.to-json");
                        require("./modules/es6.date.to-iso-string");
                        require("./modules/es6.date.to-string");
                        require("./modules/es6.date.to-primitive");
                        require("./modules/es6.array.is-array");
                        require("./modules/es6.array.from");
                        require("./modules/es6.array.of");
                        require("./modules/es6.array.join");
                        require("./modules/es6.array.slice");
                        require("./modules/es6.array.sort");
                        require("./modules/es6.array.for-each");
                        require("./modules/es6.array.map");
                        require("./modules/es6.array.filter");
                        require("./modules/es6.array.some");
                        require("./modules/es6.array.every");
                        require("./modules/es6.array.reduce");
                        require("./modules/es6.array.reduce-right");
                        require("./modules/es6.array.index-of");
                        require("./modules/es6.array.last-index-of");
                        require("./modules/es6.array.copy-within");
                        require("./modules/es6.array.fill");
                        require("./modules/es6.array.find");
                        require("./modules/es6.array.find-index");
                        require("./modules/es6.array.species");
                        require("./modules/es6.array.iterator");
                        require("./modules/es6.regexp.constructor");
                        require("./modules/es6.regexp.to-string");
                        require("./modules/es6.regexp.flags");
                        require("./modules/es6.regexp.match");
                        require("./modules/es6.regexp.replace");
                        require("./modules/es6.regexp.search");
                        require("./modules/es6.regexp.split");
                        require("./modules/es6.promise");
                        require("./modules/es6.map");
                        require("./modules/es6.set");
                        require("./modules/es6.weak-map");
                        require("./modules/es6.weak-set");
                        require("./modules/es6.typed.array-buffer");
                        require("./modules/es6.typed.data-view");
                        require("./modules/es6.typed.int8-array");
                        require("./modules/es6.typed.uint8-array");
                        require("./modules/es6.typed.uint8-clamped-array");
                        require("./modules/es6.typed.int16-array");
                        require("./modules/es6.typed.uint16-array");
                        require("./modules/es6.typed.int32-array");
                        require("./modules/es6.typed.uint32-array");
                        require("./modules/es6.typed.float32-array");
                        require("./modules/es6.typed.float64-array");
                        require("./modules/es6.reflect.apply");
                        require("./modules/es6.reflect.construct");
                        require("./modules/es6.reflect.define-property");
                        require("./modules/es6.reflect.delete-property");
                        require("./modules/es6.reflect.enumerate");
                        require("./modules/es6.reflect.get");
                        require("./modules/es6.reflect.get-own-property-descriptor");
                        require("./modules/es6.reflect.get-prototype-of");
                        require("./modules/es6.reflect.has");
                        require("./modules/es6.reflect.is-extensible");
                        require("./modules/es6.reflect.own-keys");
                        require("./modules/es6.reflect.prevent-extensions");
                        require("./modules/es6.reflect.set");
                        require("./modules/es6.reflect.set-prototype-of");
                        require("./modules/es7.array.includes");
                        require("./modules/es7.array.flat-map");
                        require("./modules/es7.array.flatten");
                        require("./modules/es7.string.at");
                        require("./modules/es7.string.pad-start");
                        require("./modules/es7.string.pad-end");
                        require("./modules/es7.string.trim-left");
                        require("./modules/es7.string.trim-right");
                        require("./modules/es7.string.match-all");
                        require("./modules/es7.symbol.async-iterator");
                        require("./modules/es7.symbol.observable");
                        require("./modules/es7.object.get-own-property-descriptors");
                        require("./modules/es7.object.values");
                        require("./modules/es7.object.entries");
                        require("./modules/es7.object.define-getter");
                        require("./modules/es7.object.define-setter");
                        require("./modules/es7.object.lookup-getter");
                        require("./modules/es7.object.lookup-setter");
                        require("./modules/es7.map.to-json");
                        require("./modules/es7.set.to-json");
                        require("./modules/es7.map.of");
                        require("./modules/es7.set.of");
                        require("./modules/es7.weak-map.of");
                        require("./modules/es7.weak-set.of");
                        require("./modules/es7.map.from");
                        require("./modules/es7.set.from");
                        require("./modules/es7.weak-map.from");
                        require("./modules/es7.weak-set.from");
                        require("./modules/es7.global");
                        require("./modules/es7.system.global");
                        require("./modules/es7.error.is-error");
                        require("./modules/es7.math.clamp");
                        require("./modules/es7.math.deg-per-rad");
                        require("./modules/es7.math.degrees");
                        require("./modules/es7.math.fscale");
                        require("./modules/es7.math.iaddh");
                        require("./modules/es7.math.isubh");
                        require("./modules/es7.math.imulh");
                        require("./modules/es7.math.rad-per-deg");
                        require("./modules/es7.math.radians");
                        require("./modules/es7.math.scale");
                        require("./modules/es7.math.umulh");
                        require("./modules/es7.math.signbit");
                        require("./modules/es7.promise.finally");
                        require("./modules/es7.promise.try");
                        require("./modules/es7.reflect.define-metadata");
                        require("./modules/es7.reflect.delete-metadata");
                        require("./modules/es7.reflect.get-metadata");
                        require("./modules/es7.reflect.get-metadata-keys");
                        require("./modules/es7.reflect.get-own-metadata");
                        require("./modules/es7.reflect.get-own-metadata-keys");
                        require("./modules/es7.reflect.has-metadata");
                        require("./modules/es7.reflect.has-own-metadata");
                        require("./modules/es7.reflect.metadata");
                        require("./modules/es7.asap");
                        require("./modules/es7.observable");
                        require("./modules/web.timers");
                        require("./modules/web.immediate");
                        require("./modules/web.dom.iterable");
                        module.exports = require("./modules/_core")
                    }, {
                        "./modules/_core": 71,
                        "./modules/es6.array.copy-within": 177,
                        "./modules/es6.array.every": 178,
                        "./modules/es6.array.fill": 179,
                        "./modules/es6.array.filter": 180,
                        "./modules/es6.array.find": 182,
                        "./modules/es6.array.find-index": 181,
                        "./modules/es6.array.for-each": 183,
                        "./modules/es6.array.from": 184,
                        "./modules/es6.array.index-of": 185,
                        "./modules/es6.array.is-array": 186,
                        "./modules/es6.array.iterator": 187,
                        "./modules/es6.array.join": 188,
                        "./modules/es6.array.last-index-of": 189,
                        "./modules/es6.array.map": 190,
                        "./modules/es6.array.of": 191,
                        "./modules/es6.array.reduce": 193,
                        "./modules/es6.array.reduce-right": 192,
                        "./modules/es6.array.slice": 194,
                        "./modules/es6.array.some": 195,
                        "./modules/es6.array.sort": 196,
                        "./modules/es6.array.species": 197,
                        "./modules/es6.date.now": 198,
                        "./modules/es6.date.to-iso-string": 199,
                        "./modules/es6.date.to-json": 200,
                        "./modules/es6.date.to-primitive": 201,
                        "./modules/es6.date.to-string": 202,
                        "./modules/es6.function.bind": 203,
                        "./modules/es6.function.has-instance": 204,
                        "./modules/es6.function.name": 205,
                        "./modules/es6.map": 206,
                        "./modules/es6.math.acosh": 207,
                        "./modules/es6.math.asinh": 208,
                        "./modules/es6.math.atanh": 209,
                        "./modules/es6.math.cbrt": 210,
                        "./modules/es6.math.clz32": 211,
                        "./modules/es6.math.cosh": 212,
                        "./modules/es6.math.expm1": 213,
                        "./modules/es6.math.fround": 214,
                        "./modules/es6.math.hypot": 215,
                        "./modules/es6.math.imul": 216,
                        "./modules/es6.math.log10": 217,
                        "./modules/es6.math.log1p": 218,
                        "./modules/es6.math.log2": 219,
                        "./modules/es6.math.sign": 220,
                        "./modules/es6.math.sinh": 221,
                        "./modules/es6.math.tanh": 222,
                        "./modules/es6.math.trunc": 223,
                        "./modules/es6.number.constructor": 224,
                        "./modules/es6.number.epsilon": 225,
                        "./modules/es6.number.is-finite": 226,
                        "./modules/es6.number.is-integer": 227,
                        "./modules/es6.number.is-nan": 228,
                        "./modules/es6.number.is-safe-integer": 229,
                        "./modules/es6.number.max-safe-integer": 230,
                        "./modules/es6.number.min-safe-integer": 231,
                        "./modules/es6.number.parse-float": 232,
                        "./modules/es6.number.parse-int": 233,
                        "./modules/es6.number.to-fixed": 234,
                        "./modules/es6.number.to-precision": 235,
                        "./modules/es6.object.assign": 236,
                        "./modules/es6.object.create": 237,
                        "./modules/es6.object.define-properties": 238,
                        "./modules/es6.object.define-property": 239,
                        "./modules/es6.object.freeze": 240,
                        "./modules/es6.object.get-own-property-descriptor": 241,
                        "./modules/es6.object.get-own-property-names": 242,
                        "./modules/es6.object.get-prototype-of": 243,
                        "./modules/es6.object.is": 247,
                        "./modules/es6.object.is-extensible": 244,
                        "./modules/es6.object.is-frozen": 245,
                        "./modules/es6.object.is-sealed": 246,
                        "./modules/es6.object.keys": 248,
                        "./modules/es6.object.prevent-extensions": 249,
                        "./modules/es6.object.seal": 250,
                        "./modules/es6.object.set-prototype-of": 251,
                        "./modules/es6.object.to-string": 252,
                        "./modules/es6.parse-float": 253,
                        "./modules/es6.parse-int": 254,
                        "./modules/es6.promise": 255,
                        "./modules/es6.reflect.apply": 256,
                        "./modules/es6.reflect.construct": 257,
                        "./modules/es6.reflect.define-property": 258,
                        "./modules/es6.reflect.delete-property": 259,
                        "./modules/es6.reflect.enumerate": 260,
                        "./modules/es6.reflect.get": 263,
                        "./modules/es6.reflect.get-own-property-descriptor": 261,
                        "./modules/es6.reflect.get-prototype-of": 262,
                        "./modules/es6.reflect.has": 264,
                        "./modules/es6.reflect.is-extensible": 265,
                        "./modules/es6.reflect.own-keys": 266,
                        "./modules/es6.reflect.prevent-extensions": 267,
                        "./modules/es6.reflect.set": 269,
                        "./modules/es6.reflect.set-prototype-of": 268,
                        "./modules/es6.regexp.constructor": 270,
                        "./modules/es6.regexp.flags": 271,
                        "./modules/es6.regexp.match": 272,
                        "./modules/es6.regexp.replace": 273,
                        "./modules/es6.regexp.search": 274,
                        "./modules/es6.regexp.split": 275,
                        "./modules/es6.regexp.to-string": 276,
                        "./modules/es6.set": 277,
                        "./modules/es6.string.anchor": 278,
                        "./modules/es6.string.big": 279,
                        "./modules/es6.string.blink": 280,
                        "./modules/es6.string.bold": 281,
                        "./modules/es6.string.code-point-at": 282,
                        "./modules/es6.string.ends-with": 283,
                        "./modules/es6.string.fixed": 284,
                        "./modules/es6.string.fontcolor": 285,
                        "./modules/es6.string.fontsize": 286,
                        "./modules/es6.string.from-code-point": 287,
                        "./modules/es6.string.includes": 288,
                        "./modules/es6.string.italics": 289,
                        "./modules/es6.string.iterator": 290,
                        "./modules/es6.string.link": 291,
                        "./modules/es6.string.raw": 292,
                        "./modules/es6.string.repeat": 293,
                        "./modules/es6.string.small": 294,
                        "./modules/es6.string.starts-with": 295,
                        "./modules/es6.string.strike": 296,
                        "./modules/es6.string.sub": 297,
                        "./modules/es6.string.sup": 298,
                        "./modules/es6.string.trim": 299,
                        "./modules/es6.symbol": 300,
                        "./modules/es6.typed.array-buffer": 301,
                        "./modules/es6.typed.data-view": 302,
                        "./modules/es6.typed.float32-array": 303,
                        "./modules/es6.typed.float64-array": 304,
                        "./modules/es6.typed.int16-array": 305,
                        "./modules/es6.typed.int32-array": 306,
                        "./modules/es6.typed.int8-array": 307,
                        "./modules/es6.typed.uint16-array": 308,
                        "./modules/es6.typed.uint32-array": 309,
                        "./modules/es6.typed.uint8-array": 310,
                        "./modules/es6.typed.uint8-clamped-array": 311,
                        "./modules/es6.weak-map": 312,
                        "./modules/es6.weak-set": 313,
                        "./modules/es7.array.flat-map": 314,
                        "./modules/es7.array.flatten": 315,
                        "./modules/es7.array.includes": 316,
                        "./modules/es7.asap": 317,
                        "./modules/es7.error.is-error": 318,
                        "./modules/es7.global": 319,
                        "./modules/es7.map.from": 320,
                        "./modules/es7.map.of": 321,
                        "./modules/es7.map.to-json": 322,
                        "./modules/es7.math.clamp": 323,
                        "./modules/es7.math.deg-per-rad": 324,
                        "./modules/es7.math.degrees": 325,
                        "./modules/es7.math.fscale": 326,
                        "./modules/es7.math.iaddh": 327,
                        "./modules/es7.math.imulh": 328,
                        "./modules/es7.math.isubh": 329,
                        "./modules/es7.math.rad-per-deg": 330,
                        "./modules/es7.math.radians": 331,
                        "./modules/es7.math.scale": 332,
                        "./modules/es7.math.signbit": 333,
                        "./modules/es7.math.umulh": 334,
                        "./modules/es7.object.define-getter": 335,
                        "./modules/es7.object.define-setter": 336,
                        "./modules/es7.object.entries": 337,
                        "./modules/es7.object.get-own-property-descriptors": 338,
                        "./modules/es7.object.lookup-getter": 339,
                        "./modules/es7.object.lookup-setter": 340,
                        "./modules/es7.object.values": 341,
                        "./modules/es7.observable": 342,
                        "./modules/es7.promise.finally": 343,
                        "./modules/es7.promise.try": 344,
                        "./modules/es7.reflect.define-metadata": 345,
                        "./modules/es7.reflect.delete-metadata": 346,
                        "./modules/es7.reflect.get-metadata": 348,
                        "./modules/es7.reflect.get-metadata-keys": 347,
                        "./modules/es7.reflect.get-own-metadata": 350,
                        "./modules/es7.reflect.get-own-metadata-keys": 349,
                        "./modules/es7.reflect.has-metadata": 351,
                        "./modules/es7.reflect.has-own-metadata": 352,
                        "./modules/es7.reflect.metadata": 353,
                        "./modules/es7.set.from": 354,
                        "./modules/es7.set.of": 355,
                        "./modules/es7.set.to-json": 356,
                        "./modules/es7.string.at": 357,
                        "./modules/es7.string.match-all": 358,
                        "./modules/es7.string.pad-end": 359,
                        "./modules/es7.string.pad-start": 360,
                        "./modules/es7.string.trim-left": 361,
                        "./modules/es7.string.trim-right": 362,
                        "./modules/es7.symbol.async-iterator": 363,
                        "./modules/es7.symbol.observable": 364,
                        "./modules/es7.system.global": 365,
                        "./modules/es7.weak-map.from": 366,
                        "./modules/es7.weak-map.of": 367,
                        "./modules/es7.weak-set.from": 368,
                        "./modules/es7.weak-set.of": 369,
                        "./modules/web.dom.iterable": 370,
                        "./modules/web.immediate": 371,
                        "./modules/web.timers": 372
                    }],
                    374: [function(require, module, exports) {
                        (function(Buffer) {
                            exports.isArray = function(arg) {
                                if (Array.isArray) {
                                    return Array.isArray(arg)
                                }
                                return "[object Array]" === objectToString(arg)
                            };
                            exports.isBoolean = function(arg) {
                                return "boolean" === typeof arg
                            };
                            exports.isNull = function(arg) {
                                return null === arg
                            };
                            exports.isNullOrUndefined = function(arg) {
                                return null == arg
                            };
                            exports.isNumber = function(arg) {
                                return "number" === typeof arg
                            };
                            exports.isString = function(arg) {
                                return "string" === typeof arg
                            };
                            exports.isSymbol = function(arg) {
                                return "symbol" === typeof arg
                            };
                            exports.isUndefined = function(arg) {
                                return void 0 === arg
                            };
                            exports.isRegExp = function(re) {
                                return "[object RegExp]" === objectToString(re)
                            };
                            exports.isObject = function(arg) {
                                return "object" === typeof arg && null !== arg
                            };
                            exports.isDate = function(d) {
                                return "[object Date]" === objectToString(d)
                            };
                            exports.isError = function(e) {
                                return "[object Error]" === objectToString(e) || e instanceof Error
                            };
                            exports.isFunction = function(arg) {
                                return "function" === typeof arg
                            };
                            exports.isPrimitive = function(arg) {
                                return null === arg || "boolean" === typeof arg || "number" === typeof arg || "string" === typeof arg || "symbol" === typeof arg || "undefined" === typeof arg
                            };
                            exports.isBuffer = Buffer.isBuffer;

                            function objectToString(o) {
                                return Object.prototype.toString.call(o)
                            }
                        }).call(this, {
                            isBuffer: require("../../is-buffer/index.js")
                        })
                    }, {
                        "../../is-buffer/index.js": 393
                    }],
                    375: [function(require, module) {
                        (function(Buffer) {
                            "use strict";
                            var inherits = require("inherits"),
                                md5 = require("./md5"),
                                RIPEMD160 = require("ripemd160"),
                                sha = require("sha.js"),
                                Base = require("cipher-base");

                            function HashNoConstructor(hash) {
                                Base.call(this, "digest");
                                this._hash = hash;
                                this.buffers = []
                            }
                            inherits(HashNoConstructor, Base);
                            HashNoConstructor.prototype._update = function(data) {
                                this.buffers.push(data)
                            };
                            HashNoConstructor.prototype._final = function() {
                                var buf = Buffer.concat(this.buffers),
                                    r = this._hash(buf);
                                this.buffers = null;
                                return r
                            };

                            function Hash(hash) {
                                Base.call(this, "digest");
                                this._hash = hash
                            }
                            inherits(Hash, Base);
                            Hash.prototype._update = function(data) {
                                this._hash.update(data)
                            };
                            Hash.prototype._final = function() {
                                return this._hash.digest()
                            };
                            module.exports = function(alg) {
                                alg = alg.toLowerCase();
                                if ("md5" === alg) return new HashNoConstructor(md5);
                                if ("rmd160" === alg || "ripemd160" === alg) return new Hash(new RIPEMD160());
                                return new Hash(sha(alg))
                            }
                        }).call(this, require("buffer").Buffer)
                    }, {
                        "./md5": 377,
                        buffer: 45,
                        "cipher-base": 47,
                        inherits: 392,
                        ripemd160: 419,
                        "sha.js": 422
                    }],
                    376: [function(require, module) {
                        (function(Buffer) {
                            "use strict";
                            var intSize = 4,
                                zeroBuffer = new Buffer(intSize);
                            zeroBuffer.fill(0);

                            function toArray(buf) {
                                if (0 !== buf.length % intSize) {
                                    var len = buf.length + (intSize - buf.length % intSize);
                                    buf = Buffer.concat([buf, zeroBuffer], len)
                                }
                                for (var arr = Array(buf.length >>> 2), i = 0, j = 0; i < buf.length; i += intSize, j++) {
                                    arr[j] = buf.readInt32LE(i)
                                }
                                return arr
                            }
                            module.exports = function(buf, fn) {
                                var arr = fn(toArray(buf), buf.length * 8);
                                buf = new Buffer(16);
                                for (var i = 0; i < arr.length; i++) {
                                    buf.writeInt32LE(arr[i], i << 2, !0)
                                }
                                return buf
                            }
                        }).call(this, require("buffer").Buffer)
                    }, {
                        buffer: 45
                    }],
                    377: [function(require, module) {
                        "use strict";
                        var makeHash = require("./make-hash");

                        function core_md5(x, len) {
                            x[len >> 5] |= 128 << len % 32;
                            x[(len + 64 >>> 9 << 4) + 14] = len;
                            for (var a = 1732584193, b = -271733879, c = -1732584194, d = 271733878, i = 0; i < x.length; i += 16) {
                                var olda = a,
                                    oldb = b,
                                    oldc = c,
                                    oldd = d;
                                a = md5_ff(a, b, c, d, x[i + 0], 7, -680876936);
                                d = md5_ff(d, a, b, c, x[i + 1], 12, -389564586);
                                c = md5_ff(c, d, a, b, x[i + 2], 17, 606105819);
                                b = md5_ff(b, c, d, a, x[i + 3], 22, -1044525330);
                                a = md5_ff(a, b, c, d, x[i + 4], 7, -176418897);
                                d = md5_ff(d, a, b, c, x[i + 5], 12, 1200080426);
                                c = md5_ff(c, d, a, b, x[i + 6], 17, -1473231341);
                                b = md5_ff(b, c, d, a, x[i + 7], 22, -45705983);
                                a = md5_ff(a, b, c, d, x[i + 8], 7, 1770035416);
                                d = md5_ff(d, a, b, c, x[i + 9], 12, -1958414417);
                                c = md5_ff(c, d, a, b, x[i + 10], 17, -42063);
                                b = md5_ff(b, c, d, a, x[i + 11], 22, -1990404162);
                                a = md5_ff(a, b, c, d, x[i + 12], 7, 1804603682);
                                d = md5_ff(d, a, b, c, x[i + 13], 12, -40341101);
                                c = md5_ff(c, d, a, b, x[i + 14], 17, -1502002290);
                                b = md5_ff(b, c, d, a, x[i + 15], 22, 1236535329);
                                a = md5_gg(a, b, c, d, x[i + 1], 5, -165796510);
                                d = md5_gg(d, a, b, c, x[i + 6], 9, -1069501632);
                                c = md5_gg(c, d, a, b, x[i + 11], 14, 643717713);
                                b = md5_gg(b, c, d, a, x[i + 0], 20, -373897302);
                                a = md5_gg(a, b, c, d, x[i + 5], 5, -701558691);
                                d = md5_gg(d, a, b, c, x[i + 10], 9, 38016083);
                                c = md5_gg(c, d, a, b, x[i + 15], 14, -660478335);
                                b = md5_gg(b, c, d, a, x[i + 4], 20, -405537848);
                                a = md5_gg(a, b, c, d, x[i + 9], 5, 568446438);
                                d = md5_gg(d, a, b, c, x[i + 14], 9, -1019803690);
                                c = md5_gg(c, d, a, b, x[i + 3], 14, -187363961);
                                b = md5_gg(b, c, d, a, x[i + 8], 20, 1163531501);
                                a = md5_gg(a, b, c, d, x[i + 13], 5, -1444681467);
                                d = md5_gg(d, a, b, c, x[i + 2], 9, -51403784);
                                c = md5_gg(c, d, a, b, x[i + 7], 14, 1735328473);
                                b = md5_gg(b, c, d, a, x[i + 12], 20, -1926607734);
                                a = md5_hh(a, b, c, d, x[i + 5], 4, -378558);
                                d = md5_hh(d, a, b, c, x[i + 8], 11, -2022574463);
                                c = md5_hh(c, d, a, b, x[i + 11], 16, 1839030562);
                                b = md5_hh(b, c, d, a, x[i + 14], 23, -35309556);
                                a = md5_hh(a, b, c, d, x[i + 1], 4, -1530992060);
                                d = md5_hh(d, a, b, c, x[i + 4], 11, 1272893353);
                                c = md5_hh(c, d, a, b, x[i + 7], 16, -155497632);
                                b = md5_hh(b, c, d, a, x[i + 10], 23, -1094730640);
                                a = md5_hh(a, b, c, d, x[i + 13], 4, 681279174);
                                d = md5_hh(d, a, b, c, x[i + 0], 11, -358537222);
                                c = md5_hh(c, d, a, b, x[i + 3], 16, -722521979);
                                b = md5_hh(b, c, d, a, x[i + 6], 23, 76029189);
                                a = md5_hh(a, b, c, d, x[i + 9], 4, -640364487);
                                d = md5_hh(d, a, b, c, x[i + 12], 11, -421815835);
                                c = md5_hh(c, d, a, b, x[i + 15], 16, 530742520);
                                b = md5_hh(b, c, d, a, x[i + 2], 23, -995338651);
                                a = md5_ii(a, b, c, d, x[i + 0], 6, -198630844);
                                d = md5_ii(d, a, b, c, x[i + 7], 10, 1126891415);
                                c = md5_ii(c, d, a, b, x[i + 14], 15, -1416354905);
                                b = md5_ii(b, c, d, a, x[i + 5], 21, -57434055);
                                a = md5_ii(a, b, c, d, x[i + 12], 6, 1700485571);
                                d = md5_ii(d, a, b, c, x[i + 3], 10, -1894986606);
                                c = md5_ii(c, d, a, b, x[i + 10], 15, -1051523);
                                b = md5_ii(b, c, d, a, x[i + 1], 21, -2054922799);
                                a = md5_ii(a, b, c, d, x[i + 8], 6, 1873313359);
                                d = md5_ii(d, a, b, c, x[i + 15], 10, -30611744);
                                c = md5_ii(c, d, a, b, x[i + 6], 15, -1560198380);
                                b = md5_ii(b, c, d, a, x[i + 13], 21, 1309151649);
                                a = md5_ii(a, b, c, d, x[i + 4], 6, -145523070);
                                d = md5_ii(d, a, b, c, x[i + 11], 10, -1120210379);
                                c = md5_ii(c, d, a, b, x[i + 2], 15, 718787259);
                                b = md5_ii(b, c, d, a, x[i + 9], 21, -343485551);
                                a = safe_add(a, olda);
                                b = safe_add(b, oldb);
                                c = safe_add(c, oldc);
                                d = safe_add(d, oldd)
                            }
                            return [a, b, c, d]
                        }

                        function md5_cmn(q, a, b, x, s, t) {
                            return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s), b)
                        }

                        function md5_ff(a, b, c, d, x, s, t) {
                            return md5_cmn(b & c | ~b & d, a, b, x, s, t)
                        }

                        function md5_gg(a, b, c, d, x, s, t) {
                            return md5_cmn(b & d | c & ~d, a, b, x, s, t)
                        }

                        function md5_hh(a, b, c, d, x, s, t) {
                            return md5_cmn(b ^ c ^ d, a, b, x, s, t)
                        }

                        function md5_ii(a, b, c, d, x, s, t) {
                            return md5_cmn(c ^ (b | ~d), a, b, x, s, t)
                        }

                        function safe_add(x, y) {
                            var lsw = (65535 & x) + (65535 & y);
                            return (x >> 16) + (y >> 16) + (lsw >> 16) << 16 | 65535 & lsw
                        }

                        function bit_rol(num, cnt) {
                            return num << cnt | num >>> 32 - cnt
                        }
                        module.exports = function(buf) {
                            return makeHash(buf, core_md5)
                        }
                    }, {
                        "./make-hash": 376
                    }],
                    378: [function(require, module) {
                        "use strict";
                        var inherits = require("inherits"),
                            Legacy = require("./legacy"),
                            Base = require("cipher-base"),
                            Buffer = require("safe-buffer").Buffer,
                            md5 = require("create-hash/md5"),
                            RIPEMD160 = require("ripemd160"),
                            sha = require("sha.js"),
                            ZEROS = Buffer.alloc(128);

                        function Hmac(alg, key) {
                            Base.call(this, "digest");
                            if ("string" === typeof key) {
                                key = Buffer.from(key)
                            }
                            var blocksize = "sha512" === alg || "sha384" === alg ? 128 : 64;
                            this._alg = alg;
                            this._key = key;
                            if (key.length > blocksize) {
                                var hash = "rmd160" === alg ? new RIPEMD160 : sha(alg);
                                key = hash.update(key).digest()
                            } else if (key.length < blocksize) {
                                key = Buffer.concat([key, ZEROS], blocksize)
                            }
                            for (var ipad = this._ipad = Buffer.allocUnsafe(blocksize), opad = this._opad = Buffer.allocUnsafe(blocksize), i = 0; i < blocksize; i++) {
                                ipad[i] = 54 ^ key[i];
                                opad[i] = 92 ^ key[i]
                            }
                            this._hash = "rmd160" === alg ? new RIPEMD160 : sha(alg);
                            this._hash.update(ipad)
                        }
                        inherits(Hmac, Base);
                        Hmac.prototype._update = function(data) {
                            this._hash.update(data)
                        };
                        Hmac.prototype._final = function() {
                            var h = this._hash.digest(),
                                hash = "rmd160" === this._alg ? new RIPEMD160 : sha(this._alg);
                            return hash.update(this._opad).update(h).digest()
                        };
                        module.exports = function(alg, key) {
                            alg = alg.toLowerCase();
                            if ("rmd160" === alg || "ripemd160" === alg) {
                                return new Hmac("rmd160", key)
                            }
                            if ("md5" === alg) {
                                return new Legacy(md5, key)
                            }
                            return new Hmac(alg, key)
                        }
                    }, {
                        "./legacy": 379,
                        "cipher-base": 47,
                        "create-hash/md5": 377,
                        inherits: 392,
                        ripemd160: 419,
                        "safe-buffer": 420,
                        "sha.js": 422
                    }],
                    379: [function(require, module) {
                        "use strict";
                        var inherits = require("inherits"),
                            Buffer = require("safe-buffer").Buffer,
                            Base = require("cipher-base"),
                            ZEROS = Buffer.alloc(128),
                            blocksize = 64;

                        function Hmac(alg, key) {
                            Base.call(this, "digest");
                            if ("string" === typeof key) {
                                key = Buffer.from(key)
                            }
                            this._alg = alg;
                            this._key = key;
                            if (key.length > blocksize) {
                                key = alg(key)
                            } else if (key.length < blocksize) {
                                key = Buffer.concat([key, ZEROS], blocksize)
                            }
                            for (var ipad = this._ipad = Buffer.allocUnsafe(blocksize), opad = this._opad = Buffer.allocUnsafe(blocksize), i = 0; i < blocksize; i++) {
                                ipad[i] = 54 ^ key[i];
                                opad[i] = 92 ^ key[i]
                            }
                            this._hash = [ipad]
                        }
                        inherits(Hmac, Base);
                        Hmac.prototype._update = function(data) {
                            this._hash.push(data)
                        };
                        Hmac.prototype._final = function() {
                            var h = this._alg(Buffer.concat(this._hash));
                            return this._alg(Buffer.concat([this._opad, h]))
                        };
                        module.exports = Hmac
                    }, {
                        "cipher-base": 47,
                        inherits: 392,
                        "safe-buffer": 420
                    }],
                    380: [function(require, module, exports) {
                        (function(process) {
                            exports = module.exports = require("./debug");
                            exports.log = function() {
                                return "object" === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments)
                            };
                            exports.formatArgs = formatArgs;
                            exports.save = save;
                            exports.load = load;
                            exports.useColors = function() {
                                if ("undefined" !== typeof window && window.process && "renderer" === window.process.type) {
                                    return !0
                                }
                                if ("undefined" !== typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
                                    return !1
                                }
                                return "undefined" !== typeof document && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || "undefined" !== typeof window && window.console && (window.console.firebug || window.console.exception && window.console.table) || "undefined" !== typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && 31 <= parseInt(RegExp.$1, 10) || "undefined" !== typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/)
                            };
                            exports.storage = "undefined" != typeof chrome && "undefined" != typeof chrome.storage ? chrome.storage.local : function() {
                                try {
                                    return window.localStorage
                                } catch (e) {}
                            }();
                            exports.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"];
                            exports.formatters.j = function(v) {
                                try {
                                    return JSON.stringify(v)
                                } catch (err) {
                                    return "[UnexpectedJSONParseError]: " + err.message
                                }
                            };

                            function formatArgs(args) {
                                var useColors = this.useColors;
                                args[0] = (useColors ? "%c" : "") + this.namespace + (useColors ? " %c" : " ") + args[0] + (useColors ? "%c " : " ") + "+" + exports.humanize(this.diff);
                                if (!useColors) return;
                                var c = "color: " + this.color;
                                args.splice(1, 0, c, "color: inherit");
                                var index = 0,
                                    lastC = 0;
                                args[0].replace(/%[a-zA-Z%]/g, function(match) {
                                    if ("%%" === match) return;
                                    index++;
                                    if ("%c" === match) {
                                        lastC = index
                                    }
                                });
                                args.splice(lastC, 0, c)
                            }

                            function save(namespaces) {
                                try {
                                    if (null == namespaces) {
                                        exports.storage.removeItem("debug")
                                    } else {
                                        exports.storage.debug = namespaces
                                    }
                                } catch (e) {}
                            }

                            function load() {
                                var r;
                                try {
                                    r = exports.storage.debug
                                } catch (e) {}
                                if (!r && "undefined" !== typeof process && "env" in process) {
                                    r = process.env.DEBUG
                                }
                                return r
                            }
                            exports.enable(load())
                        }).call(this, require("_process"))
                    }, {
                        "./debug": 381,
                        _process: 399
                    }],
                    381: [function(require, module, exports) {
                        exports = module.exports = createDebug.debug = createDebug["default"] = createDebug;
                        exports.coerce = function(val) {
                            if (val instanceof Error) return val.stack || val.message;
                            return val
                        };
                        exports.disable = disable;
                        exports.enable = enable;
                        exports.enabled = enabled;
                        exports.humanize = require("ms");
                        exports.instances = [];
                        exports.names = [];
                        exports.skips = [];
                        exports.formatters = {};

                        function selectColor(namespace) {
                            var hash = 0,
                                i;
                            for (i in namespace) {
                                hash = (hash << 5) - hash + namespace.charCodeAt(i);
                                hash |= 0
                            }
                            return exports.colors[_Mathabs(hash) % exports.colors.length]
                        }

                        function createDebug(namespace) {
                            var prevTime;

                            function debug() {
                                if (!debug.enabled) return;
                                var self = debug,
                                    curr = +new Date,
                                    ms = curr - (prevTime || curr);
                                self.diff = ms;
                                self.prev = prevTime;
                                self.curr = curr;
                                prevTime = curr;
                                for (var args = Array(arguments.length), i = 0; i < args.length; i++) {
                                    args[i] = arguments[i]
                                }
                                args[0] = exports.coerce(args[0]);
                                if ("string" !== typeof args[0]) {
                                    args.unshift("%O")
                                }
                                var index = 0;
                                args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
                                    if ("%%" === match) return match;
                                    index++;
                                    var formatter = exports.formatters[format];
                                    if ("function" === typeof formatter) {
                                        var val = args[index];
                                        match = formatter.call(self, val);
                                        args.splice(index, 1);
                                        index--
                                    }
                                    return match
                                });
                                exports.formatArgs.call(self, args);
                                var logFn = debug.log || exports.log || console.log.bind(console);
                                logFn.apply(self, args)
                            }
                            debug.namespace = namespace;
                            debug.enabled = exports.enabled(namespace);
                            debug.useColors = exports.useColors();
                            debug.color = selectColor(namespace);
                            debug.destroy = destroy;
                            if ("function" === typeof exports.init) {
                                exports.init(debug)
                            }
                            exports.instances.push(debug);
                            return debug
                        }

                        function destroy() {
                            var index = exports.instances.indexOf(this);
                            if (-1 !== index) {
                                exports.instances.splice(index, 1);
                                return !0
                            } else {
                                return !1
                            }
                        }

                        function enable(namespaces) {
                            exports.save(namespaces);
                            exports.names = [];
                            exports.skips = [];
                            var i, split = ("string" === typeof namespaces ? namespaces : "").split(/[\s,]+/),
                                len = split.length;
                            for (i = 0; i < len; i++) {
                                if (!split[i]) continue;
                                namespaces = split[i].replace(/\*/g, ".*?");
                                if ("-" === namespaces[0]) {
                                    exports.skips.push(new RegExp("^" + namespaces.substr(1) + "$"))
                                } else {
                                    exports.names.push(new RegExp("^" + namespaces + "$"))
                                }
                            }
                            for (i = 0; i < exports.instances.length; i++) {
                                var instance = exports.instances[i];
                                instance.enabled = exports.enabled(instance.namespace)
                            }
                        }

                        function disable() {
                            exports.enable("")
                        }

                        function enabled(name) {
                            if ("*" === name[name.length - 1]) {
                                return !0
                            }
                            var i, len;
                            for (i = 0, len = exports.skips.length; i < len; i++) {
                                if (exports.skips[i].test(name)) {
                                    return !1
                                }
                            }
                            for (i = 0, len = exports.names.length; i < len; i++) {
                                if (exports.names[i].test(name)) {
                                    return !0
                                }
                            }
                            return !1
                        }
                    }, {
                        ms: 397
                    }],
                    382: [function(require, module) {
                        var assert = require("assert"),
                            BigInteger = require("bigi"),
                            Point = require("./point");

                        function Curve(p, a, b, Gx, Gy, n, h) {
                            this.p = p;
                            this.a = a;
                            this.b = b;
                            this.G = Point.fromAffine(this, Gx, Gy);
                            this.n = n;
                            this.h = h;
                            this.infinity = new Point(this, null, null, BigInteger.ZERO);
                            this.pOverFour = p.add(BigInteger.ONE).shiftRight(2);
                            this.pLength = _Mathfloor((this.p.bitLength() + 7) / 8)
                        }
                        Curve.prototype.pointFromX = function(isOdd, x) {
                            var alpha = x.pow(3).add(this.a.multiply(x)).add(this.b).mod(this.p),
                                beta = alpha.modPow(this.pOverFour, this.p),
                                y = beta;
                            if (beta.isEven() ^ !isOdd) {
                                y = this.p.subtract(y)
                            }
                            return Point.fromAffine(this, x, y)
                        };
                        Curve.prototype.isInfinity = function(Q) {
                            if (Q === this.infinity) return !0;
                            return 0 === Q.z.signum() && 0 !== Q.y.signum()
                        };
                        Curve.prototype.isOnCurve = function(Q) {
                            if (this.isInfinity(Q)) return !0;
                            var x = Q.affineX,
                                y = Q.affineY,
                                a = this.a,
                                b = this.b,
                                p = this.p;
                            if (0 > x.signum() || 0 <= x.compareTo(p)) return !1;
                            if (0 > y.signum() || 0 <= y.compareTo(p)) return !1;
                            var lhs = y.square().mod(p),
                                rhs = x.pow(3).add(a.multiply(x)).add(b).mod(p);
                            return lhs.equals(rhs)
                        };
                        Curve.prototype.validate = function(Q) {
                            assert(!this.isInfinity(Q), "Point is at infinity");
                            assert(this.isOnCurve(Q), "Point is not on the curve");
                            var nQ = Q.multiply(this.n);
                            assert(this.isInfinity(nQ), "Point is not a scalar multiple of G");
                            return !0
                        };
                        module.exports = Curve
                    }, {
                        "./point": 386,
                        assert: 12,
                        bigi: 18
                    }],
                    383: [function(require, module) {
                        module.exports = {
                            secp128r1: {
                                p: "fffffffdffffffffffffffffffffffff",
                                a: "fffffffdfffffffffffffffffffffffc",
                                b: "e87579c11079f43dd824993c2cee5ed3",
                                n: "fffffffe0000000075a30d1b9038a115",
                                h: "01",
                                Gx: "161ff7528b899b2d0c28607ca52c5b86",
                                Gy: "cf5ac8395bafeb13c02da292dded7a83"
                            },
                            secp160k1: {
                                p: "fffffffffffffffffffffffffffffffeffffac73",
                                a: "00",
                                b: "07",
                                n: "0100000000000000000001b8fa16dfab9aca16b6b3",
                                h: "01",
                                Gx: "3b4c382ce37aa192a4019e763036f4f5dd4d7ebb",
                                Gy: "938cf935318fdced6bc28286531733c3f03c4fee"
                            },
                            secp160r1: {
                                p: "ffffffffffffffffffffffffffffffff7fffffff",
                                a: "ffffffffffffffffffffffffffffffff7ffffffc",
                                b: "1c97befc54bd7a8b65acf89f81d4d4adc565fa45",
                                n: "0100000000000000000001f4c8f927aed3ca752257",
                                h: "01",
                                Gx: "4a96b5688ef573284664698968c38bb913cbfc82",
                                Gy: "23a628553168947d59dcc912042351377ac5fb32"
                            },
                            secp192k1: {
                                p: "fffffffffffffffffffffffffffffffffffffffeffffee37",
                                a: "00",
                                b: "03",
                                n: "fffffffffffffffffffffffe26f2fc170f69466a74defd8d",
                                h: "01",
                                Gx: "db4ff10ec057e9ae26b07d0280b7f4341da5d1b1eae06c7d",
                                Gy: "9b2f2f6d9c5628a7844163d015be86344082aa88d95e2f9d"
                            },
                            secp192r1: {
                                p: "fffffffffffffffffffffffffffffffeffffffffffffffff",
                                a: "fffffffffffffffffffffffffffffffefffffffffffffffc",
                                b: "64210519e59c80e70fa7e9ab72243049feb8deecc146b9b1",
                                n: "ffffffffffffffffffffffff99def836146bc9b1b4d22831",
                                h: "01",
                                Gx: "188da80eb03090f67cbf20eb43a18800f4ff0afd82ff1012",
                                Gy: "07192b95ffc8da78631011ed6b24cdd573f977a11e794811"
                            },
                            secp256k1: {
                                p: "fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f",
                                a: "00",
                                b: "07",
                                n: "fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141",
                                h: "01",
                                Gx: "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
                                Gy: "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8"
                            },
                            secp256r1: {
                                p: "ffffffff00000001000000000000000000000000ffffffffffffffffffffffff",
                                a: "ffffffff00000001000000000000000000000000fffffffffffffffffffffffc",
                                b: "5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b",
                                n: "ffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551",
                                h: "01",
                                Gx: "6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296",
                                Gy: "4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5"
                            }
                        }
                    }, {}],
                    384: [function(require, module) {
                        var Point = require("./point"),
                            Curve = require("./curve"),
                            getCurveByName = require("./names");
                        module.exports = {
                            Curve: Curve,
                            Point: Point,
                            getCurveByName: getCurveByName
                        }
                    }, {
                        "./curve": 382,
                        "./names": 385,
                        "./point": 386
                    }],
                    385: [function(require, module) {
                        var BigInteger = require("bigi"),
                            curves = require("./curves.json"),
                            Curve = require("./curve");
                        module.exports = function(name) {
                            var curve = curves[name];
                            if (!curve) return null;
                            var p = new BigInteger(curve.p, 16),
                                a = new BigInteger(curve.a, 16),
                                b = new BigInteger(curve.b, 16),
                                n = new BigInteger(curve.n, 16),
                                h = new BigInteger(curve.h, 16),
                                Gx = new BigInteger(curve.Gx, 16),
                                Gy = new BigInteger(curve.Gy, 16);
                            return new Curve(p, a, b, Gx, Gy, n, h)
                        }
                    }, {
                        "./curve": 382,
                        "./curves.json": 383,
                        bigi: 18
                    }],
                    386: [function(require, module) {
                        var assert = require("assert"),
                            Buffer = require("safe-buffer").Buffer,
                            BigInteger = require("bigi"),
                            THREE = BigInteger.valueOf(3);

                        function Point(curve, x, y, z) {
                            assert.notStrictEqual(z, void 0, "Missing Z coordinate");
                            this.curve = curve;
                            this.x = x;
                            this.y = y;
                            this.z = z;
                            this._zInv = null;
                            this.compressed = !0
                        }
                        Object.defineProperty(Point.prototype, "zInv", {
                            get: function() {
                                if (null === this._zInv) {
                                    this._zInv = this.z.modInverse(this.curve.p)
                                }
                                return this._zInv
                            }
                        });
                        Object.defineProperty(Point.prototype, "affineX", {
                            get: function() {
                                return this.x.multiply(this.zInv).mod(this.curve.p)
                            }
                        });
                        Object.defineProperty(Point.prototype, "affineY", {
                            get: function() {
                                return this.y.multiply(this.zInv).mod(this.curve.p)
                            }
                        });
                        Point.fromAffine = function(curve, x, y) {
                            return new Point(curve, x, y, BigInteger.ONE)
                        };
                        Point.prototype.equals = function(other) {
                            if (other === this) return !0;
                            if (this.curve.isInfinity(this)) return this.curve.isInfinity(other);
                            if (this.curve.isInfinity(other)) return this.curve.isInfinity(this);
                            var u = other.y.multiply(this.z).subtract(this.y.multiply(other.z)).mod(this.curve.p);
                            if (0 !== u.signum()) return !1;
                            var v = other.x.multiply(this.z).subtract(this.x.multiply(other.z)).mod(this.curve.p);
                            return 0 === v.signum()
                        };
                        Point.prototype.negate = function() {
                            var y = this.curve.p.subtract(this.y);
                            return new Point(this.curve, this.x, y, this.z)
                        };
                        Point.prototype.add = function(b) {
                            if (this.curve.isInfinity(this)) return b;
                            if (this.curve.isInfinity(b)) return this;
                            var x1 = this.x,
                                y1 = this.y,
                                x2 = b.x,
                                y2 = b.y,
                                u = y2.multiply(this.z).subtract(y1.multiply(b.z)).mod(this.curve.p),
                                v = x2.multiply(this.z).subtract(x1.multiply(b.z)).mod(this.curve.p);
                            if (0 === v.signum()) {
                                if (0 === u.signum()) {
                                    return this.twice()
                                }
                                return this.curve.infinity
                            }
                            var v2 = v.square(),
                                v3 = v2.multiply(v),
                                x1v2 = x1.multiply(v2),
                                zu2 = u.square().multiply(this.z),
                                x3 = zu2.subtract(x1v2.shiftLeft(1)).multiply(b.z).subtract(v3).multiply(v).mod(this.curve.p),
                                y3 = x1v2.multiply(THREE).multiply(u).subtract(y1.multiply(v3)).subtract(zu2.multiply(u)).multiply(b.z).add(u.multiply(v3)).mod(this.curve.p),
                                z3 = v3.multiply(this.z).multiply(b.z).mod(this.curve.p);
                            return new Point(this.curve, x3, y3, z3)
                        };
                        Point.prototype.twice = function() {
                            if (this.curve.isInfinity(this)) return this;
                            if (0 === this.y.signum()) return this.curve.infinity;
                            var x1 = this.x,
                                y1 = this.y,
                                y1z1 = y1.multiply(this.z).mod(this.curve.p),
                                y1sqz1 = y1z1.multiply(y1).mod(this.curve.p),
                                a = this.curve.a,
                                w = x1.square().multiply(THREE);
                            if (0 !== a.signum()) {
                                w = w.add(this.z.square().multiply(a))
                            }
                            w = w.mod(this.curve.p);
                            var x3 = w.square().subtract(x1.shiftLeft(3).multiply(y1sqz1)).shiftLeft(1).multiply(y1z1).mod(this.curve.p),
                                y3 = w.multiply(THREE).multiply(x1).subtract(y1sqz1.shiftLeft(1)).shiftLeft(2).multiply(y1sqz1).subtract(w.pow(3)).mod(this.curve.p),
                                z3 = y1z1.pow(3).shiftLeft(3).mod(this.curve.p);
                            return new Point(this.curve, x3, y3, z3)
                        };
                        Point.prototype.multiply = function(k) {
                            if (this.curve.isInfinity(this)) return this;
                            if (0 === k.signum()) return this.curve.infinity;
                            for (var e = k, h = e.multiply(THREE), neg = this.negate(), R = this, i = h.bitLength() - 2; 0 < i; --i) {
                                var hBit = h.testBit(i),
                                    eBit = e.testBit(i);
                                R = R.twice();
                                if (hBit !== eBit) {
                                    R = R.add(hBit ? this : neg)
                                }
                            }
                            return R
                        };
                        Point.prototype.multiplyTwo = function(j, x, k) {
                            var i = _Mathmax(j.bitLength(), k.bitLength()) - 1,
                                R = this.curve.infinity,
                                both = this.add(x);
                            while (0 <= i) {
                                var jBit = j.testBit(i),
                                    kBit = k.testBit(i);
                                R = R.twice();
                                if (jBit) {
                                    if (kBit) {
                                        R = R.add(both)
                                    } else {
                                        R = R.add(this)
                                    }
                                } else if (kBit) {
                                    R = R.add(x)
                                }--i
                            }
                            return R
                        };
                        Point.prototype.getEncoded = function(compressed) {
                            if (null == compressed) compressed = this.compressed;
                            if (this.curve.isInfinity(this)) return Buffer.alloc(1, 0);
                            var x = this.affineX,
                                y = this.affineY,
                                byteLength = this.curve.pLength,
                                buffer;
                            if (compressed) {
                                buffer = Buffer.allocUnsafe(1 + byteLength);
                                buffer.writeUInt8(y.isEven() ? 2 : 3, 0)
                            } else {
                                buffer = Buffer.allocUnsafe(1 + byteLength + byteLength);
                                buffer.writeUInt8(4, 0);
                                y.toBuffer(byteLength).copy(buffer, 1 + byteLength)
                            }
                            x.toBuffer(byteLength).copy(buffer, 1);
                            return buffer
                        };
                        Point.decodeFrom = function(curve, buffer) {
                            var type = buffer.readUInt8(0),
                                compressed = 4 !== type,
                                byteLength = _Mathfloor((curve.p.bitLength() + 7) / 8),
                                x = BigInteger.fromBuffer(buffer.slice(1, 1 + byteLength)),
                                Q;
                            if (compressed) {
                                assert.equal(buffer.length, byteLength + 1, "Invalid sequence length");
                                assert(2 === type || 3 === type, "Invalid sequence tag");
                                Q = curve.pointFromX(3 === type, x)
                            } else {
                                assert.equal(buffer.length, 1 + byteLength + byteLength, "Invalid sequence length");
                                var y = BigInteger.fromBuffer(buffer.slice(1 + byteLength));
                                Q = Point.fromAffine(curve, x, y)
                            }
                            Q.compressed = compressed;
                            return Q
                        };
                        Point.prototype.toString = function() {
                            if (this.curve.isInfinity(this)) return "(INFINITY)";
                            return "(" + this.affineX.toString() + "," + this.affineY.toString() + ")"
                        };
                        module.exports = Point
                    }, {
                        assert: 12,
                        bigi: 18,
                        "safe-buffer": 420
                    }],
                    387: [function(require, module) {
                        (function(process, global) {
                            (function() {
                                "use strict";

                                function lib$es6$promise$utils$$objectOrFunction(x) {
                                    return "function" === typeof x || "object" === typeof x && null !== x
                                }

                                function lib$es6$promise$utils$$isFunction(x) {
                                    return "function" === typeof x
                                }

                                function lib$es6$promise$utils$$isMaybeThenable(x) {
                                    return "object" === typeof x && null !== x
                                }
                                var lib$es6$promise$utils$$_isArray;
                                if (!Array.isArray) {
                                    lib$es6$promise$utils$$_isArray = function(x) {
                                        return "[object Array]" === Object.prototype.toString.call(x)
                                    }
                                } else {
                                    lib$es6$promise$utils$$_isArray = Array.isArray
                                }
                                var lib$es6$promise$utils$$isArray = lib$es6$promise$utils$$_isArray,
                                    lib$es6$promise$asap$$len = 0,
                                    lib$es6$promise$asap$$toString = {}.toString,
                                    lib$es6$promise$asap$$vertxNext, lib$es6$promise$asap$$customSchedulerFn, lib$es6$promise$asap$$asap = function(callback, arg) {
                                        lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len] = callback;
                                        lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len + 1] = arg;
                                        lib$es6$promise$asap$$len += 2;
                                        if (2 === lib$es6$promise$asap$$len) {
                                            if (lib$es6$promise$asap$$customSchedulerFn) {
                                                lib$es6$promise$asap$$customSchedulerFn(lib$es6$promise$asap$$flush)
                                            } else {
                                                lib$es6$promise$asap$$scheduleFlush()
                                            }
                                        }
                                    };
                                var lib$es6$promise$asap$$browserWindow = "undefined" !== typeof window ? window : void 0,
                                    lib$es6$promise$asap$$browserGlobal = lib$es6$promise$asap$$browserWindow || {},
                                    lib$es6$promise$asap$$BrowserMutationObserver = lib$es6$promise$asap$$browserGlobal.MutationObserver || lib$es6$promise$asap$$browserGlobal.WebKitMutationObserver,
                                    lib$es6$promise$asap$$isNode = "undefined" !== typeof process && "[object process]" === {}.toString.call(process),
                                    lib$es6$promise$asap$$isWorker = "undefined" !== typeof Uint8ClampedArray && "undefined" !== typeof importScripts && "undefined" !== typeof MessageChannel;

                                function lib$es6$promise$asap$$useNextTick() {
                                    var nextTick = process.nextTick,
                                        version = process.versions.node.match(/^(?:(\d+)\.)?(?:(\d+)\.)?(\*|\d+)$/);
                                    if (Array.isArray(version) && "0" === version[1] && "10" === version[2]) {
                                        nextTick = setImmediate
                                    }
                                    return function() {
                                        nextTick(lib$es6$promise$asap$$flush)
                                    }
                                }

                                function lib$es6$promise$asap$$useVertxTimer() {
                                    return function() {
                                        lib$es6$promise$asap$$vertxNext(lib$es6$promise$asap$$flush)
                                    }
                                }

                                function lib$es6$promise$asap$$useMutationObserver() {
                                    var iterations = 0,
                                        observer = new lib$es6$promise$asap$$BrowserMutationObserver(lib$es6$promise$asap$$flush),
                                        node = document.createTextNode("");
                                    observer.observe(node, {
                                        characterData: !0
                                    });
                                    return function() {
                                        node.data = iterations = ++iterations % 2
                                    }
                                }

                                function lib$es6$promise$asap$$useMessageChannel() {
                                    var channel = new MessageChannel;
                                    channel.port1.onmessage = lib$es6$promise$asap$$flush;
                                    return function() {
                                        channel.port2.postMessage(0)
                                    }
                                }

                                function lib$es6$promise$asap$$useSetTimeout() {
                                    return function() {
                                        setTimeout(lib$es6$promise$asap$$flush, 1)
                                    }
                                }
                                var lib$es6$promise$asap$$queue = Array(1e3);

                                function lib$es6$promise$asap$$flush() {
                                    for (var i = 0; i < lib$es6$promise$asap$$len; i += 2) {
                                        var callback = lib$es6$promise$asap$$queue[i],
                                            arg = lib$es6$promise$asap$$queue[i + 1];
                                        callback(arg);
                                        lib$es6$promise$asap$$queue[i] = void 0;
                                        lib$es6$promise$asap$$queue[i + 1] = void 0
                                    }
                                    lib$es6$promise$asap$$len = 0
                                }

                                function lib$es6$promise$asap$$attemptVertex() {
                                    try {
                                        var vertx = require("vertx");
                                        lib$es6$promise$asap$$vertxNext = vertx.runOnLoop || vertx.runOnContext;
                                        return lib$es6$promise$asap$$useVertxTimer()
                                    } catch (e) {
                                        return lib$es6$promise$asap$$useSetTimeout()
                                    }
                                }
                                var lib$es6$promise$asap$$scheduleFlush;
                                if (lib$es6$promise$asap$$isNode) {
                                    lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useNextTick()
                                } else if (lib$es6$promise$asap$$BrowserMutationObserver) {
                                    lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMutationObserver()
                                } else if (lib$es6$promise$asap$$isWorker) {
                                    lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMessageChannel()
                                } else if (lib$es6$promise$asap$$browserWindow === void 0 && "function" === typeof require) {
                                    lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$attemptVertex()
                                } else {
                                    lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useSetTimeout()
                                }

                                function lib$es6$promise$$internal$$noop() {}
                                var lib$es6$promise$$internal$$PENDING, lib$es6$promise$$internal$$FULFILLED = 1,
                                    lib$es6$promise$$internal$$REJECTED = 2,
                                    lib$es6$promise$$internal$$GET_THEN_ERROR = new lib$es6$promise$$internal$$ErrorObject;

                                function lib$es6$promise$$internal$$selfFullfillment() {
                                    return new TypeError("You cannot resolve a promise with itself")
                                }

                                function lib$es6$promise$$internal$$cannotReturnOwn() {
                                    return new TypeError("A promises callback cannot return that same promise.")
                                }

                                function lib$es6$promise$$internal$$getThen(promise) {
                                    try {
                                        return promise.then
                                    } catch (error) {
                                        lib$es6$promise$$internal$$GET_THEN_ERROR.error = error;
                                        return lib$es6$promise$$internal$$GET_THEN_ERROR
                                    }
                                }

                                function lib$es6$promise$$internal$$tryThen(then, value, fulfillmentHandler, rejectionHandler) {
                                    try {
                                        then.call(value, fulfillmentHandler, rejectionHandler)
                                    } catch (e) {
                                        return e
                                    }
                                }

                                function lib$es6$promise$$internal$$handleForeignThenable(promise, thenable, then) {
                                    lib$es6$promise$asap$$asap(function(promise) {
                                        var sealed = !1,
                                            error = lib$es6$promise$$internal$$tryThen(then, thenable, function(value) {
                                                if (sealed) {
                                                    return
                                                }
                                                sealed = !0;
                                                if (thenable !== value) {
                                                    lib$es6$promise$$internal$$resolve(promise, value)
                                                } else {
                                                    lib$es6$promise$$internal$$fulfill(promise, value)
                                                }
                                            }, function(reason) {
                                                if (sealed) {
                                                    return
                                                }
                                                sealed = !0;
                                                lib$es6$promise$$internal$$reject(promise, reason)
                                            }, "Settle: " + (promise._label || " unknown promise"));
                                        if (!sealed && error) {
                                            sealed = !0;
                                            lib$es6$promise$$internal$$reject(promise, error)
                                        }
                                    }, promise)
                                }

                                function lib$es6$promise$$internal$$handleOwnThenable(promise, thenable) {
                                    if (thenable._state === lib$es6$promise$$internal$$FULFILLED) {
                                        lib$es6$promise$$internal$$fulfill(promise, thenable._result)
                                    } else if (thenable._state === lib$es6$promise$$internal$$REJECTED) {
                                        lib$es6$promise$$internal$$reject(promise, thenable._result)
                                    } else {
                                        lib$es6$promise$$internal$$subscribe(thenable, void 0, function(value) {
                                            lib$es6$promise$$internal$$resolve(promise, value)
                                        }, function(reason) {
                                            lib$es6$promise$$internal$$reject(promise, reason)
                                        })
                                    }
                                }

                                function lib$es6$promise$$internal$$handleMaybeThenable(promise, maybeThenable) {
                                    if (maybeThenable.constructor === promise.constructor) {
                                        lib$es6$promise$$internal$$handleOwnThenable(promise, maybeThenable)
                                    } else {
                                        var then = lib$es6$promise$$internal$$getThen(maybeThenable);
                                        if (then === lib$es6$promise$$internal$$GET_THEN_ERROR) {
                                            lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$GET_THEN_ERROR.error)
                                        } else if (then === void 0) {
                                            lib$es6$promise$$internal$$fulfill(promise, maybeThenable)
                                        } else if (lib$es6$promise$utils$$isFunction(then)) {
                                            lib$es6$promise$$internal$$handleForeignThenable(promise, maybeThenable, then)
                                        } else {
                                            lib$es6$promise$$internal$$fulfill(promise, maybeThenable)
                                        }
                                    }
                                }

                                function lib$es6$promise$$internal$$resolve(promise, value) {
                                    if (promise === value) {
                                        lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$selfFullfillment())
                                    } else if (lib$es6$promise$utils$$objectOrFunction(value)) {
                                        lib$es6$promise$$internal$$handleMaybeThenable(promise, value)
                                    } else {
                                        lib$es6$promise$$internal$$fulfill(promise, value)
                                    }
                                }

                                function lib$es6$promise$$internal$$publishRejection(promise) {
                                    if (promise._onerror) {
                                        promise._onerror(promise._result)
                                    }
                                    lib$es6$promise$$internal$$publish(promise)
                                }

                                function lib$es6$promise$$internal$$fulfill(promise, value) {
                                    if (promise._state !== lib$es6$promise$$internal$$PENDING) {
                                        return
                                    }
                                    promise._result = value;
                                    promise._state = lib$es6$promise$$internal$$FULFILLED;
                                    if (0 !== promise._subscribers.length) {
                                        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, promise)
                                    }
                                }

                                function lib$es6$promise$$internal$$reject(promise, reason) {
                                    if (promise._state !== lib$es6$promise$$internal$$PENDING) {
                                        return
                                    }
                                    promise._state = lib$es6$promise$$internal$$REJECTED;
                                    promise._result = reason;
                                    lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publishRejection, promise)
                                }

                                function lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection) {
                                    var subscribers = parent._subscribers,
                                        length = subscribers.length;
                                    parent._onerror = null;
                                    subscribers[length] = child;
                                    subscribers[length + lib$es6$promise$$internal$$FULFILLED] = onFulfillment;
                                    subscribers[length + lib$es6$promise$$internal$$REJECTED] = onRejection;
                                    if (0 === length && parent._state) {
                                        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, parent)
                                    }
                                }

                                function lib$es6$promise$$internal$$publish(promise) {
                                    var subscribers = promise._subscribers,
                                        settled = promise._state;
                                    if (0 === subscribers.length) {
                                        return
                                    }
                                    for (var child, callback, detail = promise._result, i = 0; i < subscribers.length; i += 3) {
                                        child = subscribers[i];
                                        callback = subscribers[i + settled];
                                        if (child) {
                                            lib$es6$promise$$internal$$invokeCallback(settled, child, callback, detail)
                                        } else {
                                            callback(detail)
                                        }
                                    }
                                    promise._subscribers.length = 0
                                }

                                function lib$es6$promise$$internal$$ErrorObject() {
                                    this.error = null
                                }
                                var lib$es6$promise$$internal$$TRY_CATCH_ERROR = new lib$es6$promise$$internal$$ErrorObject;

                                function lib$es6$promise$$internal$$tryCatch(callback, detail) {
                                    try {
                                        return callback(detail)
                                    } catch (e) {
                                        lib$es6$promise$$internal$$TRY_CATCH_ERROR.error = e;
                                        return lib$es6$promise$$internal$$TRY_CATCH_ERROR
                                    }
                                }

                                function lib$es6$promise$$internal$$invokeCallback(settled, promise, callback, detail) {
                                    var hasCallback = lib$es6$promise$utils$$isFunction(callback),
                                        value, error, succeeded, failed;
                                    if (hasCallback) {
                                        value = lib$es6$promise$$internal$$tryCatch(callback, detail);
                                        if (value === lib$es6$promise$$internal$$TRY_CATCH_ERROR) {
                                            failed = !0;
                                            error = value.error;
                                            value = null
                                        } else {
                                            succeeded = !0
                                        }
                                        if (promise === value) {
                                            lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$cannotReturnOwn());
                                            return
                                        }
                                    } else {
                                        value = detail;
                                        succeeded = !0
                                    }
                                    if (promise._state !== lib$es6$promise$$internal$$PENDING) {} else if (hasCallback && succeeded) {
                                        lib$es6$promise$$internal$$resolve(promise, value)
                                    } else if (failed) {
                                        lib$es6$promise$$internal$$reject(promise, error)
                                    } else if (settled === lib$es6$promise$$internal$$FULFILLED) {
                                        lib$es6$promise$$internal$$fulfill(promise, value)
                                    } else if (settled === lib$es6$promise$$internal$$REJECTED) {
                                        lib$es6$promise$$internal$$reject(promise, value)
                                    }
                                }

                                function lib$es6$promise$$internal$$initializePromise(promise, resolver) {
                                    try {
                                        resolver(function(value) {
                                            lib$es6$promise$$internal$$resolve(promise, value)
                                        }, function(reason) {
                                            lib$es6$promise$$internal$$reject(promise, reason)
                                        })
                                    } catch (e) {
                                        lib$es6$promise$$internal$$reject(promise, e)
                                    }
                                }

                                function lib$es6$promise$enumerator$$Enumerator(Constructor, input) {
                                    var enumerator = this;
                                    enumerator._instanceConstructor = Constructor;
                                    enumerator.promise = new Constructor(lib$es6$promise$$internal$$noop);
                                    if (enumerator._validateInput(input)) {
                                        enumerator._input = input;
                                        enumerator.length = input.length;
                                        enumerator._remaining = input.length;
                                        enumerator._init();
                                        if (0 === enumerator.length) {
                                            lib$es6$promise$$internal$$fulfill(enumerator.promise, enumerator._result)
                                        } else {
                                            enumerator.length = enumerator.length || 0;
                                            enumerator._enumerate();
                                            if (0 === enumerator._remaining) {
                                                lib$es6$promise$$internal$$fulfill(enumerator.promise, enumerator._result)
                                            }
                                        }
                                    } else {
                                        lib$es6$promise$$internal$$reject(enumerator.promise, enumerator._validationError())
                                    }
                                }
                                lib$es6$promise$enumerator$$Enumerator.prototype._validateInput = function(input) {
                                    return lib$es6$promise$utils$$isArray(input)
                                };
                                lib$es6$promise$enumerator$$Enumerator.prototype._validationError = function() {
                                    return new Error("Array Methods must be provided an Array")
                                };
                                lib$es6$promise$enumerator$$Enumerator.prototype._init = function() {
                                    this._result = Array(this.length)
                                };
                                lib$es6$promise$enumerator$$Enumerator.prototype._enumerate = function() {
                                    for (var enumerator = this, length = enumerator.length, promise = enumerator.promise, input = enumerator._input, i = 0; promise._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {
                                        enumerator._eachEntry(input[i], i)
                                    }
                                };
                                lib$es6$promise$enumerator$$Enumerator.prototype._eachEntry = function(entry, i) {
                                    var enumerator = this,
                                        c = enumerator._instanceConstructor;
                                    if (lib$es6$promise$utils$$isMaybeThenable(entry)) {
                                        if (entry.constructor === c && entry._state !== lib$es6$promise$$internal$$PENDING) {
                                            entry._onerror = null;
                                            enumerator._settledAt(entry._state, i, entry._result)
                                        } else {
                                            enumerator._willSettleAt(c.resolve(entry), i)
                                        }
                                    } else {
                                        enumerator._remaining--;
                                        enumerator._result[i] = entry
                                    }
                                };
                                lib$es6$promise$enumerator$$Enumerator.prototype._settledAt = function(state, i, value) {
                                    var enumerator = this,
                                        promise = enumerator.promise;
                                    if (promise._state === lib$es6$promise$$internal$$PENDING) {
                                        enumerator._remaining--;
                                        if (state === lib$es6$promise$$internal$$REJECTED) {
                                            lib$es6$promise$$internal$$reject(promise, value)
                                        } else {
                                            enumerator._result[i] = value
                                        }
                                    }
                                    if (0 === enumerator._remaining) {
                                        lib$es6$promise$$internal$$fulfill(promise, enumerator._result)
                                    }
                                };
                                lib$es6$promise$enumerator$$Enumerator.prototype._willSettleAt = function(promise, i) {
                                    var enumerator = this;
                                    lib$es6$promise$$internal$$subscribe(promise, void 0, function(value) {
                                        enumerator._settledAt(lib$es6$promise$$internal$$FULFILLED, i, value)
                                    }, function(reason) {
                                        enumerator._settledAt(lib$es6$promise$$internal$$REJECTED, i, reason)
                                    })
                                };
                                var lib$es6$promise$promise$$counter = 0;

                                function lib$es6$promise$promise$$needsResolver() {
                                    throw new TypeError("You must pass a resolver function as the first argument to the promise constructor")
                                }

                                function lib$es6$promise$promise$$needsNew() {
                                    throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.")
                                }
                                var lib$es6$promise$promise$$default = lib$es6$promise$promise$$Promise;

                                function lib$es6$promise$promise$$Promise(resolver) {
                                    this._id = lib$es6$promise$promise$$counter++;
                                    this._state = void 0;
                                    this._result = void 0;
                                    this._subscribers = [];
                                    if (lib$es6$promise$$internal$$noop !== resolver) {
                                        if (!lib$es6$promise$utils$$isFunction(resolver)) {
                                            lib$es6$promise$promise$$needsResolver()
                                        }
                                        if (!(this instanceof lib$es6$promise$promise$$Promise)) {
                                            lib$es6$promise$promise$$needsNew()
                                        }
                                        lib$es6$promise$$internal$$initializePromise(this, resolver)
                                    }
                                }
                                lib$es6$promise$promise$$Promise.all = function(entries) {
                                    return new lib$es6$promise$enumerator$$Enumerator(this, entries).promise
                                };
                                lib$es6$promise$promise$$Promise.race = function(entries) {
                                    var Constructor = this,
                                        promise = new Constructor(lib$es6$promise$$internal$$noop);
                                    if (!lib$es6$promise$utils$$isArray(entries)) {
                                        lib$es6$promise$$internal$$reject(promise, new TypeError("You must pass an array to race."));
                                        return promise
                                    }
                                    var length = entries.length;

                                    function onFulfillment(value) {
                                        lib$es6$promise$$internal$$resolve(promise, value)
                                    }

                                    function onRejection(reason) {
                                        lib$es6$promise$$internal$$reject(promise, reason)
                                    }
                                    for (var i = 0; promise._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {
                                        lib$es6$promise$$internal$$subscribe(Constructor.resolve(entries[i]), void 0, onFulfillment, onRejection)
                                    }
                                    return promise
                                };
                                lib$es6$promise$promise$$Promise.resolve = function(object) {
                                    var Constructor = this;
                                    if (object && "object" === typeof object && object.constructor === Constructor) {
                                        return object
                                    }
                                    var promise = new Constructor(lib$es6$promise$$internal$$noop);
                                    lib$es6$promise$$internal$$resolve(promise, object);
                                    return promise
                                };
                                lib$es6$promise$promise$$Promise.reject = function(reason) {
                                    var Constructor = this,
                                        promise = new Constructor(lib$es6$promise$$internal$$noop);
                                    lib$es6$promise$$internal$$reject(promise, reason);
                                    return promise
                                };
                                lib$es6$promise$promise$$Promise._setScheduler = function(scheduleFn) {
                                    lib$es6$promise$asap$$customSchedulerFn = scheduleFn
                                };
                                lib$es6$promise$promise$$Promise._setAsap = function(asapFn) {
                                    lib$es6$promise$asap$$asap = asapFn
                                };
                                lib$es6$promise$promise$$Promise._asap = lib$es6$promise$asap$$asap;
                                lib$es6$promise$promise$$Promise.prototype = {
                                    constructor: lib$es6$promise$promise$$Promise,
                                    then: function(onFulfillment, onRejection) {
                                        var parent = this,
                                            state = parent._state;
                                        if (state === lib$es6$promise$$internal$$FULFILLED && !onFulfillment || state === lib$es6$promise$$internal$$REJECTED && !onRejection) {
                                            return this
                                        }
                                        var child = new this.constructor(lib$es6$promise$$internal$$noop),
                                            result = parent._result;
                                        if (state) {
                                            var callback = arguments[state - 1];
                                            lib$es6$promise$asap$$asap(function() {
                                                lib$es6$promise$$internal$$invokeCallback(state, child, callback, result)
                                            })
                                        } else {
                                            lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection)
                                        }
                                        return child
                                    },
                                    catch: function(onRejection) {
                                        return this.then(null, onRejection)
                                    }
                                };
                                var lib$es6$promise$polyfill$$default = function() {
                                        var local;
                                        if ("undefined" !== typeof global) {
                                            local = global
                                        } else if ("undefined" !== typeof self) {
                                            local = self
                                        } else {
                                            try {
                                                local = Function("return this")()
                                            } catch (e) {
                                                throw new Error("polyfill failed because global object is unavailable in this environment")
                                            }
                                        }
                                        var P = local.Promise;
                                        if (P && "[object Promise]" === Object.prototype.toString.call(P.resolve()) && !P.cast) {
                                            return
                                        }
                                        local.Promise = lib$es6$promise$promise$$default
                                    },
                                    lib$es6$promise$umd$$ES6Promise = {
                                        Promise: lib$es6$promise$promise$$default,
                                        polyfill: lib$es6$promise$polyfill$$default
                                    };
                                if ("function" === typeof define && define.amd) {
                                    define(function() {
                                        return lib$es6$promise$umd$$ES6Promise
                                    })
                                } else if ("undefined" !== typeof module && module.exports) {
                                    module.exports = lib$es6$promise$umd$$ES6Promise
                                } else if ("undefined" !== typeof this) {
                                    this.ES6Promise = lib$es6$promise$umd$$ES6Promise
                                }
                                lib$es6$promise$polyfill$$default()
                            }).call(this)
                        }).call(this, require("_process"), "undefined" !== typeof global ? global : "undefined" !== typeof self ? self : "undefined" !== typeof window ? window : {})
                    }, {
                        _process: 399
                    }],
                    388: [function(require, module) {
                        function EventEmitter() {
                            this._events = this._events || {};
                            this._maxListeners = this._maxListeners || void 0
                        }
                        module.exports = EventEmitter;
                        EventEmitter.EventEmitter = EventEmitter;
                        EventEmitter.prototype._events = void 0;
                        EventEmitter.prototype._maxListeners = void 0;
                        EventEmitter.defaultMaxListeners = 10;
                        EventEmitter.prototype.setMaxListeners = function(n) {
                            if (!isNumber(n) || 0 > n || isNaN(n)) throw TypeError("n must be a positive number");
                            this._maxListeners = n;
                            return this
                        };
                        EventEmitter.prototype.emit = function(type) {
                            var er, handler, len, args, i, listeners;
                            if (!this._events) this._events = {};
                            if ("error" === type) {
                                if (!this._events.error || isObject(this._events.error) && !this._events.error.length) {
                                    er = arguments[1];
                                    if (er instanceof Error) {
                                        throw er
                                    } else {
                                        var err = new Error("Uncaught, unspecified \"error\" event. (" + er + ")");
                                        err.context = er;
                                        throw err
                                    }
                                }
                            }
                            handler = this._events[type];
                            if (isUndefined(handler)) return !1;
                            if (isFunction(handler)) {
                                switch (arguments.length) {
                                    case 1:
                                        handler.call(this);
                                        break;
                                    case 2:
                                        handler.call(this, arguments[1]);
                                        break;
                                    case 3:
                                        handler.call(this, arguments[1], arguments[2]);
                                        break;
                                    default:
                                        args = Array.prototype.slice.call(arguments, 1);
                                        handler.apply(this, args);
                                }
                            } else if (isObject(handler)) {
                                args = Array.prototype.slice.call(arguments, 1);
                                listeners = handler.slice();
                                len = listeners.length;
                                for (i = 0; i < len; i++) listeners[i].apply(this, args)
                            }
                            return !0
                        };
                        EventEmitter.prototype.addListener = function(type, listener) {
                            var m;
                            if (!isFunction(listener)) throw TypeError("listener must be a function");
                            if (!this._events) this._events = {};
                            if (this._events.newListener) this.emit("newListener", type, isFunction(listener.listener) ? listener.listener : listener);
                            if (!this._events[type]) this._events[type] = listener;
                            else if (isObject(this._events[type])) this._events[type].push(listener);
                            else this._events[type] = [this._events[type], listener];
                            if (isObject(this._events[type]) && !this._events[type].warned) {
                                if (!isUndefined(this._maxListeners)) {
                                    m = this._maxListeners
                                } else {
                                    m = EventEmitter.defaultMaxListeners
                                }
                                if (m && 0 < m && this._events[type].length > m) {
                                    this._events[type].warned = !0;
                                    console.error("(node) warning: possible EventEmitter memory " + "leak detected. %d listeners added. " + "Use emitter.setMaxListeners() to increase limit.", this._events[type].length);
                                    if ("function" === typeof console.trace) {
                                        console.trace()
                                    }
                                }
                            }
                            return this
                        };
                        EventEmitter.prototype.on = EventEmitter.prototype.addListener;
                        EventEmitter.prototype.once = function(type, listener) {
                            if (!isFunction(listener)) throw TypeError("listener must be a function");
                            var fired = !1;

                            function g() {
                                this.removeListener(type, g);
                                if (!fired) {
                                    fired = !0;
                                    listener.apply(this, arguments)
                                }
                            }
                            g.listener = listener;
                            this.on(type, g);
                            return this
                        };
                        EventEmitter.prototype.removeListener = function(type, listener) {
                            var list, position, length, i;
                            if (!isFunction(listener)) throw TypeError("listener must be a function");
                            if (!this._events || !this._events[type]) return this;
                            list = this._events[type];
                            length = list.length;
                            position = -1;
                            if (list === listener || isFunction(list.listener) && list.listener === listener) {
                                delete this._events[type];
                                if (this._events.removeListener) this.emit("removeListener", type, listener)
                            } else if (isObject(list)) {
                                for (i = length; 0 < i--;) {
                                    if (list[i] === listener || list[i].listener && list[i].listener === listener) {
                                        position = i;
                                        break
                                    }
                                }
                                if (0 > position) return this;
                                if (1 === list.length) {
                                    list.length = 0;
                                    delete this._events[type]
                                } else {
                                    list.splice(position, 1)
                                }
                                if (this._events.removeListener) this.emit("removeListener", type, listener)
                            }
                            return this
                        };
                        EventEmitter.prototype.removeAllListeners = function(type) {
                            var key, listeners;
                            if (!this._events) return this;
                            if (!this._events.removeListener) {
                                if (0 === arguments.length) this._events = {};
                                else if (this._events[type]) delete this._events[type];
                                return this
                            }
                            if (0 === arguments.length) {
                                for (key in this._events) {
                                    if ("removeListener" === key) continue;
                                    this.removeAllListeners(key)
                                }
                                this.removeAllListeners("removeListener");
                                this._events = {};
                                return this
                            }
                            listeners = this._events[type];
                            if (isFunction(listeners)) {
                                this.removeListener(type, listeners)
                            } else if (listeners) {
                                while (listeners.length) this.removeListener(type, listeners[listeners.length - 1])
                            }
                            delete this._events[type];
                            return this
                        };
                        EventEmitter.prototype.listeners = function(type) {
                            var ret;
                            if (!this._events || !this._events[type]) ret = [];
                            else if (isFunction(this._events[type])) ret = [this._events[type]];
                            else ret = this._events[type].slice();
                            return ret
                        };
                        EventEmitter.prototype.listenerCount = function(type) {
                            if (this._events) {
                                var evlistener = this._events[type];
                                if (isFunction(evlistener)) return 1;
                                else if (evlistener) return evlistener.length
                            }
                            return 0
                        };
                        EventEmitter.listenerCount = function(emitter, type) {
                            return emitter.listenerCount(type)
                        };

                        function isFunction(arg) {
                            return "function" === typeof arg
                        }

                        function isNumber(arg) {
                            return "number" === typeof arg
                        }

                        function isObject(arg) {
                            return "object" === typeof arg && null !== arg
                        }

                        function isUndefined(arg) {
                            return void 0 === arg
                        }
                    }, {}],
                    389: [function(require, module) {
                        (function(Buffer) {
                            "use strict";
                            var Transform = require("stream").Transform,
                                inherits = require("inherits");

                            function HashBase(blockSize) {
                                Transform.call(this);
                                this._block = new Buffer(blockSize);
                                this._blockSize = blockSize;
                                this._blockOffset = 0;
                                this._length = [0, 0, 0, 0];
                                this._finalized = !1
                            }
                            inherits(HashBase, Transform);
                            HashBase.prototype._transform = function(chunk, encoding, callback) {
                                var error = null;
                                try {
                                    if ("buffer" !== encoding) chunk = new Buffer(chunk, encoding);
                                    this.update(chunk)
                                } catch (err) {
                                    error = err
                                }
                                callback(error)
                            };
                            HashBase.prototype._flush = function(callback) {
                                var error = null;
                                try {
                                    this.push(this._digest())
                                } catch (err) {
                                    error = err
                                }
                                callback(error)
                            };
                            HashBase.prototype.update = function(data, encoding) {
                                if (!Buffer.isBuffer(data) && "string" !== typeof data) throw new TypeError("Data must be a string or a buffer");
                                if (this._finalized) throw new Error("Digest already called");
                                if (!Buffer.isBuffer(data)) data = new Buffer(data, encoding || "binary");
                                var block = this._block,
                                    offset = 0;
                                while (this._blockOffset + data.length - offset >= this._blockSize) {
                                    for (var i = this._blockOffset; i < this._blockSize;) block[i++] = data[offset++];
                                    this._update();
                                    this._blockOffset = 0
                                }
                                while (offset < data.length) block[this._blockOffset++] = data[offset++];
                                for (var j = 0, carry = 8 * data.length; 0 < carry; ++j) {
                                    this._length[j] += carry;
                                    carry = 0 | this._length[j] / 4294967296;
                                    if (0 < carry) this._length[j] -= 4294967296 * carry
                                }
                                return this
                            };
                            HashBase.prototype._update = function() {
                                throw new Error("_update is not implemented")
                            };
                            HashBase.prototype.digest = function(encoding) {
                                if (this._finalized) throw new Error("Digest already called");
                                this._finalized = !0;
                                var digest = this._digest();
                                if (encoding !== void 0) digest = digest.toString(encoding);
                                return digest
                            };
                            HashBase.prototype._digest = function() {
                                throw new Error("_digest is not implemented")
                            };
                            module.exports = HashBase
                        }).call(this, require("buffer").Buffer)
                    }, {
                        buffer: 45,
                        inherits: 392,
                        stream: 430
                    }],
                    390: [function(require, module) {
                        var http = require("http"),
                            url = require("url"),
                            https = module.exports;
                        for (var key in http) {
                            if (http.hasOwnProperty(key)) https[key] = http[key]
                        }
                        https.request = function(params, cb) {
                            params = validateParams(params);
                            return http.request.call(this, params, cb)
                        };
                        https.get = function(params, cb) {
                            params = validateParams(params);
                            return http.get.call(this, params, cb)
                        };

                        function validateParams(params) {
                            if ("string" === typeof params) {
                                params = url.parse(params)
                            }
                            if (!params.protocol) {
                                params.protocol = "https:"
                            }
                            if ("https:" !== params.protocol) {
                                throw new Error("Protocol \"" + params.protocol + "\" not supported. Expected \"https:\"")
                            }
                            return params
                        }
                    }, {
                        http: 431,
                        url: 442
                    }],
                    391: [function(require, module, exports) {
                        exports.read = function(buffer, offset, isLE, mLen, nBytes) {
                            var e, m, eLen = 8 * nBytes - mLen - 1,
                                eMax = (1 << eLen) - 1,
                                eBias = eMax >> 1,
                                nBits = -7,
                                i = isLE ? nBytes - 1 : 0,
                                d = isLE ? -1 : 1,
                                s = buffer[offset + i];
                            i += d;
                            e = s & (1 << -nBits) - 1;
                            s >>= -nBits;
                            nBits += eLen;
                            for (; 0 < nBits; e = 256 * e + buffer[offset + i], i += d, nBits -= 8) {}
                            m = e & (1 << -nBits) - 1;
                            e >>= -nBits;
                            nBits += mLen;
                            for (; 0 < nBits; m = 256 * m + buffer[offset + i], i += d, nBits -= 8) {}
                            if (0 === e) {
                                e = 1 - eBias
                            } else if (e === eMax) {
                                return m ? NaN : (s ? -1 : 1) * (1 / 0)
                            } else {
                                m = m + _Mathpow(2, mLen);
                                e = e - eBias
                            }
                            return (s ? -1 : 1) * m * _Mathpow(2, e - mLen)
                        };
                        exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
                            var e, m, c, eLen = 8 * nBytes - mLen - 1,
                                eMax = (1 << eLen) - 1,
                                eBias = eMax >> 1,
                                rt = 23 === mLen ? 5.960464477539063e-8 - 6.617444900424222e-24 : 0,
                                i = isLE ? 0 : nBytes - 1,
                                d = isLE ? 1 : -1,
                                s = 0 > value || 0 === value && 0 > 1 / value ? 1 : 0;
                            value = _Mathabs(value);
                            if (isNaN(value) || value === 1 / 0) {
                                m = isNaN(value) ? 1 : 0;
                                e = eMax
                            } else {
                                e = _Mathfloor(_Mathlog(value) / _MathLN);
                                if (1 > value * (c = _Mathpow(2, -e))) {
                                    e--;
                                    c *= 2
                                }
                                if (1 <= e + eBias) {
                                    value += rt / c
                                } else {
                                    value += rt * _Mathpow(2, 1 - eBias)
                                }
                                if (2 <= value * c) {
                                    e++;
                                    c /= 2
                                }
                                if (e + eBias >= eMax) {
                                    m = 0;
                                    e = eMax
                                } else if (1 <= e + eBias) {
                                    m = (value * c - 1) * _Mathpow(2, mLen);
                                    e = e + eBias
                                } else {
                                    m = value * _Mathpow(2, eBias - 1) * _Mathpow(2, mLen);
                                    e = 0
                                }
                            }
                            for (; 8 <= mLen; buffer[offset + i] = 255 & m, i += d, m /= 256, mLen -= 8) {}
                            e = e << mLen | m;
                            eLen += mLen;
                            for (; 0 < eLen; buffer[offset + i] = 255 & e, i += d, e /= 256, eLen -= 8) {}
                            buffer[offset + i - d] |= 128 * s
                        }
                    }, {}],
                    392: [function(require, module) {
                        if ("function" === typeof Object.create) {
                            module.exports = function(ctor, superCtor) {
                                ctor.super_ = superCtor;
                                ctor.prototype = Object.create(superCtor.prototype, {
                                    constructor: {
                                        value: ctor,
                                        enumerable: !1,
                                        writable: !0,
                                        configurable: !0
                                    }
                                })
                            }
                        } else {
                            module.exports = function(ctor, superCtor) {
                                ctor.super_ = superCtor;
                                var TempCtor = function() {};
                                TempCtor.prototype = superCtor.prototype;
                                ctor.prototype = new TempCtor;
                                ctor.prototype.constructor = ctor
                            }
                        }
                    }, {}],
                    393: [function(require, module) {
                        module.exports = function(obj) {
                            return null != obj && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
                        };

                        function isBuffer(obj) {
                            return !!obj.constructor && "function" === typeof obj.constructor.isBuffer && obj.constructor.isBuffer(obj)
                        }

                        function isSlowBuffer(obj) {
                            return "function" === typeof obj.readFloatLE && "function" === typeof obj.slice && isBuffer(obj.slice(0, 0))
                        }
                    }, {}],
                    394: [function(require, module) {
                        var toString = {}.toString;
                        module.exports = Array.isArray || function(arr) {
                            return "[object Array]" == toString.call(arr)
                        }
                    }, {}],
                    395: [function() {}, {}],
                    396: [function(require, module) {
                        (function(process, global, __dirname) {
                            (function() {
                                var _nodejs = "undefined" !== typeof process && process.versions && process.versions.node,
                                    _browser = !_nodejs && ("undefined" !== typeof window || "undefined" !== typeof self);
                                if (_browser) {
                                    if ("undefined" === typeof global) {
                                        if ("undefined" !== typeof window) {
                                            global = window
                                        } else if ("undefined" !== typeof self) {
                                            global = self
                                        } else if ("undefined" !== typeof $) {
                                            global = $
                                        }
                                    }
                                }
                                var wrapper = function(jsonld) {
                                        jsonld.compact = function(input, ctx, options, callback) {
                                            if (2 > arguments.length) {
                                                return jsonld.nextTick(function() {
                                                    callback(new TypeError("Could not compact, too few arguments."))
                                                })
                                            }
                                            if ("function" === typeof options) {
                                                callback = options;
                                                options = {}
                                            }
                                            options = options || {};
                                            if (null === ctx) {
                                                return jsonld.nextTick(function() {
                                                    callback(new JsonLdError("The compaction context must not be null.", "jsonld.CompactError", {
                                                        code: "invalid local context"
                                                    }))
                                                })
                                            }
                                            if (null === input) {
                                                return jsonld.nextTick(function() {
                                                    callback(null, null)
                                                })
                                            }
                                            if (!("base" in options)) {
                                                options.base = "string" === typeof input ? input : ""
                                            }
                                            if (!("compactArrays" in options)) {
                                                options.compactArrays = !0
                                            }
                                            if (!("graph" in options)) {
                                                options.graph = !1
                                            }
                                            if (!("skipExpansion" in options)) {
                                                options.skipExpansion = !1
                                            }
                                            if (!("documentLoader" in options)) {
                                                options.documentLoader = jsonld.loadDocument
                                            }
                                            if (!("link" in options)) {
                                                options.link = !1
                                            }
                                            if (options.link) {
                                                options.skipExpansion = !0
                                            }
                                            var expand = function(input, options, callback) {
                                                if (options.skipExpansion) {
                                                    return jsonld.nextTick(function() {
                                                        callback(null, input)
                                                    })
                                                }
                                                jsonld.expand(input, options, callback)
                                            };
                                            expand(input, options, function(err, expanded) {
                                                if (err) {
                                                    return callback(new JsonLdError("Could not expand input before compaction.", "jsonld.CompactError", {
                                                        cause: err
                                                    }))
                                                }
                                                var activeCtx = _getInitialContext(options);
                                                jsonld.processContext(activeCtx, ctx, options, function(err, activeCtx) {
                                                    if (err) {
                                                        return callback(new JsonLdError("Could not process context before compaction.", "jsonld.CompactError", {
                                                            cause: err
                                                        }))
                                                    }
                                                    var compacted;
                                                    try {
                                                        compacted = new Processor().compact(activeCtx, null, expanded, options)
                                                    } catch (ex) {
                                                        return callback(ex)
                                                    }
                                                    cleanup(null, compacted, activeCtx, options)
                                                })
                                            });

                                            function cleanup(err, compacted, activeCtx, options) {
                                                if (err) {
                                                    return callback(err)
                                                }
                                                if (options.compactArrays && !options.graph && _isArray(compacted)) {
                                                    if (1 === compacted.length) {
                                                        compacted = compacted[0]
                                                    } else if (0 === compacted.length) {
                                                        compacted = {}
                                                    }
                                                } else if (options.graph && _isObject(compacted)) {
                                                    compacted = [compacted]
                                                }
                                                if (_isObject(ctx) && "@context" in ctx) {
                                                    ctx = ctx["@context"]
                                                }
                                                ctx = _clone(ctx);
                                                if (!_isArray(ctx)) {
                                                    ctx = [ctx]
                                                }
                                                var tmp = ctx;
                                                ctx = [];
                                                for (var i = 0; i < tmp.length; ++i) {
                                                    if (!_isObject(tmp[i]) || 0 < Object.keys(tmp[i]).length) {
                                                        ctx.push(tmp[i])
                                                    }
                                                }
                                                var hasContext = 0 < ctx.length;
                                                if (1 === ctx.length) {
                                                    ctx = ctx[0]
                                                }
                                                if (_isArray(compacted)) {
                                                    var kwgraph = _compactIri(activeCtx, "@graph"),
                                                        graph = compacted;
                                                    compacted = {};
                                                    if (hasContext) {
                                                        compacted["@context"] = ctx
                                                    }
                                                    compacted[kwgraph] = graph
                                                } else if (_isObject(compacted) && hasContext) {
                                                    var graph = compacted;
                                                    compacted = {
                                                        "@context": ctx
                                                    };
                                                    for (var key in graph) {
                                                        compacted[key] = graph[key]
                                                    }
                                                }
                                                callback(null, compacted, activeCtx)
                                            }
                                        };
                                        jsonld.expand = function(input, options, callback) {
                                            if (1 > arguments.length) {
                                                return jsonld.nextTick(function() {
                                                    callback(new TypeError("Could not expand, too few arguments."))
                                                })
                                            }
                                            if ("function" === typeof options) {
                                                callback = options;
                                                options = {}
                                            }
                                            options = options || {};
                                            if (!("documentLoader" in options)) {
                                                options.documentLoader = jsonld.loadDocument
                                            }
                                            if (!("keepFreeFloatingNodes" in options)) {
                                                options.keepFreeFloatingNodes = !1
                                            }
                                            jsonld.nextTick(function() {
                                                if ("string" === typeof input) {
                                                    var done = function(err, remoteDoc) {
                                                            if (err) {
                                                                return callback(err)
                                                            }
                                                            try {
                                                                if (!remoteDoc.document) {
                                                                    throw new JsonLdError("No remote document found at the given URL.", "jsonld.NullRemoteDocument")
                                                                }
                                                                if ("string" === typeof remoteDoc.document) {
                                                                    remoteDoc.document = JSON.parse(remoteDoc.document)
                                                                }
                                                            } catch (ex) {
                                                                return callback(new JsonLdError("Could not retrieve a JSON-LD document from the URL. URL " + "dereferencing not implemented.", "jsonld.LoadDocumentError", {
                                                                    code: "loading document failed",
                                                                    cause: ex,
                                                                    remoteDoc: remoteDoc
                                                                }))
                                                            }
                                                            expand(remoteDoc)
                                                        },
                                                        promise = options.documentLoader(input, done);
                                                    if (promise && "then" in promise) {
                                                        promise.then(done.bind(null, null), done)
                                                    }
                                                    return
                                                }
                                                expand({
                                                    contextUrl: null,
                                                    documentUrl: null,
                                                    document: input
                                                })
                                            });

                                            function expand(remoteDoc) {
                                                if (!("base" in options)) {
                                                    options.base = remoteDoc.documentUrl || ""
                                                }
                                                var input = {
                                                    document: _clone(remoteDoc.document),
                                                    remoteContext: {
                                                        "@context": remoteDoc.contextUrl
                                                    }
                                                };
                                                if ("expandContext" in options) {
                                                    var expandContext = _clone(options.expandContext);
                                                    if ("object" === typeof expandContext && "@context" in expandContext) {
                                                        input.expandContext = expandContext
                                                    } else {
                                                        input.expandContext = {
                                                            "@context": expandContext
                                                        }
                                                    }
                                                }
                                                _retrieveContextUrls(input, options, function(err, input) {
                                                    if (err) {
                                                        return callback(err)
                                                    }
                                                    var expanded;
                                                    try {
                                                        var processor = new Processor,
                                                            activeCtx = _getInitialContext(options),
                                                            document = input.document,
                                                            remoteContext = input.remoteContext["@context"];
                                                        if (input.expandContext) {
                                                            activeCtx = processor.processContext(activeCtx, input.expandContext["@context"], options)
                                                        }
                                                        if (remoteContext) {
                                                            activeCtx = processor.processContext(activeCtx, remoteContext, options)
                                                        }
                                                        expanded = processor.expand(activeCtx, null, document, options, !1);
                                                        if (_isObject(expanded) && "@graph" in expanded && 1 === Object.keys(expanded).length) {
                                                            expanded = expanded["@graph"]
                                                        } else if (null === expanded) {
                                                            expanded = []
                                                        }
                                                        if (!_isArray(expanded)) {
                                                            expanded = [expanded]
                                                        }
                                                    } catch (ex) {
                                                        return callback(ex)
                                                    }
                                                    callback(null, expanded)
                                                })
                                            }
                                        };
                                        jsonld.flatten = function(input, ctx, options, callback) {
                                            if (1 > arguments.length) {
                                                return jsonld.nextTick(function() {
                                                    callback(new TypeError("Could not flatten, too few arguments."))
                                                })
                                            }
                                            if ("function" === typeof options) {
                                                callback = options;
                                                options = {}
                                            } else if ("function" === typeof ctx) {
                                                callback = ctx;
                                                ctx = null;
                                                options = {}
                                            }
                                            options = options || {};
                                            if (!("base" in options)) {
                                                options.base = "string" === typeof input ? input : ""
                                            }
                                            if (!("documentLoader" in options)) {
                                                options.documentLoader = jsonld.loadDocument
                                            }
                                            jsonld.expand(input, options, function(err, _input) {
                                                if (err) {
                                                    return callback(new JsonLdError("Could not expand input before flattening.", "jsonld.FlattenError", {
                                                        cause: err
                                                    }))
                                                }
                                                var flattened;
                                                try {
                                                    flattened = new Processor().flatten(_input)
                                                } catch (ex) {
                                                    return callback(ex)
                                                }
                                                if (null === ctx) {
                                                    return callback(null, flattened)
                                                }
                                                options.graph = !0;
                                                options.skipExpansion = !0;
                                                jsonld.compact(flattened, ctx, options, function(err, compacted) {
                                                    if (err) {
                                                        return callback(new JsonLdError("Could not compact flattened output.", "jsonld.FlattenError", {
                                                            cause: err
                                                        }))
                                                    }
                                                    callback(null, compacted)
                                                })
                                            })
                                        };
                                        jsonld.frame = function(input, frame, options, callback) {
                                            if (2 > arguments.length) {
                                                return jsonld.nextTick(function() {
                                                    callback(new TypeError("Could not frame, too few arguments."))
                                                })
                                            }
                                            if ("function" === typeof options) {
                                                callback = options;
                                                options = {}
                                            }
                                            options = options || {};
                                            if (!("base" in options)) {
                                                options.base = "string" === typeof input ? input : ""
                                            }
                                            if (!("documentLoader" in options)) {
                                                options.documentLoader = jsonld.loadDocument
                                            }
                                            if (!("embed" in options)) {
                                                options.embed = "@last"
                                            }
                                            options.explicit = options.explicit || !1;
                                            if (!("requireAll" in options)) {
                                                options.requireAll = !0
                                            }
                                            options.omitDefault = options.omitDefault || !1;
                                            jsonld.nextTick(function() {
                                                if ("string" === typeof frame) {
                                                    var done = function(err, remoteDoc) {
                                                            if (err) {
                                                                return callback(err)
                                                            }
                                                            try {
                                                                if (!remoteDoc.document) {
                                                                    throw new JsonLdError("No remote document found at the given URL.", "jsonld.NullRemoteDocument")
                                                                }
                                                                if ("string" === typeof remoteDoc.document) {
                                                                    remoteDoc.document = JSON.parse(remoteDoc.document)
                                                                }
                                                            } catch (ex) {
                                                                return callback(new JsonLdError("Could not retrieve a JSON-LD document from the URL. URL " + "dereferencing not implemented.", "jsonld.LoadDocumentError", {
                                                                    code: "loading document failed",
                                                                    cause: ex,
                                                                    remoteDoc: remoteDoc
                                                                }))
                                                            }
                                                            doFrame(remoteDoc)
                                                        },
                                                        promise = options.documentLoader(frame, done);
                                                    if (promise && "then" in promise) {
                                                        promise.then(done.bind(null, null), done)
                                                    }
                                                    return
                                                }
                                                doFrame({
                                                    contextUrl: null,
                                                    documentUrl: null,
                                                    document: frame
                                                })
                                            });

                                            function doFrame(remoteFrame) {
                                                var frame = remoteFrame.document,
                                                    ctx;
                                                if (frame) {
                                                    ctx = frame["@context"];
                                                    if (remoteFrame.contextUrl) {
                                                        if (!ctx) {
                                                            ctx = remoteFrame.contextUrl
                                                        } else if (_isArray(ctx)) {
                                                            ctx.push(remoteFrame.contextUrl)
                                                        } else {
                                                            ctx = [ctx, remoteFrame.contextUrl]
                                                        }
                                                        frame["@context"] = ctx
                                                    } else {
                                                        ctx = ctx || {}
                                                    }
                                                } else {
                                                    ctx = {}
                                                }
                                                jsonld.expand(input, options, function(err, expanded) {
                                                    if (err) {
                                                        return callback(new JsonLdError("Could not expand input before framing.", "jsonld.FrameError", {
                                                            cause: err
                                                        }))
                                                    }
                                                    var opts = _clone(options);
                                                    opts.isFrame = !0;
                                                    opts.keepFreeFloatingNodes = !0;
                                                    jsonld.expand(frame, opts, function(err, expandedFrame) {
                                                        if (err) {
                                                            return callback(new JsonLdError("Could not expand frame before framing.", "jsonld.FrameError", {
                                                                cause: err
                                                            }))
                                                        }
                                                        var framed;
                                                        try {
                                                            framed = new Processor().frame(expanded, expandedFrame, opts)
                                                        } catch (ex) {
                                                            return callback(ex)
                                                        }
                                                        opts.graph = !0;
                                                        opts.skipExpansion = !0;
                                                        opts.link = {};
                                                        jsonld.compact(framed, ctx, opts, function(err, compacted, ctx) {
                                                            if (err) {
                                                                return callback(new JsonLdError("Could not compact framed output.", "jsonld.FrameError", {
                                                                    cause: err
                                                                }))
                                                            }
                                                            var graph = _compactIri(ctx, "@graph");
                                                            opts.link = {};
                                                            compacted[graph] = _removePreserve(ctx, compacted[graph], opts);
                                                            callback(null, compacted)
                                                        })
                                                    })
                                                })
                                            }
                                        };
                                        jsonld.link = function(input, ctx, options, callback) {
                                            var frame = {};
                                            if (ctx) {
                                                frame["@context"] = ctx
                                            }
                                            frame["@embed"] = "@link";
                                            jsonld.frame(input, frame, options, callback)
                                        };
                                        jsonld.objectify = function(input, ctx, options, callback) {
                                            if ("function" === typeof options) {
                                                callback = options;
                                                options = {}
                                            }
                                            options = options || {};
                                            if (!("base" in options)) {
                                                options.base = "string" === typeof input ? input : ""
                                            }
                                            if (!("documentLoader" in options)) {
                                                options.documentLoader = jsonld.loadDocument
                                            }
                                            jsonld.expand(input, options, function(err, _input) {
                                                if (err) {
                                                    return callback(new JsonLdError("Could not expand input before linking.", "jsonld.LinkError", {
                                                        cause: err
                                                    }))
                                                }
                                                var flattened;
                                                try {
                                                    flattened = new Processor().flatten(_input)
                                                } catch (ex) {
                                                    return callback(ex)
                                                }
                                                options.graph = !0;
                                                options.skipExpansion = !0;
                                                jsonld.compact(flattened, ctx, options, function(err, compacted, ctx) {
                                                    if (err) {
                                                        return callback(new JsonLdError("Could not compact flattened output before linking.", "jsonld.LinkError", {
                                                            cause: err
                                                        }))
                                                    }
                                                    var graph = _compactIri(ctx, "@graph"),
                                                        top = compacted[graph][0],
                                                        recurse = function(subject) {
                                                            if (!_isObject(subject) && !_isArray(subject)) {
                                                                return
                                                            }
                                                            if (_isObject(subject)) {
                                                                if (recurse.visited[subject["@id"]]) {
                                                                    return
                                                                }
                                                                recurse.visited[subject["@id"]] = !0
                                                            }
                                                            for (var k in subject) {
                                                                var obj = subject[k],
                                                                    isid = "@id" === jsonld.getContextValue(ctx, k, "@type");
                                                                if (!_isArray(obj) && !_isObject(obj) && !isid) {
                                                                    continue
                                                                }
                                                                if (_isString(obj) && isid) {
                                                                    subject[k] = obj = top[obj];
                                                                    recurse(obj)
                                                                } else if (_isArray(obj)) {
                                                                    for (var i = 0; i < obj.length; ++i) {
                                                                        if (_isString(obj[i]) && isid) {
                                                                            obj[i] = top[obj[i]]
                                                                        } else if (_isObject(obj[i]) && "@id" in obj[i]) {
                                                                            obj[i] = top[obj[i]["@id"]]
                                                                        }
                                                                        recurse(obj[i])
                                                                    }
                                                                } else if (_isObject(obj)) {
                                                                    var sid = obj["@id"];
                                                                    subject[k] = obj = top[sid];
                                                                    recurse(obj)
                                                                }
                                                            }
                                                        };
                                                    recurse.visited = {};
                                                    recurse(top);
                                                    compacted.of_type = {};
                                                    for (var s in top) {
                                                        if (!("@type" in top[s])) {
                                                            continue
                                                        }
                                                        var types = top[s]["@type"];
                                                        if (!_isArray(types)) {
                                                            types = [types]
                                                        }
                                                        for (var t = 0; t < types.length; ++t) {
                                                            if (!(types[t] in compacted.of_type)) {
                                                                compacted.of_type[types[t]] = []
                                                            }
                                                            compacted.of_type[types[t]].push(top[s])
                                                        }
                                                    }
                                                    callback(null, compacted)
                                                })
                                            })
                                        };
                                        jsonld.normalize = function(input, options, callback) {
                                            if (1 > arguments.length) {
                                                return jsonld.nextTick(function() {
                                                    callback(new TypeError("Could not normalize, too few arguments."))
                                                })
                                            }
                                            if ("function" === typeof options) {
                                                callback = options;
                                                options = {}
                                            }
                                            options = options || {};
                                            if (!("algorithm" in options)) {
                                                options.algorithm = "URGNA2012"
                                            }
                                            if (!("base" in options)) {
                                                options.base = "string" === typeof input ? input : ""
                                            }
                                            if (!("documentLoader" in options)) {
                                                options.documentLoader = jsonld.loadDocument
                                            }
                                            if ("inputFormat" in options) {
                                                if ("application/nquads" !== options.inputFormat) {
                                                    return callback(new JsonLdError("Unknown normalization input format.", "jsonld.NormalizeError"))
                                                }
                                                var parsedInput = _parseNQuads(input);
                                                new Processor().normalize(parsedInput, options, callback)
                                            } else {
                                                var opts = _clone(options);
                                                delete opts.format;
                                                opts.produceGeneralizedRdf = !1;
                                                jsonld.toRDF(input, opts, function(err, dataset) {
                                                    if (err) {
                                                        return callback(new JsonLdError("Could not convert input to RDF dataset before normalization.", "jsonld.NormalizeError", {
                                                            cause: err
                                                        }))
                                                    }
                                                    new Processor().normalize(dataset, options, callback)
                                                })
                                            }
                                        };
                                        jsonld.fromRDF = function(dataset, options, callback) {
                                            if (1 > arguments.length) {
                                                return jsonld.nextTick(function() {
                                                    callback(new TypeError("Could not convert from RDF, too few arguments."))
                                                })
                                            }
                                            if ("function" === typeof options) {
                                                callback = options;
                                                options = {}
                                            }
                                            options = options || {};
                                            if (!("useRdfType" in options)) {
                                                options.useRdfType = !1
                                            }
                                            if (!("useNativeTypes" in options)) {
                                                options.useNativeTypes = !1
                                            }
                                            if (!("format" in options) && _isString(dataset)) {
                                                if (!("format" in options)) {
                                                    options.format = "application/nquads"
                                                }
                                            }
                                            jsonld.nextTick(function() {
                                                var rdfParser;
                                                if (options.format) {
                                                    rdfParser = options.rdfParser || _rdfParsers[options.format];
                                                    if (!rdfParser) {
                                                        return callback(new JsonLdError("Unknown input format.", "jsonld.UnknownFormat", {
                                                            format: options.format
                                                        }))
                                                    }
                                                } else {
                                                    rdfParser = function() {
                                                        return dataset
                                                    }
                                                }
                                                var callbackCalled = !1;
                                                try {
                                                    dataset = rdfParser(dataset, function(err, dataset) {
                                                        callbackCalled = !0;
                                                        if (err) {
                                                            return callback(err)
                                                        }
                                                        fromRDF(dataset, options, callback)
                                                    })
                                                } catch (e) {
                                                    if (!callbackCalled) {
                                                        return callback(e)
                                                    }
                                                    throw e
                                                }
                                                if (dataset) {
                                                    if ("then" in dataset) {
                                                        return dataset.then(function(dataset) {
                                                            fromRDF(dataset, options, callback)
                                                        }, callback)
                                                    }
                                                    fromRDF(dataset, options, callback)
                                                }

                                                function fromRDF(dataset, options, callback) {
                                                    new Processor().fromRDF(dataset, options, callback)
                                                }
                                            })
                                        };
                                        jsonld.toRDF = function(input, options, callback) {
                                            if (1 > arguments.length) {
                                                return jsonld.nextTick(function() {
                                                    callback(new TypeError("Could not convert to RDF, too few arguments."))
                                                })
                                            }
                                            if ("function" === typeof options) {
                                                callback = options;
                                                options = {}
                                            }
                                            options = options || {};
                                            if (!("base" in options)) {
                                                options.base = "string" === typeof input ? input : ""
                                            }
                                            if (!("documentLoader" in options)) {
                                                options.documentLoader = jsonld.loadDocument
                                            }
                                            jsonld.expand(input, options, function(err, expanded) {
                                                if (err) {
                                                    return callback(new JsonLdError("Could not expand input before serialization to RDF.", "jsonld.RdfError", {
                                                        cause: err
                                                    }))
                                                }
                                                var dataset;
                                                try {
                                                    dataset = Processor.prototype.toRDF(expanded, options);
                                                    if (options.format) {
                                                        if ("application/nquads" === options.format) {
                                                            return callback(null, _toNQuads(dataset))
                                                        }
                                                        throw new JsonLdError("Unknown output format.", "jsonld.UnknownFormat", {
                                                            format: options.format
                                                        })
                                                    }
                                                } catch (ex) {
                                                    return callback(ex)
                                                }
                                                callback(null, dataset)
                                            })
                                        };
                                        jsonld.createNodeMap = function(input, options, callback) {
                                            if (1 > arguments.length) {
                                                return jsonld.nextTick(function() {
                                                    callback(new TypeError("Could not create node map, too few arguments."))
                                                })
                                            }
                                            if ("function" === typeof options) {
                                                callback = options;
                                                options = {}
                                            }
                                            options = options || {};
                                            if (!("base" in options)) {
                                                options.base = "string" === typeof input ? input : ""
                                            }
                                            if (!("documentLoader" in options)) {
                                                options.documentLoader = jsonld.loadDocument
                                            }
                                            jsonld.expand(input, options, function(err, _input) {
                                                if (err) {
                                                    return callback(new JsonLdError("Could not expand input before creating node map.", "jsonld.CreateNodeMapError", {
                                                        cause: err
                                                    }))
                                                }
                                                var nodeMap;
                                                try {
                                                    nodeMap = new Processor().createNodeMap(_input, options)
                                                } catch (ex) {
                                                    return callback(ex)
                                                }
                                                callback(null, nodeMap)
                                            })
                                        };
                                        jsonld.merge = function(docs, ctx, options, callback) {
                                            if (1 > arguments.length) {
                                                return jsonld.nextTick(function() {
                                                    callback(new TypeError("Could not merge, too few arguments."))
                                                })
                                            }
                                            if (!_isArray(docs)) {
                                                return jsonld.nextTick(function() {
                                                    callback(new TypeError("Could not merge, \"docs\" must be an array."))
                                                })
                                            }
                                            if ("function" === typeof options) {
                                                callback = options;
                                                options = {}
                                            } else if ("function" === typeof ctx) {
                                                callback = ctx;
                                                ctx = null;
                                                options = {}
                                            }
                                            options = options || {};
                                            for (var expanded = [], error = null, count = docs.length, i = 0, opts; i < docs.length; ++i) {
                                                opts = {};
                                                for (var key in options) {
                                                    opts[key] = options[key]
                                                }
                                                jsonld.expand(docs[i], opts, expandComplete)
                                            }

                                            function expandComplete(err, _input) {
                                                if (error) {
                                                    return
                                                }
                                                if (err) {
                                                    error = err;
                                                    return callback(new JsonLdError("Could not expand input before flattening.", "jsonld.FlattenError", {
                                                        cause: err
                                                    }))
                                                }
                                                expanded.push(_input);
                                                if (0 === --count) {
                                                    merge(expanded)
                                                }
                                            }

                                            function merge(expanded) {
                                                var mergeNodes = !0;
                                                if ("mergeNodes" in options) {
                                                    mergeNodes = options.mergeNodes
                                                }
                                                var issuer = options.namer || options.issuer || new IdentifierIssuer("_:b"),
                                                    graphs = {
                                                        "@default": {}
                                                    },
                                                    defaultGraph;
                                                try {
                                                    for (var i = 0, doc; i < expanded.length; ++i) {
                                                        doc = expanded[i];
                                                        doc = jsonld.relabelBlankNodes(doc, {
                                                            issuer: new IdentifierIssuer("_:b" + i + "-")
                                                        });
                                                        var _graphs = mergeNodes || 0 === i ? graphs : {
                                                            "@default": {}
                                                        };
                                                        _createNodeMap(doc, _graphs, "@default", issuer);
                                                        if (_graphs !== graphs) {
                                                            for (var graphName in _graphs) {
                                                                var _nodeMap = _graphs[graphName];
                                                                if (!(graphName in graphs)) {
                                                                    graphs[graphName] = _nodeMap;
                                                                    continue
                                                                }
                                                                var nodeMap = graphs[graphName];
                                                                for (var key in _nodeMap) {
                                                                    if (!(key in nodeMap)) {
                                                                        nodeMap[key] = _nodeMap[key]
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                    defaultGraph = _mergeNodeMaps(graphs)
                                                } catch (ex) {
                                                    return callback(ex)
                                                }
                                                for (var flattened = [], keys = Object.keys(defaultGraph).sort(), ki = 0, node; ki < keys.length; ++ki) {
                                                    node = defaultGraph[keys[ki]];
                                                    if (!_isSubjectReference(node)) {
                                                        flattened.push(node)
                                                    }
                                                }
                                                if (null === ctx) {
                                                    return callback(null, flattened)
                                                }
                                                options.graph = !0;
                                                options.skipExpansion = !0;
                                                jsonld.compact(flattened, ctx, options, function(err, compacted) {
                                                    if (err) {
                                                        return callback(new JsonLdError("Could not compact merged output.", "jsonld.MergeError", {
                                                            cause: err
                                                        }))
                                                    }
                                                    callback(null, compacted)
                                                })
                                            }
                                        };
                                        jsonld.relabelBlankNodes = function(input, options) {
                                            options = options || {};
                                            var issuer = options.namer || options.issuer || new IdentifierIssuer("_:b");
                                            return _labelBlankNodes(issuer, input)
                                        };
                                        jsonld.prependBase = function(base, iri) {
                                            return _prependBase(base, iri)
                                        };
                                        jsonld.documentLoader = function(url, callback) {
                                            var err = new JsonLdError("Could not retrieve a JSON-LD document from the URL. URL " + "dereferencing not implemented.", "jsonld.LoadDocumentError", {
                                                code: "loading document failed"
                                            });
                                            if (_nodejs) {
                                                return callback(err, {
                                                    contextUrl: null,
                                                    documentUrl: url,
                                                    document: null
                                                })
                                            }
                                            return jsonld.promisify(function(callback) {
                                                callback(err)
                                            })
                                        };
                                        jsonld.loadDocument = function(url, callback) {
                                            var promise = jsonld.documentLoader(url, callback);
                                            if (promise && "then" in promise) {
                                                promise.then(callback.bind(null, null), callback)
                                            }
                                        };
                                        jsonld.promises = function(options) {
                                            options = options || {};
                                            var slice = Array.prototype.slice,
                                                promisify = jsonld.promisify,
                                                api = options.api || {},
                                                version = options.version || "jsonld.js";
                                            if ("string" === typeof options.api) {
                                                if (!options.version) {
                                                    version = options.api
                                                }
                                                api = {}
                                            }
                                            api.expand = function() {
                                                if (1 > arguments.length) {
                                                    throw new TypeError("Could not expand, too few arguments.")
                                                }
                                                return promisify.apply(null, [jsonld.expand].concat(slice.call(arguments)))
                                            };
                                            api.compact = function() {
                                                if (2 > arguments.length) {
                                                    throw new TypeError("Could not compact, too few arguments.")
                                                }
                                                var compact = function(input, ctx, options, callback) {
                                                    if ("function" === typeof options) {
                                                        callback = options;
                                                        options = {}
                                                    }
                                                    options = options || {};
                                                    jsonld.compact(input, ctx, options, function(err, compacted) {
                                                        callback(err, compacted)
                                                    })
                                                };
                                                return promisify.apply(null, [compact].concat(slice.call(arguments)))
                                            };
                                            api.flatten = function() {
                                                if (1 > arguments.length) {
                                                    throw new TypeError("Could not flatten, too few arguments.")
                                                }
                                                return promisify.apply(null, [jsonld.flatten].concat(slice.call(arguments)))
                                            };
                                            api.frame = function() {
                                                if (2 > arguments.length) {
                                                    throw new TypeError("Could not frame, too few arguments.")
                                                }
                                                return promisify.apply(null, [jsonld.frame].concat(slice.call(arguments)))
                                            };
                                            api.fromRDF = function() {
                                                if (1 > arguments.length) {
                                                    throw new TypeError("Could not convert from RDF, too few arguments.")
                                                }
                                                return promisify.apply(null, [jsonld.fromRDF].concat(slice.call(arguments)))
                                            };
                                            api.toRDF = function() {
                                                if (1 > arguments.length) {
                                                    throw new TypeError("Could not convert to RDF, too few arguments.")
                                                }
                                                return promisify.apply(null, [jsonld.toRDF].concat(slice.call(arguments)))
                                            };
                                            api.normalize = function() {
                                                if (1 > arguments.length) {
                                                    throw new TypeError("Could not normalize, too few arguments.")
                                                }
                                                return promisify.apply(null, [jsonld.normalize].concat(slice.call(arguments)))
                                            };
                                            if ("jsonld.js" === version) {
                                                api.link = function() {
                                                    if (2 > arguments.length) {
                                                        throw new TypeError("Could not link, too few arguments.")
                                                    }
                                                    return promisify.apply(null, [jsonld.link].concat(slice.call(arguments)))
                                                };
                                                api.objectify = function() {
                                                    return promisify.apply(null, [jsonld.objectify].concat(slice.call(arguments)))
                                                };
                                                api.createNodeMap = function() {
                                                    return promisify.apply(null, [jsonld.createNodeMap].concat(slice.call(arguments)))
                                                };
                                                api.merge = function() {
                                                    return promisify.apply(null, [jsonld.merge].concat(slice.call(arguments)))
                                                }
                                            }
                                            try {
                                                jsonld.Promise = global.Promise || require("es6-promise").Promise
                                            } catch (e) {
                                                var f = function() {
                                                    throw new Error("Unable to find a Promise implementation.")
                                                };
                                                for (var method in api) {
                                                    api[method] = f
                                                }
                                            }
                                            return api
                                        };
                                        jsonld.promisify = function(op) {
                                            if (!jsonld.Promise) {
                                                try {
                                                    jsonld.Promise = global.Promise || require("es6-promise").Promise
                                                } catch (e) {
                                                    throw new Error("Unable to find a Promise implementation.")
                                                }
                                            }
                                            var args = Array.prototype.slice.call(arguments, 1);
                                            return new jsonld.Promise(function(resolve, reject) {
                                                op.apply(null, args.concat(function(err, value) {
                                                    if (!err) {
                                                        resolve(value)
                                                    } else {
                                                        reject(err)
                                                    }
                                                }))
                                            })
                                        };
                                        jsonld.promises({
                                            api: jsonld.promises
                                        });

                                        function JsonLdProcessor() {}
                                        JsonLdProcessor.prototype = jsonld.promises({
                                            version: "json-ld-1.0"
                                        });
                                        JsonLdProcessor.prototype.toString = function() {
                                            if (this instanceof JsonLdProcessor) {
                                                return "[object JsonLdProcessor]"
                                            }
                                            return "[object JsonLdProcessorPrototype]"
                                        };
                                        jsonld.JsonLdProcessor = JsonLdProcessor;
                                        var canDefineProperty = !!Object.defineProperty;
                                        if (canDefineProperty) {
                                            try {
                                                Object.defineProperty({}, "x", {})
                                            } catch (e) {
                                                canDefineProperty = !1
                                            }
                                        }
                                        if (canDefineProperty) {
                                            Object.defineProperty(JsonLdProcessor, "prototype", {
                                                writable: !1,
                                                enumerable: !1
                                            });
                                            Object.defineProperty(JsonLdProcessor.prototype, "constructor", {
                                                writable: !0,
                                                enumerable: !1,
                                                configurable: !0,
                                                value: JsonLdProcessor
                                            })
                                        }
                                        if (_browser && "undefined" === typeof global.JsonLdProcessor) {
                                            if (canDefineProperty) {
                                                Object.defineProperty(global, "JsonLdProcessor", {
                                                    writable: !0,
                                                    enumerable: !1,
                                                    configurable: !0,
                                                    value: JsonLdProcessor
                                                })
                                            } else {
                                                global.JsonLdProcessor = JsonLdProcessor
                                            }
                                        }
                                        var _setImmediate = "function" === typeof setImmediate && setImmediate,
                                            _delay = _setImmediate ? function(fn) {
                                                _setImmediate(fn)
                                            } : function(fn) {
                                                setTimeout(fn, 0)
                                            };
                                        if ("object" === typeof process && "function" === typeof process.nextTick) {
                                            jsonld.nextTick = process.nextTick
                                        } else {
                                            jsonld.nextTick = _delay
                                        }
                                        jsonld.setImmediate = _setImmediate ? _delay : jsonld.nextTick;
                                        jsonld.parseLinkHeader = function(header) {
                                            for (var rval = {}, entries = header.match(/(?:<[^>]*?>|"[^"]*?"|[^,])+/g), rLinkHeader = /\s*<([^>]*?)>\s*(?:;\s*(.*))?/, i = 0, match; i < entries.length; ++i) {
                                                match = entries[i].match(rLinkHeader);
                                                if (!match) {
                                                    continue
                                                }
                                                var result = {
                                                        target: match[1]
                                                    },
                                                    params = match[2],
                                                    rParams = /(.*?)=(?:(?:"([^"]*?)")|([^"]*?))\s*(?:(?:;\s*)|$)/g;
                                                while (match = rParams.exec(params)) {
                                                    result[match[1]] = match[2] === void 0 ? match[3] : match[2]
                                                }
                                                var rel = result.rel || "";
                                                if (_isArray(rval[rel])) {
                                                    rval[rel].push(result)
                                                } else if (rel in rval) {
                                                    rval[rel] = [rval[rel], result]
                                                } else {
                                                    rval[rel] = result
                                                }
                                            }
                                            return rval
                                        };
                                        jsonld.RequestQueue = function() {
                                            this._requests = {}
                                        };
                                        jsonld.RequestQueue.prototype.wrapLoader = function(loader) {
                                            this._loader = loader;
                                            this._usePromise = 1 === loader.length;
                                            return this.add.bind(this)
                                        };
                                        jsonld.RequestQueue.prototype.add = function(url, callback) {
                                            var self = this;
                                            if (!callback && !self._usePromise) {
                                                throw new Error("callback must be specified.")
                                            }
                                            if (self._usePromise) {
                                                return new jsonld.Promise(function(resolve, reject) {
                                                    var load = self._requests[url];
                                                    if (!load) {
                                                        load = self._requests[url] = self._loader(url).then(function(remoteDoc) {
                                                            delete self._requests[url];
                                                            return remoteDoc
                                                        }).catch(function(err) {
                                                            delete self._requests[url];
                                                            throw err
                                                        })
                                                    }
                                                    load.then(function(remoteDoc) {
                                                        resolve(remoteDoc)
                                                    }).catch(function(err) {
                                                        reject(err)
                                                    })
                                                })
                                            }
                                            if (url in self._requests) {
                                                self._requests[url].push(callback)
                                            } else {
                                                self._requests[url] = [callback];
                                                self._loader(url, function(err, remoteDoc) {
                                                    var callbacks = self._requests[url];
                                                    delete self._requests[url];
                                                    for (var i = 0; i < callbacks.length; ++i) {
                                                        callbacks[i](err, remoteDoc)
                                                    }
                                                })
                                            }
                                        };
                                        jsonld.DocumentCache = function(size) {
                                            this.order = [];
                                            this.cache = {};
                                            this.size = size || 50;
                                            this.expires = 1e3 * 30
                                        };
                                        jsonld.DocumentCache.prototype.get = function(url) {
                                            if (url in this.cache) {
                                                var entry = this.cache[url];
                                                if (entry.expires >= +new Date) {
                                                    return entry.ctx
                                                }
                                                delete this.cache[url];
                                                this.order.splice(this.order.indexOf(url), 1)
                                            }
                                            return null
                                        };
                                        jsonld.DocumentCache.prototype.set = function(url, ctx) {
                                            if (this.order.length === this.size) {
                                                delete this.cache[this.order.shift()]
                                            }
                                            this.order.push(url);
                                            this.cache[url] = {
                                                ctx: ctx,
                                                expires: +new Date + this.expires
                                            }
                                        };
                                        jsonld.ActiveContextCache = function(size) {
                                            this.order = [];
                                            this.cache = {};
                                            this.size = size || 100
                                        };
                                        jsonld.ActiveContextCache.prototype.get = function(activeCtx, localCtx) {
                                            var key1 = JSON.stringify(activeCtx),
                                                key2 = JSON.stringify(localCtx),
                                                level1 = this.cache[key1];
                                            if (level1 && key2 in level1) {
                                                return level1[key2]
                                            }
                                            return null
                                        };
                                        jsonld.ActiveContextCache.prototype.set = function(activeCtx, localCtx, result) {
                                            if (this.order.length === this.size) {
                                                var entry = this.order.shift();
                                                delete this.cache[entry.activeCtx][entry.localCtx]
                                            }
                                            var key1 = JSON.stringify(activeCtx),
                                                key2 = JSON.stringify(localCtx);
                                            this.order.push({
                                                activeCtx: key1,
                                                localCtx: key2
                                            });
                                            if (!(key1 in this.cache)) {
                                                this.cache[key1] = {}
                                            }
                                            this.cache[key1][key2] = _clone(result)
                                        };
                                        jsonld.cache = {
                                            activeCtx: new jsonld.ActiveContextCache
                                        };
                                        jsonld.documentLoaders = {};
                                        jsonld.documentLoaders.jquery = function($, options) {
                                            options = options || {};
                                            var queue = new jsonld.RequestQueue,
                                                usePromise = "usePromise" in options ? options.usePromise : "undefined" !== typeof Promise;
                                            if (usePromise) {
                                                return queue.wrapLoader(function(url) {
                                                    return jsonld.promisify(loader, url)
                                                })
                                            }
                                            return queue.wrapLoader(loader);

                                            function loader(url, callback) {
                                                if (0 !== url.indexOf("http:") && 0 !== url.indexOf("https:")) {
                                                    return callback(new JsonLdError("URL could not be dereferenced; only \"http\" and \"https\" URLs are " + "supported.", "jsonld.InvalidUrl", {
                                                        code: "loading document failed",
                                                        url: url
                                                    }), {
                                                        contextUrl: null,
                                                        documentUrl: url,
                                                        document: null
                                                    })
                                                }
                                                if (options.secure && 0 !== url.indexOf("https")) {
                                                    return callback(new JsonLdError("URL could not be dereferenced; secure mode is enabled and " + "the URL's scheme is not \"https\".", "jsonld.InvalidUrl", {
                                                        code: "loading document failed",
                                                        url: url
                                                    }), {
                                                        contextUrl: null,
                                                        documentUrl: url,
                                                        document: null
                                                    })
                                                }
                                                $.ajax({
                                                    url: url,
                                                    accepts: {
                                                        json: "application/ld+json, application/json"
                                                    },
                                                    headers: {
                                                        Accept: "application/ld+json, application/json"
                                                    },
                                                    dataType: "json",
                                                    crossDomain: !0,
                                                    success: function(data, textStatus, jqXHR) {
                                                        var doc = {
                                                                contextUrl: null,
                                                                documentUrl: url,
                                                                document: data
                                                            },
                                                            contentType = jqXHR.getResponseHeader("Content-Type"),
                                                            linkHeader = jqXHR.getResponseHeader("Link");
                                                        if (linkHeader && "application/ld+json" !== contentType) {
                                                            linkHeader = jsonld.parseLinkHeader(linkHeader)[LINK_HEADER_REL];
                                                            if (_isArray(linkHeader)) {
                                                                return callback(new JsonLdError("URL could not be dereferenced, it has more than one " + "associated HTTP Link Header.", "jsonld.InvalidUrl", {
                                                                    code: "multiple context link headers",
                                                                    url: url
                                                                }), doc)
                                                            }
                                                            if (linkHeader) {
                                                                doc.contextUrl = linkHeader.target
                                                            }
                                                        }
                                                        callback(null, doc)
                                                    },
                                                    error: function(jqXHR, textStatus, err) {
                                                        callback(new JsonLdError("URL could not be dereferenced, an error occurred.", "jsonld.LoadDocumentError", {
                                                            code: "loading document failed",
                                                            url: url,
                                                            cause: err
                                                        }), {
                                                            contextUrl: null,
                                                            documentUrl: url,
                                                            document: null
                                                        })
                                                    }
                                                })
                                            }
                                        };
                                        jsonld.documentLoaders.node = function(options) {
                                            options = options || {};
                                            var strictSSL = "strictSSL" in options ? options.strictSSL : !0,
                                                maxRedirects = "maxRedirects" in options ? options.maxRedirects : -1,
                                                request = "request" in options ? options.request : require("request"),
                                                acceptHeader = "application/ld+json, application/json",
                                                http = require("http"),
                                                queue = new jsonld.RequestQueue;
                                            if (options.usePromise) {
                                                return queue.wrapLoader(function(url) {
                                                    return jsonld.promisify(loadDocument, url, [])
                                                })
                                            }
                                            var headers = options.headers || {};
                                            if ("Accept" in headers || "accept" in headers) {
                                                throw new RangeError("Accept header may not be specified as an option; only \"" + acceptHeader + "\" is supported.")
                                            }
                                            return queue.wrapLoader(function(url, callback) {
                                                loadDocument(url, [], callback)
                                            });

                                            function loadDocument(url, redirects, callback) {
                                                if (0 !== url.indexOf("http:") && 0 !== url.indexOf("https:")) {
                                                    return callback(new JsonLdError("URL could not be dereferenced; only \"http\" and \"https\" URLs are " + "supported.", "jsonld.InvalidUrl", {
                                                        code: "loading document failed",
                                                        url: url
                                                    }), {
                                                        contextUrl: null,
                                                        documentUrl: url,
                                                        document: null
                                                    })
                                                }
                                                if (options.secure && 0 !== url.indexOf("https")) {
                                                    return callback(new JsonLdError("URL could not be dereferenced; secure mode is enabled and " + "the URL's scheme is not \"https\".", "jsonld.InvalidUrl", {
                                                        code: "loading document failed",
                                                        url: url
                                                    }), {
                                                        contextUrl: null,
                                                        documentUrl: url,
                                                        document: null
                                                    })
                                                }
                                                var doc = null;
                                                if (null !== doc) {
                                                    return callback(null, doc)
                                                }
                                                var headers = {
                                                    Accept: acceptHeader
                                                };
                                                for (var k in options.headers) {
                                                    headers[k] = options.headers[k]
                                                }
                                                request({
                                                    url: url,
                                                    headers: headers,
                                                    strictSSL: strictSSL,
                                                    followRedirect: !1
                                                }, handleResponse);

                                                function handleResponse(err, res, body) {
                                                    doc = {
                                                        contextUrl: null,
                                                        documentUrl: url,
                                                        document: body || null
                                                    };
                                                    if (err) {
                                                        return callback(new JsonLdError("URL could not be dereferenced, an error occurred.", "jsonld.LoadDocumentError", {
                                                            code: "loading document failed",
                                                            url: url,
                                                            cause: err
                                                        }), doc)
                                                    }
                                                    var statusText = http.STATUS_CODES[res.statusCode];
                                                    if (400 <= res.statusCode) {
                                                        return callback(new JsonLdError("URL could not be dereferenced: " + statusText, "jsonld.InvalidUrl", {
                                                            code: "loading document failed",
                                                            url: url,
                                                            httpStatusCode: res.statusCode
                                                        }), doc)
                                                    }
                                                    if (res.headers.link && "application/ld+json" !== res.headers["content-type"]) {
                                                        var linkHeader = jsonld.parseLinkHeader(res.headers.link)[LINK_HEADER_REL];
                                                        if (_isArray(linkHeader)) {
                                                            return callback(new JsonLdError("URL could not be dereferenced, it has more than one associated " + "HTTP Link Header.", "jsonld.InvalidUrl", {
                                                                code: "multiple context link headers",
                                                                url: url
                                                            }), doc)
                                                        }
                                                        if (linkHeader) {
                                                            doc.contextUrl = linkHeader.target
                                                        }
                                                    }
                                                    if (300 <= res.statusCode && 400 > res.statusCode && res.headers.location) {
                                                        if (redirects.length === maxRedirects) {
                                                            return callback(new JsonLdError("URL could not be dereferenced; there were too many redirects.", "jsonld.TooManyRedirects", {
                                                                code: "loading document failed",
                                                                url: url,
                                                                httpStatusCode: res.statusCode,
                                                                redirects: redirects
                                                            }), doc)
                                                        }
                                                        if (-1 !== redirects.indexOf(url)) {
                                                            return callback(new JsonLdError("URL could not be dereferenced; infinite redirection was detected.", "jsonld.InfiniteRedirectDetected", {
                                                                code: "recursive context inclusion",
                                                                url: url,
                                                                httpStatusCode: res.statusCode,
                                                                redirects: redirects
                                                            }), doc)
                                                        }
                                                        redirects.push(url);
                                                        return loadDocument(res.headers.location, redirects, callback)
                                                    }
                                                    redirects.push(url);
                                                    callback(err, doc)
                                                }
                                            }
                                        };
                                        jsonld.documentLoaders.xhr = function(options) {
                                            options = options || {};
                                            var rlink = /(^|(\r\n))link:/i,
                                                queue = new jsonld.RequestQueue,
                                                usePromise = "usePromise" in options ? options.usePromise : "undefined" !== typeof Promise;
                                            if (usePromise) {
                                                return queue.wrapLoader(function(url) {
                                                    return jsonld.promisify(loader, url)
                                                })
                                            }
                                            return queue.wrapLoader(loader);

                                            function loader(url, callback) {
                                                if (0 !== url.indexOf("http:") && 0 !== url.indexOf("https:")) {
                                                    return callback(new JsonLdError("URL could not be dereferenced; only \"http\" and \"https\" URLs are " + "supported.", "jsonld.InvalidUrl", {
                                                        code: "loading document failed",
                                                        url: url
                                                    }), {
                                                        contextUrl: null,
                                                        documentUrl: url,
                                                        document: null
                                                    })
                                                }
                                                if (options.secure && 0 !== url.indexOf("https")) {
                                                    return callback(new JsonLdError("URL could not be dereferenced; secure mode is enabled and " + "the URL's scheme is not \"https\".", "jsonld.InvalidUrl", {
                                                        code: "loading document failed",
                                                        url: url
                                                    }), {
                                                        contextUrl: null,
                                                        documentUrl: url,
                                                        document: null
                                                    })
                                                }
                                                var xhr = options.xhr || XMLHttpRequest,
                                                    req = new xhr;
                                                req.onload = function() {
                                                    if (400 <= req.status) {
                                                        return callback(new JsonLdError("URL could not be dereferenced: " + req.statusText, "jsonld.LoadDocumentError", {
                                                            code: "loading document failed",
                                                            url: url,
                                                            httpStatusCode: req.status
                                                        }), {
                                                            contextUrl: null,
                                                            documentUrl: url,
                                                            document: null
                                                        })
                                                    }
                                                    var doc = {
                                                            contextUrl: null,
                                                            documentUrl: url,
                                                            document: req.response
                                                        },
                                                        contentType = req.getResponseHeader("Content-Type"),
                                                        linkHeader;
                                                    if (rlink.test(req.getAllResponseHeaders())) {
                                                        linkHeader = req.getResponseHeader("Link")
                                                    }
                                                    if (linkHeader && "application/ld+json" !== contentType) {
                                                        linkHeader = jsonld.parseLinkHeader(linkHeader)[LINK_HEADER_REL];
                                                        if (_isArray(linkHeader)) {
                                                            return callback(new JsonLdError("URL could not be dereferenced, it has more than one " + "associated HTTP Link Header.", "jsonld.InvalidUrl", {
                                                                code: "multiple context link headers",
                                                                url: url
                                                            }), doc)
                                                        }
                                                        if (linkHeader) {
                                                            doc.contextUrl = linkHeader.target
                                                        }
                                                    }
                                                    callback(null, doc)
                                                };
                                                req.onerror = function() {
                                                    callback(new JsonLdError("URL could not be dereferenced, an error occurred.", "jsonld.LoadDocumentError", {
                                                        code: "loading document failed",
                                                        url: url
                                                    }), {
                                                        contextUrl: null,
                                                        documentUrl: url,
                                                        document: null
                                                    })
                                                };
                                                req.open("GET", url, !0);
                                                req.setRequestHeader("Accept", "application/ld+json, application/json");
                                                req.send()
                                            }
                                        };
                                        jsonld.useDocumentLoader = function(type) {
                                            if (!(type in jsonld.documentLoaders)) {
                                                throw new JsonLdError("Unknown document loader type: \"" + type + "\"", "jsonld.UnknownDocumentLoader", {
                                                    type: type
                                                })
                                            }
                                            jsonld.documentLoader = jsonld.documentLoaders[type].apply(jsonld, Array.prototype.slice.call(arguments, 1))
                                        };
                                        jsonld.processContext = function(activeCtx, localCtx) {
                                            var options = {},
                                                callbackArg = 2;
                                            if (3 < arguments.length) {
                                                options = arguments[2] || {};
                                                callbackArg += 1
                                            }
                                            var callback = arguments[callbackArg];
                                            if (!("base" in options)) {
                                                options.base = ""
                                            }
                                            if (!("documentLoader" in options)) {
                                                options.documentLoader = jsonld.loadDocument
                                            }
                                            if (null === localCtx) {
                                                return callback(null, _getInitialContext(options))
                                            }
                                            localCtx = _clone(localCtx);
                                            if (!(_isObject(localCtx) && "@context" in localCtx)) {
                                                localCtx = {
                                                    "@context": localCtx
                                                }
                                            }
                                            _retrieveContextUrls(localCtx, options, function(err, ctx) {
                                                if (err) {
                                                    return callback(err)
                                                }
                                                try {
                                                    ctx = new Processor().processContext(activeCtx, ctx, options)
                                                } catch (ex) {
                                                    return callback(ex)
                                                }
                                                callback(null, ctx)
                                            })
                                        };
                                        jsonld.hasProperty = function(subject, property) {
                                            var rval = !1;
                                            if (property in subject) {
                                                var value = subject[property];
                                                rval = !_isArray(value) || 0 < value.length
                                            }
                                            return rval
                                        };
                                        jsonld.hasValue = function(subject, property, value) {
                                            var rval = !1;
                                            if (jsonld.hasProperty(subject, property)) {
                                                var val = subject[property],
                                                    isList = _isList(val);
                                                if (_isArray(val) || isList) {
                                                    if (isList) {
                                                        val = val["@list"]
                                                    }
                                                    for (var i = 0; i < val.length; ++i) {
                                                        if (jsonld.compareValues(value, val[i])) {
                                                            rval = !0;
                                                            break
                                                        }
                                                    }
                                                } else if (!_isArray(value)) {
                                                    rval = jsonld.compareValues(value, val)
                                                }
                                            }
                                            return rval
                                        };
                                        jsonld.addValue = function(subject, property, value, options) {
                                            options = options || {};
                                            if (!("propertyIsArray" in options)) {
                                                options.propertyIsArray = !1
                                            }
                                            if (!("allowDuplicate" in options)) {
                                                options.allowDuplicate = !0
                                            }
                                            if (_isArray(value)) {
                                                if (0 === value.length && options.propertyIsArray && !(property in subject)) {
                                                    subject[property] = []
                                                }
                                                for (var i = 0; i < value.length; ++i) {
                                                    jsonld.addValue(subject, property, value[i], options)
                                                }
                                            } else if (property in subject) {
                                                var hasValue = !options.allowDuplicate && jsonld.hasValue(subject, property, value);
                                                if (!_isArray(subject[property]) && (!hasValue || options.propertyIsArray)) {
                                                    subject[property] = [subject[property]]
                                                }
                                                if (!hasValue) {
                                                    subject[property].push(value)
                                                }
                                            } else {
                                                subject[property] = options.propertyIsArray ? [value] : value
                                            }
                                        };
                                        jsonld.getValues = function(subject, property) {
                                            var rval = subject[property] || [];
                                            if (!_isArray(rval)) {
                                                rval = [rval]
                                            }
                                            return rval
                                        };
                                        jsonld.removeProperty = function(subject, property) {
                                            delete subject[property]
                                        };
                                        jsonld.removeValue = function(subject, property, value, options) {
                                            options = options || {};
                                            if (!("propertyIsArray" in options)) {
                                                options.propertyIsArray = !1
                                            }
                                            var values = jsonld.getValues(subject, property).filter(function(e) {
                                                return !jsonld.compareValues(e, value)
                                            });
                                            if (0 === values.length) {
                                                jsonld.removeProperty(subject, property)
                                            } else if (1 === values.length && !options.propertyIsArray) {
                                                subject[property] = values[0]
                                            } else {
                                                subject[property] = values
                                            }
                                        };
                                        jsonld.compareValues = function(v1, v2) {
                                            if (v1 === v2) {
                                                return !0
                                            }
                                            if (_isValue(v1) && _isValue(v2) && v1["@value"] === v2["@value"] && v1["@type"] === v2["@type"] && v1["@language"] === v2["@language"] && v1["@index"] === v2["@index"]) {
                                                return !0
                                            }
                                            if (_isObject(v1) && "@id" in v1 && _isObject(v2) && "@id" in v2) {
                                                return v1["@id"] === v2["@id"]
                                            }
                                            return !1
                                        };
                                        jsonld.getContextValue = function(ctx, key, type) {
                                            var rval = null;
                                            if (null === key) {
                                                return rval
                                            }
                                            if ("@language" === type && type in ctx) {
                                                rval = ctx[type]
                                            }
                                            if (ctx.mappings[key]) {
                                                var entry = ctx.mappings[key];
                                                if (_isUndefined(type)) {
                                                    rval = entry
                                                } else if (type in entry) {
                                                    rval = entry[type]
                                                }
                                            }
                                            return rval
                                        };
                                        var _rdfParsers = {};
                                        jsonld.registerRDFParser = function(contentType, parser) {
                                            _rdfParsers[contentType] = parser
                                        };
                                        jsonld.unregisterRDFParser = function(contentType) {
                                            delete _rdfParsers[contentType]
                                        };
                                        if (_nodejs) {
                                            if ("undefined" === typeof XMLSerializer) {
                                                var XMLSerializer = null
                                            }
                                            if ("undefined" === typeof Node) {
                                                var Node = {
                                                    ELEMENT_NODE: 1,
                                                    ATTRIBUTE_NODE: 2,
                                                    TEXT_NODE: 3,
                                                    CDATA_SECTION_NODE: 4,
                                                    ENTITY_REFERENCE_NODE: 5,
                                                    ENTITY_NODE: 6,
                                                    PROCESSING_INSTRUCTION_NODE: 7,
                                                    COMMENT_NODE: 8,
                                                    DOCUMENT_NODE: 9,
                                                    DOCUMENT_TYPE_NODE: 10,
                                                    DOCUMENT_FRAGMENT_NODE: 11,
                                                    NOTATION_NODE: 12
                                                }
                                            }
                                        }
                                        var XSD_BOOLEAN = "http://www.w3.org/2001/XMLSchema#boolean",
                                            XSD_DOUBLE = "http://www.w3.org/2001/XMLSchema#double",
                                            XSD_INTEGER = "http://www.w3.org/2001/XMLSchema#integer",
                                            XSD_STRING = "http://www.w3.org/2001/XMLSchema#string",
                                            RDF = "http://www.w3.org/1999/02/22-rdf-syntax-ns#",
                                            RDF_FIRST = RDF + "first",
                                            RDF_REST = RDF + "rest",
                                            RDF_NIL = RDF + "nil",
                                            RDF_TYPE = RDF + "type",
                                            RDF_LANGSTRING = RDF + "langString",
                                            LINK_HEADER_REL = "http://www.w3.org/ns/json-ld#context",
                                            MAX_CONTEXT_URLS = 10,
                                            JsonLdError = function(msg, type, details) {
                                                if (_nodejs) {
                                                    Error.call(this);
                                                    Error.captureStackTrace(this, this.constructor)
                                                } else if ("undefined" !== typeof Error) {
                                                    this.stack = new Error().stack
                                                }
                                                this.name = type || "jsonld.Error";
                                                this.message = msg || "An unspecified JSON-LD error occurred.";
                                                this.details = details || {}
                                            };
                                        if (_nodejs) {
                                            require("util").inherits(JsonLdError, Error)
                                        } else if ("undefined" !== typeof Error) {
                                            JsonLdError.prototype = new Error
                                        }
                                        var Processor = function() {};
                                        Processor.prototype.compact = function(activeCtx, activeProperty, element, options) {
                                            if (_isArray(element)) {
                                                for (var rval = [], i = 0, compacted; i < element.length; ++i) {
                                                    compacted = this.compact(activeCtx, activeProperty, element[i], options);
                                                    if (null !== compacted) {
                                                        rval.push(compacted)
                                                    }
                                                }
                                                if (options.compactArrays && 1 === rval.length) {
                                                    var container = jsonld.getContextValue(activeCtx, activeProperty, "@container");
                                                    if (null === container) {
                                                        rval = rval[0]
                                                    }
                                                }
                                                return rval
                                            }
                                            if (_isObject(element)) {
                                                if (options.link && "@id" in element && element["@id"] in options.link) {
                                                    for (var linked = options.link[element["@id"]], i = 0; i < linked.length; ++i) {
                                                        if (linked[i].expanded === element) {
                                                            return linked[i].compacted
                                                        }
                                                    }
                                                }
                                                if (_isValue(element) || _isSubjectReference(element)) {
                                                    var rval = _compactValue(activeCtx, activeProperty, element);
                                                    if (options.link && _isSubjectReference(element)) {
                                                        if (!(element["@id"] in options.link)) {
                                                            options.link[element["@id"]] = []
                                                        }
                                                        options.link[element["@id"]].push({
                                                            expanded: element,
                                                            compacted: rval
                                                        })
                                                    }
                                                    return rval
                                                }
                                                var insideReverse = "@reverse" === activeProperty,
                                                    rval = {};
                                                if (options.link && "@id" in element) {
                                                    if (!(element["@id"] in options.link)) {
                                                        options.link[element["@id"]] = []
                                                    }
                                                    options.link[element["@id"]].push({
                                                        expanded: element,
                                                        compacted: rval
                                                    })
                                                }
                                                for (var keys = Object.keys(element).sort(), ki = 0; ki < keys.length; ++ki) {
                                                    var expandedProperty = keys[ki],
                                                        expandedValue = element[expandedProperty];
                                                    if ("@id" === expandedProperty || "@type" === expandedProperty) {
                                                        var compactedValue;
                                                        if (_isString(expandedValue)) {
                                                            compactedValue = _compactIri(activeCtx, expandedValue, null, {
                                                                vocab: "@type" === expandedProperty
                                                            })
                                                        } else {
                                                            compactedValue = [];
                                                            for (var vi = 0; vi < expandedValue.length; ++vi) {
                                                                compactedValue.push(_compactIri(activeCtx, expandedValue[vi], null, {
                                                                    vocab: !0
                                                                }))
                                                            }
                                                        }
                                                        var alias = _compactIri(activeCtx, expandedProperty),
                                                            isArray = _isArray(compactedValue) && 0 === expandedValue.length;
                                                        jsonld.addValue(rval, alias, compactedValue, {
                                                            propertyIsArray: isArray
                                                        });
                                                        continue
                                                    }
                                                    if ("@reverse" === expandedProperty) {
                                                        var compactedValue = this.compact(activeCtx, "@reverse", expandedValue, options);
                                                        for (var compactedProperty in compactedValue) {
                                                            if (activeCtx.mappings[compactedProperty] && activeCtx.mappings[compactedProperty].reverse) {
                                                                var value = compactedValue[compactedProperty],
                                                                    container = jsonld.getContextValue(activeCtx, compactedProperty, "@container"),
                                                                    useArray = "@set" === container || !options.compactArrays;
                                                                jsonld.addValue(rval, compactedProperty, value, {
                                                                    propertyIsArray: useArray
                                                                });
                                                                delete compactedValue[compactedProperty]
                                                            }
                                                        }
                                                        if (0 < Object.keys(compactedValue).length) {
                                                            var alias = _compactIri(activeCtx, expandedProperty);
                                                            jsonld.addValue(rval, alias, compactedValue)
                                                        }
                                                        continue
                                                    }
                                                    if ("@index" === expandedProperty) {
                                                        var container = jsonld.getContextValue(activeCtx, activeProperty, "@container");
                                                        if ("@index" === container) {
                                                            continue
                                                        }
                                                        var alias = _compactIri(activeCtx, expandedProperty);
                                                        jsonld.addValue(rval, alias, expandedValue);
                                                        continue
                                                    }
                                                    if ("@graph" !== expandedProperty && "@list" !== expandedProperty && _isKeyword(expandedProperty)) {
                                                        var alias = _compactIri(activeCtx, expandedProperty);
                                                        jsonld.addValue(rval, alias, expandedValue);
                                                        continue
                                                    }
                                                    if (0 === expandedValue.length) {
                                                        var itemActiveProperty = _compactIri(activeCtx, expandedProperty, expandedValue, {
                                                            vocab: !0
                                                        }, insideReverse);
                                                        jsonld.addValue(rval, itemActiveProperty, expandedValue, {
                                                            propertyIsArray: !0
                                                        })
                                                    }
                                                    for (var vi = 0; vi < expandedValue.length; ++vi) {
                                                        var expandedItem = expandedValue[vi],
                                                            itemActiveProperty = _compactIri(activeCtx, expandedProperty, expandedItem, {
                                                                vocab: !0
                                                            }, insideReverse),
                                                            container = jsonld.getContextValue(activeCtx, itemActiveProperty, "@container"),
                                                            isList = _isList(expandedItem),
                                                            list = null;
                                                        if (isList) {
                                                            list = expandedItem["@list"]
                                                        }
                                                        var compactedItem = this.compact(activeCtx, itemActiveProperty, isList ? list : expandedItem, options);
                                                        if (isList) {
                                                            if (!_isArray(compactedItem)) {
                                                                compactedItem = [compactedItem]
                                                            }
                                                            if ("@list" !== container) {
                                                                var wrapper = {};
                                                                wrapper[_compactIri(activeCtx, "@list")] = compactedItem;
                                                                compactedItem = wrapper;
                                                                if ("@index" in expandedItem) {
                                                                    compactedItem[_compactIri(activeCtx, "@index")] = expandedItem["@index"]
                                                                }
                                                            } else if (itemActiveProperty in rval) {
                                                                throw new JsonLdError("JSON-LD compact error; property has a \"@list\" @container " + "rule but there is more than a single @list that matches " + "the compacted term in the document. Compaction might mix " + "unwanted items into the list.", "jsonld.SyntaxError", {
                                                                    code: "compaction to list of lists"
                                                                })
                                                            }
                                                        }
                                                        if ("@language" === container || "@index" === container) {
                                                            var mapObject;
                                                            if (itemActiveProperty in rval) {
                                                                mapObject = rval[itemActiveProperty]
                                                            } else {
                                                                rval[itemActiveProperty] = mapObject = {}
                                                            }
                                                            if ("@language" === container && _isValue(compactedItem)) {
                                                                compactedItem = compactedItem["@value"]
                                                            }
                                                            jsonld.addValue(mapObject, expandedItem[container], compactedItem)
                                                        } else {
                                                            var isArray = !options.compactArrays || "@set" === container || "@list" === container || _isArray(compactedItem) && 0 === compactedItem.length || "@list" === expandedProperty || "@graph" === expandedProperty;
                                                            jsonld.addValue(rval, itemActiveProperty, compactedItem, {
                                                                propertyIsArray: isArray
                                                            })
                                                        }
                                                    }
                                                }
                                                return rval
                                            }
                                            return element
                                        };
                                        Processor.prototype.expand = function(activeCtx, activeProperty, element, options, insideList) {
                                            var self = this;
                                            if (null === element || element === void 0) {
                                                return null
                                            }
                                            if (!_isArray(element) && !_isObject(element)) {
                                                if (!insideList && (null === activeProperty || "@graph" === _expandIri(activeCtx, activeProperty, {
                                                        vocab: !0
                                                    }))) {
                                                    return null
                                                }
                                                return _expandValue(activeCtx, activeProperty, element)
                                            }
                                            if (_isArray(element)) {
                                                var rval = [],
                                                    container = jsonld.getContextValue(activeCtx, activeProperty, "@container");
                                                insideList = insideList || "@list" === container;
                                                for (var i = 0, e; i < element.length; ++i) {
                                                    e = self.expand(activeCtx, activeProperty, element[i], options);
                                                    if (insideList && (_isArray(e) || _isList(e))) {
                                                        throw new JsonLdError("Invalid JSON-LD syntax; lists of lists are not permitted.", "jsonld.SyntaxError", {
                                                            code: "list of lists"
                                                        })
                                                    }
                                                    if (null !== e) {
                                                        if (_isArray(e)) {
                                                            rval = rval.concat(e)
                                                        } else {
                                                            rval.push(e)
                                                        }
                                                    }
                                                }
                                                return rval
                                            }
                                            if ("@context" in element) {
                                                activeCtx = self.processContext(activeCtx, element["@context"], options)
                                            }
                                            for (var expandedActiveProperty = _expandIri(activeCtx, activeProperty, {
                                                    vocab: !0
                                                }), rval = {}, keys = Object.keys(element).sort(), ki = 0; ki < keys.length; ++ki) {
                                                var key = keys[ki],
                                                    value = element[key],
                                                    expandedValue;
                                                if ("@context" === key) {
                                                    continue
                                                }
                                                var expandedProperty = _expandIri(activeCtx, key, {
                                                    vocab: !0
                                                });
                                                if (null === expandedProperty || !(_isAbsoluteIri(expandedProperty) || _isKeyword(expandedProperty))) {
                                                    continue
                                                }
                                                if (_isKeyword(expandedProperty)) {
                                                    if ("@reverse" === expandedActiveProperty) {
                                                        throw new JsonLdError("Invalid JSON-LD syntax; a keyword cannot be used as a @reverse " + "property.", "jsonld.SyntaxError", {
                                                            code: "invalid reverse property map",
                                                            value: value
                                                        })
                                                    }
                                                    if (expandedProperty in rval) {
                                                        throw new JsonLdError("Invalid JSON-LD syntax; colliding keywords detected.", "jsonld.SyntaxError", {
                                                            code: "colliding keywords",
                                                            keyword: expandedProperty
                                                        })
                                                    }
                                                }
                                                if ("@id" === expandedProperty && !_isString(value)) {
                                                    if (!options.isFrame) {
                                                        throw new JsonLdError("Invalid JSON-LD syntax; \"@id\" value must a string.", "jsonld.SyntaxError", {
                                                            code: "invalid @id value",
                                                            value: value
                                                        })
                                                    }
                                                    if (!_isObject(value)) {
                                                        throw new JsonLdError("Invalid JSON-LD syntax; \"@id\" value must be a string or an " + "object.", "jsonld.SyntaxError", {
                                                            code: "invalid @id value",
                                                            value: value
                                                        })
                                                    }
                                                }
                                                if ("@type" === expandedProperty) {
                                                    _validateTypeValue(value)
                                                }
                                                if ("@graph" === expandedProperty && !(_isObject(value) || _isArray(value))) {
                                                    throw new JsonLdError("Invalid JSON-LD syntax; \"@graph\" value must not be an " + "object or an array.", "jsonld.SyntaxError", {
                                                        code: "invalid @graph value",
                                                        value: value
                                                    })
                                                }
                                                if ("@value" === expandedProperty && (_isObject(value) || _isArray(value))) {
                                                    throw new JsonLdError("Invalid JSON-LD syntax; \"@value\" value must not be an " + "object or an array.", "jsonld.SyntaxError", {
                                                        code: "invalid value object value",
                                                        value: value
                                                    })
                                                }
                                                if ("@language" === expandedProperty) {
                                                    if (null === value) {
                                                        continue
                                                    }
                                                    if (!_isString(value)) {
                                                        throw new JsonLdError("Invalid JSON-LD syntax; \"@language\" value must be a string.", "jsonld.SyntaxError", {
                                                            code: "invalid language-tagged string",
                                                            value: value
                                                        })
                                                    }
                                                    value = value.toLowerCase()
                                                }
                                                if ("@index" === expandedProperty) {
                                                    if (!_isString(value)) {
                                                        throw new JsonLdError("Invalid JSON-LD syntax; \"@index\" value must be a string.", "jsonld.SyntaxError", {
                                                            code: "invalid @index value",
                                                            value: value
                                                        })
                                                    }
                                                }
                                                if ("@reverse" === expandedProperty) {
                                                    if (!_isObject(value)) {
                                                        throw new JsonLdError("Invalid JSON-LD syntax; \"@reverse\" value must be an object.", "jsonld.SyntaxError", {
                                                            code: "invalid @reverse value",
                                                            value: value
                                                        })
                                                    }
                                                    expandedValue = self.expand(activeCtx, "@reverse", value, options);
                                                    if ("@reverse" in expandedValue) {
                                                        for (var property in expandedValue["@reverse"]) {
                                                            jsonld.addValue(rval, property, expandedValue["@reverse"][property], {
                                                                propertyIsArray: !0
                                                            })
                                                        }
                                                    }
                                                    var reverseMap = rval["@reverse"] || null;
                                                    for (var property in expandedValue) {
                                                        if ("@reverse" === property) {
                                                            continue
                                                        }
                                                        if (null === reverseMap) {
                                                            reverseMap = rval["@reverse"] = {}
                                                        }
                                                        jsonld.addValue(reverseMap, property, [], {
                                                            propertyIsArray: !0
                                                        });
                                                        for (var items = expandedValue[property], ii = 0, item; ii < items.length; ++ii) {
                                                            item = items[ii];
                                                            if (_isValue(item) || _isList(item)) {
                                                                throw new JsonLdError("Invalid JSON-LD syntax; \"@reverse\" value must not be a " + "@value or an @list.", "jsonld.SyntaxError", {
                                                                    code: "invalid reverse property value",
                                                                    value: expandedValue
                                                                })
                                                            }
                                                            jsonld.addValue(reverseMap, property, item, {
                                                                propertyIsArray: !0
                                                            })
                                                        }
                                                    }
                                                    continue
                                                }
                                                var container = jsonld.getContextValue(activeCtx, key, "@container");
                                                if ("@language" === container && _isObject(value)) {
                                                    expandedValue = _expandLanguageMap(value)
                                                } else if ("@index" === container && _isObject(value)) {
                                                    expandedValue = function(activeProperty) {
                                                        for (var rval = [], keys = Object.keys(value).sort(), ki = 0; ki < keys.length; ++ki) {
                                                            var key = keys[ki],
                                                                val = value[key];
                                                            if (!_isArray(val)) {
                                                                val = [val]
                                                            }
                                                            val = self.expand(activeCtx, activeProperty, val, options, !1);
                                                            for (var vi = 0, item; vi < val.length; ++vi) {
                                                                item = val[vi];
                                                                if (!("@index" in item)) {
                                                                    item["@index"] = key
                                                                }
                                                                rval.push(item)
                                                            }
                                                        }
                                                        return rval
                                                    }(key)
                                                } else {
                                                    var isList = "@list" === expandedProperty;
                                                    if (isList || "@set" === expandedProperty) {
                                                        var nextActiveProperty = activeProperty;
                                                        if (isList && "@graph" === expandedActiveProperty) {
                                                            nextActiveProperty = null
                                                        }
                                                        expandedValue = self.expand(activeCtx, nextActiveProperty, value, options, isList);
                                                        if (isList && _isList(expandedValue)) {
                                                            throw new JsonLdError("Invalid JSON-LD syntax; lists of lists are not permitted.", "jsonld.SyntaxError", {
                                                                code: "list of lists"
                                                            })
                                                        }
                                                    } else {
                                                        expandedValue = self.expand(activeCtx, key, value, options, !1)
                                                    }
                                                }
                                                if (null === expandedValue && "@value" !== expandedProperty) {
                                                    continue
                                                }
                                                if ("@list" !== expandedProperty && !_isList(expandedValue) && "@list" === container) {
                                                    expandedValue = _isArray(expandedValue) ? expandedValue : [expandedValue];
                                                    expandedValue = {
                                                        "@list": expandedValue
                                                    }
                                                }
                                                if (activeCtx.mappings[key] && activeCtx.mappings[key].reverse) {
                                                    var reverseMap = rval["@reverse"] = rval["@reverse"] || {};
                                                    if (!_isArray(expandedValue)) {
                                                        expandedValue = [expandedValue]
                                                    }
                                                    for (var ii = 0, item; ii < expandedValue.length; ++ii) {
                                                        item = expandedValue[ii];
                                                        if (_isValue(item) || _isList(item)) {
                                                            throw new JsonLdError("Invalid JSON-LD syntax; \"@reverse\" value must not be a " + "@value or an @list.", "jsonld.SyntaxError", {
                                                                code: "invalid reverse property value",
                                                                value: expandedValue
                                                            })
                                                        }
                                                        jsonld.addValue(reverseMap, expandedProperty, item, {
                                                            propertyIsArray: !0
                                                        })
                                                    }
                                                    continue
                                                }
                                                var useArray = -1 === ["@index", "@id", "@type", "@value", "@language"].indexOf(expandedProperty);
                                                jsonld.addValue(rval, expandedProperty, expandedValue, {
                                                    propertyIsArray: useArray
                                                })
                                            }
                                            keys = Object.keys(rval);
                                            var count = keys.length;
                                            if ("@value" in rval) {
                                                if ("@type" in rval && "@language" in rval) {
                                                    throw new JsonLdError("Invalid JSON-LD syntax; an element containing \"@value\" may not " + "contain both \"@type\" and \"@language\".", "jsonld.SyntaxError", {
                                                        code: "invalid value object",
                                                        element: rval
                                                    })
                                                }
                                                var validCount = count - 1;
                                                if ("@type" in rval) {
                                                    validCount -= 1
                                                }
                                                if ("@index" in rval) {
                                                    validCount -= 1
                                                }
                                                if ("@language" in rval) {
                                                    validCount -= 1
                                                }
                                                if (0 !== validCount) {
                                                    throw new JsonLdError("Invalid JSON-LD syntax; an element containing \"@value\" may only " + "have an \"@index\" property and at most one other property " + "which can be \"@type\" or \"@language\".", "jsonld.SyntaxError", {
                                                        code: "invalid value object",
                                                        element: rval
                                                    })
                                                }
                                                if (null === rval["@value"]) {
                                                    rval = null
                                                } else if ("@language" in rval && !_isString(rval["@value"])) {
                                                    throw new JsonLdError("Invalid JSON-LD syntax; only strings may be language-tagged.", "jsonld.SyntaxError", {
                                                        code: "invalid language-tagged value",
                                                        element: rval
                                                    })
                                                } else if ("@type" in rval && (!_isAbsoluteIri(rval["@type"]) || 0 === rval["@type"].indexOf("_:"))) {
                                                    throw new JsonLdError("Invalid JSON-LD syntax; an element containing \"@value\" and \"@type\" " + "must have an absolute IRI for the value of \"@type\".", "jsonld.SyntaxError", {
                                                        code: "invalid typed value",
                                                        element: rval
                                                    })
                                                }
                                            } else if ("@type" in rval && !_isArray(rval["@type"])) {
                                                rval["@type"] = [rval["@type"]]
                                            } else if ("@set" in rval || "@list" in rval) {
                                                if (1 < count && !(2 === count && "@index" in rval)) {
                                                    throw new JsonLdError("Invalid JSON-LD syntax; if an element has the property \"@set\" " + "or \"@list\", then it can have at most one other property that is " + "\"@index\".", "jsonld.SyntaxError", {
                                                        code: "invalid set or list object",
                                                        element: rval
                                                    })
                                                }
                                                if ("@set" in rval) {
                                                    rval = rval["@set"];
                                                    keys = Object.keys(rval);
                                                    count = keys.length
                                                }
                                            } else if (1 === count && "@language" in rval) {
                                                rval = null
                                            }
                                            if (_isObject(rval) && !options.keepFreeFloatingNodes && !insideList && (null === activeProperty || "@graph" === expandedActiveProperty)) {
                                                if (0 === count || "@value" in rval || "@list" in rval || 1 === count && "@id" in rval) {
                                                    rval = null
                                                }
                                            }
                                            return rval
                                        };
                                        Processor.prototype.createNodeMap = function(input, options) {
                                            options = options || {};
                                            var issuer = options.namer || options.issuer || new IdentifierIssuer("_:b"),
                                                graphs = {
                                                    "@default": {}
                                                };
                                            _createNodeMap(input, graphs, "@default", issuer);
                                            return _mergeNodeMaps(graphs)
                                        };
                                        Processor.prototype.flatten = function(input) {
                                            for (var defaultGraph = this.createNodeMap(input), flattened = [], keys = Object.keys(defaultGraph).sort(), ki = 0, node; ki < keys.length; ++ki) {
                                                node = defaultGraph[keys[ki]];
                                                if (!_isSubjectReference(node)) {
                                                    flattened.push(node)
                                                }
                                            }
                                            return flattened
                                        };
                                        Processor.prototype.frame = function(input, frame, options) {
                                            var state = {
                                                    options: options,
                                                    graphs: {
                                                        "@default": {},
                                                        "@merged": {}
                                                    },
                                                    subjectStack: [],
                                                    link: {}
                                                },
                                                issuer = new IdentifierIssuer("_:b");
                                            _createNodeMap(input, state.graphs, "@merged", issuer);
                                            state.subjects = state.graphs["@merged"];
                                            var framed = [];
                                            _frame(state, Object.keys(state.subjects).sort(), frame, framed, null);
                                            return framed
                                        };
                                        Processor.prototype.normalize = function(dataset, options, callback) {
                                            if ("URDNA2015" === options.algorithm) {
                                                return new URDNA2015(options).main(dataset, callback)
                                            }
                                            if ("URGNA2012" === options.algorithm) {
                                                return new URGNA2012(options).main(dataset, callback)
                                            }
                                            callback(new Error("Invalid RDF Dataset Normalization algorithm: " + options.algorithm))
                                        };
                                        Processor.prototype.fromRDF = function(dataset, options, callback) {
                                            var defaultGraph = {},
                                                graphMap = {
                                                    "@default": defaultGraph
                                                },
                                                referencedOnce = {};
                                            for (var name in dataset) {
                                                var graph = dataset[name];
                                                if (!(name in graphMap)) {
                                                    graphMap[name] = {}
                                                }
                                                if ("@default" !== name && !(name in defaultGraph)) {
                                                    defaultGraph[name] = {
                                                        "@id": name
                                                    }
                                                }
                                                for (var nodeMap = graphMap[name], ti = 0; ti < graph.length; ++ti) {
                                                    var triple = graph[ti],
                                                        s = triple.subject.value,
                                                        p = triple.predicate.value,
                                                        o = triple.object;
                                                    if (!(s in nodeMap)) {
                                                        nodeMap[s] = {
                                                            "@id": s
                                                        }
                                                    }
                                                    var node = nodeMap[s],
                                                        objectIsId = "IRI" === o.type || "blank node" === o.type;
                                                    if (objectIsId && !(o.value in nodeMap)) {
                                                        nodeMap[o.value] = {
                                                            "@id": o.value
                                                        }
                                                    }
                                                    if (p === RDF_TYPE && !options.useRdfType && objectIsId) {
                                                        jsonld.addValue(node, "@type", o.value, {
                                                            propertyIsArray: !0
                                                        });
                                                        continue
                                                    }
                                                    var value = _RDFToObject(o, options.useNativeTypes);
                                                    jsonld.addValue(node, p, value, {
                                                        propertyIsArray: !0
                                                    });
                                                    if (objectIsId) {
                                                        if (o.value === RDF_NIL) {
                                                            var object = nodeMap[o.value];
                                                            if (!("usages" in object)) {
                                                                object.usages = []
                                                            }
                                                            object.usages.push({
                                                                node: node,
                                                                property: p,
                                                                value: value
                                                            })
                                                        } else if (o.value in referencedOnce) {
                                                            referencedOnce[o.value] = !1
                                                        } else {
                                                            referencedOnce[o.value] = {
                                                                node: node,
                                                                property: p,
                                                                value: value
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                            for (var name in graphMap) {
                                                var graphObject = graphMap[name];
                                                if (!(RDF_NIL in graphObject)) {
                                                    continue
                                                }
                                                for (var nil = graphObject[RDF_NIL], i = 0; i < nil.usages.length; ++i) {
                                                    var usage = nil.usages[i],
                                                        node = usage.node,
                                                        property = usage.property,
                                                        head = usage.value,
                                                        list = [],
                                                        listNodes = [],
                                                        nodeKeyCount = Object.keys(node).length;
                                                    while (property === RDF_REST && _isObject(referencedOnce[node["@id"]]) && _isArray(node[RDF_FIRST]) && 1 === node[RDF_FIRST].length && _isArray(node[RDF_REST]) && 1 === node[RDF_REST].length && (3 === nodeKeyCount || 4 === nodeKeyCount && _isArray(node["@type"]) && 1 === node["@type"].length && node["@type"][0] === RDF + "List")) {
                                                        list.push(node[RDF_FIRST][0]);
                                                        listNodes.push(node["@id"]);
                                                        usage = referencedOnce[node["@id"]];
                                                        node = usage.node;
                                                        property = usage.property;
                                                        head = usage.value;
                                                        nodeKeyCount = Object.keys(node).length;
                                                        if (0 !== node["@id"].indexOf("_:")) {
                                                            break
                                                        }
                                                    }
                                                    if (property === RDF_FIRST) {
                                                        if (node["@id"] === RDF_NIL) {
                                                            continue
                                                        }
                                                        head = graphObject[head["@id"]][RDF_REST][0];
                                                        list.pop();
                                                        listNodes.pop()
                                                    }
                                                    delete head["@id"];
                                                    head["@list"] = list.reverse();
                                                    for (var j = 0; j < listNodes.length; ++j) {
                                                        delete graphObject[listNodes[j]]
                                                    }
                                                }
                                                delete nil.usages
                                            }
                                            for (var result = [], subjects = Object.keys(defaultGraph).sort(), i = 0; i < subjects.length; ++i) {
                                                var subject = subjects[i],
                                                    node = defaultGraph[subject];
                                                if (subject in graphMap) {
                                                    for (var graph = node["@graph"] = [], graphObject = graphMap[subject], subjects_ = Object.keys(graphObject).sort(), si = 0, node_; si < subjects_.length; ++si) {
                                                        node_ = graphObject[subjects_[si]];
                                                        if (!_isSubjectReference(node_)) {
                                                            graph.push(node_)
                                                        }
                                                    }
                                                }
                                                if (!_isSubjectReference(node)) {
                                                    result.push(node)
                                                }
                                            }
                                            callback(null, result)
                                        };
                                        Processor.prototype.toRDF = function(input, options) {
                                            var issuer = new IdentifierIssuer("_:b"),
                                                nodeMap = {
                                                    "@default": {}
                                                };
                                            _createNodeMap(input, nodeMap, "@default", issuer);
                                            for (var dataset = {}, graphNames = Object.keys(nodeMap).sort(), i = 0, graphName; i < graphNames.length; ++i) {
                                                graphName = graphNames[i];
                                                if ("@default" === graphName || _isAbsoluteIri(graphName)) {
                                                    dataset[graphName] = _graphToRDF(nodeMap[graphName], issuer, options)
                                                }
                                            }
                                            return dataset
                                        };
                                        Processor.prototype.processContext = function(activeCtx, localCtx, options) {
                                            if (_isObject(localCtx) && "@context" in localCtx && _isArray(localCtx["@context"])) {
                                                localCtx = localCtx["@context"]
                                            }
                                            var ctxs = _isArray(localCtx) ? localCtx : [localCtx];
                                            if (0 === ctxs.length) {
                                                return activeCtx.clone()
                                            }
                                            for (var rval = activeCtx, i = 0, ctx; i < ctxs.length; ++i) {
                                                ctx = ctxs[i];
                                                if (null === ctx) {
                                                    rval = activeCtx = _getInitialContext(options);
                                                    continue
                                                }
                                                if (_isObject(ctx) && "@context" in ctx) {
                                                    ctx = ctx["@context"]
                                                }
                                                if (!_isObject(ctx)) {
                                                    throw new JsonLdError("Invalid JSON-LD syntax; @context must be an object.", "jsonld.SyntaxError", {
                                                        code: "invalid local context",
                                                        context: ctx
                                                    })
                                                }
                                                if (jsonld.cache.activeCtx) {
                                                    var cached = jsonld.cache.activeCtx.get(activeCtx, ctx);
                                                    if (cached) {
                                                        rval = activeCtx = cached;
                                                        continue
                                                    }
                                                }
                                                activeCtx = rval;
                                                rval = rval.clone();
                                                var defined = {};
                                                if ("@base" in ctx) {
                                                    var base = ctx["@base"];
                                                    if (null === base) {
                                                        base = null
                                                    } else if (!_isString(base)) {
                                                        throw new JsonLdError("Invalid JSON-LD syntax; the value of \"@base\" in a " + "@context must be a string or null.", "jsonld.SyntaxError", {
                                                            code: "invalid base IRI",
                                                            context: ctx
                                                        })
                                                    } else if ("" !== base && !_isAbsoluteIri(base)) {
                                                        throw new JsonLdError("Invalid JSON-LD syntax; the value of \"@base\" in a " + "@context must be an absolute IRI or the empty string.", "jsonld.SyntaxError", {
                                                            code: "invalid base IRI",
                                                            context: ctx
                                                        })
                                                    }
                                                    if (null !== base) {
                                                        base = jsonld.url.parse(base || "")
                                                    }
                                                    rval["@base"] = base;
                                                    defined["@base"] = !0
                                                }
                                                if ("@vocab" in ctx) {
                                                    var value = ctx["@vocab"];
                                                    if (null === value) {
                                                        delete rval["@vocab"]
                                                    } else if (!_isString(value)) {
                                                        throw new JsonLdError("Invalid JSON-LD syntax; the value of \"@vocab\" in a " + "@context must be a string or null.", "jsonld.SyntaxError", {
                                                            code: "invalid vocab mapping",
                                                            context: ctx
                                                        })
                                                    } else if (!_isAbsoluteIri(value)) {
                                                        throw new JsonLdError("Invalid JSON-LD syntax; the value of \"@vocab\" in a " + "@context must be an absolute IRI.", "jsonld.SyntaxError", {
                                                            code: "invalid vocab mapping",
                                                            context: ctx
                                                        })
                                                    } else {
                                                        rval["@vocab"] = value
                                                    }
                                                    defined["@vocab"] = !0
                                                }
                                                if ("@language" in ctx) {
                                                    var value = ctx["@language"];
                                                    if (null === value) {
                                                        delete rval["@language"]
                                                    } else if (!_isString(value)) {
                                                        throw new JsonLdError("Invalid JSON-LD syntax; the value of \"@language\" in a " + "@context must be a string or null.", "jsonld.SyntaxError", {
                                                            code: "invalid default language",
                                                            context: ctx
                                                        })
                                                    } else {
                                                        rval["@language"] = value.toLowerCase()
                                                    }
                                                    defined["@language"] = !0
                                                }
                                                for (var key in ctx) {
                                                    _createTermDefinition(rval, ctx, key, defined)
                                                }
                                                if (jsonld.cache.activeCtx) {
                                                    jsonld.cache.activeCtx.set(activeCtx, ctx, rval)
                                                }
                                            }
                                            return rval
                                        };

                                        function _expandLanguageMap(languageMap) {
                                            for (var rval = [], keys = Object.keys(languageMap).sort(), ki = 0; ki < keys.length; ++ki) {
                                                var key = keys[ki],
                                                    val = languageMap[key];
                                                if (!_isArray(val)) {
                                                    val = [val]
                                                }
                                                for (var vi = 0, item; vi < val.length; ++vi) {
                                                    item = val[vi];
                                                    if (null === item) {
                                                        continue
                                                    }
                                                    if (!_isString(item)) {
                                                        throw new JsonLdError("Invalid JSON-LD syntax; language map values must be strings.", "jsonld.SyntaxError", {
                                                            code: "invalid language map value",
                                                            languageMap: languageMap
                                                        })
                                                    }
                                                    rval.push({
                                                        "@value": item,
                                                        "@language": key.toLowerCase()
                                                    })
                                                }
                                            }
                                            return rval
                                        }

                                        function _labelBlankNodes(issuer, element) {
                                            if (_isArray(element)) {
                                                for (var i = 0; i < element.length; ++i) {
                                                    element[i] = _labelBlankNodes(issuer, element[i])
                                                }
                                            } else if (_isList(element)) {
                                                element["@list"] = _labelBlankNodes(issuer, element["@list"])
                                            } else if (_isObject(element)) {
                                                if (_isBlankNode(element)) {
                                                    element["@id"] = issuer.getId(element["@id"])
                                                }
                                                for (var keys = Object.keys(element).sort(), ki = 0, key; ki < keys.length; ++ki) {
                                                    key = keys[ki];
                                                    if ("@id" !== key) {
                                                        element[key] = _labelBlankNodes(issuer, element[key])
                                                    }
                                                }
                                            }
                                            return element
                                        }

                                        function _expandValue(activeCtx, activeProperty, value) {
                                            if (null === value || value === void 0) {
                                                return null
                                            }
                                            var expandedProperty = _expandIri(activeCtx, activeProperty, {
                                                vocab: !0
                                            });
                                            if ("@id" === expandedProperty) {
                                                return _expandIri(activeCtx, value, {
                                                    base: !0
                                                })
                                            } else if ("@type" === expandedProperty) {
                                                return _expandIri(activeCtx, value, {
                                                    vocab: !0,
                                                    base: !0
                                                })
                                            }
                                            var type = jsonld.getContextValue(activeCtx, activeProperty, "@type");
                                            if ("@id" === type || "@graph" === expandedProperty && _isString(value)) {
                                                return {
                                                    "@id": _expandIri(activeCtx, value, {
                                                        base: !0
                                                    })
                                                }
                                            }
                                            if ("@vocab" === type) {
                                                return {
                                                    "@id": _expandIri(activeCtx, value, {
                                                        vocab: !0,
                                                        base: !0
                                                    })
                                                }
                                            }
                                            if (_isKeyword(expandedProperty)) {
                                                return value
                                            }
                                            var rval = {};
                                            if (null !== type) {
                                                rval["@type"] = type
                                            } else if (_isString(value)) {
                                                var language = jsonld.getContextValue(activeCtx, activeProperty, "@language");
                                                if (null !== language) {
                                                    rval["@language"] = language
                                                }
                                            }
                                            if (-1 === ["boolean", "number", "string"].indexOf(typeof value)) {
                                                value = value.toString()
                                            }
                                            rval["@value"] = value;
                                            return rval
                                        }

                                        function _graphToRDF(graph, issuer, options) {
                                            for (var rval = [], ids = Object.keys(graph).sort(), i = 0; i < ids.length; ++i) {
                                                for (var id = ids[i], node = graph[id], properties = Object.keys(node).sort(), pi = 0; pi < properties.length; ++pi) {
                                                    var property = properties[pi],
                                                        items = node[property];
                                                    if ("@type" === property) {
                                                        property = RDF_TYPE
                                                    } else if (_isKeyword(property)) {
                                                        continue
                                                    }
                                                    for (var ii = 0; ii < items.length; ++ii) {
                                                        var item = items[ii],
                                                            subject = {};
                                                        subject.type = 0 === id.indexOf("_:") ? "blank node" : "IRI";
                                                        subject.value = id;
                                                        if (!_isAbsoluteIri(id)) {
                                                            continue
                                                        }
                                                        var predicate = {
                                                            type: 0 === property.indexOf("_:") ? "blank node" : "IRI",
                                                            value: property
                                                        };
                                                        if (!_isAbsoluteIri(property)) {
                                                            continue
                                                        }
                                                        if ("blank node" === predicate.type && !options.produceGeneralizedRdf) {
                                                            continue
                                                        }
                                                        if (_isList(item)) {
                                                            _listToRDF(item["@list"], issuer, subject, predicate, rval)
                                                        } else {
                                                            var object = _objectToRDF(item);
                                                            if (object) {
                                                                rval.push({
                                                                    subject: subject,
                                                                    predicate: predicate,
                                                                    object: object
                                                                })
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                            return rval
                                        }

                                        function _listToRDF(list, issuer, subject, predicate, triples) {
                                            for (var first = {
                                                    type: "IRI",
                                                    value: RDF_FIRST
                                                }, rest = {
                                                    type: "IRI",
                                                    value: RDF_REST
                                                }, nil = {
                                                    type: "IRI",
                                                    value: RDF_NIL
                                                }, i = 0; i < list.length; ++i) {
                                                var item = list[i],
                                                    blankNode = {
                                                        type: "blank node",
                                                        value: issuer.getId()
                                                    };
                                                triples.push({
                                                    subject: subject,
                                                    predicate: predicate,
                                                    object: blankNode
                                                });
                                                subject = blankNode;
                                                predicate = first;
                                                var object = _objectToRDF(item);
                                                if (object) {
                                                    triples.push({
                                                        subject: subject,
                                                        predicate: predicate,
                                                        object: object
                                                    })
                                                }
                                                predicate = rest
                                            }
                                            triples.push({
                                                subject: subject,
                                                predicate: predicate,
                                                object: nil
                                            })
                                        }

                                        function _objectToRDF(item) {
                                            var object = {};
                                            if (_isValue(item)) {
                                                object.type = "literal";
                                                var value = item["@value"],
                                                    datatype = item["@type"] || null;
                                                if (_isBoolean(value)) {
                                                    object.value = value.toString();
                                                    object.datatype = datatype || XSD_BOOLEAN
                                                } else if (_isDouble(value) || datatype === XSD_DOUBLE) {
                                                    if (!_isDouble(value)) {
                                                        value = parseFloat(value)
                                                    }
                                                    object.value = value.toExponential(15).replace(/(\d)0*e\+?/, "$1E");
                                                    object.datatype = datatype || XSD_DOUBLE
                                                } else if (_isNumber(value)) {
                                                    object.value = value.toFixed(0);
                                                    object.datatype = datatype || XSD_INTEGER
                                                } else if ("@language" in item) {
                                                    object.value = value;
                                                    object.datatype = datatype || RDF_LANGSTRING;
                                                    object.language = item["@language"]
                                                } else {
                                                    object.value = value;
                                                    object.datatype = datatype || XSD_STRING
                                                }
                                            } else {
                                                var id = _isObject(item) ? item["@id"] : item;
                                                object.type = 0 === id.indexOf("_:") ? "blank node" : "IRI";
                                                object.value = id
                                            }
                                            if ("IRI" === object.type && !_isAbsoluteIri(object.value)) {
                                                return null
                                            }
                                            return object
                                        }

                                        function _RDFToObject(o, useNativeTypes) {
                                            if ("IRI" === o.type || "blank node" === o.type) {
                                                return {
                                                    "@id": o.value
                                                }
                                            }
                                            var rval = {
                                                "@value": o.value
                                            };
                                            if (o.language) {
                                                rval["@language"] = o.language
                                            } else {
                                                var type = o.datatype;
                                                if (!type) {
                                                    type = XSD_STRING
                                                }
                                                if (useNativeTypes) {
                                                    if (type === XSD_BOOLEAN) {
                                                        if ("true" === rval["@value"]) {
                                                            rval["@value"] = !0
                                                        } else if ("false" === rval["@value"]) {
                                                            rval["@value"] = !1
                                                        }
                                                    } else if (_isNumeric(rval["@value"])) {
                                                        if (type === XSD_INTEGER) {
                                                            var i = parseInt(rval["@value"], 10);
                                                            if (i.toFixed(0) === rval["@value"]) {
                                                                rval["@value"] = i
                                                            }
                                                        } else if (type === XSD_DOUBLE) {
                                                            rval["@value"] = parseFloat(rval["@value"])
                                                        }
                                                    }
                                                    if (-1 === [XSD_BOOLEAN, XSD_INTEGER, XSD_DOUBLE, XSD_STRING].indexOf(type)) {
                                                        rval["@type"] = type
                                                    }
                                                } else if (type !== XSD_STRING) {
                                                    rval["@type"] = type
                                                }
                                            }
                                            return rval
                                        }

                                        function _compareRDFTriples(t1, t2) {
                                            for (var attrs = ["subject", "predicate", "object"], i = 0, attr; i < attrs.length; ++i) {
                                                attr = attrs[i];
                                                if (t1[attr].type !== t2[attr].type || t1[attr].value !== t2[attr].value) {
                                                    return !1
                                                }
                                            }
                                            if (t1.object.language !== t2.object.language) {
                                                return !1
                                            }
                                            if (t1.object.datatype !== t2.object.datatype) {
                                                return !1
                                            }
                                            return !0
                                        }
                                        var URDNA2015 = function() {
                                                var POSITIONS = {
                                                        subject: "s",
                                                        object: "o",
                                                        name: "g"
                                                    },
                                                    Normalize = function(options) {
                                                        options = options || {};
                                                        this.name = "URDNA2015";
                                                        this.options = options;
                                                        this.blankNodeInfo = {};
                                                        this.hashToBlankNodes = {};
                                                        this.canonicalIssuer = new IdentifierIssuer("_:c14n");
                                                        this.quads = [];
                                                        this.schedule = {};
                                                        if ("maxCallStackDepth" in options) {
                                                            this.schedule.MAX_DEPTH = options.maxCallStackDepth
                                                        } else {
                                                            this.schedule.MAX_DEPTH = 500
                                                        }
                                                        if ("maxTotalCallStackDepth" in options) {
                                                            this.schedule.MAX_TOTAL_DEPTH = options.maxCallStackDepth
                                                        } else {
                                                            this.schedule.MAX_TOTAL_DEPTH = 4294967295
                                                        }
                                                        this.schedule.depth = 0;
                                                        this.schedule.totalDepth = 0;
                                                        if ("timeSlice" in options) {
                                                            this.schedule.timeSlice = options.timeSlice
                                                        } else {
                                                            this.schedule.timeSlice = 10
                                                        }
                                                    };
                                                Normalize.prototype.doWork = function(fn, callback) {
                                                    var schedule = this.schedule;
                                                    if (schedule.totalDepth >= schedule.MAX_TOTAL_DEPTH) {
                                                        return callback(new Error("Maximum total call stack depth exceeded; normalization aborting."))
                                                    }(function work() {
                                                        if (schedule.depth === schedule.MAX_DEPTH) {
                                                            schedule.depth = 0;
                                                            schedule.running = !1;
                                                            return jsonld.nextTick(work)
                                                        }
                                                        var now = new Date().getTime();
                                                        if (!schedule.running) {
                                                            schedule.start = new Date().getTime();
                                                            schedule.deadline = schedule.start + schedule.timeSlice
                                                        }
                                                        if (now < schedule.deadline) {
                                                            schedule.running = !0;
                                                            schedule.depth++;
                                                            schedule.totalDepth++;
                                                            return fn(function(err, result) {
                                                                schedule.depth--;
                                                                schedule.totalDepth--;
                                                                callback(err, result)
                                                            })
                                                        }
                                                        schedule.depth = 0;
                                                        schedule.running = !1;
                                                        jsonld.setImmediate(work)
                                                    })()
                                                };
                                                Normalize.prototype.forEach = function(iterable, fn, callback) {
                                                    var self = this,
                                                        iterator, idx = 0,
                                                        length;
                                                    if (_isArray(iterable)) {
                                                        length = iterable.length;
                                                        iterator = function() {
                                                            if (idx === length) {
                                                                return !1
                                                            }
                                                            iterator.value = iterable[idx++];
                                                            iterator.key = idx;
                                                            return !0
                                                        }
                                                    } else {
                                                        var keys = Object.keys(iterable);
                                                        length = keys.length;
                                                        iterator = function() {
                                                            if (idx === length) {
                                                                return !1
                                                            }
                                                            iterator.key = keys[idx++];
                                                            iterator.value = iterable[iterator.key];
                                                            return !0
                                                        }
                                                    }(function iterate(err) {
                                                        if (err) {
                                                            return callback(err)
                                                        }
                                                        if (iterator()) {
                                                            return self.doWork(function() {
                                                                fn(iterator.value, iterator.key, iterate)
                                                            })
                                                        }
                                                        callback()
                                                    })()
                                                };
                                                Normalize.prototype.waterfall = function(fns, callback) {
                                                    var self = this;
                                                    self.forEach(fns, function(fn, idx, callback) {
                                                        self.doWork(fn, callback)
                                                    }, callback)
                                                };
                                                Normalize.prototype.whilst = function(condition, fn, callback) {
                                                    var self = this;
                                                    (function loop(err) {
                                                        if (err) {
                                                            return callback(err)
                                                        }
                                                        if (!condition()) {
                                                            return callback()
                                                        }
                                                        self.doWork(fn, loop)
                                                    })()
                                                };
                                                Normalize.prototype.main = function(dataset, callback) {
                                                    var self = this;
                                                    self.schedule.start = new Date().getTime();
                                                    var result;
                                                    if (self.options.format) {
                                                        if ("application/nquads" !== self.options.format) {
                                                            return callback(new JsonLdError("Unknown output format.", "jsonld.UnknownFormat", {
                                                                format: self.options.format
                                                            }))
                                                        }
                                                    }
                                                    var nonNormalized = {};
                                                    self.waterfall([function(callback) {
                                                        self.forEach(dataset, function(triples, graphName, callback) {
                                                            if ("@default" === graphName) {
                                                                graphName = null
                                                            }
                                                            self.forEach(triples, function(quad, idx, callback) {
                                                                if (null !== graphName) {
                                                                    if (0 === graphName.indexOf("_:")) {
                                                                        quad.name = {
                                                                            type: "blank node",
                                                                            value: graphName
                                                                        }
                                                                    } else {
                                                                        quad.name = {
                                                                            type: "IRI",
                                                                            value: graphName
                                                                        }
                                                                    }
                                                                }
                                                                self.quads.push(quad);
                                                                self.forEachComponent(quad, function(component) {
                                                                    if ("blank node" !== component.type) {
                                                                        return
                                                                    }
                                                                    var id = component.value;
                                                                    if (id in self.blankNodeInfo) {
                                                                        self.blankNodeInfo[id].quads.push(quad)
                                                                    } else {
                                                                        nonNormalized[id] = !0;
                                                                        self.blankNodeInfo[id] = {
                                                                            quads: [quad]
                                                                        }
                                                                    }
                                                                });
                                                                callback()
                                                            }, callback)
                                                        }, callback)
                                                    }, function(callback) {
                                                        var simple = !0;
                                                        self.whilst(function() {
                                                            return simple
                                                        }, function(callback) {
                                                            simple = !1;
                                                            self.hashToBlankNodes = {};
                                                            self.waterfall([function(callback) {
                                                                self.forEach(nonNormalized, function(value, id, callback) {
                                                                    self.hashFirstDegreeQuads(id, function(err, hash) {
                                                                        if (err) {
                                                                            return callback(err)
                                                                        }
                                                                        if (hash in self.hashToBlankNodes) {
                                                                            self.hashToBlankNodes[hash].push(id)
                                                                        } else {
                                                                            self.hashToBlankNodes[hash] = [id]
                                                                        }
                                                                        callback()
                                                                    })
                                                                }, callback)
                                                            }, function(callback) {
                                                                var hashes = Object.keys(self.hashToBlankNodes).sort();
                                                                self.forEach(hashes, function(hash, i, callback) {
                                                                    var idList = self.hashToBlankNodes[hash];
                                                                    if (1 < idList.length) {
                                                                        return callback()
                                                                    }
                                                                    var id = idList[0];
                                                                    self.canonicalIssuer.getId(id);
                                                                    delete nonNormalized[id];
                                                                    delete self.hashToBlankNodes[hash];
                                                                    simple = !0;
                                                                    callback()
                                                                }, callback)
                                                            }], callback)
                                                        }, callback)
                                                    }, function(callback) {
                                                        var hashes = Object.keys(self.hashToBlankNodes).sort();
                                                        self.forEach(hashes, function(hash, idx, callback) {
                                                            var hashPathList = [],
                                                                idList = self.hashToBlankNodes[hash];
                                                            self.waterfall([function(callback) {
                                                                self.forEach(idList, function(id, idx, callback) {
                                                                    if (self.canonicalIssuer.hasId(id)) {
                                                                        return callback()
                                                                    }
                                                                    var issuer = new IdentifierIssuer("_:b");
                                                                    issuer.getId(id);
                                                                    self.hashNDegreeQuads(id, issuer, function(err, result) {
                                                                        if (err) {
                                                                            return callback(err)
                                                                        }
                                                                        hashPathList.push(result);
                                                                        callback()
                                                                    })
                                                                }, callback)
                                                            }, function(callback) {
                                                                hashPathList.sort(function(a, b) {
                                                                    return a.hash < b.hash ? -1 : a.hash > b.hash ? 1 : 0
                                                                });
                                                                self.forEach(hashPathList, function(result, idx, callback) {
                                                                    for (var existing in result.issuer.existing) {
                                                                        self.canonicalIssuer.getId(existing)
                                                                    }
                                                                    callback()
                                                                }, callback)
                                                            }], callback)
                                                        }, callback)
                                                    }, function(callback) {
                                                        var normalized = [];
                                                        self.waterfall([function(callback) {
                                                            self.forEach(self.quads, function(quad, idx, callback) {
                                                                self.forEachComponent(quad, function(component) {
                                                                    if ("blank node" === component.type && 0 !== component.value.indexOf(self.canonicalIssuer.prefix)) {
                                                                        component.value = self.canonicalIssuer.getId(component.value)
                                                                    }
                                                                });
                                                                normalized.push(_toNQuad(quad));
                                                                callback()
                                                            }, callback)
                                                        }, function(callback) {
                                                            normalized.sort();
                                                            if ("application/nquads" === self.options.format) {
                                                                result = normalized.join("");
                                                                return callback()
                                                            }
                                                            result = _parseNQuads(normalized.join(""));
                                                            callback()
                                                        }], callback)
                                                    }], function(err) {
                                                        callback(err, result)
                                                    })
                                                };
                                                Normalize.prototype.hashFirstDegreeQuads = function(id, callback) {
                                                    var self = this,
                                                        info = self.blankNodeInfo[id];
                                                    if ("hash" in info) {
                                                        return callback(null, info.hash)
                                                    }
                                                    var nquads = [],
                                                        quads = info.quads;
                                                    self.forEach(quads, function(quad, idx, callback) {
                                                        var copy = {
                                                            predicate: quad.predicate
                                                        };
                                                        self.forEachComponent(quad, function(component, key) {
                                                            copy[key] = self.modifyFirstDegreeComponent(id, component, key)
                                                        });
                                                        nquads.push(_toNQuad(copy));
                                                        callback()
                                                    }, function(err) {
                                                        if (err) {
                                                            return callback(err)
                                                        }
                                                        nquads.sort();
                                                        info.hash = NormalizeHash.hashNQuads(self.name, nquads);
                                                        callback(null, info.hash)
                                                    })
                                                };
                                                Normalize.prototype.modifyFirstDegreeComponent = function(id, component) {
                                                    if ("blank node" !== component.type) {
                                                        return component
                                                    }
                                                    component = _clone(component);
                                                    component.value = component.value === id ? "_:a" : "_:z";
                                                    return component
                                                };
                                                Normalize.prototype.hashRelatedBlankNode = function(related, quad, issuer, position, callback) {
                                                    var self = this,
                                                        id;
                                                    self.waterfall([function(callback) {
                                                        if (self.canonicalIssuer.hasId(related)) {
                                                            id = self.canonicalIssuer.getId(related);
                                                            return callback()
                                                        }
                                                        if (issuer.hasId(related)) {
                                                            id = issuer.getId(related);
                                                            return callback()
                                                        }
                                                        self.hashFirstDegreeQuads(related, function(err, hash) {
                                                            if (err) {
                                                                return callback(err)
                                                            }
                                                            id = hash;
                                                            callback()
                                                        })
                                                    }], function(err) {
                                                        if (err) {
                                                            return callback(err)
                                                        }
                                                        var md = new NormalizeHash(self.name);
                                                        md.update(position);
                                                        if ("g" !== position) {
                                                            md.update(self.getRelatedPredicate(quad))
                                                        }
                                                        md.update(id);
                                                        return callback(null, md.digest())
                                                    })
                                                };
                                                Normalize.prototype.getRelatedPredicate = function(quad) {
                                                    return "<" + quad.predicate.value + ">"
                                                };
                                                Normalize.prototype.hashNDegreeQuads = function(id, issuer, callback) {
                                                    var self = this,
                                                        hashToRelated, md = new NormalizeHash(self.name);
                                                    self.waterfall([function(callback) {
                                                        self.createHashToRelated(id, issuer, function(err, result) {
                                                            if (err) {
                                                                return callback(err)
                                                            }
                                                            hashToRelated = result;
                                                            callback()
                                                        })
                                                    }, function(callback) {
                                                        var hashes = Object.keys(hashToRelated).sort();
                                                        self.forEach(hashes, function(hash, idx, callback) {
                                                            md.update(hash);
                                                            var chosenPath = "",
                                                                chosenIssuer, permutator = new Permutator(hashToRelated[hash]);
                                                            self.whilst(function() {
                                                                return permutator.hasNext()
                                                            }, function(nextPermutation) {
                                                                var permutation = permutator.next(),
                                                                    issuerCopy = issuer.clone(),
                                                                    path = "",
                                                                    recursionList = [];
                                                                self.waterfall([function(callback) {
                                                                    self.forEach(permutation, function(related, idx, callback) {
                                                                        if (self.canonicalIssuer.hasId(related)) {
                                                                            path += self.canonicalIssuer.getId(related)
                                                                        } else {
                                                                            if (!issuerCopy.hasId(related)) {
                                                                                recursionList.push(related)
                                                                            }
                                                                            path += issuerCopy.getId(related)
                                                                        }
                                                                        if (0 !== chosenPath.length && path.length >= chosenPath.length && path > chosenPath) {
                                                                            return nextPermutation()
                                                                        }
                                                                        callback()
                                                                    }, callback)
                                                                }, function(callback) {
                                                                    self.forEach(recursionList, function(related, idx, callback) {
                                                                        self.hashNDegreeQuads(related, issuerCopy, function(err, result) {
                                                                            if (err) {
                                                                                return callback(err)
                                                                            }
                                                                            path += issuerCopy.getId(related);
                                                                            path += "<" + result.hash + ">";
                                                                            issuerCopy = result.issuer;
                                                                            if (0 !== chosenPath.length && path.length >= chosenPath.length && path > chosenPath) {
                                                                                return nextPermutation()
                                                                            }
                                                                            callback()
                                                                        })
                                                                    }, callback)
                                                                }, function(callback) {
                                                                    if (0 === chosenPath.length || path < chosenPath) {
                                                                        chosenPath = path;
                                                                        chosenIssuer = issuerCopy
                                                                    }
                                                                    callback()
                                                                }], nextPermutation)
                                                            }, function(err) {
                                                                if (err) {
                                                                    return callback(err)
                                                                }
                                                                md.update(chosenPath);
                                                                issuer = chosenIssuer;
                                                                callback()
                                                            })
                                                        }, callback)
                                                    }], function(err) {
                                                        callback(err, {
                                                            hash: md.digest(),
                                                            issuer: issuer
                                                        })
                                                    })
                                                };
                                                Normalize.prototype.createHashToRelated = function(id, issuer, callback) {
                                                    var self = this,
                                                        hashToRelated = {},
                                                        quads = self.blankNodeInfo[id].quads;
                                                    self.forEach(quads, function(quad, idx, callback) {
                                                        self.forEach(quad, function(component, key, callback) {
                                                            if ("predicate" === key || !("blank node" === component.type && component.value !== id)) {
                                                                return callback()
                                                            }
                                                            var related = component.value,
                                                                position = POSITIONS[key];
                                                            self.hashRelatedBlankNode(related, quad, issuer, position, function(err, hash) {
                                                                if (err) {
                                                                    return callback(err)
                                                                }
                                                                if (hash in hashToRelated) {
                                                                    hashToRelated[hash].push(related)
                                                                } else {
                                                                    hashToRelated[hash] = [related]
                                                                }
                                                                callback()
                                                            })
                                                        }, callback)
                                                    }, function(err) {
                                                        callback(err, hashToRelated)
                                                    })
                                                };
                                                Normalize.prototype.forEachComponent = function(quad, op) {
                                                    for (var key in quad) {
                                                        if ("predicate" === key) {
                                                            continue
                                                        }
                                                        op(quad[key], key, quad)
                                                    }
                                                };
                                                return Normalize
                                            }(),
                                            URGNA2012 = function() {
                                                var Normalize = function(options) {
                                                    URDNA2015.call(this, options);
                                                    this.name = "URGNA2012"
                                                };
                                                Normalize.prototype = new URDNA2015;
                                                Normalize.prototype.modifyFirstDegreeComponent = function(id, component, key) {
                                                    if ("blank node" !== component.type) {
                                                        return component
                                                    }
                                                    component = _clone(component);
                                                    if ("name" === key) {
                                                        component.value = "_:g"
                                                    } else {
                                                        component.value = component.value === id ? "_:a" : "_:z"
                                                    }
                                                    return component
                                                };
                                                Normalize.prototype.getRelatedPredicate = function(quad) {
                                                    return quad.predicate.value
                                                };
                                                Normalize.prototype.createHashToRelated = function(id, issuer, callback) {
                                                    var self = this,
                                                        hashToRelated = {},
                                                        quads = self.blankNodeInfo[id].quads;
                                                    self.forEach(quads, function(quad, idx, callback) {
                                                        var position, related;
                                                        if ("blank node" === quad.subject.type && quad.subject.value !== id) {
                                                            related = quad.subject.value;
                                                            position = "p"
                                                        } else if ("blank node" === quad.object.type && quad.object.value !== id) {
                                                            related = quad.object.value;
                                                            position = "r"
                                                        } else {
                                                            return callback()
                                                        }
                                                        self.hashRelatedBlankNode(related, quad, issuer, position, function(err, hash) {
                                                            if (hash in hashToRelated) {
                                                                hashToRelated[hash].push(related)
                                                            } else {
                                                                hashToRelated[hash] = [related]
                                                            }
                                                            callback()
                                                        })
                                                    }, function(err) {
                                                        callback(err, hashToRelated)
                                                    })
                                                };
                                                return Normalize
                                            }();

                                        function _createNodeMap(input, graphs, graph, issuer, name, list) {
                                            if (_isArray(input)) {
                                                for (var i = 0; i < input.length; ++i) {
                                                    _createNodeMap(input[i], graphs, graph, issuer, void 0, list)
                                                }
                                                return
                                            }
                                            if (!_isObject(input)) {
                                                if (list) {
                                                    list.push(input)
                                                }
                                                return
                                            }
                                            if (_isValue(input)) {
                                                if ("@type" in input) {
                                                    var type = input["@type"];
                                                    if (0 === type.indexOf("_:")) {
                                                        input["@type"] = type = issuer.getId(type)
                                                    }
                                                }
                                                if (list) {
                                                    list.push(input)
                                                }
                                                return
                                            }
                                            if ("@type" in input) {
                                                for (var types = input["@type"], i = 0, type; i < types.length; ++i) {
                                                    type = types[i];
                                                    if (0 === type.indexOf("_:")) {
                                                        issuer.getId(type)
                                                    }
                                                }
                                            }
                                            if (_isUndefined(name)) {
                                                name = _isBlankNode(input) ? issuer.getId(input["@id"]) : input["@id"]
                                            }
                                            if (list) {
                                                list.push({
                                                    "@id": name
                                                })
                                            }
                                            var subjects = graphs[graph],
                                                subject = subjects[name] = subjects[name] || {};
                                            subject["@id"] = name;
                                            for (var properties = Object.keys(input).sort(), pi = 0, property; pi < properties.length; ++pi) {
                                                property = properties[pi];
                                                if ("@id" === property) {
                                                    continue
                                                }
                                                if ("@reverse" === property) {
                                                    var referencedNode = {
                                                            "@id": name
                                                        },
                                                        reverseMap = input["@reverse"];
                                                    for (var reverseProperty in reverseMap) {
                                                        for (var items = reverseMap[reverseProperty], ii = 0; ii < items.length; ++ii) {
                                                            var item = items[ii],
                                                                itemName = item["@id"];
                                                            if (_isBlankNode(item)) {
                                                                itemName = issuer.getId(itemName)
                                                            }
                                                            _createNodeMap(item, graphs, graph, issuer, itemName);
                                                            jsonld.addValue(subjects[itemName], reverseProperty, referencedNode, {
                                                                propertyIsArray: !0,
                                                                allowDuplicate: !1
                                                            })
                                                        }
                                                    }
                                                    continue
                                                }
                                                if ("@graph" === property) {
                                                    if (!(name in graphs)) {
                                                        graphs[name] = {}
                                                    }
                                                    var g = "@merged" === graph ? graph : name;
                                                    _createNodeMap(input[property], graphs, g, issuer);
                                                    continue
                                                }
                                                if ("@type" !== property && _isKeyword(property)) {
                                                    if ("@index" === property && property in subject && (input[property] !== subject[property] || input[property]["@id"] !== subject[property]["@id"])) {
                                                        throw new JsonLdError("Invalid JSON-LD syntax; conflicting @index property detected.", "jsonld.SyntaxError", {
                                                            code: "conflicting indexes",
                                                            subject: subject
                                                        })
                                                    }
                                                    subject[property] = input[property];
                                                    continue
                                                }
                                                var objects = input[property];
                                                if (0 === property.indexOf("_:")) {
                                                    property = issuer.getId(property)
                                                }
                                                if (0 === objects.length) {
                                                    jsonld.addValue(subject, property, [], {
                                                        propertyIsArray: !0
                                                    });
                                                    continue
                                                }
                                                for (var oi = 0, o; oi < objects.length; ++oi) {
                                                    o = objects[oi];
                                                    if ("@type" === property) {
                                                        o = 0 === o.indexOf("_:") ? issuer.getId(o) : o
                                                    }
                                                    if (_isSubject(o) || _isSubjectReference(o)) {
                                                        var id = _isBlankNode(o) ? issuer.getId(o["@id"]) : o["@id"];
                                                        jsonld.addValue(subject, property, {
                                                            "@id": id
                                                        }, {
                                                            propertyIsArray: !0,
                                                            allowDuplicate: !1
                                                        });
                                                        _createNodeMap(o, graphs, graph, issuer, id)
                                                    } else if (_isList(o)) {
                                                        var _list = [];
                                                        _createNodeMap(o["@list"], graphs, graph, issuer, name, _list);
                                                        o = {
                                                            "@list": _list
                                                        };
                                                        jsonld.addValue(subject, property, o, {
                                                            propertyIsArray: !0,
                                                            allowDuplicate: !1
                                                        })
                                                    } else {
                                                        _createNodeMap(o, graphs, graph, issuer, name);
                                                        jsonld.addValue(subject, property, o, {
                                                            propertyIsArray: !0,
                                                            allowDuplicate: !1
                                                        })
                                                    }
                                                }
                                            }
                                        }

                                        function _mergeNodeMaps(graphs) {
                                            for (var defaultGraph = graphs["@default"], graphNames = Object.keys(graphs).sort(), i = 0, graphName; i < graphNames.length; ++i) {
                                                graphName = graphNames[i];
                                                if ("@default" === graphName) {
                                                    continue
                                                }
                                                var nodeMap = graphs[graphName],
                                                    subject = defaultGraph[graphName];
                                                if (!subject) {
                                                    defaultGraph[graphName] = subject = {
                                                        "@id": graphName,
                                                        "@graph": []
                                                    }
                                                } else if (!("@graph" in subject)) {
                                                    subject["@graph"] = []
                                                }
                                                for (var graph = subject["@graph"], ids = Object.keys(nodeMap).sort(), ii = 0, node; ii < ids.length; ++ii) {
                                                    node = nodeMap[ids[ii]];
                                                    if (!_isSubjectReference(node)) {
                                                        graph.push(node)
                                                    }
                                                }
                                            }
                                            return defaultGraph
                                        }

                                        function _frame(state, subjects, frame, parent, property) {
                                            _validateFrame(frame);
                                            frame = frame[0];
                                            for (var options = state.options, flags = {
                                                    embed: _getFrameFlag(frame, options, "embed"),
                                                    explicit: _getFrameFlag(frame, options, "explicit"),
                                                    requireAll: _getFrameFlag(frame, options, "requireAll")
                                                }, matches = _filterSubjects(state, subjects, frame, flags), ids = Object.keys(matches).sort(), idx = 0; idx < ids.length; ++idx) {
                                                var id = ids[idx],
                                                    subject = matches[id];
                                                if ("@link" === flags.embed && id in state.link) {
                                                    _addFrameOutput(parent, property, state.link[id]);
                                                    continue
                                                }
                                                if (null === property) {
                                                    state.uniqueEmbeds = {}
                                                }
                                                var output = {
                                                    "@id": id
                                                };
                                                state.link[id] = output;
                                                if ("@never" === flags.embed || _createsCircularReference(subject, state.subjectStack)) {
                                                    _addFrameOutput(parent, property, output);
                                                    continue
                                                }
                                                if ("@last" === flags.embed) {
                                                    if (id in state.uniqueEmbeds) {
                                                        _removeEmbed(state, id)
                                                    }
                                                    state.uniqueEmbeds[id] = {
                                                        parent: parent,
                                                        property: property
                                                    }
                                                }
                                                state.subjectStack.push(subject);
                                                for (var props = Object.keys(subject).sort(), i = 0, prop; i < props.length; i++) {
                                                    prop = props[i];
                                                    if (_isKeyword(prop)) {
                                                        output[prop] = _clone(subject[prop]);
                                                        continue
                                                    }
                                                    if (flags.explicit && !(prop in frame)) {
                                                        continue
                                                    }
                                                    for (var objects = subject[prop], oi = 0, o; oi < objects.length; ++oi) {
                                                        o = objects[oi];
                                                        if (_isList(o)) {
                                                            var list = {
                                                                "@list": []
                                                            };
                                                            _addFrameOutput(output, prop, list);
                                                            var src = o["@list"];
                                                            for (var n in src) {
                                                                o = src[n];
                                                                if (_isSubjectReference(o)) {
                                                                    var subframe = prop in frame ? frame[prop][0]["@list"] : _createImplicitFrame(flags);
                                                                    _frame(state, [o["@id"]], subframe, list, "@list")
                                                                } else {
                                                                    _addFrameOutput(list, "@list", _clone(o))
                                                                }
                                                            }
                                                            continue
                                                        }
                                                        if (_isSubjectReference(o)) {
                                                            var subframe = prop in frame ? frame[prop] : _createImplicitFrame(flags);
                                                            _frame(state, [o["@id"]], subframe, output, prop)
                                                        } else {
                                                            _addFrameOutput(output, prop, _clone(o))
                                                        }
                                                    }
                                                }
                                                for (var props = Object.keys(frame).sort(), i = 0, prop; i < props.length; ++i) {
                                                    prop = props[i];
                                                    if (_isKeyword(prop)) {
                                                        continue
                                                    }
                                                    var next = frame[prop][0],
                                                        omitDefaultOn = _getFrameFlag(next, options, "omitDefault");
                                                    if (!omitDefaultOn && !(prop in output)) {
                                                        var preserve = "@null";
                                                        if ("@default" in next) {
                                                            preserve = _clone(next["@default"])
                                                        }
                                                        if (!_isArray(preserve)) {
                                                            preserve = [preserve]
                                                        }
                                                        output[prop] = [{
                                                            "@preserve": preserve
                                                        }]
                                                    }
                                                }
                                                _addFrameOutput(parent, property, output);
                                                state.subjectStack.pop()
                                            }
                                        }

                                        function _createImplicitFrame(flags) {
                                            var frame = {};
                                            for (var key in flags) {
                                                if (flags[key] !== void 0) {
                                                    frame["@" + key] = [flags[key]]
                                                }
                                            }
                                            return [frame]
                                        }

                                        function _createsCircularReference(subjectToEmbed, subjectStack) {
                                            for (var i = subjectStack.length - 1; 0 <= i; --i) {
                                                if (subjectStack[i]["@id"] === subjectToEmbed["@id"]) {
                                                    return !0
                                                }
                                            }
                                            return !1
                                        }

                                        function _getFrameFlag(frame, options, name) {
                                            var flag = "@" + name,
                                                rval = flag in frame ? frame[flag][0] : options[name];
                                            if ("embed" === name) {
                                                if (!0 === rval) {
                                                    rval = "@last"
                                                } else if (!1 === rval) {
                                                    rval = "@never"
                                                } else if ("@always" !== rval && "@never" !== rval && "@link" !== rval) {
                                                    rval = "@last"
                                                }
                                            }
                                            return rval
                                        }

                                        function _validateFrame(frame) {
                                            if (!_isArray(frame) || 1 !== frame.length || !_isObject(frame[0])) {
                                                throw new JsonLdError("Invalid JSON-LD syntax; a JSON-LD frame must be a single object.", "jsonld.SyntaxError", {
                                                    frame: frame
                                                })
                                            }
                                        }

                                        function _filterSubjects(state, subjects, frame, flags) {
                                            for (var rval = {}, i = 0; i < subjects.length; ++i) {
                                                var id = subjects[i],
                                                    subject = state.subjects[id];
                                                if (_filterSubject(subject, frame, flags)) {
                                                    rval[id] = subject
                                                }
                                            }
                                            return rval
                                        }

                                        function _filterSubject(subject, frame, flags) {
                                            if ("@type" in frame && !(1 === frame["@type"].length && _isObject(frame["@type"][0]))) {
                                                for (var types = frame["@type"], i = 0; i < types.length; ++i) {
                                                    if (jsonld.hasValue(subject, "@type", types[i])) {
                                                        return !0
                                                    }
                                                }
                                                return !1
                                            }
                                            var wildcard = !0,
                                                matchesSome = !1;
                                            for (var key in frame) {
                                                if (_isKeyword(key)) {
                                                    if ("@id" !== key && "@type" !== key) {
                                                        continue
                                                    }
                                                    wildcard = !1;
                                                    if ("@id" === key && _isString(frame[key])) {
                                                        if (subject[key] !== frame[key]) {
                                                            return !1
                                                        }
                                                        matchesSome = !0;
                                                        continue
                                                    }
                                                }
                                                wildcard = !1;
                                                if (key in subject) {
                                                    if (_isArray(frame[key]) && 0 === frame[key].length && subject[key] !== void 0) {
                                                        return !1
                                                    }
                                                    matchesSome = !0;
                                                    continue
                                                }
                                                var hasDefault = _isArray(frame[key]) && _isObject(frame[key][0]) && "@default" in frame[key][0];
                                                if (flags.requireAll && !hasDefault) {
                                                    return !1
                                                }
                                            }
                                            return wildcard || matchesSome
                                        }

                                        function _removeEmbed(state, id) {
                                            var embeds = state.uniqueEmbeds,
                                                embed = embeds[id],
                                                parent = embed.parent,
                                                property = embed.property,
                                                subject = {
                                                    "@id": id
                                                };
                                            if (_isArray(parent)) {
                                                for (var i = 0; i < parent.length; ++i) {
                                                    if (jsonld.compareValues(parent[i], subject)) {
                                                        parent[i] = subject;
                                                        break
                                                    }
                                                }
                                            } else {
                                                var useArray = _isArray(parent[property]);
                                                jsonld.removeValue(parent, property, subject, {
                                                    propertyIsArray: useArray
                                                });
                                                jsonld.addValue(parent, property, subject, {
                                                    propertyIsArray: useArray
                                                })
                                            }
                                            var removeDependents = function(id) {
                                                for (var ids = Object.keys(embeds), i = 0, next; i < ids.length; ++i) {
                                                    next = ids[i];
                                                    if (next in embeds && _isObject(embeds[next].parent) && embeds[next].parent["@id"] === id) {
                                                        delete embeds[next];
                                                        removeDependents(next)
                                                    }
                                                }
                                            };
                                            removeDependents(id)
                                        }

                                        function _addFrameOutput(parent, property, output) {
                                            if (_isObject(parent)) {
                                                jsonld.addValue(parent, property, output, {
                                                    propertyIsArray: !0
                                                })
                                            } else {
                                                parent.push(output)
                                            }
                                        }

                                        function _removePreserve(ctx, input, options) {
                                            if (_isArray(input)) {
                                                for (var output = [], i = 0, result; i < input.length; ++i) {
                                                    result = _removePreserve(ctx, input[i], options);
                                                    if (null !== result) {
                                                        output.push(result)
                                                    }
                                                }
                                                input = output
                                            } else if (_isObject(input)) {
                                                if ("@preserve" in input) {
                                                    if ("@null" === input["@preserve"]) {
                                                        return null
                                                    }
                                                    return input["@preserve"]
                                                }
                                                if (_isValue(input)) {
                                                    return input
                                                }
                                                if (_isList(input)) {
                                                    input["@list"] = _removePreserve(ctx, input["@list"], options);
                                                    return input
                                                }
                                                var idAlias = _compactIri(ctx, "@id");
                                                if (idAlias in input) {
                                                    var id = input[idAlias];
                                                    if (id in options.link) {
                                                        var idx = options.link[id].indexOf(input);
                                                        if (-1 === idx) {
                                                            options.link[id].push(input)
                                                        } else {
                                                            return options.link[id][idx]
                                                        }
                                                    } else {
                                                        options.link[id] = [input]
                                                    }
                                                }
                                                for (var prop in input) {
                                                    var result = _removePreserve(ctx, input[prop], options),
                                                        container = jsonld.getContextValue(ctx, prop, "@container");
                                                    if (options.compactArrays && _isArray(result) && 1 === result.length && null === container) {
                                                        result = result[0]
                                                    }
                                                    input[prop] = result
                                                }
                                            }
                                            return input
                                        }

                                        function _compareShortestLeast(a, b) {
                                            if (a.length < b.length) {
                                                return -1
                                            }
                                            if (b.length < a.length) {
                                                return 1
                                            }
                                            if (a === b) {
                                                return 0
                                            }
                                            return a < b ? -1 : 1
                                        }

                                        function _selectTerm(activeCtx, iri, value, containers, typeOrLanguage, typeOrLanguageValue) {
                                            if (null === typeOrLanguageValue) {
                                                typeOrLanguageValue = "@null"
                                            }
                                            var prefs = [];
                                            if (("@id" === typeOrLanguageValue || "@reverse" === typeOrLanguageValue) && _isSubjectReference(value)) {
                                                if ("@reverse" === typeOrLanguageValue) {
                                                    prefs.push("@reverse")
                                                }
                                                var term = _compactIri(activeCtx, value["@id"], null, {
                                                    vocab: !0
                                                });
                                                if (term in activeCtx.mappings && activeCtx.mappings[term] && activeCtx.mappings[term]["@id"] === value["@id"]) {
                                                    prefs.push.apply(prefs, ["@vocab", "@id"])
                                                } else {
                                                    prefs.push.apply(prefs, ["@id", "@vocab"])
                                                }
                                            } else {
                                                prefs.push(typeOrLanguageValue)
                                            }
                                            prefs.push("@none");
                                            for (var containerMap = activeCtx.inverse[iri], ci = 0, container; ci < containers.length; ++ci) {
                                                container = containers[ci];
                                                if (!(container in containerMap)) {
                                                    continue
                                                }
                                                for (var typeOrLanguageValueMap = containerMap[container][typeOrLanguage], pi = 0, pref; pi < prefs.length; ++pi) {
                                                    pref = prefs[pi];
                                                    if (!(pref in typeOrLanguageValueMap)) {
                                                        continue
                                                    }
                                                    return typeOrLanguageValueMap[pref]
                                                }
                                            }
                                            return null
                                        }

                                        function _compactIri(activeCtx, iri, value, relativeTo, reverse) {
                                            if (null === iri) {
                                                return iri
                                            }
                                            if (_isUndefined(value)) {
                                                value = null
                                            }
                                            if (_isUndefined(reverse)) {
                                                reverse = !1
                                            }
                                            relativeTo = relativeTo || {};
                                            var inverseCtx = activeCtx.getInverse();
                                            if (_isKeyword(iri)) {
                                                if (iri in inverseCtx) {
                                                    return inverseCtx[iri]["@none"]["@type"]["@none"]
                                                }
                                                return iri
                                            }
                                            if (relativeTo.vocab && iri in inverseCtx) {
                                                var defaultLanguage = activeCtx["@language"] || "@none",
                                                    containers = [];
                                                if (_isObject(value) && "@index" in value) {
                                                    containers.push("@index")
                                                }
                                                var typeOrLanguage = "@language",
                                                    typeOrLanguageValue = "@null";
                                                if (reverse) {
                                                    typeOrLanguage = "@type";
                                                    typeOrLanguageValue = "@reverse";
                                                    containers.push("@set")
                                                } else if (_isList(value)) {
                                                    if (!("@index" in value)) {
                                                        containers.push("@list")
                                                    }
                                                    for (var list = value["@list"], commonLanguage = 0 === list.length ? defaultLanguage : null, commonType = null, i = 0; i < list.length; ++i) {
                                                        var item = list[i],
                                                            itemLanguage = "@none",
                                                            itemType = "@none";
                                                        if (_isValue(item)) {
                                                            if ("@language" in item) {
                                                                itemLanguage = item["@language"]
                                                            } else if ("@type" in item) {
                                                                itemType = item["@type"]
                                                            } else {
                                                                itemLanguage = "@null"
                                                            }
                                                        } else {
                                                            itemType = "@id"
                                                        }
                                                        if (null === commonLanguage) {
                                                            commonLanguage = itemLanguage
                                                        } else if (itemLanguage !== commonLanguage && _isValue(item)) {
                                                            commonLanguage = "@none"
                                                        }
                                                        if (null === commonType) {
                                                            commonType = itemType
                                                        } else if (itemType !== commonType) {
                                                            commonType = "@none"
                                                        }
                                                        if ("@none" === commonLanguage && "@none" === commonType) {
                                                            break
                                                        }
                                                    }
                                                    commonLanguage = commonLanguage || "@none";
                                                    commonType = commonType || "@none";
                                                    if ("@none" !== commonType) {
                                                        typeOrLanguage = "@type";
                                                        typeOrLanguageValue = commonType
                                                    } else {
                                                        typeOrLanguageValue = commonLanguage
                                                    }
                                                } else {
                                                    if (_isValue(value)) {
                                                        if ("@language" in value && !("@index" in value)) {
                                                            containers.push("@language");
                                                            typeOrLanguageValue = value["@language"]
                                                        } else if ("@type" in value) {
                                                            typeOrLanguage = "@type";
                                                            typeOrLanguageValue = value["@type"]
                                                        }
                                                    } else {
                                                        typeOrLanguage = "@type";
                                                        typeOrLanguageValue = "@id"
                                                    }
                                                    containers.push("@set")
                                                }
                                                containers.push("@none");
                                                var term = _selectTerm(activeCtx, iri, value, containers, typeOrLanguage, typeOrLanguageValue);
                                                if (null !== term) {
                                                    return term
                                                }
                                            }
                                            if (relativeTo.vocab) {
                                                if ("@vocab" in activeCtx) {
                                                    var vocab = activeCtx["@vocab"];
                                                    if (0 === iri.indexOf(vocab) && iri !== vocab) {
                                                        var suffix = iri.substr(vocab.length);
                                                        if (!(suffix in activeCtx.mappings)) {
                                                            return suffix
                                                        }
                                                    }
                                                }
                                            }
                                            var choice = null,
                                                idx = 0,
                                                partialMatches = [],
                                                iriMap = activeCtx.fastCurieMap,
                                                maxPartialLength = iri.length - 1;
                                            for (; idx < maxPartialLength && iri[idx] in iriMap; ++idx) {
                                                iriMap = iriMap[iri[idx]];
                                                if ("" in iriMap) {
                                                    partialMatches.push(iriMap[""][0])
                                                }
                                            }
                                            for (var i = partialMatches.length - 1; 0 <= i; --i) {
                                                for (var entry = partialMatches[i], terms = entry.terms, ti = 0; ti < terms.length; ++ti) {
                                                    var curie = terms[ti] + ":" + iri.substr(entry.iri.length),
                                                        isUsableCurie = !(curie in activeCtx.mappings) || null === value && activeCtx.mappings[curie]["@id"] === iri;
                                                    if (isUsableCurie && (null === choice || 0 > _compareShortestLeast(curie, choice))) {
                                                        choice = curie
                                                    }
                                                }
                                            }
                                            if (null !== choice) {
                                                return choice
                                            }
                                            if (!relativeTo.vocab) {
                                                return _removeBase(activeCtx["@base"], iri)
                                            }
                                            return iri
                                        }

                                        function _compactValue(activeCtx, activeProperty, value) {
                                            if (_isValue(value)) {
                                                var type = jsonld.getContextValue(activeCtx, activeProperty, "@type"),
                                                    language = jsonld.getContextValue(activeCtx, activeProperty, "@language"),
                                                    container = jsonld.getContextValue(activeCtx, activeProperty, "@container"),
                                                    preserveIndex = "@index" in value && "@index" !== container;
                                                if (!preserveIndex) {
                                                    if (value["@type"] === type || value["@language"] === language) {
                                                        return value["@value"]
                                                    }
                                                }
                                                var keyCount = Object.keys(value).length,
                                                    isValueOnlyKey = 1 === keyCount || 2 === keyCount && "@index" in value && !preserveIndex,
                                                    hasDefaultLanguage = "@language" in activeCtx,
                                                    isValueString = _isString(value["@value"]),
                                                    hasNullMapping = activeCtx.mappings[activeProperty] && null === activeCtx.mappings[activeProperty]["@language"];
                                                if (isValueOnlyKey && (!hasDefaultLanguage || !isValueString || hasNullMapping)) {
                                                    return value["@value"]
                                                }
                                                var rval = {};
                                                if (preserveIndex) {
                                                    rval[_compactIri(activeCtx, "@index")] = value["@index"]
                                                }
                                                if ("@type" in value) {
                                                    rval[_compactIri(activeCtx, "@type")] = _compactIri(activeCtx, value["@type"], null, {
                                                        vocab: !0
                                                    })
                                                } else if ("@language" in value) {
                                                    rval[_compactIri(activeCtx, "@language")] = value["@language"]
                                                }
                                                rval[_compactIri(activeCtx, "@value")] = value["@value"];
                                                return rval
                                            }
                                            var expandedProperty = _expandIri(activeCtx, activeProperty, {
                                                    vocab: !0
                                                }),
                                                type = jsonld.getContextValue(activeCtx, activeProperty, "@type"),
                                                compacted = _compactIri(activeCtx, value["@id"], null, {
                                                    vocab: "@vocab" === type
                                                });
                                            if ("@id" === type || "@vocab" === type || "@graph" === expandedProperty) {
                                                return compacted
                                            }
                                            var rval = {};
                                            rval[_compactIri(activeCtx, "@id")] = compacted;
                                            return rval
                                        }

                                        function _createTermDefinition(activeCtx, localCtx, term, defined) {
                                            if (term in defined) {
                                                if (defined[term]) {
                                                    return
                                                }
                                                throw new JsonLdError("Cyclical context definition detected.", "jsonld.CyclicalContext", {
                                                    code: "cyclic IRI mapping",
                                                    context: localCtx,
                                                    term: term
                                                })
                                            }
                                            defined[term] = !1;
                                            if (_isKeyword(term)) {
                                                throw new JsonLdError("Invalid JSON-LD syntax; keywords cannot be overridden.", "jsonld.SyntaxError", {
                                                    code: "keyword redefinition",
                                                    context: localCtx,
                                                    term: term
                                                })
                                            }
                                            if ("" === term) {
                                                throw new JsonLdError("Invalid JSON-LD syntax; a term cannot be an empty string.", "jsonld.SyntaxError", {
                                                    code: "invalid term definition",
                                                    context: localCtx
                                                })
                                            }
                                            if (activeCtx.mappings[term]) {
                                                delete activeCtx.mappings[term]
                                            }
                                            var value = localCtx[term];
                                            if (null === value || _isObject(value) && null === value["@id"]) {
                                                activeCtx.mappings[term] = null;
                                                defined[term] = !0;
                                                return
                                            }
                                            if (_isString(value)) {
                                                value = {
                                                    "@id": value
                                                }
                                            }
                                            if (!_isObject(value)) {
                                                throw new JsonLdError("Invalid JSON-LD syntax; @context property values must be " + "strings or objects.", "jsonld.SyntaxError", {
                                                    code: "invalid term definition",
                                                    context: localCtx
                                                })
                                            }
                                            var mapping = activeCtx.mappings[term] = {};
                                            mapping.reverse = !1;
                                            if ("@reverse" in value) {
                                                if ("@id" in value) {
                                                    throw new JsonLdError("Invalid JSON-LD syntax; a @reverse term definition must not " + "contain @id.", "jsonld.SyntaxError", {
                                                        code: "invalid reverse property",
                                                        context: localCtx
                                                    })
                                                }
                                                var reverse = value["@reverse"];
                                                if (!_isString(reverse)) {
                                                    throw new JsonLdError("Invalid JSON-LD syntax; a @context @reverse value must be a string.", "jsonld.SyntaxError", {
                                                        code: "invalid IRI mapping",
                                                        context: localCtx
                                                    })
                                                }
                                                var id = _expandIri(activeCtx, reverse, {
                                                    vocab: !0,
                                                    base: !1
                                                }, localCtx, defined);
                                                if (!_isAbsoluteIri(id)) {
                                                    throw new JsonLdError("Invalid JSON-LD syntax; a @context @reverse value must be an " + "absolute IRI or a blank node identifier.", "jsonld.SyntaxError", {
                                                        code: "invalid IRI mapping",
                                                        context: localCtx
                                                    })
                                                }
                                                mapping["@id"] = id;
                                                mapping.reverse = !0
                                            } else if ("@id" in value) {
                                                var id = value["@id"];
                                                if (!_isString(id)) {
                                                    throw new JsonLdError("Invalid JSON-LD syntax; a @context @id value must be an array " + "of strings or a string.", "jsonld.SyntaxError", {
                                                        code: "invalid IRI mapping",
                                                        context: localCtx
                                                    })
                                                }
                                                if (id !== term) {
                                                    id = _expandIri(activeCtx, id, {
                                                        vocab: !0,
                                                        base: !1
                                                    }, localCtx, defined);
                                                    if (!_isAbsoluteIri(id) && !_isKeyword(id)) {
                                                        throw new JsonLdError("Invalid JSON-LD syntax; a @context @id value must be an " + "absolute IRI, a blank node identifier, or a keyword.", "jsonld.SyntaxError", {
                                                            code: "invalid IRI mapping",
                                                            context: localCtx
                                                        })
                                                    }
                                                    mapping["@id"] = id
                                                }
                                            }
                                            var colon = term.indexOf(":");
                                            mapping._termHasColon = -1 !== colon;
                                            if (!("@id" in mapping)) {
                                                if (mapping._termHasColon) {
                                                    var prefix = term.substr(0, colon);
                                                    if (prefix in localCtx) {
                                                        _createTermDefinition(activeCtx, localCtx, prefix, defined)
                                                    }
                                                    if (activeCtx.mappings[prefix]) {
                                                        var suffix = term.substr(colon + 1);
                                                        mapping["@id"] = activeCtx.mappings[prefix]["@id"] + suffix
                                                    } else {
                                                        mapping["@id"] = term
                                                    }
                                                } else {
                                                    if (!("@vocab" in activeCtx)) {
                                                        throw new JsonLdError("Invalid JSON-LD syntax; @context terms must define an @id.", "jsonld.SyntaxError", {
                                                            code: "invalid IRI mapping",
                                                            context: localCtx,
                                                            term: term
                                                        })
                                                    }
                                                    mapping["@id"] = activeCtx["@vocab"] + term
                                                }
                                            }
                                            defined[term] = !0;
                                            if ("@type" in value) {
                                                var type = value["@type"];
                                                if (!_isString(type)) {
                                                    throw new JsonLdError("Invalid JSON-LD syntax; an @context @type values must be a string.", "jsonld.SyntaxError", {
                                                        code: "invalid type mapping",
                                                        context: localCtx
                                                    })
                                                }
                                                if ("@id" !== type && "@vocab" !== type) {
                                                    type = _expandIri(activeCtx, type, {
                                                        vocab: !0,
                                                        base: !1
                                                    }, localCtx, defined);
                                                    if (!_isAbsoluteIri(type)) {
                                                        throw new JsonLdError("Invalid JSON-LD syntax; an @context @type value must be an " + "absolute IRI.", "jsonld.SyntaxError", {
                                                            code: "invalid type mapping",
                                                            context: localCtx
                                                        })
                                                    }
                                                    if (0 === type.indexOf("_:")) {
                                                        throw new JsonLdError("Invalid JSON-LD syntax; an @context @type values must be an IRI, " + "not a blank node identifier.", "jsonld.SyntaxError", {
                                                            code: "invalid type mapping",
                                                            context: localCtx
                                                        })
                                                    }
                                                }
                                                mapping["@type"] = type
                                            }
                                            if ("@container" in value) {
                                                var container = value["@container"];
                                                if ("@list" !== container && "@set" !== container && "@index" !== container && "@language" !== container) {
                                                    throw new JsonLdError("Invalid JSON-LD syntax; @context @container value must be " + "one of the following: @list, @set, @index, or @language.", "jsonld.SyntaxError", {
                                                        code: "invalid container mapping",
                                                        context: localCtx
                                                    })
                                                }
                                                if (mapping.reverse && "@index" !== container && "@set" !== container && null !== container) {
                                                    throw new JsonLdError("Invalid JSON-LD syntax; @context @container value for a @reverse " + "type definition must be @index or @set.", "jsonld.SyntaxError", {
                                                        code: "invalid reverse property",
                                                        context: localCtx
                                                    })
                                                }
                                                mapping["@container"] = container
                                            }
                                            if ("@language" in value && !("@type" in value)) {
                                                var language = value["@language"];
                                                if (null !== language && !_isString(language)) {
                                                    throw new JsonLdError("Invalid JSON-LD syntax; @context @language value must be " + "a string or null.", "jsonld.SyntaxError", {
                                                        code: "invalid language mapping",
                                                        context: localCtx
                                                    })
                                                }
                                                if (null !== language) {
                                                    language = language.toLowerCase()
                                                }
                                                mapping["@language"] = language
                                            }
                                            var id = mapping["@id"];
                                            if ("@context" === id || "@preserve" === id) {
                                                throw new JsonLdError("Invalid JSON-LD syntax; @context and @preserve cannot be aliased.", "jsonld.SyntaxError", {
                                                    code: "invalid keyword alias",
                                                    context: localCtx
                                                })
                                            }
                                        }

                                        function _expandIri(activeCtx, value, relativeTo, localCtx, defined) {
                                            if (null === value || _isKeyword(value)) {
                                                return value
                                            }
                                            value = value + "";
                                            if (localCtx && value in localCtx && !0 !== defined[value]) {
                                                _createTermDefinition(activeCtx, localCtx, value, defined)
                                            }
                                            relativeTo = relativeTo || {};
                                            if (relativeTo.vocab) {
                                                var mapping = activeCtx.mappings[value];
                                                if (null === mapping) {
                                                    return null
                                                }
                                                if (mapping) {
                                                    return mapping["@id"]
                                                }
                                            }
                                            var colon = value.indexOf(":");
                                            if (-1 !== colon) {
                                                var prefix = value.substr(0, colon),
                                                    suffix = value.substr(colon + 1);
                                                if ("_" === prefix || 0 === suffix.indexOf("//")) {
                                                    return value
                                                }
                                                if (localCtx && prefix in localCtx) {
                                                    _createTermDefinition(activeCtx, localCtx, prefix, defined)
                                                }
                                                var mapping = activeCtx.mappings[prefix];
                                                if (mapping) {
                                                    return mapping["@id"] + suffix
                                                }
                                                return value
                                            }
                                            if (relativeTo.vocab && "@vocab" in activeCtx) {
                                                return activeCtx["@vocab"] + value
                                            }
                                            var rval = value;
                                            if (relativeTo.base) {
                                                rval = jsonld.prependBase(activeCtx["@base"], rval)
                                            }
                                            return rval
                                        }

                                        function _prependBase(base, iri) {
                                            if (null === base) {
                                                return iri
                                            }
                                            if (-1 !== iri.indexOf(":")) {
                                                return iri
                                            }
                                            if (_isString(base)) {
                                                base = jsonld.url.parse(base || "")
                                            }
                                            var rel = jsonld.url.parse(iri),
                                                transform = {
                                                    protocol: base.protocol || ""
                                                };
                                            if (null !== rel.authority) {
                                                transform.authority = rel.authority;
                                                transform.path = rel.path;
                                                transform.query = rel.query
                                            } else {
                                                transform.authority = base.authority;
                                                if ("" === rel.path) {
                                                    transform.path = base.path;
                                                    if (null !== rel.query) {
                                                        transform.query = rel.query
                                                    } else {
                                                        transform.query = base.query
                                                    }
                                                } else {
                                                    if (0 === rel.path.indexOf("/")) {
                                                        transform.path = rel.path
                                                    } else {
                                                        var path = base.path;
                                                        if ("" !== rel.path) {
                                                            path = path.substr(0, path.lastIndexOf("/") + 1);
                                                            if (0 < path.length && "/" !== path.substr(-1)) {
                                                                path += "/"
                                                            }
                                                            path += rel.path
                                                        }
                                                        transform.path = path
                                                    }
                                                    transform.query = rel.query
                                                }
                                            }
                                            transform.path = _removeDotSegments(transform.path, !!transform.authority);
                                            var rval = transform.protocol;
                                            if (null !== transform.authority) {
                                                rval += "//" + transform.authority
                                            }
                                            rval += transform.path;
                                            if (null !== transform.query) {
                                                rval += "?" + transform.query
                                            }
                                            if (null !== rel.fragment) {
                                                rval += "#" + rel.fragment
                                            }
                                            if ("" === rval) {
                                                rval = "./"
                                            }
                                            return rval
                                        }

                                        function _removeBase(base, iri) {
                                            if (null === base) {
                                                return iri
                                            }
                                            if (_isString(base)) {
                                                base = jsonld.url.parse(base || "")
                                            }
                                            var root = "";
                                            if ("" !== base.href) {
                                                root += (base.protocol || "") + "//" + (base.authority || "")
                                            } else if (iri.indexOf("//")) {
                                                root += "//"
                                            }
                                            if (0 !== iri.indexOf(root)) {
                                                return iri
                                            }
                                            var rel = jsonld.url.parse(iri.substr(root.length)),
                                                baseSegments = base.normalizedPath.split("/"),
                                                iriSegments = rel.normalizedPath.split("/"),
                                                last = rel.fragment || rel.query ? 0 : 1;
                                            while (0 < baseSegments.length && iriSegments.length > last) {
                                                if (baseSegments[0] !== iriSegments[0]) {
                                                    break
                                                }
                                                baseSegments.shift();
                                                iriSegments.shift()
                                            }
                                            var rval = "";
                                            if (0 < baseSegments.length) {
                                                baseSegments.pop();
                                                for (var i = 0; i < baseSegments.length; ++i) {
                                                    rval += "../"
                                                }
                                            }
                                            rval += iriSegments.join("/");
                                            if (null !== rel.query) {
                                                rval += "?" + rel.query
                                            }
                                            if (null !== rel.fragment) {
                                                rval += "#" + rel.fragment
                                            }
                                            if ("" === rval) {
                                                rval = "./"
                                            }
                                            return rval
                                        }

                                        function _getInitialContext(options) {
                                            var base = jsonld.url.parse(options.base || "");
                                            return {
                                                "@base": base,
                                                mappings: {},
                                                inverse: null,
                                                getInverse: _createInverseContext,
                                                clone: _cloneActiveContext
                                            };

                                            function _createInverseContext() {
                                                var activeCtx = this;
                                                if (activeCtx.inverse) {
                                                    return activeCtx.inverse
                                                }
                                                for (var inverse = activeCtx.inverse = {}, fastCurieMap = activeCtx.fastCurieMap = {}, irisToTerms = {}, defaultLanguage = activeCtx["@language"] || "@none", mappings = activeCtx.mappings, terms = Object.keys(mappings).sort(_compareShortestLeast), i = 0; i < terms.length; ++i) {
                                                    var term = terms[i],
                                                        mapping = mappings[term];
                                                    if (null === mapping) {
                                                        continue
                                                    }
                                                    var container = mapping["@container"] || "@none",
                                                        ids = mapping["@id"];
                                                    if (!_isArray(ids)) {
                                                        ids = [ids]
                                                    }
                                                    for (var ii = 0; ii < ids.length; ++ii) {
                                                        var iri = ids[ii],
                                                            entry = inverse[iri],
                                                            isKeyword = _isKeyword(iri);
                                                        if (!entry) {
                                                            inverse[iri] = entry = {};
                                                            if (!isKeyword && !mapping._termHasColon) {
                                                                irisToTerms[iri] = [term];
                                                                var fastCurieEntry = {
                                                                    iri: iri,
                                                                    terms: irisToTerms[iri]
                                                                };
                                                                if (iri[0] in fastCurieMap) {
                                                                    fastCurieMap[iri[0]].push(fastCurieEntry)
                                                                } else {
                                                                    fastCurieMap[iri[0]] = [fastCurieEntry]
                                                                }
                                                            }
                                                        } else if (!isKeyword && !mapping._termHasColon) {
                                                            irisToTerms[iri].push(term)
                                                        }
                                                        if (!entry[container]) {
                                                            entry[container] = {
                                                                "@language": {},
                                                                "@type": {}
                                                            }
                                                        }
                                                        entry = entry[container];
                                                        if (mapping.reverse) {
                                                            _addPreferredTerm(mapping, term, entry["@type"], "@reverse")
                                                        } else if ("@type" in mapping) {
                                                            _addPreferredTerm(mapping, term, entry["@type"], mapping["@type"])
                                                        } else if ("@language" in mapping) {
                                                            var language = mapping["@language"] || "@null";
                                                            _addPreferredTerm(mapping, term, entry["@language"], language)
                                                        } else {
                                                            _addPreferredTerm(mapping, term, entry["@language"], defaultLanguage);
                                                            _addPreferredTerm(mapping, term, entry["@type"], "@none");
                                                            _addPreferredTerm(mapping, term, entry["@language"], "@none")
                                                        }
                                                    }
                                                }
                                                for (var key in fastCurieMap) {
                                                    _buildIriMap(fastCurieMap, key, 1)
                                                }
                                                return inverse
                                            }

                                            function _buildIriMap(iriMap, key, idx) {
                                                for (var entries = iriMap[key], next = iriMap[key] = {}, iri, letter, i = 0; i < entries.length; ++i) {
                                                    iri = entries[i].iri;
                                                    if (idx >= iri.length) {
                                                        letter = ""
                                                    } else {
                                                        letter = iri[idx]
                                                    }
                                                    if (letter in next) {
                                                        next[letter].push(entries[i])
                                                    } else {
                                                        next[letter] = [entries[i]]
                                                    }
                                                }
                                                for (var key in next) {
                                                    if ("" === key) {
                                                        continue
                                                    }
                                                    _buildIriMap(next, key, idx + 1)
                                                }
                                            }

                                            function _addPreferredTerm(mapping, term, entry, typeOrLanguageValue) {
                                                if (!(typeOrLanguageValue in entry)) {
                                                    entry[typeOrLanguageValue] = term
                                                }
                                            }

                                            function _cloneActiveContext() {
                                                var child = {
                                                    "@base": this["@base"],
                                                    mappings: _clone(this.mappings),
                                                    clone: this.clone,
                                                    inverse: null,
                                                    getInverse: this.getInverse
                                                };
                                                if ("@language" in this) {
                                                    child["@language"] = this["@language"]
                                                }
                                                if ("@vocab" in this) {
                                                    child["@vocab"] = this["@vocab"]
                                                }
                                                return child
                                            }
                                        }

                                        function _isKeyword(v) {
                                            if (!_isString(v)) {
                                                return !1
                                            }
                                            switch (v) {
                                                case "@base":
                                                case "@context":
                                                case "@container":
                                                case "@default":
                                                case "@embed":
                                                case "@explicit":
                                                case "@graph":
                                                case "@id":
                                                case "@index":
                                                case "@language":
                                                case "@list":
                                                case "@omitDefault":
                                                case "@preserve":
                                                case "@requireAll":
                                                case "@reverse":
                                                case "@set":
                                                case "@type":
                                                case "@value":
                                                case "@vocab":
                                                    return !0;
                                            }
                                            return !1
                                        }

                                        function _isObject(v) {
                                            return "[object Object]" === Object.prototype.toString.call(v)
                                        }

                                        function _isEmptyObject(v) {
                                            return _isObject(v) && 0 === Object.keys(v).length
                                        }

                                        function _isArray(v) {
                                            return Array.isArray(v)
                                        }

                                        function _validateTypeValue(v) {
                                            if (_isString(v) || _isEmptyObject(v)) {
                                                return
                                            }
                                            var isValid = !1;
                                            if (_isArray(v)) {
                                                isValid = !0;
                                                for (var i = 0; i < v.length; ++i) {
                                                    if (!_isString(v[i])) {
                                                        isValid = !1;
                                                        break
                                                    }
                                                }
                                            }
                                            if (!isValid) {
                                                throw new JsonLdError("Invalid JSON-LD syntax; \"@type\" value must a string, an array of " + "strings, or an empty object.", "jsonld.SyntaxError", {
                                                    code: "invalid type value",
                                                    value: v
                                                })
                                            }
                                        }

                                        function _isString(v) {
                                            return "string" === typeof v || "[object String]" === Object.prototype.toString.call(v)
                                        }

                                        function _isNumber(v) {
                                            return "number" === typeof v || "[object Number]" === Object.prototype.toString.call(v)
                                        }

                                        function _isDouble(v) {
                                            return _isNumber(v) && -1 !== (v + "").indexOf(".")
                                        }

                                        function _isNumeric(v) {
                                            return !isNaN(parseFloat(v)) && isFinite(v)
                                        }

                                        function _isBoolean(v) {
                                            return "boolean" === typeof v || "[object Boolean]" === Object.prototype.toString.call(v)
                                        }

                                        function _isUndefined(v) {
                                            return "undefined" === typeof v
                                        }

                                        function _isSubject(v) {
                                            var rval = !1;
                                            if (_isObject(v) && !("@value" in v || "@set" in v || "@list" in v)) {
                                                var keyCount = Object.keys(v).length;
                                                rval = 1 < keyCount || !("@id" in v)
                                            }
                                            return rval
                                        }

                                        function _isSubjectReference(v) {
                                            return _isObject(v) && 1 === Object.keys(v).length && "@id" in v
                                        }

                                        function _isValue(v) {
                                            return _isObject(v) && "@value" in v
                                        }

                                        function _isList(v) {
                                            return _isObject(v) && "@list" in v
                                        }

                                        function _isBlankNode(v) {
                                            var rval = !1;
                                            if (_isObject(v)) {
                                                if ("@id" in v) {
                                                    rval = 0 === v["@id"].indexOf("_:")
                                                } else {
                                                    rval = 0 === Object.keys(v).length || !("@value" in v || "@set" in v || "@list" in v)
                                                }
                                            }
                                            return rval
                                        }

                                        function _isAbsoluteIri(v) {
                                            return _isString(v) && -1 !== v.indexOf(":")
                                        }

                                        function _clone(value) {
                                            if (value && "object" === typeof value) {
                                                var rval;
                                                if (_isArray(value)) {
                                                    rval = [];
                                                    for (var i = 0; i < value.length; ++i) {
                                                        rval[i] = _clone(value[i])
                                                    }
                                                } else if (_isObject(value)) {
                                                    rval = {};
                                                    for (var key in value) {
                                                        rval[key] = _clone(value[key])
                                                    }
                                                } else {
                                                    rval = value.toString()
                                                }
                                                return rval
                                            }
                                            return value
                                        }

                                        function _findContextUrls(input, urls, replace, base) {
                                            var count = Object.keys(urls).length;
                                            if (_isArray(input)) {
                                                for (var i = 0; i < input.length; ++i) {
                                                    _findContextUrls(input[i], urls, replace, base)
                                                }
                                                return count < Object.keys(urls).length
                                            } else if (_isObject(input)) {
                                                for (var key in input) {
                                                    if ("@context" !== key) {
                                                        _findContextUrls(input[key], urls, replace, base);
                                                        continue
                                                    }
                                                    var ctx = input[key];
                                                    if (_isArray(ctx)) {
                                                        for (var length = ctx.length, i = 0, _ctx; i < length; ++i) {
                                                            _ctx = ctx[i];
                                                            if (_isString(_ctx)) {
                                                                _ctx = jsonld.prependBase(base, _ctx);
                                                                if (replace) {
                                                                    _ctx = urls[_ctx];
                                                                    if (_isArray(_ctx)) {
                                                                        Array.prototype.splice.apply(ctx, [i, 1].concat(_ctx));
                                                                        i += _ctx.length - 1;
                                                                        length = ctx.length
                                                                    } else {
                                                                        ctx[i] = _ctx
                                                                    }
                                                                } else if (!(_ctx in urls)) {
                                                                    urls[_ctx] = !1
                                                                }
                                                            }
                                                        }
                                                    } else if (_isString(ctx)) {
                                                        ctx = jsonld.prependBase(base, ctx);
                                                        if (replace) {
                                                            input[key] = urls[ctx]
                                                        } else if (!(ctx in urls)) {
                                                            urls[ctx] = !1
                                                        }
                                                    }
                                                }
                                                return count < Object.keys(urls).length
                                            }
                                            return !1
                                        }

                                        function _retrieveContextUrls(input, options, callback) {
                                            var error = null,
                                                documentLoader = options.documentLoader,
                                                retrieve = function(input, cycles, documentLoader, base, callback) {
                                                    if (Object.keys(cycles).length > MAX_CONTEXT_URLS) {
                                                        error = new JsonLdError("Maximum number of @context URLs exceeded.", "jsonld.ContextUrlError", {
                                                            code: "loading remote context failed",
                                                            max: MAX_CONTEXT_URLS
                                                        });
                                                        return callback(error)
                                                    }
                                                    var urls = {},
                                                        finished = function() {
                                                            _findContextUrls(input, urls, !0, base);
                                                            callback(null, input)
                                                        };
                                                    if (!_findContextUrls(input, urls, !1, base)) {
                                                        return finished()
                                                    }
                                                    var queue = [];
                                                    for (var url in urls) {
                                                        if (!1 === urls[url]) {
                                                            queue.push(url)
                                                        }
                                                    }
                                                    for (var count = queue.length, i = 0; i < queue.length; ++i) {
                                                        (function(url) {
                                                            if (url in cycles) {
                                                                error = new JsonLdError("Cyclical @context URLs detected.", "jsonld.ContextUrlError", {
                                                                    code: "recursive context inclusion",
                                                                    url: url
                                                                });
                                                                return callback(error)
                                                            }
                                                            var _cycles = _clone(cycles);
                                                            _cycles[url] = !0;
                                                            var done = function(err, remoteDoc) {
                                                                    if (error) {
                                                                        return
                                                                    }
                                                                    var ctx = remoteDoc ? remoteDoc.document : null;
                                                                    if (!err && _isString(ctx)) {
                                                                        try {
                                                                            ctx = JSON.parse(ctx)
                                                                        } catch (ex) {
                                                                            err = ex
                                                                        }
                                                                    }
                                                                    if (err) {
                                                                        err = new JsonLdError("Dereferencing a URL did not result in a valid JSON-LD object. " + "Possible causes are an inaccessible URL perhaps due to " + "a same-origin policy (ensure the server uses CORS if you are " + "using client-side JavaScript), too many redirects, a " + "non-JSON response, or more than one HTTP Link Header was " + "provided for a remote context.", "jsonld.InvalidUrl", {
                                                                            code: "loading remote context failed",
                                                                            url: url,
                                                                            cause: err
                                                                        })
                                                                    } else if (!_isObject(ctx)) {
                                                                        err = new JsonLdError("Dereferencing a URL did not result in a JSON object. The " + "response was valid JSON, but it was not a JSON object.", "jsonld.InvalidUrl", {
                                                                            code: "invalid remote context",
                                                                            url: url,
                                                                            cause: err
                                                                        })
                                                                    }
                                                                    if (err) {
                                                                        error = err;
                                                                        return callback(error)
                                                                    }
                                                                    if (!("@context" in ctx)) {
                                                                        ctx = {
                                                                            "@context": {}
                                                                        }
                                                                    } else {
                                                                        ctx = {
                                                                            "@context": ctx["@context"]
                                                                        }
                                                                    }
                                                                    if (remoteDoc.contextUrl) {
                                                                        if (!_isArray(ctx["@context"])) {
                                                                            ctx["@context"] = [ctx["@context"]]
                                                                        }
                                                                        ctx["@context"].push(remoteDoc.contextUrl)
                                                                    }
                                                                    retrieve(ctx, _cycles, documentLoader, url, function(err, ctx) {
                                                                        if (err) {
                                                                            return callback(err)
                                                                        }
                                                                        urls[url] = ctx["@context"];
                                                                        count -= 1;
                                                                        if (0 === count) {
                                                                            finished()
                                                                        }
                                                                    })
                                                                },
                                                                promise = documentLoader(url, done);
                                                            if (promise && "then" in promise) {
                                                                promise.then(done.bind(null, null), done)
                                                            }
                                                        })(queue[i])
                                                    }
                                                };
                                            retrieve(input, {}, documentLoader, options.base, callback)
                                        }
                                        if (!Object.keys) {
                                            Object.keys = function(o) {
                                                if (o !== Object(o)) {
                                                    throw new TypeError("Object.keys called on non-object")
                                                }
                                                var rval = [];
                                                for (var p in o) {
                                                    if (Object.prototype.hasOwnProperty.call(o, p)) {
                                                        rval.push(p)
                                                    }
                                                }
                                                return rval
                                            }
                                        }

                                        function _parseNQuads(input) {
                                            for (var iri = "(?:<([^:]+:[^>]*)>)", bnode = "(_:(?:[A-Za-z0-9]+))", comment = "(?:#.*)?", ws = "[ \\t]+", wso = "[ \\t]*", eoln = /(?:\r\n)|(?:\n)|(?:\r)/g, empty = new RegExp("^" + wso + comment + "$"), quad = new RegExp("^" + wso + ("(?:" + iri + "|" + bnode + ")" + ws) + (iri + ws) + ("(?:" + iri + "|" + bnode + "|" + ("(?:" + "\"([^\"\\\\]*(?:\\\\.[^\"\\\\]*)*)\"" + "(?:" + ("(?:\\^\\^" + iri + ")") + "|" + "(?:@([a-z]+(?:-[a-z0-9]+)*))" + ")?)") + ")" + wso) + ("(?:\\.|(?:(?:" + iri + "|" + bnode + ")" + wso + "\\.))") + wso + comment + "$"), dataset = {}, lines = input.split(eoln), lineNumber = 0, li = 0, line; li < lines.length; ++li) {
                                                line = lines[li];
                                                lineNumber++;
                                                if (empty.test(line)) {
                                                    continue
                                                }
                                                var match = line.match(quad);
                                                if (null === match) {
                                                    throw new JsonLdError("Error while parsing N-Quads; invalid quad.", "jsonld.ParseError", {
                                                        line: lineNumber
                                                    })
                                                }
                                                var triple = {};
                                                if (!_isUndefined(match[1])) {
                                                    triple.subject = {
                                                        type: "IRI",
                                                        value: match[1]
                                                    }
                                                } else {
                                                    triple.subject = {
                                                        type: "blank node",
                                                        value: match[2]
                                                    }
                                                }
                                                triple.predicate = {
                                                    type: "IRI",
                                                    value: match[3]
                                                };
                                                if (!_isUndefined(match[4])) {
                                                    triple.object = {
                                                        type: "IRI",
                                                        value: match[4]
                                                    }
                                                } else if (!_isUndefined(match[5])) {
                                                    triple.object = {
                                                        type: "blank node",
                                                        value: match[5]
                                                    }
                                                } else {
                                                    triple.object = {
                                                        type: "literal"
                                                    };
                                                    if (!_isUndefined(match[7])) {
                                                        triple.object.datatype = match[7]
                                                    } else if (!_isUndefined(match[8])) {
                                                        triple.object.datatype = RDF_LANGSTRING;
                                                        triple.object.language = match[8]
                                                    } else {
                                                        triple.object.datatype = XSD_STRING
                                                    }
                                                    var unescaped = match[6].replace(/\\"/g, "\"").replace(/\\t/g, "\t").replace(/\\n/g, "\n").replace(/\\r/g, "\r").replace(/\\\\/g, "\\");
                                                    triple.object.value = unescaped
                                                }
                                                var name = "@default";
                                                if (!_isUndefined(match[9])) {
                                                    name = match[9]
                                                } else if (!_isUndefined(match[10])) {
                                                    name = match[10]
                                                }
                                                if (!(name in dataset)) {
                                                    dataset[name] = [triple]
                                                } else {
                                                    for (var unique = !0, triples = dataset[name], ti = 0; unique && ti < triples.length; ++ti) {
                                                        if (_compareRDFTriples(triples[ti], triple)) {
                                                            unique = !1
                                                        }
                                                    }
                                                    if (unique) {
                                                        triples.push(triple)
                                                    }
                                                }
                                            }
                                            return dataset
                                        }
                                        jsonld.registerRDFParser("application/nquads", _parseNQuads);

                                        function _toNQuads(dataset) {
                                            var quads = [];
                                            for (var graphName in dataset) {
                                                for (var triples = dataset[graphName], ti = 0, triple; ti < triples.length; ++ti) {
                                                    triple = triples[ti];
                                                    if ("@default" === graphName) {
                                                        graphName = null
                                                    }
                                                    quads.push(_toNQuad(triple, graphName))
                                                }
                                            }
                                            return quads.sort().join("")
                                        }

                                        function _toNQuad(triple, graphName) {
                                            var s = triple.subject,
                                                p = triple.predicate,
                                                o = triple.object,
                                                g = graphName || null;
                                            if ("name" in triple && triple.name) {
                                                g = triple.name.value
                                            }
                                            var quad = "";
                                            if ("IRI" === s.type) {
                                                quad += "<" + s.value + ">"
                                            } else {
                                                quad += s.value
                                            }
                                            quad += " ";
                                            if ("IRI" === p.type) {
                                                quad += "<" + p.value + ">"
                                            } else {
                                                quad += p.value
                                            }
                                            quad += " ";
                                            if ("IRI" === o.type) {
                                                quad += "<" + o.value + ">"
                                            } else if ("blank node" === o.type) {
                                                quad += o.value
                                            } else {
                                                var escaped = o.value.replace(/\\/g, "\\\\").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\"/g, "\\\"");
                                                quad += "\"" + escaped + "\"";
                                                if (o.datatype === RDF_LANGSTRING) {
                                                    if (o.language) {
                                                        quad += "@" + o.language
                                                    }
                                                } else if (o.datatype !== XSD_STRING) {
                                                    quad += "^^<" + o.datatype + ">"
                                                }
                                            }
                                            if (null !== g && g !== void 0) {
                                                if (0 !== g.indexOf("_:")) {
                                                    quad += " <" + g + ">"
                                                } else {
                                                    quad += " " + g
                                                }
                                            }
                                            quad += " .\n";
                                            return quad
                                        }

                                        function _parseRdfaApiData(data) {
                                            for (var dataset = {
                                                    "@default": []
                                                }, subjects = data.getSubjects(), si = 0, subject; si < subjects.length; ++si) {
                                                subject = subjects[si];
                                                if (null === subject) {
                                                    continue
                                                }
                                                var triples = data.getSubjectTriples(subject);
                                                if (null === triples) {
                                                    continue
                                                }
                                                var predicates = triples.predicates;
                                                for (var predicate in predicates) {
                                                    for (var objects = predicates[predicate].objects, oi = 0; oi < objects.length; ++oi) {
                                                        var object = objects[oi],
                                                            triple = {};
                                                        if (0 === subject.indexOf("_:")) {
                                                            triple.subject = {
                                                                type: "blank node",
                                                                value: subject
                                                            }
                                                        } else {
                                                            triple.subject = {
                                                                type: "IRI",
                                                                value: subject
                                                            }
                                                        }
                                                        if (0 === predicate.indexOf("_:")) {
                                                            triple.predicate = {
                                                                type: "blank node",
                                                                value: predicate
                                                            }
                                                        } else {
                                                            triple.predicate = {
                                                                type: "IRI",
                                                                value: predicate
                                                            }
                                                        }
                                                        var value = object.value;
                                                        if (object.type === RDF + "XMLLiteral") {
                                                            if (!XMLSerializer) {
                                                                _defineXMLSerializer()
                                                            }
                                                            var serializer = new XMLSerializer;
                                                            value = "";
                                                            for (var x = 0; x < object.value.length; x++) {
                                                                if (object.value[x].nodeType === Node.ELEMENT_NODE) {
                                                                    value += serializer.serializeToString(object.value[x])
                                                                } else if (object.value[x].nodeType === Node.TEXT_NODE) {
                                                                    value += object.value[x].nodeValue
                                                                }
                                                            }
                                                        }
                                                        triple.object = {};
                                                        if (object.type === RDF + "object") {
                                                            if (0 === object.value.indexOf("_:")) {
                                                                triple.object.type = "blank node"
                                                            } else {
                                                                triple.object.type = "IRI"
                                                            }
                                                        } else {
                                                            triple.object.type = "literal";
                                                            if (object.type === RDF + "PlainLiteral") {
                                                                if (object.language) {
                                                                    triple.object.datatype = RDF_LANGSTRING;
                                                                    triple.object.language = object.language
                                                                } else {
                                                                    triple.object.datatype = XSD_STRING
                                                                }
                                                            } else {
                                                                triple.object.datatype = object.type
                                                            }
                                                        }
                                                        triple.object.value = value;
                                                        dataset["@default"].push(triple)
                                                    }
                                                }
                                            }
                                            return dataset
                                        }
                                        jsonld.registerRDFParser("rdfa-api", _parseRdfaApiData);

                                        function IdentifierIssuer(prefix) {
                                            this.prefix = prefix;
                                            this.counter = 0;
                                            this.existing = {}
                                        }
                                        jsonld.IdentifierIssuer = IdentifierIssuer;
                                        jsonld.UniqueNamer = IdentifierIssuer;
                                        IdentifierIssuer.prototype.clone = function() {
                                            var copy = new IdentifierIssuer(this.prefix);
                                            copy.counter = this.counter;
                                            copy.existing = _clone(this.existing);
                                            return copy
                                        };
                                        IdentifierIssuer.prototype.getId = function(old) {
                                            if (old && old in this.existing) {
                                                return this.existing[old]
                                            }
                                            var identifier = this.prefix + this.counter;
                                            this.counter += 1;
                                            if (old) {
                                                this.existing[old] = identifier
                                            }
                                            return identifier
                                        };
                                        IdentifierIssuer.prototype.getName = IdentifierIssuer.prototype.getName;
                                        IdentifierIssuer.prototype.hasId = function(old) {
                                            return old in this.existing
                                        };
                                        IdentifierIssuer.prototype.isNamed = IdentifierIssuer.prototype.hasId;
                                        var Permutator = function(list) {
                                            this.list = list.sort();
                                            this.done = !1;
                                            this.left = {};
                                            for (var i = 0; i < list.length; ++i) {
                                                this.left[list[i]] = !0
                                            }
                                        };
                                        Permutator.prototype.hasNext = function() {
                                            return !this.done
                                        };
                                        Permutator.prototype.next = function() {
                                            for (var rval = this.list.slice(), k = null, pos = 0, length = this.list.length, i = 0; i < length; ++i) {
                                                var element = this.list[i],
                                                    left = this.left[element];
                                                if ((null === k || element > k) && (left && 0 < i && element > this.list[i - 1] || !left && i < length - 1 && element > this.list[i + 1])) {
                                                    k = element;
                                                    pos = i
                                                }
                                            }
                                            if (null === k) {
                                                this.done = !0
                                            } else {
                                                var swap = this.left[k] ? pos - 1 : pos + 1;
                                                this.list[pos] = this.list[swap];
                                                this.list[swap] = k;
                                                for (var i = 0; i < length; ++i) {
                                                    if (this.list[i] > k) {
                                                        this.left[this.list[i]] = !this.left[this.list[i]]
                                                    }
                                                }
                                            }
                                            return rval
                                        };
                                        var NormalizeHash = function(algorithm) {
                                            if (!(this instanceof NormalizeHash)) {
                                                return new NormalizeHash(algorithm)
                                            }
                                            if (-1 === ["URDNA2015", "URGNA2012"].indexOf(algorithm)) {
                                                throw new Error("Invalid RDF Dataset Normalization algorithm: " + algorithm)
                                            }
                                            NormalizeHash._init.call(this, algorithm)
                                        };
                                        NormalizeHash.hashNQuads = function(algorithm, nquads) {
                                            for (var md = new NormalizeHash(algorithm), i = 0; i < nquads.length; ++i) {
                                                md.update(nquads[i])
                                            }
                                            return md.digest()
                                        };
                                        (function(_nodejs) {
                                            if (_nodejs) {
                                                var crypto = require("crypto");
                                                NormalizeHash._init = function(algorithm) {
                                                    if ("URDNA2015" === algorithm) {
                                                        algorithm = "sha256"
                                                    } else {
                                                        algorithm = "sha1"
                                                    }
                                                    this.md = crypto.createHash(algorithm)
                                                };
                                                NormalizeHash.prototype.update = function(msg) {
                                                    return this.md.update(msg, "utf8")
                                                };
                                                NormalizeHash.prototype.digest = function() {
                                                    return this.md.digest("hex")
                                                };
                                                return
                                            }
                                            NormalizeHash._init = function(algorithm) {
                                                if ("URDNA2015" === algorithm) {
                                                    algorithm = new sha256.Algorithm
                                                } else {
                                                    algorithm = new sha1.Algorithm
                                                }
                                                this.md = new MessageDigest(algorithm)
                                            };
                                            NormalizeHash.prototype.update = function(msg) {
                                                return this.md.update(msg)
                                            };
                                            NormalizeHash.prototype.digest = function() {
                                                return this.md.digest().toHex()
                                            };
                                            var MessageDigest = function(algorithm) {
                                                if (!(this instanceof MessageDigest)) {
                                                    return new MessageDigest(algorithm)
                                                }
                                                this._algorithm = algorithm;
                                                if (!MessageDigest._padding || MessageDigest._padding.length < this._algorithm.blockSize) {
                                                    MessageDigest._padding = "\x80";
                                                    var c = "\0",
                                                        n = 64;
                                                    while (0 < n) {
                                                        if (1 & n) {
                                                            MessageDigest._padding += c
                                                        }
                                                        n >>>= 1;
                                                        if (0 < n) {
                                                            c += c
                                                        }
                                                    }
                                                }
                                                this.start()
                                            };
                                            MessageDigest.prototype.start = function() {
                                                this.messageLength = 0;
                                                this.fullMessageLength = [];
                                                for (var int32s = this._algorithm.messageLengthSize / 4, i = 0; i < int32s; ++i) {
                                                    this.fullMessageLength.push(0)
                                                }
                                                this._input = new MessageDigest.ByteBuffer;
                                                this.state = this._algorithm.start();
                                                return this
                                            };
                                            MessageDigest.prototype.update = function(msg) {
                                                msg = new MessageDigest.ByteBuffer(unescape(encodeURIComponent(msg)));
                                                this.messageLength += msg.length();
                                                var len = msg.length();
                                                len = [len / 4294967296 >>> 0, len >>> 0];
                                                for (var i = this.fullMessageLength.length - 1; 0 <= i; --i) {
                                                    this.fullMessageLength[i] += len[1];
                                                    len[1] = len[0] + (this.fullMessageLength[i] / 4294967296 >>> 0);
                                                    this.fullMessageLength[i] = this.fullMessageLength[i] >>> 0;
                                                    len[0] = len[1] / 4294967296 >>> 0
                                                }
                                                this._input.putBytes(msg.bytes());
                                                while (this._input.length() >= this._algorithm.blockSize) {
                                                    this.state = this._algorithm.digest(this.state, this._input)
                                                }
                                                if (2048 < this._input.read || 0 === this._input.length()) {
                                                    this._input.compact()
                                                }
                                                return this
                                            };
                                            MessageDigest.prototype.digest = function() {
                                                var finalBlock = new MessageDigest.ByteBuffer;
                                                finalBlock.putBytes(this._input.bytes());
                                                var remaining = this.fullMessageLength[this.fullMessageLength.length - 1] + this._algorithm.messageLengthSize,
                                                    overflow = remaining & this._algorithm.blockSize - 1;
                                                finalBlock.putBytes(MessageDigest._padding.substr(0, this._algorithm.blockSize - overflow));
                                                for (var messageLength = new MessageDigest.ByteBuffer, i = 0; i < this.fullMessageLength.length; ++i) {
                                                    messageLength.putInt32(this.fullMessageLength[i] << 3 | this.fullMessageLength[i + 1] >>> 28)
                                                }
                                                this._algorithm.writeMessageLength(finalBlock, messageLength);
                                                var state = this._algorithm.digest(this.state.copy(), finalBlock),
                                                    rval = new MessageDigest.ByteBuffer;
                                                state.write(rval);
                                                return rval
                                            };
                                            MessageDigest.ByteBuffer = function(data) {
                                                if ("string" === typeof data) {
                                                    this.data = data
                                                } else {
                                                    this.data = ""
                                                }
                                                this.read = 0
                                            };
                                            MessageDigest.ByteBuffer.prototype.putInt32 = function(i) {
                                                this.data += _StringfromCharCode(255 & i >> 24) + _StringfromCharCode(255 & i >> 16) + _StringfromCharCode(255 & i >> 8) + _StringfromCharCode(255 & i)
                                            };
                                            MessageDigest.ByteBuffer.prototype.getInt32 = function() {
                                                var rval = this.data.charCodeAt(this.read) << 24 ^ this.data.charCodeAt(this.read + 1) << 16 ^ this.data.charCodeAt(this.read + 2) << 8 ^ this.data.charCodeAt(this.read + 3);
                                                this.read += 4;
                                                return rval
                                            };
                                            MessageDigest.ByteBuffer.prototype.putBytes = function(bytes) {
                                                this.data += bytes
                                            };
                                            MessageDigest.ByteBuffer.prototype.bytes = function() {
                                                return this.data.slice(this.read)
                                            };
                                            MessageDigest.ByteBuffer.prototype.length = function() {
                                                return this.data.length - this.read
                                            };
                                            MessageDigest.ByteBuffer.prototype.compact = function() {
                                                this.data = this.data.slice(this.read);
                                                this.read = 0
                                            };
                                            MessageDigest.ByteBuffer.prototype.toHex = function() {
                                                for (var rval = "", i = this.read, b; i < this.data.length; ++i) {
                                                    b = this.data.charCodeAt(i);
                                                    if (16 > b) {
                                                        rval += "0"
                                                    }
                                                    rval += b.toString(16)
                                                }
                                                return rval
                                            };
                                            var sha1 = {
                                                _w: null,
                                                Algorithm: function() {
                                                    this.name = "sha1", this.blockSize = 64;
                                                    this.digestLength = 20;
                                                    this.messageLengthSize = 8
                                                }
                                            };
                                            sha1.Algorithm.prototype.start = function() {
                                                if (!sha1._w) {
                                                    sha1._w = Array(80)
                                                }
                                                return sha1._createState()
                                            };
                                            sha1.Algorithm.prototype.writeMessageLength = function(finalBlock, messageLength) {
                                                finalBlock.putBytes(messageLength.bytes())
                                            };
                                            sha1.Algorithm.prototype.digest = function(s, input) {
                                                var t, a, b, c, d, e, f, i, len = input.length(),
                                                    _w = sha1._w;
                                                while (64 <= len) {
                                                    a = s.h0;
                                                    b = s.h1;
                                                    c = s.h2;
                                                    d = s.h3;
                                                    e = s.h4;
                                                    for (i = 0; 16 > i; ++i) {
                                                        t = input.getInt32();
                                                        _w[i] = t;
                                                        f = d ^ b & (c ^ d);
                                                        t = (a << 5 | a >>> 27) + f + e + 1518500249 + t;
                                                        e = d;
                                                        d = c;
                                                        c = b << 30 | b >>> 2;
                                                        b = a;
                                                        a = t
                                                    }
                                                    for (; 20 > i; ++i) {
                                                        t = _w[i - 3] ^ _w[i - 8] ^ _w[i - 14] ^ _w[i - 16];
                                                        t = t << 1 | t >>> 31;
                                                        _w[i] = t;
                                                        f = d ^ b & (c ^ d);
                                                        t = (a << 5 | a >>> 27) + f + e + 1518500249 + t;
                                                        e = d;
                                                        d = c;
                                                        c = b << 30 | b >>> 2;
                                                        b = a;
                                                        a = t
                                                    }
                                                    for (; 32 > i; ++i) {
                                                        t = _w[i - 3] ^ _w[i - 8] ^ _w[i - 14] ^ _w[i - 16];
                                                        t = t << 1 | t >>> 31;
                                                        _w[i] = t;
                                                        f = b ^ c ^ d;
                                                        t = (a << 5 | a >>> 27) + f + e + 1859775393 + t;
                                                        e = d;
                                                        d = c;
                                                        c = b << 30 | b >>> 2;
                                                        b = a;
                                                        a = t
                                                    }
                                                    for (; 40 > i; ++i) {
                                                        t = _w[i - 6] ^ _w[i - 16] ^ _w[i - 28] ^ _w[i - 32];
                                                        t = t << 2 | t >>> 30;
                                                        _w[i] = t;
                                                        f = b ^ c ^ d;
                                                        t = (a << 5 | a >>> 27) + f + e + 1859775393 + t;
                                                        e = d;
                                                        d = c;
                                                        c = b << 30 | b >>> 2;
                                                        b = a;
                                                        a = t
                                                    }
                                                    for (; 60 > i; ++i) {
                                                        t = _w[i - 6] ^ _w[i - 16] ^ _w[i - 28] ^ _w[i - 32];
                                                        t = t << 2 | t >>> 30;
                                                        _w[i] = t;
                                                        f = b & c | d & (b ^ c);
                                                        t = (a << 5 | a >>> 27) + f + e + 2400959708 + t;
                                                        e = d;
                                                        d = c;
                                                        c = b << 30 | b >>> 2;
                                                        b = a;
                                                        a = t
                                                    }
                                                    for (; 80 > i; ++i) {
                                                        t = _w[i - 6] ^ _w[i - 16] ^ _w[i - 28] ^ _w[i - 32];
                                                        t = t << 2 | t >>> 30;
                                                        _w[i] = t;
                                                        f = b ^ c ^ d;
                                                        t = (a << 5 | a >>> 27) + f + e + 3395469782 + t;
                                                        e = d;
                                                        d = c;
                                                        c = b << 30 | b >>> 2;
                                                        b = a;
                                                        a = t
                                                    }
                                                    s.h0 = 0 | s.h0 + a;
                                                    s.h1 = 0 | s.h1 + b;
                                                    s.h2 = 0 | s.h2 + c;
                                                    s.h3 = 0 | s.h3 + d;
                                                    s.h4 = 0 | s.h4 + e;
                                                    len -= 64
                                                }
                                                return s
                                            };
                                            sha1._createState = function() {
                                                var state = {
                                                    h0: 1732584193,
                                                    h1: 4023233417,
                                                    h2: 2562383102,
                                                    h3: 271733878,
                                                    h4: 3285377520
                                                };
                                                state.copy = function() {
                                                    var rval = sha1._createState();
                                                    rval.h0 = state.h0;
                                                    rval.h1 = state.h1;
                                                    rval.h2 = state.h2;
                                                    rval.h3 = state.h3;
                                                    rval.h4 = state.h4;
                                                    return rval
                                                };
                                                state.write = function(buffer) {
                                                    buffer.putInt32(state.h0);
                                                    buffer.putInt32(state.h1);
                                                    buffer.putInt32(state.h2);
                                                    buffer.putInt32(state.h3);
                                                    buffer.putInt32(state.h4)
                                                };
                                                return state
                                            };
                                            var sha256 = {
                                                _k: null,
                                                _w: null,
                                                Algorithm: function() {
                                                    this.name = "sha256", this.blockSize = 64;
                                                    this.digestLength = 32;
                                                    this.messageLengthSize = 8
                                                }
                                            };
                                            sha256.Algorithm.prototype.start = function() {
                                                if (!sha256._k) {
                                                    sha256._init()
                                                }
                                                return sha256._createState()
                                            };
                                            sha256.Algorithm.prototype.writeMessageLength = function(finalBlock, messageLength) {
                                                finalBlock.putBytes(messageLength.bytes())
                                            };
                                            sha256.Algorithm.prototype.digest = function(s, input) {
                                                var t1, t2, s0, s1, ch, maj, i, a, b, c, d, e, f, g, h, len = input.length(),
                                                    _k = sha256._k,
                                                    _w = sha256._w;
                                                while (64 <= len) {
                                                    for (i = 0; 16 > i; ++i) {
                                                        _w[i] = input.getInt32()
                                                    }
                                                    for (; 64 > i; ++i) {
                                                        t1 = _w[i - 2];
                                                        t1 = (t1 >>> 17 | t1 << 15) ^ (t1 >>> 19 | t1 << 13) ^ t1 >>> 10;
                                                        t2 = _w[i - 15];
                                                        t2 = (t2 >>> 7 | t2 << 25) ^ (t2 >>> 18 | t2 << 14) ^ t2 >>> 3;
                                                        _w[i] = 0 | t1 + _w[i - 7] + t2 + _w[i - 16]
                                                    }
                                                    a = s.h0;
                                                    b = s.h1;
                                                    c = s.h2;
                                                    d = s.h3;
                                                    e = s.h4;
                                                    f = s.h5;
                                                    g = s.h6;
                                                    h = s.h7;
                                                    for (i = 0; 64 > i; ++i) {
                                                        s1 = (e >>> 6 | e << 26) ^ (e >>> 11 | e << 21) ^ (e >>> 25 | e << 7);
                                                        ch = g ^ e & (f ^ g);
                                                        s0 = (a >>> 2 | a << 30) ^ (a >>> 13 | a << 19) ^ (a >>> 22 | a << 10);
                                                        maj = a & b | c & (a ^ b);
                                                        t1 = h + s1 + ch + _k[i] + _w[i];
                                                        t2 = s0 + maj;
                                                        h = g;
                                                        g = f;
                                                        f = e;
                                                        e = 0 | d + t1;
                                                        d = c;
                                                        c = b;
                                                        b = a;
                                                        a = 0 | t1 + t2
                                                    }
                                                    s.h0 = 0 | s.h0 + a;
                                                    s.h1 = 0 | s.h1 + b;
                                                    s.h2 = 0 | s.h2 + c;
                                                    s.h3 = 0 | s.h3 + d;
                                                    s.h4 = 0 | s.h4 + e;
                                                    s.h5 = 0 | s.h5 + f;
                                                    s.h6 = 0 | s.h6 + g;
                                                    s.h7 = 0 | s.h7 + h;
                                                    len -= 64
                                                }
                                                return s
                                            };
                                            sha256._createState = function() {
                                                var state = {
                                                    h0: 1779033703,
                                                    h1: 3144134277,
                                                    h2: 1013904242,
                                                    h3: 2773480762,
                                                    h4: 1359893119,
                                                    h5: 2600822924,
                                                    h6: 528734635,
                                                    h7: 1541459225
                                                };
                                                state.copy = function() {
                                                    var rval = sha256._createState();
                                                    rval.h0 = state.h0;
                                                    rval.h1 = state.h1;
                                                    rval.h2 = state.h2;
                                                    rval.h3 = state.h3;
                                                    rval.h4 = state.h4;
                                                    rval.h5 = state.h5;
                                                    rval.h6 = state.h6;
                                                    rval.h7 = state.h7;
                                                    return rval
                                                };
                                                state.write = function(buffer) {
                                                    buffer.putInt32(state.h0);
                                                    buffer.putInt32(state.h1);
                                                    buffer.putInt32(state.h2);
                                                    buffer.putInt32(state.h3);
                                                    buffer.putInt32(state.h4);
                                                    buffer.putInt32(state.h5);
                                                    buffer.putInt32(state.h6);
                                                    buffer.putInt32(state.h7)
                                                };
                                                return state
                                            };
                                            sha256._init = function() {
                                                sha256._k = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];
                                                sha256._w = Array(64)
                                            }
                                        })(_nodejs);
                                        if (!XMLSerializer) {
                                            var _defineXMLSerializer = function() {
                                                XMLSerializer = require("xmldom").XMLSerializer
                                            }
                                        }
                                        jsonld.url = {};
                                        jsonld.url.parsers = {
                                            simple: {
                                                keys: ["href", "scheme", "authority", "path", "query", "fragment"],
                                                regex: /^(?:([^:\/?#]+):)?(?:\/\/([^\/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?/
                                            },
                                            full: {
                                                keys: ["href", "protocol", "scheme", "authority", "auth", "user", "password", "hostname", "port", "path", "directory", "file", "query", "fragment"],
                                                regex: /^(([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?(?:(((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/
                                            }
                                        };
                                        jsonld.url.parse = function(str, parser) {
                                            var parsed = {},
                                                o = jsonld.url.parsers[parser || "full"],
                                                m = o.regex.exec(str),
                                                i = o.keys.length;
                                            while (i--) {
                                                parsed[o.keys[i]] = m[i] === void 0 ? null : m[i]
                                            }
                                            parsed.normalizedPath = _removeDotSegments(parsed.path, !!parsed.authority);
                                            return parsed
                                        };

                                        function _removeDotSegments(path, hasAuthority) {
                                            var rval = "";
                                            if (0 === path.indexOf("/")) {
                                                rval = "/"
                                            }
                                            var input = path.split("/"),
                                                output = [];
                                            while (0 < input.length) {
                                                if ("." === input[0] || "" === input[0] && 1 < input.length) {
                                                    input.shift();
                                                    continue
                                                }
                                                if (".." === input[0]) {
                                                    input.shift();
                                                    if (hasAuthority || 0 < output.length && ".." !== output[output.length - 1]) {
                                                        output.pop()
                                                    } else {
                                                        output.push("..")
                                                    }
                                                    continue
                                                }
                                                output.push(input.shift())
                                            }
                                            return rval + output.join("/")
                                        }
                                        if (_nodejs) {
                                            jsonld.useDocumentLoader("node")
                                        } else if ("undefined" !== typeof XMLHttpRequest) {
                                            jsonld.useDocumentLoader("xhr")
                                        }
                                        if (_nodejs) {
                                            jsonld.use = function(extension) {
                                                switch (extension) {
                                                    case "request":
                                                        jsonld.request = require("jsonld-request");
                                                        break;
                                                    default:
                                                        throw new JsonLdError("Unknown extension.", "jsonld.UnknownExtension", {
                                                            extension: extension
                                                        });
                                                }
                                            };
                                            var _module = {
                                                exports: {},
                                                filename: __dirname
                                            };
                                            require("pkginfo")(_module, "version");
                                            jsonld.version = _module.exports.version
                                        }
                                        return jsonld
                                    },
                                    factory = function() {
                                        return wrapper(function() {
                                            return factory()
                                        })
                                    };
                                if (!_nodejs && "function" === typeof define && define.amd) {
                                    define([], function() {
                                        wrapper(factory);
                                        return factory
                                    })
                                } else {
                                    wrapper(factory);
                                    if ("function" === typeof require && "undefined" !== typeof module && module.exports) {
                                        module.exports = factory
                                    }
                                    if (_browser) {
                                        if ("undefined" === typeof jsonld) {
                                            jsonld = jsonldjs = factory
                                        } else {
                                            jsonldjs = factory
                                        }
                                    }
                                }
                                return factory
                            })()
                        }).call(this, require("_process"), "undefined" !== typeof global ? global : "undefined" !== typeof self ? self : "undefined" !== typeof window ? window : {}, "/node_modules/jsonld/js")
                    }, {
                        _process: 399,
                        crypto: 395,
                        "es6-promise": 387,
                        http: 395,
                        "jsonld-request": 395,
                        pkginfo: 395,
                        request: 395,
                        util: 395,
                        xmldom: 395
                    }],
                    397: [function(require, module) {
                        var s = 1e3,
                            m = 60 * s,
                            h = 60 * m,
                            d = 24 * h;
                        module.exports = function(val, options) {
                            options = options || {};
                            var type = typeof val;
                            if ("string" === type && 0 < val.length) {
                                return parse(val)
                            } else if ("number" === type && !1 === isNaN(val)) {
                                return options.long ? fmtLong(val) : fmtShort(val)
                            }
                            throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val))
                        };

                        function parse(str) {
                            str = str + "";
                            if (100 < str.length) {
                                return
                            }
                            var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
                            if (!match) {
                                return
                            }
                            var n = parseFloat(match[1]),
                                type = (match[2] || "ms").toLowerCase();
                            switch (type) {
                                case "years":
                                case "year":
                                case "yrs":
                                case "yr":
                                case "y":
                                    return n * (365.25 * d);
                                case "days":
                                case "day":
                                case "d":
                                    return n * d;
                                case "hours":
                                case "hour":
                                case "hrs":
                                case "hr":
                                case "h":
                                    return n * h;
                                case "minutes":
                                case "minute":
                                case "mins":
                                case "min":
                                case "m":
                                    return n * m;
                                case "seconds":
                                case "second":
                                case "secs":
                                case "sec":
                                case "s":
                                    return n * s;
                                case "milliseconds":
                                case "millisecond":
                                case "msecs":
                                case "msec":
                                case "ms":
                                    return n;
                                default:
                            }
                        }

                        function fmtShort(ms) {
                            if (ms >= d) {
                                return _Mathround(ms / d) + "d"
                            }
                            if (ms >= h) {
                                return _Mathround(ms / h) + "h"
                            }
                            if (ms >= m) {
                                return _Mathround(ms / m) + "m"
                            }
                            if (ms >= s) {
                                return _Mathround(ms / s) + "s"
                            }
                            return ms + "ms"
                        }

                        function fmtLong(ms) {
                            return plural(ms, d, "day") || plural(ms, h, "hour") || plural(ms, m, "minute") || plural(ms, s, "second") || ms + " ms"
                        }

                        function plural(ms, n, name) {
                            if (ms < n) {
                                return
                            }
                            if (ms < 1.5 * n) {
                                return _Mathfloor(ms / n) + " " + name
                            }
                            return _Mathceil(ms / n) + " " + name + "s"
                        }
                    }, {}],
                    398: [function(require, module) {
                        (function(process) {
                            "use strict";
                            if (!process.version || 0 === process.version.indexOf("v0.") || 0 === process.version.indexOf("v1.") && 0 !== process.version.indexOf("v1.8.")) {
                                module.exports = {
                                    nextTick: nextTick
                                }
                            } else {
                                module.exports = process
                            }

                            function nextTick(fn, arg1, arg2, arg3) {
                                if ("function" !== typeof fn) {
                                    throw new TypeError("\"callback\" argument must be a function")
                                }
                                var len = arguments.length,
                                    args, i;
                                switch (len) {
                                    case 0:
                                    case 1:
                                        return process.nextTick(fn);
                                    case 2:
                                        return process.nextTick(function() {
                                            fn.call(null, arg1)
                                        });
                                    case 3:
                                        return process.nextTick(function() {
                                            fn.call(null, arg1, arg2)
                                        });
                                    case 4:
                                        return process.nextTick(function() {
                                            fn.call(null, arg1, arg2, arg3)
                                        });
                                    default:
                                        args = Array(len - 1);
                                        i = 0;
                                        while (i < args.length) {
                                            args[i++] = arguments[i]
                                        }
                                        return process.nextTick(function() {
                                            fn.apply(null, args)
                                        });
                                }
                            }
                        }).call(this, require("_process"))
                    }, {
                        _process: 399
                    }],
                    399: [function(require, module) {
                        var process = module.exports = {},
                            cachedSetTimeout, cachedClearTimeout;

                        function defaultSetTimout() {
                            throw new Error("setTimeout has not been defined")
                        }

                        function defaultClearTimeout() {
                            throw new Error("clearTimeout has not been defined")
                        }(function() {
                            try {
                                if ("function" === typeof setTimeout) {
                                    cachedSetTimeout = setTimeout
                                } else {
                                    cachedSetTimeout = defaultSetTimout
                                }
                            } catch (e) {
                                cachedSetTimeout = defaultSetTimout
                            }
                            try {
                                if ("function" === typeof clearTimeout) {
                                    cachedClearTimeout = clearTimeout
                                } else {
                                    cachedClearTimeout = defaultClearTimeout
                                }
                            } catch (e) {
                                cachedClearTimeout = defaultClearTimeout
                            }
                        })();

                        function runTimeout(fun) {
                            if (cachedSetTimeout === setTimeout) {
                                return setTimeout(fun, 0)
                            }
                            if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
                                cachedSetTimeout = setTimeout;
                                return setTimeout(fun, 0)
                            }
                            try {
                                return cachedSetTimeout(fun, 0)
                            } catch (e) {
                                try {
                                    return cachedSetTimeout.call(null, fun, 0)
                                } catch (e) {
                                    return cachedSetTimeout.call(this, fun, 0)
                                }
                            }
                        }

                        function runClearTimeout(marker) {
                            if (cachedClearTimeout === clearTimeout) {
                                return clearTimeout(marker)
                            }
                            if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
                                cachedClearTimeout = clearTimeout;
                                return clearTimeout(marker)
                            }
                            try {
                                return cachedClearTimeout(marker)
                            } catch (e) {
                                try {
                                    return cachedClearTimeout.call(null, marker)
                                } catch (e) {
                                    return cachedClearTimeout.call(this, marker)
                                }
                            }
                        }
                        var queue = [],
                            draining = !1,
                            currentQueue, queueIndex = -1;

                        function cleanUpNextTick() {
                            if (!draining || !currentQueue) {
                                return
                            }
                            draining = !1;
                            if (currentQueue.length) {
                                queue = currentQueue.concat(queue)
                            } else {
                                queueIndex = -1
                            }
                            if (queue.length) {
                                drainQueue()
                            }
                        }

                        function drainQueue() {
                            if (draining) {
                                return
                            }
                            var timeout = runTimeout(cleanUpNextTick);
                            draining = !0;
                            var len = queue.length;
                            while (len) {
                                currentQueue = queue;
                                queue = [];
                                while (++queueIndex < len) {
                                    if (currentQueue) {
                                        currentQueue[queueIndex].run()
                                    }
                                }
                                queueIndex = -1;
                                len = queue.length
                            }
                            currentQueue = null;
                            draining = !1;
                            runClearTimeout(timeout)
                        }
                        process.nextTick = function(fun) {
                            var args = Array(arguments.length - 1);
                            if (1 < arguments.length) {
                                for (var i = 1; i < arguments.length; i++) {
                                    args[i - 1] = arguments[i]
                                }
                            }
                            queue.push(new Item(fun, args));
                            if (1 === queue.length && !draining) {
                                runTimeout(drainQueue)
                            }
                        };

                        function Item(fun, array) {
                            this.fun = fun;
                            this.array = array
                        }
                        Item.prototype.run = function() {
                            this.fun.apply(null, this.array)
                        };
                        process.title = "browser";
                        process.browser = !0;
                        process.env = {};
                        process.argv = [];
                        process.version = "";
                        process.versions = {};

                        function noop() {}
                        process.on = noop;
                        process.addListener = noop;
                        process.once = noop;
                        process.off = noop;
                        process.removeListener = noop;
                        process.removeAllListeners = noop;
                        process.emit = noop;
                        process.prependListener = noop;
                        process.prependOnceListener = noop;
                        process.listeners = function() {
                            return []
                        };
                        process.binding = function() {
                            throw new Error("process.binding is not supported")
                        };
                        process.cwd = function() {
                            return "/"
                        };
                        process.chdir = function() {
                            throw new Error("process.chdir is not supported")
                        };
                        process.umask = function() {
                            return 0
                        }
                    }, {}],
                    400: [function(require, module, exports) {
                        (function(global) {
                            (function(root) {
                                var freeExports = "object" == typeof exports && exports && !exports.nodeType && exports,
                                    freeModule = "object" == typeof module && module && !module.nodeType && module,
                                    freeGlobal = "object" == typeof global && global;
                                if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
                                    root = freeGlobal
                                }
                                var punycode, maxInt = 2147483647,
                                    base = 36,
                                    tMin = 1,
                                    tMax = 26,
                                    initialBias = 72,
                                    initialN = 128,
                                    delimiter = "-",
                                    regexPunycode = /^xn--/,
                                    regexNonASCII = /[^\x20-\x7E]/,
                                    regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g,
                                    errors = {
                                        overflow: "Overflow: input needs wider integers to process",
                                        "not-basic": "Illegal input >= 0x80 (not a basic code point)",
                                        "invalid-input": "Invalid input"
                                    },
                                    baseMinusTMin = base - tMin,
                                    floor = _Mathfloor,
                                    stringFromCharCode = _StringfromCharCode,
                                    key;

                                function error(type) {
                                    throw new RangeError(errors[type])
                                }

                                function map(array, fn) {
                                    var length = array.length,
                                        result = [];
                                    while (length--) {
                                        result[length] = fn(array[length])
                                    }
                                    return result
                                }

                                function mapDomain(string, fn) {
                                    var parts = string.split("@"),
                                        result = "";
                                    if (1 < parts.length) {
                                        result = parts[0] + "@";
                                        string = parts[1]
                                    }
                                    string = string.replace(regexSeparators, ".");
                                    var labels = string.split("."),
                                        encoded = map(labels, fn).join(".");
                                    return result + encoded
                                }

                                function ucs2decode(string) {
                                    var output = [],
                                        counter = 0,
                                        length = string.length,
                                        value, extra;
                                    while (counter < length) {
                                        value = string.charCodeAt(counter++);
                                        if (55296 <= value && 56319 >= value && counter < length) {
                                            extra = string.charCodeAt(counter++);
                                            if (56320 == (64512 & extra)) {
                                                output.push(((1023 & value) << 10) + (1023 & extra) + 65536)
                                            } else {
                                                output.push(value);
                                                counter--
                                            }
                                        } else {
                                            output.push(value)
                                        }
                                    }
                                    return output
                                }

                                function ucs2encode(array) {
                                    return map(array, function(value) {
                                        var output = "";
                                        if (65535 < value) {
                                            value -= 65536;
                                            output += stringFromCharCode(55296 | 1023 & value >>> 10);
                                            value = 56320 | 1023 & value
                                        }
                                        output += stringFromCharCode(value);
                                        return output
                                    }).join("")
                                }

                                function basicToDigit(codePoint) {
                                    if (10 > codePoint - 48) {
                                        return codePoint - 22
                                    }
                                    if (26 > codePoint - 65) {
                                        return codePoint - 65
                                    }
                                    if (26 > codePoint - 97) {
                                        return codePoint - 97
                                    }
                                    return base
                                }

                                function digitToBasic(digit, flag) {
                                    return digit + 22 + 75 * (26 > digit) - ((0 != flag) << 5)
                                }

                                function adapt(delta, numPoints, firstTime) {
                                    var k = 0;
                                    delta = firstTime ? floor(delta / 700) : delta >> 1;
                                    delta += floor(delta / numPoints);
                                    for (; delta > baseMinusTMin * tMax >> 1; k += base) {
                                        delta = floor(delta / baseMinusTMin)
                                    }
                                    return floor(k + (baseMinusTMin + 1) * delta / (delta + 38))
                                }

                                function decode(input) {
                                    var output = [],
                                        inputLength = input.length,
                                        out, i = 0,
                                        n = initialN,
                                        bias = initialBias,
                                        basic, j, index, oldi, w, k, digit, t, baseMinusT;
                                    basic = input.lastIndexOf(delimiter);
                                    if (0 > basic) {
                                        basic = 0
                                    }
                                    for (j = 0; j < basic; ++j) {
                                        if (128 <= input.charCodeAt(j)) {
                                            error("not-basic")
                                        }
                                        output.push(input.charCodeAt(j))
                                    }
                                    for (index = 0 < basic ? basic + 1 : 0; index < inputLength;) {
                                        for (oldi = i, w = 1, k = base;; k += base) {
                                            if (index >= inputLength) {
                                                error("invalid-input")
                                            }
                                            digit = basicToDigit(input.charCodeAt(index++));
                                            if (digit >= base || digit > floor((maxInt - i) / w)) {
                                                error("overflow")
                                            }
                                            i += digit * w;
                                            t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                                            if (digit < t) {
                                                break
                                            }
                                            baseMinusT = base - t;
                                            if (w > floor(maxInt / baseMinusT)) {
                                                error("overflow")
                                            }
                                            w *= baseMinusT
                                        }
                                        out = output.length + 1;
                                        bias = adapt(i - oldi, out, 0 == oldi);
                                        if (floor(i / out) > maxInt - n) {
                                            error("overflow")
                                        }
                                        n += floor(i / out);
                                        i %= out;
                                        output.splice(i++, 0, n)
                                    }
                                    return ucs2encode(output)
                                }

                                function encode(input) {
                                    var n, delta, handledCPCount, basicLength, bias, j, m, q, k, t, currentValue, output = [],
                                        inputLength, handledCPCountPlusOne, baseMinusT, qMinusT;
                                    input = ucs2decode(input);
                                    inputLength = input.length;
                                    n = initialN;
                                    delta = 0;
                                    bias = initialBias;
                                    for (j = 0; j < inputLength; ++j) {
                                        currentValue = input[j];
                                        if (128 > currentValue) {
                                            output.push(stringFromCharCode(currentValue))
                                        }
                                    }
                                    handledCPCount = basicLength = output.length;
                                    if (basicLength) {
                                        output.push(delimiter)
                                    }
                                    while (handledCPCount < inputLength) {
                                        for (m = maxInt, j = 0; j < inputLength; ++j) {
                                            currentValue = input[j];
                                            if (currentValue >= n && currentValue < m) {
                                                m = currentValue
                                            }
                                        }
                                        handledCPCountPlusOne = handledCPCount + 1;
                                        if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
                                            error("overflow")
                                        }
                                        delta += (m - n) * handledCPCountPlusOne;
                                        n = m;
                                        for (j = 0; j < inputLength; ++j) {
                                            currentValue = input[j];
                                            if (currentValue < n && ++delta > maxInt) {
                                                error("overflow")
                                            }
                                            if (currentValue == n) {
                                                for (q = delta, k = base;; k += base) {
                                                    t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                                                    if (q < t) {
                                                        break
                                                    }
                                                    qMinusT = q - t;
                                                    baseMinusT = base - t;
                                                    output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
                                                    q = floor(qMinusT / baseMinusT)
                                                }
                                                output.push(stringFromCharCode(digitToBasic(q, 0)));
                                                bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                                                delta = 0;
                                                ++handledCPCount
                                            }
                                        }++delta;
                                        ++n
                                    }
                                    return output.join("")
                                }
                                punycode = {
                                    version: "1.4.1",
                                    ucs2: {
                                        decode: ucs2decode,
                                        encode: ucs2encode
                                    },
                                    decode: decode,
                                    encode: encode,
                                    toASCII: function(input) {
                                        return mapDomain(input, function(string) {
                                            return regexNonASCII.test(string) ? "xn--" + encode(string) : string
                                        })
                                    },
                                    toUnicode: function(input) {
                                        return mapDomain(input, function(string) {
                                            return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string
                                        })
                                    }
                                };
                                if ("function" == typeof define && "object" == typeof define.amd && define.amd) {
                                    define("punycode", function() {
                                        return punycode
                                    })
                                } else if (freeExports && freeModule) {
                                    if (module.exports == freeExports) {
                                        freeModule.exports = punycode
                                    } else {
                                        for (key in punycode) {
                                            punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key])
                                        }
                                    }
                                } else {
                                    root.punycode = punycode
                                }
                            })(this)
                        }).call(this, "undefined" !== typeof global ? global : "undefined" !== typeof self ? self : "undefined" !== typeof window ? window : {})
                    }, {}],
                    401: [function(require, module) {
                        "use strict";

                        function hasOwnProperty(obj, prop) {
                            return Object.prototype.hasOwnProperty.call(obj, prop)
                        }
                        module.exports = function(qs, sep, eq, options) {
                            sep = sep || "&";
                            eq = eq || "=";
                            var obj = {};
                            if ("string" !== typeof qs || 0 === qs.length) {
                                return obj
                            }
                            var regexp = /\+/g;
                            qs = qs.split(sep);
                            var maxKeys = 1e3;
                            if (options && "number" === typeof options.maxKeys) {
                                maxKeys = options.maxKeys
                            }
                            var len = qs.length;
                            if (0 < maxKeys && len > maxKeys) {
                                len = maxKeys
                            }
                            for (var i = 0; i < len; ++i) {
                                var x = qs[i].replace(regexp, "%20"),
                                    idx = x.indexOf(eq),
                                    kstr, vstr, k, v;
                                if (0 <= idx) {
                                    kstr = x.substr(0, idx);
                                    vstr = x.substr(idx + 1)
                                } else {
                                    kstr = x;
                                    vstr = ""
                                }
                                k = decodeURIComponent(kstr);
                                v = decodeURIComponent(vstr);
                                if (!hasOwnProperty(obj, k)) {
                                    obj[k] = v
                                } else if (isArray(obj[k])) {
                                    obj[k].push(v)
                                } else {
                                    obj[k] = [obj[k], v]
                                }
                            }
                            return obj
                        };
                        var isArray = Array.isArray || function(xs) {
                            return "[object Array]" === Object.prototype.toString.call(xs)
                        }
                    }, {}],
                    402: [function(require, module) {
                        "use strict";
                        var stringifyPrimitive = function(v) {
                            switch (typeof v) {
                                case "string":
                                    return v;
                                case "boolean":
                                    return v ? "true" : "false";
                                case "number":
                                    return isFinite(v) ? v : "";
                                default:
                                    return "";
                            }
                        };
                        module.exports = function(obj, sep, eq, name) {
                            sep = sep || "&";
                            eq = eq || "=";
                            if (null === obj) {
                                obj = void 0
                            }
                            if ("object" === typeof obj) {
                                return map(objectKeys(obj), function(k) {
                                    var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
                                    if (isArray(obj[k])) {
                                        return map(obj[k], function(v) {
                                            return ks + encodeURIComponent(stringifyPrimitive(v))
                                        }).join(sep)
                                    } else {
                                        return ks + encodeURIComponent(stringifyPrimitive(obj[k]))
                                    }
                                }).join(sep)
                            }
                            if (!name) return "";
                            return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj))
                        };
                        var isArray = Array.isArray || function(xs) {
                            return "[object Array]" === Object.prototype.toString.call(xs)
                        };

                        function map(xs, f) {
                            if (xs.map) return xs.map(f);
                            for (var res = [], i = 0; i < xs.length; i++) {
                                res.push(f(xs[i], i))
                            }
                            return res
                        }
                        var objectKeys = Object.keys || function(obj) {
                            var res = [];
                            for (var key in obj) {
                                if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key)
                            }
                            return res
                        }
                    }, {}],
                    403: [function(require, module, exports) {
                        "use strict";
                        exports.decode = exports.parse = require("./decode");
                        exports.encode = exports.stringify = require("./encode")
                    }, {
                        "./decode": 401,
                        "./encode": 402
                    }],
                    404: [function(require, module) {
                        (function(process, global) {
                            "use strict";

                            function oldBrowser() {
                                throw new Error("Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11")
                            }
                            var Buffer = require("safe-buffer").Buffer,
                                crypto = global.crypto || global.msCrypto;
                            if (crypto && crypto.getRandomValues) {
                                module.exports = randomBytes
                            } else {
                                module.exports = oldBrowser
                            }

                            function randomBytes(size, cb) {
                                if (65536 < size) throw new Error("requested too many random bytes");
                                var rawBytes = new global.Uint8Array(size);
                                if (0 < size) {
                                    crypto.getRandomValues(rawBytes)
                                }
                                var bytes = Buffer.from(rawBytes.buffer);
                                if ("function" === typeof cb) {
                                    return process.nextTick(function() {
                                        cb(null, bytes)
                                    })
                                }
                                return bytes
                            }
                        }).call(this, require("_process"), "undefined" !== typeof global ? global : "undefined" !== typeof self ? self : "undefined" !== typeof window ? window : {})
                    }, {
                        _process: 399,
                        "safe-buffer": 420
                    }],
                    405: [function(require, module) {
                        module.exports = require("./lib/_stream_duplex.js")
                    }, {
                        "./lib/_stream_duplex.js": 406
                    }],
                    406: [function(require, module) {
                        "use strict";
                        var pna = require("process-nextick-args"),
                            objectKeys = Object.keys || function(obj) {
                                var keys = [];
                                for (var key in obj) {
                                    keys.push(key)
                                }
                                return keys
                            };
                        module.exports = Duplex;
                        var util = require("core-util-is");
                        util.inherits = require("inherits");
                        var Readable = require("./_stream_readable"),
                            Writable = require("./_stream_writable");
                        util.inherits(Duplex, Readable);
                        for (var keys = objectKeys(Writable.prototype), v = 0, method; v < keys.length; v++) {
                            method = keys[v];
                            if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method]
                        }

                        function Duplex(options) {
                            if (!(this instanceof Duplex)) return new Duplex(options);
                            Readable.call(this, options);
                            Writable.call(this, options);
                            if (options && !1 === options.readable) this.readable = !1;
                            if (options && !1 === options.writable) this.writable = !1;
                            this.allowHalfOpen = !0;
                            if (options && !1 === options.allowHalfOpen) this.allowHalfOpen = !1;
                            this.once("end", onend)
                        }

                        function onend() {
                            if (this.allowHalfOpen || this._writableState.ended) return;
                            pna.nextTick(onEndNT, this)
                        }

                        function onEndNT(self) {
                            self.end()
                        }
                        Object.defineProperty(Duplex.prototype, "destroyed", {
                            get: function() {
                                if (this._readableState === void 0 || this._writableState === void 0) {
                                    return !1
                                }
                                return this._readableState.destroyed && this._writableState.destroyed
                            },
                            set: function(value) {
                                if (this._readableState === void 0 || this._writableState === void 0) {
                                    return
                                }
                                this._readableState.destroyed = value;
                                this._writableState.destroyed = value
                            }
                        });
                        Duplex.prototype._destroy = function(err, cb) {
                            this.push(null);
                            this.end();
                            pna.nextTick(cb, err)
                        }
                    }, {
                        "./_stream_readable": 408,
                        "./_stream_writable": 410,
                        "core-util-is": 374,
                        inherits: 392,
                        "process-nextick-args": 398
                    }],
                    407: [function(require, module) {
                        "use strict";
                        module.exports = PassThrough;
                        var Transform = require("./_stream_transform"),
                            util = require("core-util-is");
                        util.inherits = require("inherits");
                        util.inherits(PassThrough, Transform);

                        function PassThrough(options) {
                            if (!(this instanceof PassThrough)) return new PassThrough(options);
                            Transform.call(this, options)
                        }
                        PassThrough.prototype._transform = function(chunk, encoding, cb) {
                            cb(null, chunk)
                        }
                    }, {
                        "./_stream_transform": 409,
                        "core-util-is": 374,
                        inherits: 392
                    }],
                    408: [function(require, module) {
                        (function(process, global) {
                            "use strict";
                            var pna = require("process-nextick-args");
                            module.exports = Readable;
                            var isArray = require("isarray"),
                                Duplex;
                            Readable.ReadableState = ReadableState;
                            var EE = require("events").EventEmitter,
                                EElistenerCount = function(emitter, type) {
                                    return emitter.listeners(type).length
                                },
                                Stream = require("./internal/streams/stream"),
                                Buffer = require("safe-buffer").Buffer,
                                OurUint8Array = global.Uint8Array || function() {};

                            function _uint8ArrayToBuffer(chunk) {
                                return Buffer.from(chunk)
                            }

                            function _isUint8Array(obj) {
                                return Buffer.isBuffer(obj) || obj instanceof OurUint8Array
                            }
                            var util = require("core-util-is");
                            util.inherits = require("inherits");
                            var debugUtil = require("util"),
                                debug = void 0;
                            if (debugUtil && debugUtil.debuglog) {
                                debug = debugUtil.debuglog("stream")
                            } else {
                                debug = function() {}
                            }
                            var BufferList = require("./internal/streams/BufferList"),
                                destroyImpl = require("./internal/streams/destroy"),
                                StringDecoder;
                            util.inherits(Readable, Stream);
                            var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];

                            function prependListener(emitter, event, fn) {
                                if ("function" === typeof emitter.prependListener) return emitter.prependListener(event, fn);
                                if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
                                else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);
                                else emitter._events[event] = [fn, emitter._events[event]]
                            }

                            function ReadableState(options, stream) {
                                Duplex = Duplex || require("./_stream_duplex");
                                options = options || {};
                                var isDuplex = stream instanceof Duplex;
                                this.objectMode = !!options.objectMode;
                                if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
                                var hwm = options.highWaterMark,
                                    readableHwm = options.readableHighWaterMark,
                                    defaultHwm = this.objectMode ? 16 : 1024 * 16;
                                if (hwm || 0 === hwm) this.highWaterMark = hwm;
                                else if (isDuplex && (readableHwm || 0 === readableHwm)) this.highWaterMark = readableHwm;
                                else this.highWaterMark = defaultHwm;
                                this.highWaterMark = _Mathfloor(this.highWaterMark);
                                this.buffer = new BufferList;
                                this.length = 0;
                                this.pipes = null;
                                this.pipesCount = 0;
                                this.flowing = null;
                                this.ended = !1;
                                this.endEmitted = !1;
                                this.reading = !1;
                                this.sync = !0;
                                this.needReadable = !1;
                                this.emittedReadable = !1;
                                this.readableListening = !1;
                                this.resumeScheduled = !1;
                                this.destroyed = !1;
                                this.defaultEncoding = options.defaultEncoding || "utf8";
                                this.awaitDrain = 0;
                                this.readingMore = !1;
                                this.decoder = null;
                                this.encoding = null;
                                if (options.encoding) {
                                    if (!StringDecoder) StringDecoder = require("string_decoder/").StringDecoder;
                                    this.decoder = new StringDecoder(options.encoding);
                                    this.encoding = options.encoding
                                }
                            }

                            function Readable(options) {
                                Duplex = Duplex || require("./_stream_duplex");
                                if (!(this instanceof Readable)) return new Readable(options);
                                this._readableState = new ReadableState(options, this);
                                this.readable = !0;
                                if (options) {
                                    if ("function" === typeof options.read) this._read = options.read;
                                    if ("function" === typeof options.destroy) this._destroy = options.destroy
                                }
                                Stream.call(this)
                            }
                            Object.defineProperty(Readable.prototype, "destroyed", {
                                get: function() {
                                    if (this._readableState === void 0) {
                                        return !1
                                    }
                                    return this._readableState.destroyed
                                },
                                set: function(value) {
                                    if (!this._readableState) {
                                        return
                                    }
                                    this._readableState.destroyed = value
                                }
                            });
                            Readable.prototype.destroy = destroyImpl.destroy;
                            Readable.prototype._undestroy = destroyImpl.undestroy;
                            Readable.prototype._destroy = function(err, cb) {
                                this.push(null);
                                cb(err)
                            };
                            Readable.prototype.push = function(chunk, encoding) {
                                var state = this._readableState,
                                    skipChunkCheck;
                                if (!state.objectMode) {
                                    if ("string" === typeof chunk) {
                                        encoding = encoding || state.defaultEncoding;
                                        if (encoding !== state.encoding) {
                                            chunk = Buffer.from(chunk, encoding);
                                            encoding = ""
                                        }
                                        skipChunkCheck = !0
                                    }
                                } else {
                                    skipChunkCheck = !0
                                }
                                return readableAddChunk(this, chunk, encoding, !1, skipChunkCheck)
                            };
                            Readable.prototype.unshift = function(chunk) {
                                return readableAddChunk(this, chunk, null, !0, !1)
                            };

                            function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
                                var state = stream._readableState;
                                if (null === chunk) {
                                    state.reading = !1;
                                    onEofChunk(stream, state)
                                } else {
                                    var er;
                                    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
                                    if (er) {
                                        stream.emit("error", er)
                                    } else if (state.objectMode || chunk && 0 < chunk.length) {
                                        if ("string" !== typeof chunk && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
                                            chunk = _uint8ArrayToBuffer(chunk)
                                        }
                                        if (addToFront) {
                                            if (state.endEmitted) stream.emit("error", new Error("stream.unshift() after end event"));
                                            else addChunk(stream, state, chunk, !0)
                                        } else if (state.ended) {
                                            stream.emit("error", new Error("stream.push() after EOF"))
                                        } else {
                                            state.reading = !1;
                                            if (state.decoder && !encoding) {
                                                chunk = state.decoder.write(chunk);
                                                if (state.objectMode || 0 !== chunk.length) addChunk(stream, state, chunk, !1);
                                                else maybeReadMore(stream, state)
                                            } else {
                                                addChunk(stream, state, chunk, !1)
                                            }
                                        }
                                    } else if (!addToFront) {
                                        state.reading = !1
                                    }
                                }
                                return needMoreData(state)
                            }

                            function addChunk(stream, state, chunk, addToFront) {
                                if (state.flowing && 0 === state.length && !state.sync) {
                                    stream.emit("data", chunk);
                                    stream.read(0)
                                } else {
                                    state.length += state.objectMode ? 1 : chunk.length;
                                    if (addToFront) state.buffer.unshift(chunk);
                                    else state.buffer.push(chunk);
                                    if (state.needReadable) emitReadable(stream)
                                }
                                maybeReadMore(stream, state)
                            }

                            function chunkInvalid(state, chunk) {
                                var er;
                                if (!_isUint8Array(chunk) && "string" !== typeof chunk && chunk !== void 0 && !state.objectMode) {
                                    er = new TypeError("Invalid non-string/buffer chunk")
                                }
                                return er
                            }

                            function needMoreData(state) {
                                return !state.ended && (state.needReadable || state.length < state.highWaterMark || 0 === state.length)
                            }
                            Readable.prototype.isPaused = function() {
                                return !1 === this._readableState.flowing
                            };
                            Readable.prototype.setEncoding = function(enc) {
                                if (!StringDecoder) StringDecoder = require("string_decoder/").StringDecoder;
                                this._readableState.decoder = new StringDecoder(enc);
                                this._readableState.encoding = enc;
                                return this
                            };
                            var MAX_HWM = 8388608;

                            function computeNewHighWaterMark(n) {
                                if (n >= MAX_HWM) {
                                    n = MAX_HWM
                                } else {
                                    n--;
                                    n |= n >>> 1;
                                    n |= n >>> 2;
                                    n |= n >>> 4;
                                    n |= n >>> 8;
                                    n |= n >>> 16;
                                    n++
                                }
                                return n
                            }

                            function howMuchToRead(n, state) {
                                if (0 >= n || 0 === state.length && state.ended) return 0;
                                if (state.objectMode) return 1;
                                if (n !== n) {
                                    if (state.flowing && state.length) return state.buffer.head.data.length;
                                    else return state.length
                                }
                                if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
                                if (n <= state.length) return n;
                                if (!state.ended) {
                                    state.needReadable = !0;
                                    return 0
                                }
                                return state.length
                            }
                            Readable.prototype.read = function(n) {
                                debug("read", n);
                                n = parseInt(n, 10);
                                var state = this._readableState,
                                    nOrig = n;
                                if (0 !== n) state.emittedReadable = !1;
                                if (0 === n && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
                                    debug("read: emitReadable", state.length, state.ended);
                                    if (0 === state.length && state.ended) endReadable(this);
                                    else emitReadable(this);
                                    return null
                                }
                                n = howMuchToRead(n, state);
                                if (0 === n && state.ended) {
                                    if (0 === state.length) endReadable(this);
                                    return null
                                }
                                var doRead = state.needReadable;
                                debug("need readable", doRead);
                                if (0 === state.length || state.length - n < state.highWaterMark) {
                                    doRead = !0;
                                    debug("length less than watermark", doRead)
                                }
                                if (state.ended || state.reading) {
                                    doRead = !1;
                                    debug("reading or ended", doRead)
                                } else if (doRead) {
                                    debug("do read");
                                    state.reading = !0;
                                    state.sync = !0;
                                    if (0 === state.length) state.needReadable = !0;
                                    this._read(state.highWaterMark);
                                    state.sync = !1;
                                    if (!state.reading) n = howMuchToRead(nOrig, state)
                                }
                                var ret;
                                if (0 < n) ret = fromList(n, state);
                                else ret = null;
                                if (null === ret) {
                                    state.needReadable = !0;
                                    n = 0
                                } else {
                                    state.length -= n
                                }
                                if (0 === state.length) {
                                    if (!state.ended) state.needReadable = !0;
                                    if (nOrig !== n && state.ended) endReadable(this)
                                }
                                if (null !== ret) this.emit("data", ret);
                                return ret
                            };

                            function onEofChunk(stream, state) {
                                if (state.ended) return;
                                if (state.decoder) {
                                    var chunk = state.decoder.end();
                                    if (chunk && chunk.length) {
                                        state.buffer.push(chunk);
                                        state.length += state.objectMode ? 1 : chunk.length
                                    }
                                }
                                state.ended = !0;
                                emitReadable(stream)
                            }

                            function emitReadable(stream) {
                                var state = stream._readableState;
                                state.needReadable = !1;
                                if (!state.emittedReadable) {
                                    debug("emitReadable", state.flowing);
                                    state.emittedReadable = !0;
                                    if (state.sync) pna.nextTick(emitReadable_, stream);
                                    else emitReadable_(stream)
                                }
                            }

                            function emitReadable_(stream) {
                                debug("emit readable");
                                stream.emit("readable");
                                flow(stream)
                            }

                            function maybeReadMore(stream, state) {
                                if (!state.readingMore) {
                                    state.readingMore = !0;
                                    pna.nextTick(maybeReadMore_, stream, state)
                                }
                            }

                            function maybeReadMore_(stream, state) {
                                var len = state.length;
                                while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
                                    debug("maybeReadMore read 0");
                                    stream.read(0);
                                    if (len === state.length) break;
                                    else len = state.length
                                }
                                state.readingMore = !1
                            }
                            Readable.prototype._read = function() {
                                this.emit("error", new Error("_read() is not implemented"))
                            };
                            Readable.prototype.pipe = function(dest, pipeOpts) {
                                var src = this,
                                    state = this._readableState;
                                switch (state.pipesCount) {
                                    case 0:
                                        state.pipes = dest;
                                        break;
                                    case 1:
                                        state.pipes = [state.pipes, dest];
                                        break;
                                    default:
                                        state.pipes.push(dest);
                                        break;
                                }
                                state.pipesCount += 1;
                                debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
                                var doEnd = (!pipeOpts || !1 !== pipeOpts.end) && dest !== process.stdout && dest !== process.stderr,
                                    endFn = doEnd ? onend : unpipe;
                                if (state.endEmitted) pna.nextTick(endFn);
                                else src.once("end", endFn);
                                dest.on("unpipe", onunpipe);

                                function onunpipe(readable, unpipeInfo) {
                                    debug("onunpipe");
                                    if (readable === src) {
                                        if (unpipeInfo && !1 === unpipeInfo.hasUnpiped) {
                                            unpipeInfo.hasUnpiped = !0;
                                            cleanup()
                                        }
                                    }
                                }

                                function onend() {
                                    debug("onend");
                                    dest.end()
                                }
                                var ondrain = pipeOnDrain(src);
                                dest.on("drain", ondrain);
                                var cleanedUp = !1;

                                function cleanup() {
                                    debug("cleanup");
                                    dest.removeListener("close", onclose);
                                    dest.removeListener("finish", onfinish);
                                    dest.removeListener("drain", ondrain);
                                    dest.removeListener("error", onerror);
                                    dest.removeListener("unpipe", onunpipe);
                                    src.removeListener("end", onend);
                                    src.removeListener("end", unpipe);
                                    src.removeListener("data", ondata);
                                    cleanedUp = !0;
                                    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain()
                                }
                                var increasedAwaitDrain = !1;
                                src.on("data", ondata);

                                function ondata(chunk) {
                                    debug("ondata");
                                    increasedAwaitDrain = !1;
                                    var ret = dest.write(chunk);
                                    if (!1 === ret && !increasedAwaitDrain) {
                                        if ((1 === state.pipesCount && state.pipes === dest || 1 < state.pipesCount && -1 !== indexOf(state.pipes, dest)) && !cleanedUp) {
                                            debug("false write response, pause", src._readableState.awaitDrain);
                                            src._readableState.awaitDrain++;
                                            increasedAwaitDrain = !0
                                        }
                                        src.pause()
                                    }
                                }

                                function onerror(er) {
                                    debug("onerror", er);
                                    unpipe();
                                    dest.removeListener("error", onerror);
                                    if (0 === EElistenerCount(dest, "error")) dest.emit("error", er)
                                }
                                prependListener(dest, "error", onerror);

                                function onclose() {
                                    dest.removeListener("finish", onfinish);
                                    unpipe()
                                }
                                dest.once("close", onclose);

                                function onfinish() {
                                    debug("onfinish");
                                    dest.removeListener("close", onclose);
                                    unpipe()
                                }
                                dest.once("finish", onfinish);

                                function unpipe() {
                                    debug("unpipe");
                                    src.unpipe(dest)
                                }
                                dest.emit("pipe", src);
                                if (!state.flowing) {
                                    debug("pipe resume");
                                    src.resume()
                                }
                                return dest
                            };

                            function pipeOnDrain(src) {
                                return function() {
                                    var state = src._readableState;
                                    debug("pipeOnDrain", state.awaitDrain);
                                    if (state.awaitDrain) state.awaitDrain--;
                                    if (0 === state.awaitDrain && EElistenerCount(src, "data")) {
                                        state.flowing = !0;
                                        flow(src)
                                    }
                                }
                            }
                            Readable.prototype.unpipe = function(dest) {
                                var state = this._readableState,
                                    unpipeInfo = {
                                        hasUnpiped: !1
                                    };
                                if (0 === state.pipesCount) return this;
                                if (1 === state.pipesCount) {
                                    if (dest && dest !== state.pipes) return this;
                                    if (!dest) dest = state.pipes;
                                    state.pipes = null;
                                    state.pipesCount = 0;
                                    state.flowing = !1;
                                    if (dest) dest.emit("unpipe", this, unpipeInfo);
                                    return this
                                }
                                if (!dest) {
                                    var dests = state.pipes,
                                        len = state.pipesCount;
                                    state.pipes = null;
                                    state.pipesCount = 0;
                                    state.flowing = !1;
                                    for (var i = 0; i < len; i++) {
                                        dests[i].emit("unpipe", this, unpipeInfo)
                                    }
                                    return this
                                }
                                var index = indexOf(state.pipes, dest);
                                if (-1 === index) return this;
                                state.pipes.splice(index, 1);
                                state.pipesCount -= 1;
                                if (1 === state.pipesCount) state.pipes = state.pipes[0];
                                dest.emit("unpipe", this, unpipeInfo);
                                return this
                            };
                            Readable.prototype.on = function(ev, fn) {
                                var res = Stream.prototype.on.call(this, ev, fn);
                                if ("data" === ev) {
                                    if (!1 !== this._readableState.flowing) this.resume()
                                } else if ("readable" === ev) {
                                    var state = this._readableState;
                                    if (!state.endEmitted && !state.readableListening) {
                                        state.readableListening = state.needReadable = !0;
                                        state.emittedReadable = !1;
                                        if (!state.reading) {
                                            pna.nextTick(nReadingNextTick, this)
                                        } else if (state.length) {
                                            emitReadable(this)
                                        }
                                    }
                                }
                                return res
                            };
                            Readable.prototype.addListener = Readable.prototype.on;

                            function nReadingNextTick(self) {
                                debug("readable nexttick read 0");
                                self.read(0)
                            }
                            Readable.prototype.resume = function() {
                                var state = this._readableState;
                                if (!state.flowing) {
                                    debug("resume");
                                    state.flowing = !0;
                                    resume(this, state)
                                }
                                return this
                            };

                            function resume(stream, state) {
                                if (!state.resumeScheduled) {
                                    state.resumeScheduled = !0;
                                    pna.nextTick(resume_, stream, state)
                                }
                            }

                            function resume_(stream, state) {
                                if (!state.reading) {
                                    debug("resume read 0");
                                    stream.read(0)
                                }
                                state.resumeScheduled = !1;
                                state.awaitDrain = 0;
                                stream.emit("resume");
                                flow(stream);
                                if (state.flowing && !state.reading) stream.read(0)
                            }
                            Readable.prototype.pause = function() {
                                debug("call pause flowing=%j", this._readableState.flowing);
                                if (!1 !== this._readableState.flowing) {
                                    debug("pause");
                                    this._readableState.flowing = !1;
                                    this.emit("pause")
                                }
                                return this
                            };

                            function flow(stream) {
                                var state = stream._readableState;
                                debug("flow", state.flowing);
                                while (state.flowing && null !== stream.read()) {}
                            }
                            Readable.prototype.wrap = function(stream) {
                                var _this = this,
                                    state = this._readableState,
                                    paused = !1;
                                stream.on("end", function() {
                                    debug("wrapped end");
                                    if (state.decoder && !state.ended) {
                                        var chunk = state.decoder.end();
                                        if (chunk && chunk.length) _this.push(chunk)
                                    }
                                    _this.push(null)
                                });
                                stream.on("data", function(chunk) {
                                    debug("wrapped data");
                                    if (state.decoder) chunk = state.decoder.write(chunk);
                                    if (state.objectMode && (null === chunk || chunk === void 0)) return;
                                    else if (!state.objectMode && (!chunk || !chunk.length)) return;
                                    var ret = _this.push(chunk);
                                    if (!ret) {
                                        paused = !0;
                                        stream.pause()
                                    }
                                });
                                for (var i in stream) {
                                    if (this[i] === void 0 && "function" === typeof stream[i]) {
                                        this[i] = function(method) {
                                            return function() {
                                                return stream[method].apply(stream, arguments)
                                            }
                                        }(i)
                                    }
                                }
                                for (var n = 0; n < kProxyEvents.length; n++) {
                                    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]))
                                }
                                this._read = function(n) {
                                    debug("wrapped _read", n);
                                    if (paused) {
                                        paused = !1;
                                        stream.resume()
                                    }
                                };
                                return this
                            };
                            Readable._fromList = fromList;

                            function fromList(n, state) {
                                if (0 === state.length) return null;
                                var ret;
                                if (state.objectMode) ret = state.buffer.shift();
                                else if (!n || n >= state.length) {
                                    if (state.decoder) ret = state.buffer.join("");
                                    else if (1 === state.buffer.length) ret = state.buffer.head.data;
                                    else ret = state.buffer.concat(state.length);
                                    state.buffer.clear()
                                } else {
                                    ret = fromListPartial(n, state.buffer, state.decoder)
                                }
                                return ret
                            }

                            function fromListPartial(n, list, hasStrings) {
                                var ret;
                                if (n < list.head.data.length) {
                                    ret = list.head.data.slice(0, n);
                                    list.head.data = list.head.data.slice(n)
                                } else if (n === list.head.data.length) {
                                    ret = list.shift()
                                } else {
                                    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list)
                                }
                                return ret
                            }

                            function copyFromBufferString(n, list) {
                                var p = list.head,
                                    c = 1,
                                    ret = p.data;
                                n -= ret.length;
                                while (p = p.next) {
                                    var str = p.data,
                                        nb = n > str.length ? str.length : n;
                                    if (nb === str.length) ret += str;
                                    else ret += str.slice(0, n);
                                    n -= nb;
                                    if (0 === n) {
                                        if (nb === str.length) {
                                            ++c;
                                            if (p.next) list.head = p.next;
                                            else list.head = list.tail = null
                                        } else {
                                            list.head = p;
                                            p.data = str.slice(nb)
                                        }
                                        break
                                    }++c
                                }
                                list.length -= c;
                                return ret
                            }

                            function copyFromBuffer(n, list) {
                                var ret = Buffer.allocUnsafe(n),
                                    p = list.head,
                                    c = 1;
                                p.data.copy(ret);
                                n -= p.data.length;
                                while (p = p.next) {
                                    var buf = p.data,
                                        nb = n > buf.length ? buf.length : n;
                                    buf.copy(ret, ret.length - n, 0, nb);
                                    n -= nb;
                                    if (0 === n) {
                                        if (nb === buf.length) {
                                            ++c;
                                            if (p.next) list.head = p.next;
                                            else list.head = list.tail = null
                                        } else {
                                            list.head = p;
                                            p.data = buf.slice(nb)
                                        }
                                        break
                                    }++c
                                }
                                list.length -= c;
                                return ret
                            }

                            function endReadable(stream) {
                                var state = stream._readableState;
                                if (0 < state.length) throw new Error("\"endReadable()\" called on non-empty stream");
                                if (!state.endEmitted) {
                                    state.ended = !0;
                                    pna.nextTick(endReadableNT, state, stream)
                                }
                            }

                            function endReadableNT(state, stream) {
                                if (!state.endEmitted && 0 === state.length) {
                                    state.endEmitted = !0;
                                    stream.readable = !1;
                                    stream.emit("end")
                                }
                            }

                            function indexOf(xs, x) {
                                for (var i = 0, l = xs.length; i < l; i++) {
                                    if (xs[i] === x) return i
                                }
                                return -1
                            }
                        }).call(this, require("_process"), "undefined" !== typeof global ? global : "undefined" !== typeof self ? self : "undefined" !== typeof window ? window : {})
                    }, {
                        "./_stream_duplex": 406,
                        "./internal/streams/BufferList": 411,
                        "./internal/streams/destroy": 412,
                        "./internal/streams/stream": 413,
                        _process: 399,
                        "core-util-is": 374,
                        events: 388,
                        inherits: 392,
                        isarray: 394,
                        "process-nextick-args": 398,
                        "safe-buffer": 420,
                        "string_decoder/": 436,
                        util: 38
                    }],
                    409: [function(require, module) {
                        "use strict";
                        module.exports = Transform;
                        var Duplex = require("./_stream_duplex"),
                            util = require("core-util-is");
                        util.inherits = require("inherits");
                        util.inherits(Transform, Duplex);

                        function afterTransform(er, data) {
                            var ts = this._transformState;
                            ts.transforming = !1;
                            var cb = ts.writecb;
                            if (!cb) {
                                return this.emit("error", new Error("write callback called multiple times"))
                            }
                            ts.writechunk = null;
                            ts.writecb = null;
                            if (null != data) this.push(data);
                            cb(er);
                            var rs = this._readableState;
                            rs.reading = !1;
                            if (rs.needReadable || rs.length < rs.highWaterMark) {
                                this._read(rs.highWaterMark)
                            }
                        }

                        function Transform(options) {
                            if (!(this instanceof Transform)) return new Transform(options);
                            Duplex.call(this, options);
                            this._transformState = {
                                afterTransform: afterTransform.bind(this),
                                needTransform: !1,
                                transforming: !1,
                                writecb: null,
                                writechunk: null,
                                writeencoding: null
                            };
                            this._readableState.needReadable = !0;
                            this._readableState.sync = !1;
                            if (options) {
                                if ("function" === typeof options.transform) this._transform = options.transform;
                                if ("function" === typeof options.flush) this._flush = options.flush
                            }
                            this.on("prefinish", prefinish)
                        }

                        function prefinish() {
                            var _this = this;
                            if ("function" === typeof this._flush) {
                                this._flush(function(er, data) {
                                    done(_this, er, data)
                                })
                            } else {
                                done(this, null, null)
                            }
                        }
                        Transform.prototype.push = function(chunk, encoding) {
                            this._transformState.needTransform = !1;
                            return Duplex.prototype.push.call(this, chunk, encoding)
                        };
                        Transform.prototype._transform = function() {
                            throw new Error("_transform() is not implemented")
                        };
                        Transform.prototype._write = function(chunk, encoding, cb) {
                            var ts = this._transformState;
                            ts.writecb = cb;
                            ts.writechunk = chunk;
                            ts.writeencoding = encoding;
                            if (!ts.transforming) {
                                var rs = this._readableState;
                                if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark)
                            }
                        };
                        Transform.prototype._read = function() {
                            var ts = this._transformState;
                            if (null !== ts.writechunk && ts.writecb && !ts.transforming) {
                                ts.transforming = !0;
                                this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform)
                            } else {
                                ts.needTransform = !0
                            }
                        };
                        Transform.prototype._destroy = function(err, cb) {
                            var _this2 = this;
                            Duplex.prototype._destroy.call(this, err, function(err2) {
                                cb(err2);
                                _this2.emit("close")
                            })
                        };

                        function done(stream, er, data) {
                            if (er) return stream.emit("error", er);
                            if (null != data) stream.push(data);
                            if (stream._writableState.length) throw new Error("Calling transform done when ws.length != 0");
                            if (stream._transformState.transforming) throw new Error("Calling transform done when still transforming");
                            return stream.push(null)
                        }
                    }, {
                        "./_stream_duplex": 406,
                        "core-util-is": 374,
                        inherits: 392
                    }],
                    410: [function(require, module) {
                        (function(process, global) {
                            "use strict";
                            var pna = require("process-nextick-args");
                            module.exports = Writable;

                            function CorkedRequest(state) {
                                var _this = this;
                                this.next = null;
                                this.entry = null;
                                this.finish = function() {
                                    onCorkedFinish(_this, state)
                                }
                            }
                            var asyncWrite = !process.browser && -1 < ["v0.10", "v0.9."].indexOf(process.version.slice(0, 5)) ? setImmediate : pna.nextTick,
                                Duplex;
                            Writable.WritableState = WritableState;
                            var util = require("core-util-is");
                            util.inherits = require("inherits");
                            var internalUtil = {
                                    deprecate: require("util-deprecate")
                                },
                                Stream = require("./internal/streams/stream"),
                                Buffer = require("safe-buffer").Buffer,
                                OurUint8Array = global.Uint8Array || function() {};

                            function _uint8ArrayToBuffer(chunk) {
                                return Buffer.from(chunk)
                            }

                            function _isUint8Array(obj) {
                                return Buffer.isBuffer(obj) || obj instanceof OurUint8Array
                            }
                            var destroyImpl = require("./internal/streams/destroy");
                            util.inherits(Writable, Stream);

                            function nop() {}

                            function WritableState(options, stream) {
                                Duplex = Duplex || require("./_stream_duplex");
                                options = options || {};
                                var isDuplex = stream instanceof Duplex;
                                this.objectMode = !!options.objectMode;
                                if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
                                var hwm = options.highWaterMark,
                                    writableHwm = options.writableHighWaterMark,
                                    defaultHwm = this.objectMode ? 16 : 1024 * 16;
                                if (hwm || 0 === hwm) this.highWaterMark = hwm;
                                else if (isDuplex && (writableHwm || 0 === writableHwm)) this.highWaterMark = writableHwm;
                                else this.highWaterMark = defaultHwm;
                                this.highWaterMark = _Mathfloor(this.highWaterMark);
                                this.finalCalled = !1;
                                this.needDrain = !1;
                                this.ending = !1;
                                this.ended = !1;
                                this.finished = !1;
                                this.destroyed = !1;
                                var noDecode = !1 === options.decodeStrings;
                                this.decodeStrings = !noDecode;
                                this.defaultEncoding = options.defaultEncoding || "utf8";
                                this.length = 0;
                                this.writing = !1;
                                this.corked = 0;
                                this.sync = !0;
                                this.bufferProcessing = !1;
                                this.onwrite = function(er) {
                                    onwrite(stream, er)
                                };
                                this.writecb = null;
                                this.writelen = 0;
                                this.bufferedRequest = null;
                                this.lastBufferedRequest = null;
                                this.pendingcb = 0;
                                this.prefinished = !1;
                                this.errorEmitted = !1;
                                this.bufferedRequestCount = 0;
                                this.corkedRequestsFree = new CorkedRequest(this)
                            }
                            WritableState.prototype.getBuffer = function() {
                                var current = this.bufferedRequest,
                                    out = [];
                                while (current) {
                                    out.push(current);
                                    current = current.next
                                }
                                return out
                            };
                            (function() {
                                try {
                                    Object.defineProperty(WritableState.prototype, "buffer", {
                                        get: internalUtil.deprecate(function() {
                                            return this.getBuffer()
                                        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer " + "instead.", "DEP0003")
                                    })
                                } catch (_) {}
                            })();
                            var realHasInstance;
                            if ("function" === typeof Symbol && Symbol.hasInstance && "function" === typeof Function.prototype[Symbol.hasInstance]) {
                                realHasInstance = Function.prototype[Symbol.hasInstance];
                                Object.defineProperty(Writable, Symbol.hasInstance, {
                                    value: function(object) {
                                        if (realHasInstance.call(this, object)) return !0;
                                        if (this !== Writable) return !1;
                                        return object && object._writableState instanceof WritableState
                                    }
                                })
                            } else {
                                realHasInstance = function(object) {
                                    return object instanceof this
                                }
                            }

                            function Writable(options) {
                                Duplex = Duplex || require("./_stream_duplex");
                                if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
                                    return new Writable(options)
                                }
                                this._writableState = new WritableState(options, this);
                                this.writable = !0;
                                if (options) {
                                    if ("function" === typeof options.write) this._write = options.write;
                                    if ("function" === typeof options.writev) this._writev = options.writev;
                                    if ("function" === typeof options.destroy) this._destroy = options.destroy;
                                    if ("function" === typeof options.final) this._final = options.final
                                }
                                Stream.call(this)
                            }
                            Writable.prototype.pipe = function() {
                                this.emit("error", new Error("Cannot pipe, not readable"))
                            };

                            function writeAfterEnd(stream, cb) {
                                var er = new Error("write after end");
                                stream.emit("error", er);
                                pna.nextTick(cb, er)
                            }

                            function validChunk(stream, state, chunk, cb) {
                                var valid = !0,
                                    er = !1;
                                if (null === chunk) {
                                    er = new TypeError("May not write null values to stream")
                                } else if ("string" !== typeof chunk && chunk !== void 0 && !state.objectMode) {
                                    er = new TypeError("Invalid non-string/buffer chunk")
                                }
                                if (er) {
                                    stream.emit("error", er);
                                    pna.nextTick(cb, er);
                                    valid = !1
                                }
                                return valid
                            }
                            Writable.prototype.write = function(chunk, encoding, cb) {
                                var state = this._writableState,
                                    ret = !1,
                                    isBuf = !state.objectMode && _isUint8Array(chunk);
                                if (isBuf && !Buffer.isBuffer(chunk)) {
                                    chunk = _uint8ArrayToBuffer(chunk)
                                }
                                if ("function" === typeof encoding) {
                                    cb = encoding;
                                    encoding = null
                                }
                                if (isBuf) encoding = "buffer";
                                else if (!encoding) encoding = state.defaultEncoding;
                                if ("function" !== typeof cb) cb = nop;
                                if (state.ended) writeAfterEnd(this, cb);
                                else if (isBuf || validChunk(this, state, chunk, cb)) {
                                    state.pendingcb++;
                                    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb)
                                }
                                return ret
                            };
                            Writable.prototype.cork = function() {
                                var state = this._writableState;
                                state.corked++
                            };
                            Writable.prototype.uncork = function() {
                                var state = this._writableState;
                                if (state.corked) {
                                    state.corked--;
                                    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state)
                                }
                            };
                            Writable.prototype.setDefaultEncoding = function(encoding) {
                                if ("string" === typeof encoding) encoding = encoding.toLowerCase();
                                if (!(-1 < ["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()))) throw new TypeError("Unknown encoding: " + encoding);
                                this._writableState.defaultEncoding = encoding;
                                return this
                            };

                            function decodeChunk(state, chunk, encoding) {
                                if (!state.objectMode && !1 !== state.decodeStrings && "string" === typeof chunk) {
                                    chunk = Buffer.from(chunk, encoding)
                                }
                                return chunk
                            }

                            function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
                                if (!isBuf) {
                                    var newChunk = decodeChunk(state, chunk, encoding);
                                    if (chunk !== newChunk) {
                                        isBuf = !0;
                                        encoding = "buffer";
                                        chunk = newChunk
                                    }
                                }
                                var len = state.objectMode ? 1 : chunk.length;
                                state.length += len;
                                var ret = state.length < state.highWaterMark;
                                if (!ret) state.needDrain = !0;
                                if (state.writing || state.corked) {
                                    var last = state.lastBufferedRequest;
                                    state.lastBufferedRequest = {
                                        chunk: chunk,
                                        encoding: encoding,
                                        isBuf: isBuf,
                                        callback: cb,
                                        next: null
                                    };
                                    if (last) {
                                        last.next = state.lastBufferedRequest
                                    } else {
                                        state.bufferedRequest = state.lastBufferedRequest
                                    }
                                    state.bufferedRequestCount += 1
                                } else {
                                    doWrite(stream, state, !1, len, chunk, encoding, cb)
                                }
                                return ret
                            }

                            function doWrite(stream, state, writev, len, chunk, encoding, cb) {
                                state.writelen = len;
                                state.writecb = cb;
                                state.writing = !0;
                                state.sync = !0;
                                if (writev) stream._writev(chunk, state.onwrite);
                                else stream._write(chunk, encoding, state.onwrite);
                                state.sync = !1
                            }

                            function onwriteError(stream, state, sync, er, cb) {
                                --state.pendingcb;
                                if (sync) {
                                    pna.nextTick(cb, er);
                                    pna.nextTick(finishMaybe, stream, state);
                                    stream._writableState.errorEmitted = !0;
                                    stream.emit("error", er)
                                } else {
                                    cb(er);
                                    stream._writableState.errorEmitted = !0;
                                    stream.emit("error", er);
                                    finishMaybe(stream, state)
                                }
                            }

                            function onwriteStateUpdate(state) {
                                state.writing = !1;
                                state.writecb = null;
                                state.length -= state.writelen;
                                state.writelen = 0
                            }

                            function onwrite(stream, er) {
                                var state = stream._writableState,
                                    sync = state.sync,
                                    cb = state.writecb;
                                onwriteStateUpdate(state);
                                if (er) onwriteError(stream, state, sync, er, cb);
                                else {
                                    var finished = needFinish(state);
                                    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
                                        clearBuffer(stream, state)
                                    }
                                    if (sync) {
                                        asyncWrite(afterWrite, stream, state, finished, cb)
                                    } else {
                                        afterWrite(stream, state, finished, cb)
                                    }
                                }
                            }

                            function afterWrite(stream, state, finished, cb) {
                                if (!finished) onwriteDrain(stream, state);
                                state.pendingcb--;
                                cb();
                                finishMaybe(stream, state)
                            }

                            function onwriteDrain(stream, state) {
                                if (0 === state.length && state.needDrain) {
                                    state.needDrain = !1;
                                    stream.emit("drain")
                                }
                            }

                            function clearBuffer(stream, state) {
                                state.bufferProcessing = !0;
                                var entry = state.bufferedRequest;
                                if (stream._writev && entry && entry.next) {
                                    var l = state.bufferedRequestCount,
                                        buffer = Array(l),
                                        holder = state.corkedRequestsFree;
                                    holder.entry = entry;
                                    var count = 0,
                                        allBuffers = !0;
                                    while (entry) {
                                        buffer[count] = entry;
                                        if (!entry.isBuf) allBuffers = !1;
                                        entry = entry.next;
                                        count += 1
                                    }
                                    buffer.allBuffers = allBuffers;
                                    doWrite(stream, state, !0, state.length, buffer, "", holder.finish);
                                    state.pendingcb++;
                                    state.lastBufferedRequest = null;
                                    if (holder.next) {
                                        state.corkedRequestsFree = holder.next;
                                        holder.next = null
                                    } else {
                                        state.corkedRequestsFree = new CorkedRequest(state)
                                    }
                                    state.bufferedRequestCount = 0
                                } else {
                                    while (entry) {
                                        var chunk = entry.chunk,
                                            encoding = entry.encoding,
                                            cb = entry.callback,
                                            len = state.objectMode ? 1 : chunk.length;
                                        doWrite(stream, state, !1, len, chunk, encoding, cb);
                                        entry = entry.next;
                                        state.bufferedRequestCount--;
                                        if (state.writing) {
                                            break
                                        }
                                    }
                                    if (null === entry) state.lastBufferedRequest = null
                                }
                                state.bufferedRequest = entry;
                                state.bufferProcessing = !1
                            }
                            Writable.prototype._write = function(chunk, encoding, cb) {
                                cb(new Error("_write() is not implemented"))
                            };
                            Writable.prototype._writev = null;
                            Writable.prototype.end = function(chunk, encoding, cb) {
                                var state = this._writableState;
                                if ("function" === typeof chunk) {
                                    cb = chunk;
                                    chunk = null;
                                    encoding = null
                                } else if ("function" === typeof encoding) {
                                    cb = encoding;
                                    encoding = null
                                }
                                if (null !== chunk && chunk !== void 0) this.write(chunk, encoding);
                                if (state.corked) {
                                    state.corked = 1;
                                    this.uncork()
                                }
                                if (!state.ending && !state.finished) endWritable(this, state, cb)
                            };

                            function needFinish(state) {
                                return state.ending && 0 === state.length && null === state.bufferedRequest && !state.finished && !state.writing
                            }

                            function callFinal(stream, state) {
                                stream._final(function(err) {
                                    state.pendingcb--;
                                    if (err) {
                                        stream.emit("error", err)
                                    }
                                    state.prefinished = !0;
                                    stream.emit("prefinish");
                                    finishMaybe(stream, state)
                                })
                            }

                            function prefinish(stream, state) {
                                if (!state.prefinished && !state.finalCalled) {
                                    if ("function" === typeof stream._final) {
                                        state.pendingcb++;
                                        state.finalCalled = !0;
                                        pna.nextTick(callFinal, stream, state)
                                    } else {
                                        state.prefinished = !0;
                                        stream.emit("prefinish")
                                    }
                                }
                            }

                            function finishMaybe(stream, state) {
                                var need = needFinish(state);
                                if (need) {
                                    prefinish(stream, state);
                                    if (0 === state.pendingcb) {
                                        state.finished = !0;
                                        stream.emit("finish")
                                    }
                                }
                                return need
                            }

                            function endWritable(stream, state, cb) {
                                state.ending = !0;
                                finishMaybe(stream, state);
                                if (cb) {
                                    if (state.finished) pna.nextTick(cb);
                                    else stream.once("finish", cb)
                                }
                                state.ended = !0;
                                stream.writable = !1
                            }

                            function onCorkedFinish(corkReq, state, err) {
                                var entry = corkReq.entry;
                                corkReq.entry = null;
                                while (entry) {
                                    var cb = entry.callback;
                                    state.pendingcb--;
                                    cb(err);
                                    entry = entry.next
                                }
                                if (state.corkedRequestsFree) {
                                    state.corkedRequestsFree.next = corkReq
                                } else {
                                    state.corkedRequestsFree = corkReq
                                }
                            }
                            Object.defineProperty(Writable.prototype, "destroyed", {
                                get: function() {
                                    if (this._writableState === void 0) {
                                        return !1
                                    }
                                    return this._writableState.destroyed
                                },
                                set: function(value) {
                                    if (!this._writableState) {
                                        return
                                    }
                                    this._writableState.destroyed = value
                                }
                            });
                            Writable.prototype.destroy = destroyImpl.destroy;
                            Writable.prototype._undestroy = destroyImpl.undestroy;
                            Writable.prototype._destroy = function(err, cb) {
                                this.end();
                                cb(err)
                            }
                        }).call(this, require("_process"), "undefined" !== typeof global ? global : "undefined" !== typeof self ? self : "undefined" !== typeof window ? window : {})
                    }, {
                        "./_stream_duplex": 406,
                        "./internal/streams/destroy": 412,
                        "./internal/streams/stream": 413,
                        _process: 399,
                        "core-util-is": 374,
                        inherits: 392,
                        "process-nextick-args": 398,
                        "safe-buffer": 420,
                        "util-deprecate": 444
                    }],
                    411: [function(require, module) {
                        "use strict";

                        function _classCallCheck(instance, Constructor) {
                            if (!(instance instanceof Constructor)) {
                                throw new TypeError("Cannot call a class as a function")
                            }
                        }
                        var Buffer = require("safe-buffer").Buffer,
                            util = require("util");

                        function copyBuffer(src, target, offset) {
                            src.copy(target, offset)
                        }
                        module.exports = function() {
                            function BufferList() {
                                _classCallCheck(this, BufferList);
                                this.head = null;
                                this.tail = null;
                                this.length = 0
                            }
                            BufferList.prototype.push = function(v) {
                                var entry = {
                                    data: v,
                                    next: null
                                };
                                if (0 < this.length) this.tail.next = entry;
                                else this.head = entry;
                                this.tail = entry;
                                ++this.length
                            };
                            BufferList.prototype.unshift = function(v) {
                                var entry = {
                                    data: v,
                                    next: this.head
                                };
                                if (0 === this.length) this.tail = entry;
                                this.head = entry;
                                ++this.length
                            };
                            BufferList.prototype.shift = function() {
                                if (0 === this.length) return;
                                var ret = this.head.data;
                                if (1 === this.length) this.head = this.tail = null;
                                else this.head = this.head.next;
                                --this.length;
                                return ret
                            };
                            BufferList.prototype.clear = function() {
                                this.head = this.tail = null;
                                this.length = 0
                            };
                            BufferList.prototype.join = function(s) {
                                if (0 === this.length) return "";
                                var p = this.head,
                                    ret = "" + p.data;
                                while (p = p.next) {
                                    ret += s + p.data
                                }
                                return ret
                            };
                            BufferList.prototype.concat = function(n) {
                                if (0 === this.length) return Buffer.alloc(0);
                                if (1 === this.length) return this.head.data;
                                var ret = Buffer.allocUnsafe(n >>> 0),
                                    p = this.head,
                                    i = 0;
                                while (p) {
                                    copyBuffer(p.data, ret, i);
                                    i += p.data.length;
                                    p = p.next
                                }
                                return ret
                            };
                            return BufferList
                        }();
                        if (util && util.inspect && util.inspect.custom) {
                            module.exports.prototype[util.inspect.custom] = function() {
                                var obj = util.inspect({
                                    length: this.length
                                });
                                return this.constructor.name + " " + obj
                            }
                        }
                    }, {
                        "safe-buffer": 420,
                        util: 38
                    }],
                    412: [function(require, module) {
                        "use strict";
                        var pna = require("process-nextick-args");

                        function emitErrorNT(self, err) {
                            self.emit("error", err)
                        }
                        module.exports = {
                            destroy: function(err, cb) {
                                var _this = this,
                                    readableDestroyed = this._readableState && this._readableState.destroyed,
                                    writableDestroyed = this._writableState && this._writableState.destroyed;
                                if (readableDestroyed || writableDestroyed) {
                                    if (cb) {
                                        cb(err)
                                    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
                                        pna.nextTick(emitErrorNT, this, err)
                                    }
                                    return this
                                }
                                if (this._readableState) {
                                    this._readableState.destroyed = !0
                                }
                                if (this._writableState) {
                                    this._writableState.destroyed = !0
                                }
                                this._destroy(err || null, function(err) {
                                    if (!cb && err) {
                                        pna.nextTick(emitErrorNT, _this, err);
                                        if (_this._writableState) {
                                            _this._writableState.errorEmitted = !0
                                        }
                                    } else if (cb) {
                                        cb(err)
                                    }
                                });
                                return this
                            },
                            undestroy: function() {
                                if (this._readableState) {
                                    this._readableState.destroyed = !1;
                                    this._readableState.reading = !1;
                                    this._readableState.ended = !1;
                                    this._readableState.endEmitted = !1
                                }
                                if (this._writableState) {
                                    this._writableState.destroyed = !1;
                                    this._writableState.ended = !1;
                                    this._writableState.ending = !1;
                                    this._writableState.finished = !1;
                                    this._writableState.errorEmitted = !1
                                }
                            }
                        }
                    }, {
                        "process-nextick-args": 398
                    }],
                    413: [function(require, module) {
                        module.exports = require("events").EventEmitter
                    }, {
                        events: 388
                    }],
                    414: [function(require, module) {
                        module.exports = require("./readable").PassThrough
                    }, {
                        "./readable": 415
                    }],
                    415: [function(require, module, exports) {
                        exports = module.exports = require("./lib/_stream_readable.js");
                        exports.Stream = exports;
                        exports.Readable = exports;
                        exports.Writable = require("./lib/_stream_writable.js");
                        exports.Duplex = require("./lib/_stream_duplex.js");
                        exports.Transform = require("./lib/_stream_transform.js");
                        exports.PassThrough = require("./lib/_stream_passthrough.js")
                    }, {
                        "./lib/_stream_duplex.js": 406,
                        "./lib/_stream_passthrough.js": 407,
                        "./lib/_stream_readable.js": 408,
                        "./lib/_stream_transform.js": 409,
                        "./lib/_stream_writable.js": 410
                    }],
                    416: [function(require, module) {
                        module.exports = require("./readable").Transform
                    }, {
                        "./readable": 415
                    }],
                    417: [function(require, module) {
                        module.exports = require("./lib/_stream_writable.js")
                    }, {
                        "./lib/_stream_writable.js": 410
                    }],
                    418: [function(require, module) {
                        (function(global) {
                            ! function(global) {
                                "use strict";
                                var Op = Object.prototype,
                                    hasOwn = Op.hasOwnProperty,
                                    $Symbol = "function" === typeof Symbol ? Symbol : {},
                                    iteratorSymbol = $Symbol.iterator || "@@iterator",
                                    asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator",
                                    toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag",
                                    inModule = "object" === typeof module,
                                    runtime = global.regeneratorRuntime;
                                if (runtime) {
                                    if (inModule) {
                                        module.exports = runtime
                                    }
                                    return
                                }
                                runtime = global.regeneratorRuntime = inModule ? module.exports : {};

                                function wrap(innerFn, outerFn, self, tryLocsList) {
                                    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,
                                        generator = Object.create(protoGenerator.prototype),
                                        context = new Context(tryLocsList || []);
                                    generator._invoke = makeInvokeMethod(innerFn, self, context);
                                    return generator
                                }
                                runtime.wrap = wrap;

                                function tryCatch(fn, obj, arg) {
                                    try {
                                        return {
                                            type: "normal",
                                            arg: fn.call(obj, arg)
                                        }
                                    } catch (err) {
                                        return {
                                            type: "throw",
                                            arg: err
                                        }
                                    }
                                }
                                var GenStateSuspendedStart = "suspendedStart",
                                    GenStateExecuting = "executing",
                                    GenStateCompleted = "completed",
                                    ContinueSentinel = {};

                                function Generator() {}

                                function GeneratorFunction() {}

                                function GeneratorFunctionPrototype() {}
                                var IteratorPrototype = {};
                                IteratorPrototype[iteratorSymbol] = function() {
                                    return this
                                };
                                var getProto = Object.getPrototypeOf,
                                    NativeIteratorPrototype = getProto && getProto(getProto(values([])));
                                if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
                                    IteratorPrototype = NativeIteratorPrototype
                                }
                                var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
                                GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
                                GeneratorFunctionPrototype.constructor = GeneratorFunction;
                                GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction";

                                function defineIteratorMethods(prototype) {
                                    ["next", "throw", "return"].forEach(function(method) {
                                        prototype[method] = function(arg) {
                                            return this._invoke(method, arg)
                                        }
                                    })
                                }
                                runtime.isGeneratorFunction = function(genFun) {
                                    var ctor = "function" === typeof genFun && genFun.constructor;
                                    return ctor ? ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name) : !1
                                };
                                runtime.mark = function(genFun) {
                                    if (Object.setPrototypeOf) {
                                        Object.setPrototypeOf(genFun, GeneratorFunctionPrototype)
                                    } else {
                                        genFun.__proto__ = GeneratorFunctionPrototype;
                                        if (!(toStringTagSymbol in genFun)) {
                                            genFun[toStringTagSymbol] = "GeneratorFunction"
                                        }
                                    }
                                    genFun.prototype = Object.create(Gp);
                                    return genFun
                                };
                                runtime.awrap = function(arg) {
                                    return {
                                        __await: arg
                                    }
                                };

                                function AsyncIterator(generator) {
                                    function invoke(method, arg, resolve, reject) {
                                        var record = tryCatch(generator[method], generator, arg);
                                        if ("throw" === record.type) {
                                            reject(record.arg)
                                        } else {
                                            var result = record.arg,
                                                value = result.value;
                                            if (value && "object" === typeof value && hasOwn.call(value, "__await")) {
                                                return Promise.resolve(value.__await).then(function(value) {
                                                    invoke("next", value, resolve, reject)
                                                }, function(err) {
                                                    invoke("throw", err, resolve, reject)
                                                })
                                            }
                                            return Promise.resolve(value).then(function(unwrapped) {
                                                result.value = unwrapped;
                                                resolve(result)
                                            }, reject)
                                        }
                                    }
                                    if ("object" === typeof global.process && global.process.domain) {
                                        invoke = global.process.domain.bind(invoke)
                                    }
                                    var previousPromise;

                                    function enqueue(method, arg) {
                                        function callInvokeWithMethodAndArg() {
                                            return new Promise(function(resolve, reject) {
                                                invoke(method, arg, resolve, reject)
                                            })
                                        }
                                        return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg()
                                    }
                                    this._invoke = enqueue
                                }
                                defineIteratorMethods(AsyncIterator.prototype);
                                AsyncIterator.prototype[asyncIteratorSymbol] = function() {
                                    return this
                                };
                                runtime.AsyncIterator = AsyncIterator;
                                runtime.async = function(innerFn, outerFn, self, tryLocsList) {
                                    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList));
                                    return runtime.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
                                        return result.done ? result.value : iter.next()
                                    })
                                };

                                function makeInvokeMethod(innerFn, self, context) {
                                    var state = GenStateSuspendedStart;
                                    return function(method, arg) {
                                        if (state === GenStateExecuting) {
                                            throw new Error("Generator is already running")
                                        }
                                        if (state === GenStateCompleted) {
                                            if ("throw" === method) {
                                                throw arg
                                            }
                                            return doneResult()
                                        }
                                        context.method = method;
                                        context.arg = arg;
                                        while (!0) {
                                            var delegate = context.delegate;
                                            if (delegate) {
                                                var delegateResult = maybeInvokeDelegate(delegate, context);
                                                if (delegateResult) {
                                                    if (delegateResult === ContinueSentinel) continue;
                                                    return delegateResult
                                                }
                                            }
                                            if ("next" === context.method) {
                                                context.sent = context._sent = context.arg
                                            } else if ("throw" === context.method) {
                                                if (state === GenStateSuspendedStart) {
                                                    state = GenStateCompleted;
                                                    throw context.arg
                                                }
                                                context.dispatchException(context.arg)
                                            } else if ("return" === context.method) {
                                                context.abrupt("return", context.arg)
                                            }
                                            state = GenStateExecuting;
                                            var record = tryCatch(innerFn, self, context);
                                            if ("normal" === record.type) {
                                                state = context.done ? GenStateCompleted : "suspendedYield";
                                                if (record.arg === ContinueSentinel) {
                                                    continue
                                                }
                                                return {
                                                    value: record.arg,
                                                    done: context.done
                                                }
                                            } else if ("throw" === record.type) {
                                                state = GenStateCompleted;
                                                context.method = "throw";
                                                context.arg = record.arg
                                            }
                                        }
                                    }
                                }

                                function maybeInvokeDelegate(delegate, context) {
                                    var method = delegate.iterator[context.method];
                                    if (method === void 0) {
                                        context.delegate = null;
                                        if ("throw" === context.method) {
                                            if (delegate.iterator.return) {
                                                context.method = "return";
                                                context.arg = void 0;
                                                maybeInvokeDelegate(delegate, context);
                                                if ("throw" === context.method) {
                                                    return ContinueSentinel
                                                }
                                            }
                                            context.method = "throw";
                                            context.arg = new TypeError("The iterator does not provide a 'throw' method")
                                        }
                                        return ContinueSentinel
                                    }
                                    var record = tryCatch(method, delegate.iterator, context.arg);
                                    if ("throw" === record.type) {
                                        context.method = "throw";
                                        context.arg = record.arg;
                                        context.delegate = null;
                                        return ContinueSentinel
                                    }
                                    var info = record.arg;
                                    if (!info) {
                                        context.method = "throw";
                                        context.arg = new TypeError("iterator result is not an object");
                                        context.delegate = null;
                                        return ContinueSentinel
                                    }
                                    if (info.done) {
                                        context[delegate.resultName] = info.value;
                                        context.next = delegate.nextLoc;
                                        if ("return" !== context.method) {
                                            context.method = "next";
                                            context.arg = void 0
                                        }
                                    } else {
                                        return info
                                    }
                                    context.delegate = null;
                                    return ContinueSentinel
                                }
                                defineIteratorMethods(Gp);
                                Gp[toStringTagSymbol] = "Generator";
                                Gp[iteratorSymbol] = function() {
                                    return this
                                };
                                Gp.toString = function() {
                                    return "[object Generator]"
                                };

                                function pushTryEntry(locs) {
                                    var entry = {
                                        tryLoc: locs[0]
                                    };
                                    if (1 in locs) {
                                        entry.catchLoc = locs[1]
                                    }
                                    if (2 in locs) {
                                        entry.finallyLoc = locs[2];
                                        entry.afterLoc = locs[3]
                                    }
                                    this.tryEntries.push(entry)
                                }

                                function resetTryEntry(entry) {
                                    var record = entry.completion || {};
                                    record.type = "normal";
                                    delete record.arg;
                                    entry.completion = record
                                }

                                function Context(tryLocsList) {
                                    this.tryEntries = [{
                                        tryLoc: "root"
                                    }];
                                    tryLocsList.forEach(pushTryEntry, this);
                                    this.reset(!0)
                                }
                                runtime.keys = function(object) {
                                    var keys = [];
                                    for (var key in object) {
                                        keys.push(key)
                                    }
                                    keys.reverse();
                                    return function next() {
                                        while (keys.length) {
                                            var key = keys.pop();
                                            if (key in object) {
                                                next.value = key;
                                                next.done = !1;
                                                return next
                                            }
                                        }
                                        next.done = !0;
                                        return next
                                    }
                                };

                                function values(iterable) {
                                    if (iterable) {
                                        var iteratorMethod = iterable[iteratorSymbol];
                                        if (iteratorMethod) {
                                            return iteratorMethod.call(iterable)
                                        }
                                        if ("function" === typeof iterable.next) {
                                            return iterable
                                        }
                                        if (!isNaN(iterable.length)) {
                                            var i = -1,
                                                next = function next() {
                                                    while (++i < iterable.length) {
                                                        if (hasOwn.call(iterable, i)) {
                                                            next.value = iterable[i];
                                                            next.done = !1;
                                                            return next
                                                        }
                                                    }
                                                    next.value = void 0;
                                                    next.done = !0;
                                                    return next
                                                };
                                            return next.next = next
                                        }
                                    }
                                    return {
                                        next: doneResult
                                    }
                                }
                                runtime.values = values;

                                function doneResult() {
                                    return {
                                        value: void 0,
                                        done: !0
                                    }
                                }
                                Context.prototype = {
                                    constructor: Context,
                                    reset: function(skipTempReset) {
                                        this.prev = 0;
                                        this.next = 0;
                                        this.sent = this._sent = void 0;
                                        this.done = !1;
                                        this.delegate = null;
                                        this.method = "next";
                                        this.arg = void 0;
                                        this.tryEntries.forEach(resetTryEntry);
                                        if (!skipTempReset) {
                                            for (var name in this) {
                                                if ("t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
                                                    this[name] = void 0
                                                }
                                            }
                                        }
                                    },
                                    stop: function() {
                                        this.done = !0;
                                        var rootEntry = this.tryEntries[0],
                                            rootRecord = rootEntry.completion;
                                        if ("throw" === rootRecord.type) {
                                            throw rootRecord.arg
                                        }
                                        return this.rval
                                    },
                                    dispatchException: function(exception) {
                                        if (this.done) {
                                            throw exception
                                        }
                                        var context = this;

                                        function handle(loc, caught) {
                                            record.type = "throw";
                                            record.arg = exception;
                                            context.next = loc;
                                            if (caught) {
                                                context.method = "next";
                                                context.arg = void 0
                                            }
                                            return !!caught
                                        }
                                        for (var i = this.tryEntries.length - 1; 0 <= i; --i) {
                                            var entry = this.tryEntries[i],
                                                record = entry.completion;
                                            if ("root" === entry.tryLoc) {
                                                return handle("end")
                                            }
                                            if (entry.tryLoc <= this.prev) {
                                                var hasCatch = hasOwn.call(entry, "catchLoc"),
                                                    hasFinally = hasOwn.call(entry, "finallyLoc");
                                                if (hasCatch && hasFinally) {
                                                    if (this.prev < entry.catchLoc) {
                                                        return handle(entry.catchLoc, !0)
                                                    } else if (this.prev < entry.finallyLoc) {
                                                        return handle(entry.finallyLoc)
                                                    }
                                                } else if (hasCatch) {
                                                    if (this.prev < entry.catchLoc) {
                                                        return handle(entry.catchLoc, !0)
                                                    }
                                                } else if (hasFinally) {
                                                    if (this.prev < entry.finallyLoc) {
                                                        return handle(entry.finallyLoc)
                                                    }
                                                } else {
                                                    throw new Error("try statement without catch or finally")
                                                }
                                            }
                                        }
                                    },
                                    abrupt: function(type, arg) {
                                        for (var i = this.tryEntries.length - 1, entry; 0 <= i; --i) {
                                            entry = this.tryEntries[i];
                                            if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
                                                var finallyEntry = entry;
                                                break
                                            }
                                        }
                                        if (finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
                                            finallyEntry = null
                                        }
                                        var record = finallyEntry ? finallyEntry.completion : {};
                                        record.type = type;
                                        record.arg = arg;
                                        if (finallyEntry) {
                                            this.method = "next";
                                            this.next = finallyEntry.finallyLoc;
                                            return ContinueSentinel
                                        }
                                        return this.complete(record)
                                    },
                                    complete: function(record, afterLoc) {
                                        if ("throw" === record.type) {
                                            throw record.arg
                                        }
                                        if ("break" === record.type || "continue" === record.type) {
                                            this.next = record.arg
                                        } else if ("return" === record.type) {
                                            this.rval = this.arg = record.arg;
                                            this.method = "return";
                                            this.next = "end"
                                        } else if ("normal" === record.type && afterLoc) {
                                            this.next = afterLoc
                                        }
                                        return ContinueSentinel
                                    },
                                    finish: function(finallyLoc) {
                                        for (var i = this.tryEntries.length - 1, entry; 0 <= i; --i) {
                                            entry = this.tryEntries[i];
                                            if (entry.finallyLoc === finallyLoc) {
                                                this.complete(entry.completion, entry.afterLoc);
                                                resetTryEntry(entry);
                                                return ContinueSentinel
                                            }
                                        }
                                    },
                                    catch: function(tryLoc) {
                                        for (var i = this.tryEntries.length - 1, entry; 0 <= i; --i) {
                                            entry = this.tryEntries[i];
                                            if (entry.tryLoc === tryLoc) {
                                                var record = entry.completion;
                                                if ("throw" === record.type) {
                                                    var thrown = record.arg;
                                                    resetTryEntry(entry)
                                                }
                                                return thrown
                                            }
                                        }
                                        throw new Error("illegal catch attempt")
                                    },
                                    delegateYield: function(iterable, resultName, nextLoc) {
                                        this.delegate = {
                                            iterator: values(iterable),
                                            resultName: resultName,
                                            nextLoc: nextLoc
                                        };
                                        if ("next" === this.method) {
                                            this.arg = void 0
                                        }
                                        return ContinueSentinel
                                    }
                                }
                            }("object" === typeof global ? global : "object" === typeof window ? window : "object" === typeof self ? self : this)
                        }).call(this, "undefined" !== typeof global ? global : "undefined" !== typeof self ? self : "undefined" !== typeof window ? window : {})
                    }, {}],
                    419: [function(require, module) {
                        (function(Buffer) {
                            "use strict";
                            var inherits = require("inherits"),
                                HashBase = require("hash-base");

                            function RIPEMD160() {
                                HashBase.call(this, 64);
                                this._a = 1732584193;
                                this._b = 4023233417;
                                this._c = 2562383102;
                                this._d = 271733878;
                                this._e = 3285377520
                            }
                            inherits(RIPEMD160, HashBase);
                            RIPEMD160.prototype._update = function() {
                                for (var m = Array(16), i = 0; 16 > i; ++i) m[i] = this._block.readInt32LE(4 * i);
                                var al = this._a,
                                    bl = this._b,
                                    cl = this._c,
                                    dl = this._d,
                                    el = this._e;
                                al = fn1(al, bl, cl, dl, el, m[0], 0, 11);
                                cl = rotl(cl, 10);
                                el = fn1(el, al, bl, cl, dl, m[1], 0, 14);
                                bl = rotl(bl, 10);
                                dl = fn1(dl, el, al, bl, cl, m[2], 0, 15);
                                al = rotl(al, 10);
                                cl = fn1(cl, dl, el, al, bl, m[3], 0, 12);
                                el = rotl(el, 10);
                                bl = fn1(bl, cl, dl, el, al, m[4], 0, 5);
                                dl = rotl(dl, 10);
                                al = fn1(al, bl, cl, dl, el, m[5], 0, 8);
                                cl = rotl(cl, 10);
                                el = fn1(el, al, bl, cl, dl, m[6], 0, 7);
                                bl = rotl(bl, 10);
                                dl = fn1(dl, el, al, bl, cl, m[7], 0, 9);
                                al = rotl(al, 10);
                                cl = fn1(cl, dl, el, al, bl, m[8], 0, 11);
                                el = rotl(el, 10);
                                bl = fn1(bl, cl, dl, el, al, m[9], 0, 13);
                                dl = rotl(dl, 10);
                                al = fn1(al, bl, cl, dl, el, m[10], 0, 14);
                                cl = rotl(cl, 10);
                                el = fn1(el, al, bl, cl, dl, m[11], 0, 15);
                                bl = rotl(bl, 10);
                                dl = fn1(dl, el, al, bl, cl, m[12], 0, 6);
                                al = rotl(al, 10);
                                cl = fn1(cl, dl, el, al, bl, m[13], 0, 7);
                                el = rotl(el, 10);
                                bl = fn1(bl, cl, dl, el, al, m[14], 0, 9);
                                dl = rotl(dl, 10);
                                al = fn1(al, bl, cl, dl, el, m[15], 0, 8);
                                cl = rotl(cl, 10);
                                el = fn2(el, al, bl, cl, dl, m[7], 1518500249, 7);
                                bl = rotl(bl, 10);
                                dl = fn2(dl, el, al, bl, cl, m[4], 1518500249, 6);
                                al = rotl(al, 10);
                                cl = fn2(cl, dl, el, al, bl, m[13], 1518500249, 8);
                                el = rotl(el, 10);
                                bl = fn2(bl, cl, dl, el, al, m[1], 1518500249, 13);
                                dl = rotl(dl, 10);
                                al = fn2(al, bl, cl, dl, el, m[10], 1518500249, 11);
                                cl = rotl(cl, 10);
                                el = fn2(el, al, bl, cl, dl, m[6], 1518500249, 9);
                                bl = rotl(bl, 10);
                                dl = fn2(dl, el, al, bl, cl, m[15], 1518500249, 7);
                                al = rotl(al, 10);
                                cl = fn2(cl, dl, el, al, bl, m[3], 1518500249, 15);
                                el = rotl(el, 10);
                                bl = fn2(bl, cl, dl, el, al, m[12], 1518500249, 7);
                                dl = rotl(dl, 10);
                                al = fn2(al, bl, cl, dl, el, m[0], 1518500249, 12);
                                cl = rotl(cl, 10);
                                el = fn2(el, al, bl, cl, dl, m[9], 1518500249, 15);
                                bl = rotl(bl, 10);
                                dl = fn2(dl, el, al, bl, cl, m[5], 1518500249, 9);
                                al = rotl(al, 10);
                                cl = fn2(cl, dl, el, al, bl, m[2], 1518500249, 11);
                                el = rotl(el, 10);
                                bl = fn2(bl, cl, dl, el, al, m[14], 1518500249, 7);
                                dl = rotl(dl, 10);
                                al = fn2(al, bl, cl, dl, el, m[11], 1518500249, 13);
                                cl = rotl(cl, 10);
                                el = fn2(el, al, bl, cl, dl, m[8], 1518500249, 12);
                                bl = rotl(bl, 10);
                                dl = fn3(dl, el, al, bl, cl, m[3], 1859775393, 11);
                                al = rotl(al, 10);
                                cl = fn3(cl, dl, el, al, bl, m[10], 1859775393, 13);
                                el = rotl(el, 10);
                                bl = fn3(bl, cl, dl, el, al, m[14], 1859775393, 6);
                                dl = rotl(dl, 10);
                                al = fn3(al, bl, cl, dl, el, m[4], 1859775393, 7);
                                cl = rotl(cl, 10);
                                el = fn3(el, al, bl, cl, dl, m[9], 1859775393, 14);
                                bl = rotl(bl, 10);
                                dl = fn3(dl, el, al, bl, cl, m[15], 1859775393, 9);
                                al = rotl(al, 10);
                                cl = fn3(cl, dl, el, al, bl, m[8], 1859775393, 13);
                                el = rotl(el, 10);
                                bl = fn3(bl, cl, dl, el, al, m[1], 1859775393, 15);
                                dl = rotl(dl, 10);
                                al = fn3(al, bl, cl, dl, el, m[2], 1859775393, 14);
                                cl = rotl(cl, 10);
                                el = fn3(el, al, bl, cl, dl, m[7], 1859775393, 8);
                                bl = rotl(bl, 10);
                                dl = fn3(dl, el, al, bl, cl, m[0], 1859775393, 13);
                                al = rotl(al, 10);
                                cl = fn3(cl, dl, el, al, bl, m[6], 1859775393, 6);
                                el = rotl(el, 10);
                                bl = fn3(bl, cl, dl, el, al, m[13], 1859775393, 5);
                                dl = rotl(dl, 10);
                                al = fn3(al, bl, cl, dl, el, m[11], 1859775393, 12);
                                cl = rotl(cl, 10);
                                el = fn3(el, al, bl, cl, dl, m[5], 1859775393, 7);
                                bl = rotl(bl, 10);
                                dl = fn3(dl, el, al, bl, cl, m[12], 1859775393, 5);
                                al = rotl(al, 10);
                                cl = fn4(cl, dl, el, al, bl, m[1], 2400959708, 11);
                                el = rotl(el, 10);
                                bl = fn4(bl, cl, dl, el, al, m[9], 2400959708, 12);
                                dl = rotl(dl, 10);
                                al = fn4(al, bl, cl, dl, el, m[11], 2400959708, 14);
                                cl = rotl(cl, 10);
                                el = fn4(el, al, bl, cl, dl, m[10], 2400959708, 15);
                                bl = rotl(bl, 10);
                                dl = fn4(dl, el, al, bl, cl, m[0], 2400959708, 14);
                                al = rotl(al, 10);
                                cl = fn4(cl, dl, el, al, bl, m[8], 2400959708, 15);
                                el = rotl(el, 10);
                                bl = fn4(bl, cl, dl, el, al, m[12], 2400959708, 9);
                                dl = rotl(dl, 10);
                                al = fn4(al, bl, cl, dl, el, m[4], 2400959708, 8);
                                cl = rotl(cl, 10);
                                el = fn4(el, al, bl, cl, dl, m[13], 2400959708, 9);
                                bl = rotl(bl, 10);
                                dl = fn4(dl, el, al, bl, cl, m[3], 2400959708, 14);
                                al = rotl(al, 10);
                                cl = fn4(cl, dl, el, al, bl, m[7], 2400959708, 5);
                                el = rotl(el, 10);
                                bl = fn4(bl, cl, dl, el, al, m[15], 2400959708, 6);
                                dl = rotl(dl, 10);
                                al = fn4(al, bl, cl, dl, el, m[14], 2400959708, 8);
                                cl = rotl(cl, 10);
                                el = fn4(el, al, bl, cl, dl, m[5], 2400959708, 6);
                                bl = rotl(bl, 10);
                                dl = fn4(dl, el, al, bl, cl, m[6], 2400959708, 5);
                                al = rotl(al, 10);
                                cl = fn4(cl, dl, el, al, bl, m[2], 2400959708, 12);
                                el = rotl(el, 10);
                                bl = fn5(bl, cl, dl, el, al, m[4], 2840853838, 9);
                                dl = rotl(dl, 10);
                                al = fn5(al, bl, cl, dl, el, m[0], 2840853838, 15);
                                cl = rotl(cl, 10);
                                el = fn5(el, al, bl, cl, dl, m[5], 2840853838, 5);
                                bl = rotl(bl, 10);
                                dl = fn5(dl, el, al, bl, cl, m[9], 2840853838, 11);
                                al = rotl(al, 10);
                                cl = fn5(cl, dl, el, al, bl, m[7], 2840853838, 6);
                                el = rotl(el, 10);
                                bl = fn5(bl, cl, dl, el, al, m[12], 2840853838, 8);
                                dl = rotl(dl, 10);
                                al = fn5(al, bl, cl, dl, el, m[2], 2840853838, 13);
                                cl = rotl(cl, 10);
                                el = fn5(el, al, bl, cl, dl, m[10], 2840853838, 12);
                                bl = rotl(bl, 10);
                                dl = fn5(dl, el, al, bl, cl, m[14], 2840853838, 5);
                                al = rotl(al, 10);
                                cl = fn5(cl, dl, el, al, bl, m[1], 2840853838, 12);
                                el = rotl(el, 10);
                                bl = fn5(bl, cl, dl, el, al, m[3], 2840853838, 13);
                                dl = rotl(dl, 10);
                                al = fn5(al, bl, cl, dl, el, m[8], 2840853838, 14);
                                cl = rotl(cl, 10);
                                el = fn5(el, al, bl, cl, dl, m[11], 2840853838, 11);
                                bl = rotl(bl, 10);
                                dl = fn5(dl, el, al, bl, cl, m[6], 2840853838, 8);
                                al = rotl(al, 10);
                                cl = fn5(cl, dl, el, al, bl, m[15], 2840853838, 5);
                                el = rotl(el, 10);
                                bl = fn5(bl, cl, dl, el, al, m[13], 2840853838, 6);
                                dl = rotl(dl, 10);
                                var ar = this._a,
                                    br = this._b,
                                    cr = this._c,
                                    dr = this._d,
                                    er = this._e;
                                ar = fn5(ar, br, cr, dr, er, m[5], 1352829926, 8);
                                cr = rotl(cr, 10);
                                er = fn5(er, ar, br, cr, dr, m[14], 1352829926, 9);
                                br = rotl(br, 10);
                                dr = fn5(dr, er, ar, br, cr, m[7], 1352829926, 9);
                                ar = rotl(ar, 10);
                                cr = fn5(cr, dr, er, ar, br, m[0], 1352829926, 11);
                                er = rotl(er, 10);
                                br = fn5(br, cr, dr, er, ar, m[9], 1352829926, 13);
                                dr = rotl(dr, 10);
                                ar = fn5(ar, br, cr, dr, er, m[2], 1352829926, 15);
                                cr = rotl(cr, 10);
                                er = fn5(er, ar, br, cr, dr, m[11], 1352829926, 15);
                                br = rotl(br, 10);
                                dr = fn5(dr, er, ar, br, cr, m[4], 1352829926, 5);
                                ar = rotl(ar, 10);
                                cr = fn5(cr, dr, er, ar, br, m[13], 1352829926, 7);
                                er = rotl(er, 10);
                                br = fn5(br, cr, dr, er, ar, m[6], 1352829926, 7);
                                dr = rotl(dr, 10);
                                ar = fn5(ar, br, cr, dr, er, m[15], 1352829926, 8);
                                cr = rotl(cr, 10);
                                er = fn5(er, ar, br, cr, dr, m[8], 1352829926, 11);
                                br = rotl(br, 10);
                                dr = fn5(dr, er, ar, br, cr, m[1], 1352829926, 14);
                                ar = rotl(ar, 10);
                                cr = fn5(cr, dr, er, ar, br, m[10], 1352829926, 14);
                                er = rotl(er, 10);
                                br = fn5(br, cr, dr, er, ar, m[3], 1352829926, 12);
                                dr = rotl(dr, 10);
                                ar = fn5(ar, br, cr, dr, er, m[12], 1352829926, 6);
                                cr = rotl(cr, 10);
                                er = fn4(er, ar, br, cr, dr, m[6], 1548603684, 9);
                                br = rotl(br, 10);
                                dr = fn4(dr, er, ar, br, cr, m[11], 1548603684, 13);
                                ar = rotl(ar, 10);
                                cr = fn4(cr, dr, er, ar, br, m[3], 1548603684, 15);
                                er = rotl(er, 10);
                                br = fn4(br, cr, dr, er, ar, m[7], 1548603684, 7);
                                dr = rotl(dr, 10);
                                ar = fn4(ar, br, cr, dr, er, m[0], 1548603684, 12);
                                cr = rotl(cr, 10);
                                er = fn4(er, ar, br, cr, dr, m[13], 1548603684, 8);
                                br = rotl(br, 10);
                                dr = fn4(dr, er, ar, br, cr, m[5], 1548603684, 9);
                                ar = rotl(ar, 10);
                                cr = fn4(cr, dr, er, ar, br, m[10], 1548603684, 11);
                                er = rotl(er, 10);
                                br = fn4(br, cr, dr, er, ar, m[14], 1548603684, 7);
                                dr = rotl(dr, 10);
                                ar = fn4(ar, br, cr, dr, er, m[15], 1548603684, 7);
                                cr = rotl(cr, 10);
                                er = fn4(er, ar, br, cr, dr, m[8], 1548603684, 12);
                                br = rotl(br, 10);
                                dr = fn4(dr, er, ar, br, cr, m[12], 1548603684, 7);
                                ar = rotl(ar, 10);
                                cr = fn4(cr, dr, er, ar, br, m[4], 1548603684, 6);
                                er = rotl(er, 10);
                                br = fn4(br, cr, dr, er, ar, m[9], 1548603684, 15);
                                dr = rotl(dr, 10);
                                ar = fn4(ar, br, cr, dr, er, m[1], 1548603684, 13);
                                cr = rotl(cr, 10);
                                er = fn4(er, ar, br, cr, dr, m[2], 1548603684, 11);
                                br = rotl(br, 10);
                                dr = fn3(dr, er, ar, br, cr, m[15], 1836072691, 9);
                                ar = rotl(ar, 10);
                                cr = fn3(cr, dr, er, ar, br, m[5], 1836072691, 7);
                                er = rotl(er, 10);
                                br = fn3(br, cr, dr, er, ar, m[1], 1836072691, 15);
                                dr = rotl(dr, 10);
                                ar = fn3(ar, br, cr, dr, er, m[3], 1836072691, 11);
                                cr = rotl(cr, 10);
                                er = fn3(er, ar, br, cr, dr, m[7], 1836072691, 8);
                                br = rotl(br, 10);
                                dr = fn3(dr, er, ar, br, cr, m[14], 1836072691, 6);
                                ar = rotl(ar, 10);
                                cr = fn3(cr, dr, er, ar, br, m[6], 1836072691, 6);
                                er = rotl(er, 10);
                                br = fn3(br, cr, dr, er, ar, m[9], 1836072691, 14);
                                dr = rotl(dr, 10);
                                ar = fn3(ar, br, cr, dr, er, m[11], 1836072691, 12);
                                cr = rotl(cr, 10);
                                er = fn3(er, ar, br, cr, dr, m[8], 1836072691, 13);
                                br = rotl(br, 10);
                                dr = fn3(dr, er, ar, br, cr, m[12], 1836072691, 5);
                                ar = rotl(ar, 10);
                                cr = fn3(cr, dr, er, ar, br, m[2], 1836072691, 14);
                                er = rotl(er, 10);
                                br = fn3(br, cr, dr, er, ar, m[10], 1836072691, 13);
                                dr = rotl(dr, 10);
                                ar = fn3(ar, br, cr, dr, er, m[0], 1836072691, 13);
                                cr = rotl(cr, 10);
                                er = fn3(er, ar, br, cr, dr, m[4], 1836072691, 7);
                                br = rotl(br, 10);
                                dr = fn3(dr, er, ar, br, cr, m[13], 1836072691, 5);
                                ar = rotl(ar, 10);
                                cr = fn2(cr, dr, er, ar, br, m[8], 2053994217, 15);
                                er = rotl(er, 10);
                                br = fn2(br, cr, dr, er, ar, m[6], 2053994217, 5);
                                dr = rotl(dr, 10);
                                ar = fn2(ar, br, cr, dr, er, m[4], 2053994217, 8);
                                cr = rotl(cr, 10);
                                er = fn2(er, ar, br, cr, dr, m[1], 2053994217, 11);
                                br = rotl(br, 10);
                                dr = fn2(dr, er, ar, br, cr, m[3], 2053994217, 14);
                                ar = rotl(ar, 10);
                                cr = fn2(cr, dr, er, ar, br, m[11], 2053994217, 14);
                                er = rotl(er, 10);
                                br = fn2(br, cr, dr, er, ar, m[15], 2053994217, 6);
                                dr = rotl(dr, 10);
                                ar = fn2(ar, br, cr, dr, er, m[0], 2053994217, 14);
                                cr = rotl(cr, 10);
                                er = fn2(er, ar, br, cr, dr, m[5], 2053994217, 6);
                                br = rotl(br, 10);
                                dr = fn2(dr, er, ar, br, cr, m[12], 2053994217, 9);
                                ar = rotl(ar, 10);
                                cr = fn2(cr, dr, er, ar, br, m[2], 2053994217, 12);
                                er = rotl(er, 10);
                                br = fn2(br, cr, dr, er, ar, m[13], 2053994217, 9);
                                dr = rotl(dr, 10);
                                ar = fn2(ar, br, cr, dr, er, m[9], 2053994217, 12);
                                cr = rotl(cr, 10);
                                er = fn2(er, ar, br, cr, dr, m[7], 2053994217, 5);
                                br = rotl(br, 10);
                                dr = fn2(dr, er, ar, br, cr, m[10], 2053994217, 15);
                                ar = rotl(ar, 10);
                                cr = fn2(cr, dr, er, ar, br, m[14], 2053994217, 8);
                                er = rotl(er, 10);
                                br = fn1(br, cr, dr, er, ar, m[12], 0, 8);
                                dr = rotl(dr, 10);
                                ar = fn1(ar, br, cr, dr, er, m[15], 0, 5);
                                cr = rotl(cr, 10);
                                er = fn1(er, ar, br, cr, dr, m[10], 0, 12);
                                br = rotl(br, 10);
                                dr = fn1(dr, er, ar, br, cr, m[4], 0, 9);
                                ar = rotl(ar, 10);
                                cr = fn1(cr, dr, er, ar, br, m[1], 0, 12);
                                er = rotl(er, 10);
                                br = fn1(br, cr, dr, er, ar, m[5], 0, 5);
                                dr = rotl(dr, 10);
                                ar = fn1(ar, br, cr, dr, er, m[8], 0, 14);
                                cr = rotl(cr, 10);
                                er = fn1(er, ar, br, cr, dr, m[7], 0, 6);
                                br = rotl(br, 10);
                                dr = fn1(dr, er, ar, br, cr, m[6], 0, 8);
                                ar = rotl(ar, 10);
                                cr = fn1(cr, dr, er, ar, br, m[2], 0, 13);
                                er = rotl(er, 10);
                                br = fn1(br, cr, dr, er, ar, m[13], 0, 6);
                                dr = rotl(dr, 10);
                                ar = fn1(ar, br, cr, dr, er, m[14], 0, 5);
                                cr = rotl(cr, 10);
                                er = fn1(er, ar, br, cr, dr, m[0], 0, 15);
                                br = rotl(br, 10);
                                dr = fn1(dr, er, ar, br, cr, m[3], 0, 13);
                                ar = rotl(ar, 10);
                                cr = fn1(cr, dr, er, ar, br, m[9], 0, 11);
                                er = rotl(er, 10);
                                br = fn1(br, cr, dr, er, ar, m[11], 0, 11);
                                dr = rotl(dr, 10);
                                var t = 0 | this._b + cl + dr;
                                this._b = 0 | this._c + dl + er;
                                this._c = 0 | this._d + el + ar;
                                this._d = 0 | this._e + al + br;
                                this._e = 0 | this._a + bl + cr;
                                this._a = t
                            };
                            RIPEMD160.prototype._digest = function() {
                                this._block[this._blockOffset++] = 128;
                                if (56 < this._blockOffset) {
                                    this._block.fill(0, this._blockOffset, 64);
                                    this._update();
                                    this._blockOffset = 0
                                }
                                this._block.fill(0, this._blockOffset, 56);
                                this._block.writeUInt32LE(this._length[0], 56);
                                this._block.writeUInt32LE(this._length[1], 60);
                                this._update();
                                var buffer = new Buffer(20);
                                buffer.writeInt32LE(this._a, 0);
                                buffer.writeInt32LE(this._b, 4);
                                buffer.writeInt32LE(this._c, 8);
                                buffer.writeInt32LE(this._d, 12);
                                buffer.writeInt32LE(this._e, 16);
                                return buffer
                            };

                            function rotl(x, n) {
                                return x << n | x >>> 32 - n
                            }

                            function fn1(a, b, c, d, e, m, k, s) {
                                return 0 | rotl(0 | a + (b ^ c ^ d) + m + k, s) + e
                            }

                            function fn2(a, b, c, d, e, m, k, s) {
                                return 0 | rotl(0 | a + (b & c | ~b & d) + m + k, s) + e
                            }

                            function fn3(a, b, c, d, e, m, k, s) {
                                return 0 | rotl(0 | a + ((b | ~c) ^ d) + m + k, s) + e
                            }

                            function fn4(a, b, c, d, e, m, k, s) {
                                return 0 | rotl(0 | a + (b & d | c & ~d) + m + k, s) + e
                            }

                            function fn5(a, b, c, d, e, m, k, s) {
                                return 0 | rotl(0 | a + (b ^ (c | ~d)) + m + k, s) + e
                            }
                            module.exports = RIPEMD160
                        }).call(this, require("buffer").Buffer)
                    }, {
                        buffer: 45,
                        "hash-base": 389,
                        inherits: 392
                    }],
                    420: [function(require, module, exports) {
                        var buffer = require("buffer"),
                            Buffer = buffer.Buffer;

                        function copyProps(src, dst) {
                            for (var key in src) {
                                dst[key] = src[key]
                            }
                        }
                        if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
                            module.exports = buffer
                        } else {
                            copyProps(buffer, exports);
                            exports.Buffer = SafeBuffer
                        }

                        function SafeBuffer(arg, encodingOrOffset, length) {
                            return Buffer(arg, encodingOrOffset, length)
                        }
                        copyProps(Buffer, SafeBuffer);
                        SafeBuffer.from = function(arg, encodingOrOffset, length) {
                            if ("number" === typeof arg) {
                                throw new TypeError("Argument must not be a number")
                            }
                            return Buffer(arg, encodingOrOffset, length)
                        };
                        SafeBuffer.alloc = function(size, fill, encoding) {
                            if ("number" !== typeof size) {
                                throw new TypeError("Argument must be a number")
                            }
                            var buf = Buffer(size);
                            if (fill !== void 0) {
                                if ("string" === typeof encoding) {
                                    buf.fill(fill, encoding)
                                } else {
                                    buf.fill(fill)
                                }
                            } else {
                                buf.fill(0)
                            }
                            return buf
                        };
                        SafeBuffer.allocUnsafe = function(size) {
                            if ("number" !== typeof size) {
                                throw new TypeError("Argument must be a number")
                            }
                            return Buffer(size)
                        };
                        SafeBuffer.allocUnsafeSlow = function(size) {
                            if ("number" !== typeof size) {
                                throw new TypeError("Argument must be a number")
                            }
                            return buffer.SlowBuffer(size)
                        }
                    }, {
                        buffer: 45
                    }],
                    421: [function(require, module) {
                        var Buffer = require("safe-buffer").Buffer;

                        function Hash(blockSize, finalSize) {
                            this._block = Buffer.alloc(blockSize);
                            this._finalSize = finalSize;
                            this._blockSize = blockSize;
                            this._len = 0
                        }
                        Hash.prototype.update = function(data, enc) {
                            if ("string" === typeof data) {
                                enc = enc || "utf8";
                                data = Buffer.from(data, enc)
                            }
                            for (var block = this._block, blockSize = this._blockSize, length = data.length, accum = this._len, offset = 0; offset < length;) {
                                for (var assigned = accum % blockSize, remainder = _Mathmin(length - offset, blockSize - assigned), i = 0; i < remainder; i++) {
                                    block[assigned + i] = data[offset + i]
                                }
                                accum += remainder;
                                offset += remainder;
                                if (0 === accum % blockSize) {
                                    this._update(block)
                                }
                            }
                            this._len += length;
                            return this
                        };
                        Hash.prototype.digest = function(enc) {
                            var rem = this._len % this._blockSize;
                            this._block[rem] = 128;
                            this._block.fill(0, rem + 1);
                            if (rem >= this._finalSize) {
                                this._update(this._block);
                                this._block.fill(0)
                            }
                            var bits = 8 * this._len;
                            if (4294967295 >= bits) {
                                this._block.writeUInt32BE(bits, this._blockSize - 4)
                            } else {
                                var lowBits = (4294967295 & bits) >>> 0;
                                this._block.writeUInt32BE((bits - lowBits) / 4294967296, this._blockSize - 8);
                                this._block.writeUInt32BE(lowBits, this._blockSize - 4)
                            }
                            this._update(this._block);
                            var hash = this._hash();
                            return enc ? hash.toString(enc) : hash
                        };
                        Hash.prototype._update = function() {
                            throw new Error("_update must be implemented by subclass")
                        };
                        module.exports = Hash
                    }, {
                        "safe-buffer": 420
                    }],
                    422: [function(require, module, exports) {
                        var exports = module.exports = function(algorithm) {
                            algorithm = algorithm.toLowerCase();
                            var Algorithm = exports[algorithm];
                            if (!Algorithm) throw new Error(algorithm + " is not supported (we accept pull requests)");
                            return new Algorithm
                        };
                        exports.sha = require("./sha");
                        exports.sha1 = require("./sha1");
                        exports.sha224 = require("./sha224");
                        exports.sha256 = require("./sha256");
                        exports.sha384 = require("./sha384");
                        exports.sha512 = require("./sha512")
                    }, {
                        "./sha": 423,
                        "./sha1": 424,
                        "./sha224": 425,
                        "./sha256": 426,
                        "./sha384": 427,
                        "./sha512": 428
                    }],
                    423: [function(require, module) {
                        var inherits = require("inherits"),
                            Hash = require("./hash"),
                            Buffer = require("safe-buffer").Buffer,
                            K = [1518500249, 1859775393, 0 | 2400959708, 0 | 3395469782],
                            W = Array(80);

                        function Sha() {
                            this.init();
                            this._w = W;
                            Hash.call(this, 64, 56)
                        }
                        inherits(Sha, Hash);
                        Sha.prototype.init = function() {
                            this._a = 1732584193;
                            this._b = 4023233417;
                            this._c = 2562383102;
                            this._d = 271733878;
                            this._e = 3285377520;
                            return this
                        };

                        function rotl5(num) {
                            return num << 5 | num >>> 27
                        }

                        function rotl30(num) {
                            return num << 30 | num >>> 2
                        }

                        function ft(s, b, c, d) {
                            if (0 === s) return b & c | ~b & d;
                            if (2 === s) return b & c | b & d | c & d;
                            return b ^ c ^ d
                        }
                        Sha.prototype._update = function(M) {
                            for (var W = this._w, a = 0 | this._a, b = 0 | this._b, c = 0 | this._c, d = 0 | this._d, e = 0 | this._e, i = 0; 16 > i; ++i) W[i] = M.readInt32BE(4 * i);
                            for (; 80 > i; ++i) W[i] = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
                            for (var j = 0; 80 > j; ++j) {
                                var s = ~~(j / 20),
                                    t = 0 | rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s];
                                e = d;
                                d = c;
                                c = rotl30(b);
                                b = a;
                                a = t
                            }
                            this._a = 0 | a + this._a;
                            this._b = 0 | b + this._b;
                            this._c = 0 | c + this._c;
                            this._d = 0 | d + this._d;
                            this._e = 0 | e + this._e
                        };
                        Sha.prototype._hash = function() {
                            var H = Buffer.allocUnsafe(20);
                            H.writeInt32BE(0 | this._a, 0);
                            H.writeInt32BE(0 | this._b, 4);
                            H.writeInt32BE(0 | this._c, 8);
                            H.writeInt32BE(0 | this._d, 12);
                            H.writeInt32BE(0 | this._e, 16);
                            return H
                        };
                        module.exports = Sha
                    }, {
                        "./hash": 421,
                        inherits: 392,
                        "safe-buffer": 420
                    }],
                    424: [function(require, module) {
                        var inherits = require("inherits"),
                            Hash = require("./hash"),
                            Buffer = require("safe-buffer").Buffer,
                            K = [1518500249, 1859775393, 0 | 2400959708, 0 | 3395469782],
                            W = Array(80);

                        function Sha1() {
                            this.init();
                            this._w = W;
                            Hash.call(this, 64, 56)
                        }
                        inherits(Sha1, Hash);
                        Sha1.prototype.init = function() {
                            this._a = 1732584193;
                            this._b = 4023233417;
                            this._c = 2562383102;
                            this._d = 271733878;
                            this._e = 3285377520;
                            return this
                        };

                        function rotl1(num) {
                            return num << 1 | num >>> 31
                        }

                        function rotl5(num) {
                            return num << 5 | num >>> 27
                        }

                        function rotl30(num) {
                            return num << 30 | num >>> 2
                        }

                        function ft(s, b, c, d) {
                            if (0 === s) return b & c | ~b & d;
                            if (2 === s) return b & c | b & d | c & d;
                            return b ^ c ^ d
                        }
                        Sha1.prototype._update = function(M) {
                            for (var W = this._w, a = 0 | this._a, b = 0 | this._b, c = 0 | this._c, d = 0 | this._d, e = 0 | this._e, i = 0; 16 > i; ++i) W[i] = M.readInt32BE(4 * i);
                            for (; 80 > i; ++i) W[i] = rotl1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16]);
                            for (var j = 0; 80 > j; ++j) {
                                var s = ~~(j / 20),
                                    t = 0 | rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s];
                                e = d;
                                d = c;
                                c = rotl30(b);
                                b = a;
                                a = t
                            }
                            this._a = 0 | a + this._a;
                            this._b = 0 | b + this._b;
                            this._c = 0 | c + this._c;
                            this._d = 0 | d + this._d;
                            this._e = 0 | e + this._e
                        };
                        Sha1.prototype._hash = function() {
                            var H = Buffer.allocUnsafe(20);
                            H.writeInt32BE(0 | this._a, 0);
                            H.writeInt32BE(0 | this._b, 4);
                            H.writeInt32BE(0 | this._c, 8);
                            H.writeInt32BE(0 | this._d, 12);
                            H.writeInt32BE(0 | this._e, 16);
                            return H
                        };
                        module.exports = Sha1
                    }, {
                        "./hash": 421,
                        inherits: 392,
                        "safe-buffer": 420
                    }],
                    425: [function(require, module) {
                        var inherits = require("inherits"),
                            Sha256 = require("./sha256"),
                            Hash = require("./hash"),
                            Buffer = require("safe-buffer").Buffer,
                            W = Array(64);

                        function Sha224() {
                            this.init();
                            this._w = W;
                            Hash.call(this, 64, 56)
                        }
                        inherits(Sha224, Sha256);
                        Sha224.prototype.init = function() {
                            this._a = 3238371032;
                            this._b = 914150663;
                            this._c = 812702999;
                            this._d = 4144912697;
                            this._e = 4290775857;
                            this._f = 1750603025;
                            this._g = 1694076839;
                            this._h = 3204075428;
                            return this
                        };
                        Sha224.prototype._hash = function() {
                            var H = Buffer.allocUnsafe(28);
                            H.writeInt32BE(this._a, 0);
                            H.writeInt32BE(this._b, 4);
                            H.writeInt32BE(this._c, 8);
                            H.writeInt32BE(this._d, 12);
                            H.writeInt32BE(this._e, 16);
                            H.writeInt32BE(this._f, 20);
                            H.writeInt32BE(this._g, 24);
                            return H
                        };
                        module.exports = Sha224
                    }, {
                        "./hash": 421,
                        "./sha256": 426,
                        inherits: 392,
                        "safe-buffer": 420
                    }],
                    426: [function(require, module) {
                        var inherits = require("inherits"),
                            Hash = require("./hash"),
                            Buffer = require("safe-buffer").Buffer,
                            K = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298],
                            W = Array(64);

                        function Sha256() {
                            this.init();
                            this._w = W;
                            Hash.call(this, 64, 56)
                        }
                        inherits(Sha256, Hash);
                        Sha256.prototype.init = function() {
                            this._a = 1779033703;
                            this._b = 3144134277;
                            this._c = 1013904242;
                            this._d = 2773480762;
                            this._e = 1359893119;
                            this._f = 2600822924;
                            this._g = 528734635;
                            this._h = 1541459225;
                            return this
                        };

                        function ch(x, y, z) {
                            return z ^ x & (y ^ z)
                        }

                        function maj(x, y, z) {
                            return x & y | z & (x | y)
                        }

                        function sigma0(x) {
                            return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10)
                        }

                        function sigma1(x) {
                            return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7)
                        }

                        function gamma0(x) {
                            return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ x >>> 3
                        }

                        function gamma1(x) {
                            return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ x >>> 10
                        }
                        Sha256.prototype._update = function(M) {
                            for (var W = this._w, a = 0 | this._a, b = 0 | this._b, c = 0 | this._c, d = 0 | this._d, e = 0 | this._e, f = 0 | this._f, g = 0 | this._g, h = 0 | this._h, i = 0; 16 > i; ++i) W[i] = M.readInt32BE(4 * i);
                            for (; 64 > i; ++i) W[i] = 0 | gamma1(W[i - 2]) + W[i - 7] + gamma0(W[i - 15]) + W[i - 16];
                            for (var j = 0; 64 > j; ++j) {
                                var T1 = 0 | h + sigma1(e) + ch(e, f, g) + K[j] + W[j],
                                    T2 = 0 | sigma0(a) + maj(a, b, c);
                                h = g;
                                g = f;
                                f = e;
                                e = 0 | d + T1;
                                d = c;
                                c = b;
                                b = a;
                                a = 0 | T1 + T2
                            }
                            this._a = 0 | a + this._a;
                            this._b = 0 | b + this._b;
                            this._c = 0 | c + this._c;
                            this._d = 0 | d + this._d;
                            this._e = 0 | e + this._e;
                            this._f = 0 | f + this._f;
                            this._g = 0 | g + this._g;
                            this._h = 0 | h + this._h
                        };
                        Sha256.prototype._hash = function() {
                            var H = Buffer.allocUnsafe(32);
                            H.writeInt32BE(this._a, 0);
                            H.writeInt32BE(this._b, 4);
                            H.writeInt32BE(this._c, 8);
                            H.writeInt32BE(this._d, 12);
                            H.writeInt32BE(this._e, 16);
                            H.writeInt32BE(this._f, 20);
                            H.writeInt32BE(this._g, 24);
                            H.writeInt32BE(this._h, 28);
                            return H
                        };
                        module.exports = Sha256
                    }, {
                        "./hash": 421,
                        inherits: 392,
                        "safe-buffer": 420
                    }],
                    427: [function(require, module) {
                        var inherits = require("inherits"),
                            SHA512 = require("./sha512"),
                            Hash = require("./hash"),
                            Buffer = require("safe-buffer").Buffer,
                            W = Array(160);

                        function Sha384() {
                            this.init();
                            this._w = W;
                            Hash.call(this, 128, 112)
                        }
                        inherits(Sha384, SHA512);
                        Sha384.prototype.init = function() {
                            this._ah = 3418070365;
                            this._bh = 1654270250;
                            this._ch = 2438529370;
                            this._dh = 355462360;
                            this._eh = 1731405415;
                            this._fh = 2394180231;
                            this._gh = 3675008525;
                            this._hh = 1203062813;
                            this._al = 3238371032;
                            this._bl = 914150663;
                            this._cl = 812702999;
                            this._dl = 4144912697;
                            this._el = 4290775857;
                            this._fl = 1750603025;
                            this._gl = 1694076839;
                            this._hl = 3204075428;
                            return this
                        };
                        Sha384.prototype._hash = function() {
                            var H = Buffer.allocUnsafe(48);

                            function writeInt64BE(h, l, offset) {
                                H.writeInt32BE(h, offset);
                                H.writeInt32BE(l, offset + 4)
                            }
                            writeInt64BE(this._ah, this._al, 0);
                            writeInt64BE(this._bh, this._bl, 8);
                            writeInt64BE(this._ch, this._cl, 16);
                            writeInt64BE(this._dh, this._dl, 24);
                            writeInt64BE(this._eh, this._el, 32);
                            writeInt64BE(this._fh, this._fl, 40);
                            return H
                        };
                        module.exports = Sha384
                    }, {
                        "./hash": 421,
                        "./sha512": 428,
                        inherits: 392,
                        "safe-buffer": 420
                    }],
                    428: [function(require, module) {
                        var inherits = require("inherits"),
                            Hash = require("./hash"),
                            Buffer = require("safe-buffer").Buffer,
                            K = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591],
                            W = Array(160);

                        function Sha512() {
                            this.init();
                            this._w = W;
                            Hash.call(this, 128, 112)
                        }
                        inherits(Sha512, Hash);
                        Sha512.prototype.init = function() {
                            this._ah = 1779033703;
                            this._bh = 3144134277;
                            this._ch = 1013904242;
                            this._dh = 2773480762;
                            this._eh = 1359893119;
                            this._fh = 2600822924;
                            this._gh = 528734635;
                            this._hh = 1541459225;
                            this._al = 4089235720;
                            this._bl = 2227873595;
                            this._cl = 4271175723;
                            this._dl = 1595750129;
                            this._el = 2917565137;
                            this._fl = 725511199;
                            this._gl = 4215389547;
                            this._hl = 327033209;
                            return this
                        };

                        function Ch(x, y, z) {
                            return z ^ x & (y ^ z)
                        }

                        function maj(x, y, z) {
                            return x & y | z & (x | y)
                        }

                        function sigma0(x, xl) {
                            return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25)
                        }

                        function sigma1(x, xl) {
                            return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23)
                        }

                        function Gamma0(x, xl) {
                            return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ x >>> 7
                        }

                        function Gamma0l(x, xl) {
                            return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25)
                        }

                        function Gamma1(x, xl) {
                            return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ x >>> 6
                        }

                        function Gamma1l(x, xl) {
                            return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26)
                        }

                        function getCarry(a, b) {
                            return a >>> 0 < b >>> 0 ? 1 : 0
                        }
                        Sha512.prototype._update = function(M) {
                            for (var W = this._w, ah = 0 | this._ah, bh = 0 | this._bh, ch = 0 | this._ch, dh = 0 | this._dh, eh = 0 | this._eh, fh = 0 | this._fh, gh = 0 | this._gh, hh = 0 | this._hh, al = 0 | this._al, bl = 0 | this._bl, cl = 0 | this._cl, dl = 0 | this._dl, el = 0 | this._el, fl = 0 | this._fl, gl = 0 | this._gl, hl = 0 | this._hl, i = 0; 32 > i; i += 2) {
                                W[i] = M.readInt32BE(4 * i);
                                W[i + 1] = M.readInt32BE(4 * i + 4)
                            }
                            for (; 160 > i; i += 2) {
                                var xh = W[i - 2 * 15],
                                    xl = W[i - 2 * 15 + 1],
                                    gamma0 = Gamma0(xh, xl),
                                    gamma0l = Gamma0l(xl, xh);
                                xh = W[i - 2 * 2];
                                xl = W[i - 2 * 2 + 1];
                                var gamma1 = Gamma1(xh, xl),
                                    gamma1l = Gamma1l(xl, xh),
                                    Wi7h = W[i - 2 * 7],
                                    Wi7l = W[i - 2 * 7 + 1],
                                    Wi16h = W[i - 2 * 16],
                                    Wi16l = W[i - 2 * 16 + 1],
                                    Wil = 0 | gamma0l + Wi7l,
                                    Wih = 0 | gamma0 + Wi7h + getCarry(Wil, gamma0l);
                                Wil = 0 | Wil + gamma1l;
                                Wih = 0 | Wih + gamma1 + getCarry(Wil, gamma1l);
                                Wil = 0 | Wil + Wi16l;
                                Wih = 0 | Wih + Wi16h + getCarry(Wil, Wi16l);
                                W[i] = Wih;
                                W[i + 1] = Wil
                            }
                            for (var j = 0; 160 > j; j += 2) {
                                Wih = W[j];
                                Wil = W[j + 1];
                                var majh = maj(ah, bh, ch),
                                    majl = maj(al, bl, cl),
                                    sigma0h = sigma0(ah, al),
                                    sigma0l = sigma0(al, ah),
                                    sigma1h = sigma1(eh, el),
                                    sigma1l = sigma1(el, eh),
                                    Kih = K[j],
                                    Kil = K[j + 1],
                                    chh = Ch(eh, fh, gh),
                                    chl = Ch(el, fl, gl),
                                    t1l = 0 | hl + sigma1l,
                                    t1h = 0 | hh + sigma1h + getCarry(t1l, hl);
                                t1l = 0 | t1l + chl;
                                t1h = 0 | t1h + chh + getCarry(t1l, chl);
                                t1l = 0 | t1l + Kil;
                                t1h = 0 | t1h + Kih + getCarry(t1l, Kil);
                                t1l = 0 | t1l + Wil;
                                t1h = 0 | t1h + Wih + getCarry(t1l, Wil);
                                var t2l = 0 | sigma0l + majl,
                                    t2h = 0 | sigma0h + majh + getCarry(t2l, sigma0l);
                                hh = gh;
                                hl = gl;
                                gh = fh;
                                gl = fl;
                                fh = eh;
                                fl = el;
                                el = 0 | dl + t1l;
                                eh = 0 | dh + t1h + getCarry(el, dl);
                                dh = ch;
                                dl = cl;
                                ch = bh;
                                cl = bl;
                                bh = ah;
                                bl = al;
                                al = 0 | t1l + t2l;
                                ah = 0 | t1h + t2h + getCarry(al, t1l)
                            }
                            this._al = 0 | this._al + al;
                            this._bl = 0 | this._bl + bl;
                            this._cl = 0 | this._cl + cl;
                            this._dl = 0 | this._dl + dl;
                            this._el = 0 | this._el + el;
                            this._fl = 0 | this._fl + fl;
                            this._gl = 0 | this._gl + gl;
                            this._hl = 0 | this._hl + hl;
                            this._ah = 0 | this._ah + ah + getCarry(this._al, al);
                            this._bh = 0 | this._bh + bh + getCarry(this._bl, bl);
                            this._ch = 0 | this._ch + ch + getCarry(this._cl, cl);
                            this._dh = 0 | this._dh + dh + getCarry(this._dl, dl);
                            this._eh = 0 | this._eh + eh + getCarry(this._el, el);
                            this._fh = 0 | this._fh + fh + getCarry(this._fl, fl);
                            this._gh = 0 | this._gh + gh + getCarry(this._gl, gl);
                            this._hh = 0 | this._hh + hh + getCarry(this._hl, hl)
                        };
                        Sha512.prototype._hash = function() {
                            var H = Buffer.allocUnsafe(64);

                            function writeInt64BE(h, l, offset) {
                                H.writeInt32BE(h, offset);
                                H.writeInt32BE(l, offset + 4)
                            }
                            writeInt64BE(this._ah, this._al, 0);
                            writeInt64BE(this._bh, this._bl, 8);
                            writeInt64BE(this._ch, this._cl, 16);
                            writeInt64BE(this._dh, this._dl, 24);
                            writeInt64BE(this._eh, this._el, 32);
                            writeInt64BE(this._fh, this._fl, 40);
                            writeInt64BE(this._gh, this._gl, 48);
                            writeInt64BE(this._hh, this._hl, 56);
                            return H
                        };
                        module.exports = Sha512
                    }, {
                        "./hash": 421,
                        inherits: 392,
                        "safe-buffer": 420
                    }],
                    429: [function(require, module) {
                        ! function(globals) {
                            "use strict";
                            var _imports = {};
                            if ("undefined" !== typeof module && module.exports) {
                                _imports.bytesToHex = require("convert-hex").bytesToHex;
                                _imports.convertString = require("convert-string");
                                module.exports = sha256
                            } else {
                                _imports.bytesToHex = globals.convertHex.bytesToHex;
                                _imports.convertString = globals.convertString;
                                globals.sha256 = sha256
                            }
                            var K = [];
                            ! function() {
                                function isPrime(n) {
                                    for (var sqrtN = _Mathsqrt(n), factor = 2; factor <= sqrtN; factor++) {
                                        if (!(n % factor)) return !1
                                    }
                                    return !0
                                }

                                function getFractionalBits(n) {
                                    return 0 | 4294967296 * (n - (0 | n))
                                }
                                var n = 2,
                                    nPrime = 0;
                                while (64 > nPrime) {
                                    if (isPrime(n)) {
                                        K[nPrime] = getFractionalBits(_Mathpow(n, 1 / 3));
                                        nPrime++
                                    }
                                    n++
                                }
                            }();
                            var bytesToWords = function(bytes) {
                                    for (var words = [], i = 0, b = 0; i < bytes.length; i++, b += 8) {
                                        words[b >>> 5] |= bytes[i] << 24 - b % 32
                                    }
                                    return words
                                },
                                wordsToBytes = function(words) {
                                    for (var bytes = [], b = 0; b < 32 * words.length; b += 8) {
                                        bytes.push(255 & words[b >>> 5] >>> 24 - b % 32)
                                    }
                                    return bytes
                                },
                                W = [],
                                processBlock = function(H, M, offset) {
                                    for (var a = H[0], b = H[1], c = H[2], d = H[3], e = H[4], f = H[5], g = H[6], h = H[7], i = 0; 64 > i; i++) {
                                        if (16 > i) {
                                            W[i] = 0 | M[offset + i]
                                        } else {
                                            var gamma0x = W[i - 15],
                                                gamma1x = W[i - 2];
                                            W[i] = ((gamma0x << 25 | gamma0x >>> 7) ^ (gamma0x << 14 | gamma0x >>> 18) ^ gamma0x >>> 3) + W[i - 7] + ((gamma1x << 15 | gamma1x >>> 17) ^ (gamma1x << 13 | gamma1x >>> 19) ^ gamma1x >>> 10) + W[i - 16]
                                        }
                                        var ch = e & f ^ ~e & g,
                                            maj = a & b ^ a & c ^ b & c,
                                            sigma0 = (a << 30 | a >>> 2) ^ (a << 19 | a >>> 13) ^ (a << 10 | a >>> 22),
                                            sigma1 = (e << 26 | e >>> 6) ^ (e << 21 | e >>> 11) ^ (e << 7 | e >>> 25),
                                            t1 = h + sigma1 + ch + K[i] + W[i];
                                        h = g;
                                        g = f;
                                        f = e;
                                        e = 0 | d + t1;
                                        d = c;
                                        c = b;
                                        b = a;
                                        a = 0 | t1 + (sigma0 + maj)
                                    }
                                    H[0] = 0 | H[0] + a;
                                    H[1] = 0 | H[1] + b;
                                    H[2] = 0 | H[2] + c;
                                    H[3] = 0 | H[3] + d;
                                    H[4] = 0 | H[4] + e;
                                    H[5] = 0 | H[5] + f;
                                    H[6] = 0 | H[6] + g;
                                    H[7] = 0 | H[7] + h
                                };

                            function sha256(message, options) {
                                if (message.constructor === String) {
                                    message = _imports.convertString.UTF8.stringToBytes(message)
                                }
                                var H = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225],
                                    m = bytesToWords(message),
                                    l = 8 * message.length;
                                m[l >> 5] |= 128 << 24 - l % 32;
                                m[(l + 64 >> 9 << 4) + 15] = l;
                                for (var i = 0; i < m.length; i += 16) {
                                    processBlock(H, m, i)
                                }
                                var digestbytes = wordsToBytes(H);
                                return options && options.asBytes ? digestbytes : options && options.asString ? _imports.convertString.bytesToString(digestbytes) : _imports.bytesToHex(digestbytes)
                            }
                            sha256.x2 = function(message, options) {
                                return sha256(sha256(message, {
                                    asBytes: !0
                                }), options)
                            }
                        }(this)
                    }, {
                        "convert-hex": 48,
                        "convert-string": 49
                    }],
                    430: [function(require, module) {
                        module.exports = Stream;
                        var EE = require("events").EventEmitter,
                            inherits = require("inherits");
                        inherits(Stream, EE);
                        Stream.Readable = require("readable-stream/readable.js");
                        Stream.Writable = require("readable-stream/writable.js");
                        Stream.Duplex = require("readable-stream/duplex.js");
                        Stream.Transform = require("readable-stream/transform.js");
                        Stream.PassThrough = require("readable-stream/passthrough.js");
                        Stream.Stream = Stream;

                        function Stream() {
                            EE.call(this)
                        }
                        Stream.prototype.pipe = function(dest, options) {
                            var source = this;

                            function ondata(chunk) {
                                if (dest.writable) {
                                    if (!1 === dest.write(chunk) && source.pause) {
                                        source.pause()
                                    }
                                }
                            }
                            source.on("data", ondata);

                            function ondrain() {
                                if (source.readable && source.resume) {
                                    source.resume()
                                }
                            }
                            dest.on("drain", ondrain);
                            if (!dest._isStdio && (!options || !1 !== options.end)) {
                                source.on("end", onend);
                                source.on("close", onclose)
                            }
                            var didOnEnd = !1;

                            function onend() {
                                if (didOnEnd) return;
                                didOnEnd = !0;
                                dest.end()
                            }

                            function onclose() {
                                if (didOnEnd) return;
                                didOnEnd = !0;
                                if ("function" === typeof dest.destroy) dest.destroy()
                            }

                            function onerror(er) {
                                cleanup();
                                if (0 === EE.listenerCount(this, "error")) {
                                    throw er
                                }
                            }
                            source.on("error", onerror);
                            dest.on("error", onerror);

                            function cleanup() {
                                source.removeListener("data", ondata);
                                dest.removeListener("drain", ondrain);
                                source.removeListener("end", onend);
                                source.removeListener("close", onclose);
                                source.removeListener("error", onerror);
                                dest.removeListener("error", onerror);
                                source.removeListener("end", cleanup);
                                source.removeListener("close", cleanup);
                                dest.removeListener("close", cleanup)
                            }
                            source.on("end", cleanup);
                            source.on("close", cleanup);
                            dest.on("close", cleanup);
                            dest.emit("pipe", source);
                            return dest
                        }
                    }, {
                        events: 388,
                        inherits: 392,
                        "readable-stream/duplex.js": 405,
                        "readable-stream/passthrough.js": 414,
                        "readable-stream/readable.js": 415,
                        "readable-stream/transform.js": 416,
                        "readable-stream/writable.js": 417
                    }],
                    431: [function(require, module, exports) {
                        (function(global) {
                            var ClientRequest = require("./lib/request"),
                                IncomingMessage = require("./lib/response"),
                                extend = require("xtend"),
                                statusCodes = require("builtin-status-codes"),
                                url = require("url"),
                                http = exports;
                            http.request = function(opts, cb) {
                                if ("string" === typeof opts) opts = url.parse(opts);
                                else opts = extend(opts);
                                var defaultProtocol = -1 === global.location.protocol.search(/^https?:$/) ? "http:" : "",
                                    protocol = opts.protocol || defaultProtocol,
                                    host = opts.hostname || opts.host,
                                    port = opts.port,
                                    path = opts.path || "/";
                                if (host && -1 !== host.indexOf(":")) host = "[" + host + "]";
                                opts.url = (host ? protocol + "//" + host : "") + (port ? ":" + port : "") + path;
                                opts.method = (opts.method || "GET").toUpperCase();
                                opts.headers = opts.headers || {};
                                var req = new ClientRequest(opts);
                                if (cb) req.on("response", cb);
                                return req
                            };
                            http.get = function(opts, cb) {
                                var req = http.request(opts, cb);
                                req.end();
                                return req
                            };
                            http.ClientRequest = ClientRequest;
                            http.IncomingMessage = IncomingMessage;
                            http.Agent = function() {};
                            http.Agent.defaultMaxSockets = 4;
                            http.STATUS_CODES = statusCodes;
                            http.METHODS = ["CHECKOUT", "CONNECT", "COPY", "DELETE", "GET", "HEAD", "LOCK", "M-SEARCH", "MERGE", "MKACTIVITY", "MKCOL", "MOVE", "NOTIFY", "OPTIONS", "PATCH", "POST", "PROPFIND", "PROPPATCH", "PURGE", "PUT", "REPORT", "SEARCH", "SUBSCRIBE", "TRACE", "UNLOCK", "UNSUBSCRIBE"]
                        }).call(this, "undefined" !== typeof global ? global : "undefined" !== typeof self ? self : "undefined" !== typeof window ? window : {})
                    }, {
                        "./lib/request": 433,
                        "./lib/response": 434,
                        "builtin-status-codes": 46,
                        url: 442,
                        xtend: 450
                    }],
                    432: [function(require, module, exports) {
                        (function(global) {
                            exports.fetch = isFunction(global.fetch) && isFunction(global.ReadableStream);
                            exports.writableStream = isFunction(global.WritableStream);
                            exports.abortController = isFunction(global.AbortController);
                            exports.blobConstructor = !1;
                            try {
                                new Blob([new ArrayBuffer(1)]);
                                exports.blobConstructor = !0
                            } catch (e) {}
                            var xhr;

                            function getXHR() {
                                if (xhr !== void 0) return xhr;
                                if (global.XMLHttpRequest) {
                                    xhr = new global.XMLHttpRequest;
                                    try {
                                        xhr.open("GET", global.XDomainRequest ? "/" : "https://example.com")
                                    } catch (e) {
                                        xhr = null
                                    }
                                } else {
                                    xhr = null
                                }
                                return xhr
                            }

                            function checkTypeSupport(type) {
                                var xhr = getXHR();
                                if (!xhr) return !1;
                                try {
                                    xhr.responseType = type;
                                    return xhr.responseType === type
                                } catch (e) {}
                                return !1
                            }
                            var haveArrayBuffer = "undefined" !== typeof global.ArrayBuffer,
                                haveSlice = haveArrayBuffer && isFunction(global.ArrayBuffer.prototype.slice);
                            exports.arraybuffer = exports.fetch || haveArrayBuffer && checkTypeSupport("arraybuffer");
                            exports.msstream = !exports.fetch && haveSlice && checkTypeSupport("ms-stream");
                            exports.mozchunkedarraybuffer = !exports.fetch && haveArrayBuffer && checkTypeSupport("moz-chunked-arraybuffer");
                            exports.overrideMimeType = exports.fetch || (getXHR() ? isFunction(getXHR().overrideMimeType) : !1);
                            exports.vbArray = isFunction(global.VBArray);

                            function isFunction(value) {
                                return "function" === typeof value
                            }
                            xhr = null
                        }).call(this, "undefined" !== typeof global ? global : "undefined" !== typeof self ? self : "undefined" !== typeof window ? window : {})
                    }, {}],
                    433: [function(require, module) {
                        (function(process, global, Buffer) {
                            var capability = require("./capability"),
                                inherits = require("inherits"),
                                response = require("./response"),
                                stream = require("readable-stream"),
                                toArrayBuffer = require("to-arraybuffer"),
                                IncomingMessage = response.IncomingMessage,
                                rStates = response.readyStates;

                            function decideMode(preferBinary, useFetch) {
                                if (capability.fetch && useFetch) {
                                    return "fetch"
                                } else if (capability.mozchunkedarraybuffer) {
                                    return "moz-chunked-arraybuffer"
                                } else if (capability.msstream) {
                                    return "ms-stream"
                                } else if (capability.arraybuffer && preferBinary) {
                                    return "arraybuffer"
                                } else if (capability.vbArray && preferBinary) {
                                    return "text:vbarray"
                                } else {
                                    return "text"
                                }
                            }
                            var ClientRequest = module.exports = function(opts) {
                                var self = this;
                                stream.Writable.call(self);
                                self._opts = opts;
                                self._body = [];
                                self._headers = {};
                                if (opts.auth) self.setHeader("Authorization", "Basic " + new Buffer(opts.auth).toString("base64"));
                                Object.keys(opts.headers).forEach(function(name) {
                                    self.setHeader(name, opts.headers[name])
                                });
                                var preferBinary, useFetch = !0;
                                if ("disable-fetch" === opts.mode || "requestTimeout" in opts && !capability.abortController) {
                                    useFetch = !1;
                                    preferBinary = !0
                                } else if ("prefer-streaming" === opts.mode) {
                                    preferBinary = !1
                                } else if ("allow-wrong-content-type" === opts.mode) {
                                    preferBinary = !capability.overrideMimeType
                                } else if (!opts.mode || "default" === opts.mode || "prefer-fast" === opts.mode) {
                                    preferBinary = !0
                                } else {
                                    throw new Error("Invalid value for opts.mode")
                                }
                                self._mode = decideMode(preferBinary, useFetch);
                                self.on("finish", function() {
                                    self._onFinish()
                                })
                            };
                            inherits(ClientRequest, stream.Writable);
                            ClientRequest.prototype.setHeader = function(name, value) {
                                var self = this,
                                    lowerName = name.toLowerCase();
                                if (-1 !== unsafeHeaders.indexOf(lowerName)) return;
                                self._headers[lowerName] = {
                                    name: name,
                                    value: value
                                }
                            };
                            ClientRequest.prototype.getHeader = function(name) {
                                var header = this._headers[name.toLowerCase()];
                                if (header) return header.value;
                                return null
                            };
                            ClientRequest.prototype.removeHeader = function(name) {
                                var self = this;
                                delete self._headers[name.toLowerCase()]
                            };
                            ClientRequest.prototype._onFinish = function() {
                                var self = this;
                                if (self._destroyed) return;
                                var opts = self._opts,
                                    headersObj = self._headers,
                                    body = null;
                                if ("GET" !== opts.method && "HEAD" !== opts.method) {
                                    if (capability.arraybuffer) {
                                        body = toArrayBuffer(Buffer.concat(self._body))
                                    } else if (capability.blobConstructor) {
                                        body = new global.Blob(self._body.map(function(buffer) {
                                            return toArrayBuffer(buffer)
                                        }), {
                                            type: (headersObj["content-type"] || {}).value || ""
                                        })
                                    } else {
                                        body = Buffer.concat(self._body).toString()
                                    }
                                }
                                var headersList = [];
                                Object.keys(headersObj).forEach(function(keyName) {
                                    var name = headersObj[keyName].name,
                                        value = headersObj[keyName].value;
                                    if (Array.isArray(value)) {
                                        value.forEach(function(v) {
                                            headersList.push([name, v])
                                        })
                                    } else {
                                        headersList.push([name, value])
                                    }
                                });
                                if ("fetch" === self._mode) {
                                    var signal = null;
                                    if (capability.abortController) {
                                        var controller = new AbortController;
                                        signal = controller.signal;
                                        self._fetchAbortController = controller;
                                        if ("requestTimeout" in opts && 0 !== opts.requestTimeout) {
                                            global.setTimeout(function() {
                                                self.emit("requestTimeout");
                                                if (self._fetchAbortController) self._fetchAbortController.abort()
                                            }, opts.requestTimeout)
                                        }
                                    }
                                    global.fetch(self._opts.url, {
                                        method: self._opts.method,
                                        headers: headersList,
                                        body: body || void 0,
                                        mode: "cors",
                                        credentials: opts.withCredentials ? "include" : "same-origin",
                                        signal: signal
                                    }).then(function(response) {
                                        self._fetchResponse = response;
                                        self._connect()
                                    }, function(reason) {
                                        self.emit("error", reason)
                                    })
                                } else {
                                    var xhr = self._xhr = new global.XMLHttpRequest;
                                    try {
                                        xhr.open(self._opts.method, self._opts.url, !0)
                                    } catch (err) {
                                        process.nextTick(function() {
                                            self.emit("error", err)
                                        });
                                        return
                                    }
                                    if ("responseType" in xhr) xhr.responseType = self._mode.split(":")[0];
                                    if ("withCredentials" in xhr) xhr.withCredentials = !!opts.withCredentials;
                                    if ("text" === self._mode && "overrideMimeType" in xhr) xhr.overrideMimeType("text/plain; charset=x-user-defined");
                                    if ("requestTimeout" in opts) {
                                        xhr.timeout = opts.requestTimeout;
                                        xhr.ontimeout = function() {
                                            self.emit("requestTimeout")
                                        }
                                    }
                                    headersList.forEach(function(header) {
                                        xhr.setRequestHeader(header[0], header[1])
                                    });
                                    self._response = null;
                                    xhr.onreadystatechange = function() {
                                        switch (xhr.readyState) {
                                            case rStates.LOADING:
                                            case rStates.DONE:
                                                self._onXHRProgress();
                                                break;
                                        }
                                    };
                                    if ("moz-chunked-arraybuffer" === self._mode) {
                                        xhr.onprogress = function() {
                                            self._onXHRProgress()
                                        }
                                    }
                                    xhr.onerror = function() {
                                        if (self._destroyed) return;
                                        self.emit("error", new Error("XHR error"))
                                    };
                                    try {
                                        xhr.send(body)
                                    } catch (err) {
                                        process.nextTick(function() {
                                            self.emit("error", err)
                                        })
                                    }
                                }
                            };

                            function statusValid(xhr) {
                                try {
                                    var status = xhr.status;
                                    return null !== status && 0 !== status
                                } catch (e) {
                                    return !1
                                }
                            }
                            ClientRequest.prototype._onXHRProgress = function() {
                                var self = this;
                                if (!statusValid(self._xhr) || self._destroyed) return;
                                if (!self._response) self._connect();
                                self._response._onXHRProgress()
                            };
                            ClientRequest.prototype._connect = function() {
                                var self = this;
                                if (self._destroyed) return;
                                self._response = new IncomingMessage(self._xhr, self._fetchResponse, self._mode);
                                self._response.on("error", function(err) {
                                    self.emit("error", err)
                                });
                                self.emit("response", self._response)
                            };
                            ClientRequest.prototype._write = function(chunk, encoding, cb) {
                                var self = this;
                                self._body.push(chunk);
                                cb()
                            };
                            ClientRequest.prototype.abort = ClientRequest.prototype.destroy = function() {
                                var self = this;
                                self._destroyed = !0;
                                if (self._response) self._response._destroyed = !0;
                                if (self._xhr) self._xhr.abort();
                                else if (self._fetchAbortController) self._fetchAbortController.abort()
                            };
                            ClientRequest.prototype.end = function(data, encoding, cb) {
                                var self = this;
                                if ("function" === typeof data) {
                                    cb = data;
                                    data = void 0
                                }
                                stream.Writable.prototype.end.call(self, data, encoding, cb)
                            };
                            ClientRequest.prototype.flushHeaders = function() {};
                            ClientRequest.prototype.setTimeout = function() {};
                            ClientRequest.prototype.setNoDelay = function() {};
                            ClientRequest.prototype.setSocketKeepAlive = function() {};
                            var unsafeHeaders = ["accept-charset", "accept-encoding", "access-control-request-headers", "access-control-request-method", "connection", "content-length", "cookie", "cookie2", "date", "dnt", "expect", "host", "keep-alive", "origin", "referer", "te", "trailer", "transfer-encoding", "upgrade", "user-agent", "via"]
                        }).call(this, require("_process"), "undefined" !== typeof global ? global : "undefined" !== typeof self ? self : "undefined" !== typeof window ? window : {}, require("buffer").Buffer)
                    }, {
                        "./capability": 432,
                        "./response": 434,
                        _process: 399,
                        buffer: 45,
                        inherits: 392,
                        "readable-stream": 415,
                        "to-arraybuffer": 437
                    }],
                    434: [function(require, module, exports) {
                        (function(process, global, Buffer) {
                            var capability = require("./capability"),
                                inherits = require("inherits"),
                                stream = require("readable-stream"),
                                rStates = exports.readyStates = {
                                    UNSENT: 0,
                                    OPENED: 1,
                                    HEADERS_RECEIVED: 2,
                                    LOADING: 3,
                                    DONE: 4
                                },
                                IncomingMessage = exports.IncomingMessage = function(xhr, response, mode) {
                                    var self = this;
                                    stream.Readable.call(self);
                                    self._mode = mode;
                                    self.headers = {};
                                    self.rawHeaders = [];
                                    self.trailers = {};
                                    self.rawTrailers = [];
                                    self.on("end", function() {
                                        process.nextTick(function() {
                                            self.emit("close")
                                        })
                                    });
                                    if ("fetch" === mode) {
                                        self._fetchResponse = response;
                                        self.url = response.url;
                                        self.statusCode = response.status;
                                        self.statusMessage = response.statusText;
                                        response.headers.forEach(function(header, key) {
                                            self.headers[key.toLowerCase()] = header;
                                            self.rawHeaders.push(key, header)
                                        });
                                        if (capability.writableStream) {
                                            var writable = new WritableStream({
                                                write: function(chunk) {
                                                    return new Promise(function(resolve) {
                                                        if (self._destroyed) {} else if (self.push(new Buffer(chunk))) {
                                                            resolve()
                                                        } else {
                                                            self._resumeFetch = resolve
                                                        }
                                                    })
                                                },
                                                close: function() {
                                                    if (!self._destroyed) self.push(null)
                                                },
                                                abort: function(err) {
                                                    if (!self._destroyed) self.emit("error", err)
                                                }
                                            });
                                            try {
                                                response.body.pipeTo(writable);
                                                return
                                            } catch (e) {}
                                        }
                                        var reader = response.body.getReader();

                                        function read() {
                                            reader.read().then(function(result) {
                                                if (self._destroyed) return;
                                                if (result.done) {
                                                    self.push(null);
                                                    return
                                                }
                                                self.push(new Buffer(result.value));
                                                read()
                                            }).catch(function(err) {
                                                if (!self._destroyed) self.emit("error", err)
                                            })
                                        }
                                        read()
                                    } else {
                                        self._xhr = xhr;
                                        self._pos = 0;
                                        self.url = xhr.responseURL;
                                        self.statusCode = xhr.status;
                                        self.statusMessage = xhr.statusText;
                                        var headers = xhr.getAllResponseHeaders().split(/\r?\n/);
                                        headers.forEach(function(header) {
                                            var matches = header.match(/^([^:]+):\s*(.*)/);
                                            if (matches) {
                                                var key = matches[1].toLowerCase();
                                                if ("set-cookie" === key) {
                                                    if (self.headers[key] === void 0) {
                                                        self.headers[key] = []
                                                    }
                                                    self.headers[key].push(matches[2])
                                                } else if (self.headers[key] !== void 0) {
                                                    self.headers[key] += ", " + matches[2]
                                                } else {
                                                    self.headers[key] = matches[2]
                                                }
                                                self.rawHeaders.push(matches[1], matches[2])
                                            }
                                        });
                                        self._charset = "x-user-defined";
                                        if (!capability.overrideMimeType) {
                                            var mimeType = self.rawHeaders["mime-type"];
                                            if (mimeType) {
                                                var charsetMatch = mimeType.match(/;\s*charset=([^;])(;|$)/);
                                                if (charsetMatch) {
                                                    self._charset = charsetMatch[1].toLowerCase()
                                                }
                                            }
                                            if (!self._charset) self._charset = "utf-8"
                                        }
                                    }
                                };
                            inherits(IncomingMessage, stream.Readable);
                            IncomingMessage.prototype._read = function() {
                                var self = this,
                                    resolve = self._resumeFetch;
                                if (resolve) {
                                    self._resumeFetch = null;
                                    resolve()
                                }
                            };
                            IncomingMessage.prototype._onXHRProgress = function() {
                                var self = this,
                                    xhr = self._xhr,
                                    response = null;
                                switch (self._mode) {
                                    case "text:vbarray":
                                        if (xhr.readyState !== rStates.DONE) break;
                                        try {
                                            response = new global.VBArray(xhr.responseBody).toArray()
                                        } catch (e) {}
                                        if (null !== response) {
                                            self.push(new Buffer(response));
                                            break
                                        }
                                    case "text":
                                        try {
                                            response = xhr.responseText
                                        } catch (e) {
                                            self._mode = "text:vbarray";
                                            break
                                        }
                                        if (response.length > self._pos) {
                                            var newData = response.substr(self._pos);
                                            if ("x-user-defined" === self._charset) {
                                                for (var buffer = new Buffer(newData.length), i = 0; i < newData.length; i++) buffer[i] = 255 & newData.charCodeAt(i);
                                                self.push(buffer)
                                            } else {
                                                self.push(newData, self._charset)
                                            }
                                            self._pos = response.length
                                        }
                                        break;
                                    case "arraybuffer":
                                        if (xhr.readyState !== rStates.DONE || !xhr.response) break;
                                        response = xhr.response;
                                        self.push(new Buffer(new Uint8Array(response)));
                                        break;
                                    case "moz-chunked-arraybuffer":
                                        response = xhr.response;
                                        if (xhr.readyState !== rStates.LOADING || !response) break;
                                        self.push(new Buffer(new Uint8Array(response)));
                                        break;
                                    case "ms-stream":
                                        response = xhr.response;
                                        if (xhr.readyState !== rStates.LOADING) break;
                                        var reader = new global.MSStreamReader;
                                        reader.onprogress = function() {
                                            if (reader.result.byteLength > self._pos) {
                                                self.push(new Buffer(new Uint8Array(reader.result.slice(self._pos))));
                                                self._pos = reader.result.byteLength
                                            }
                                        };
                                        reader.onload = function() {
                                            self.push(null)
                                        };
                                        reader.readAsArrayBuffer(response);
                                        break;
                                }
                                if (self._xhr.readyState === rStates.DONE && "ms-stream" !== self._mode) {
                                    self.push(null)
                                }
                            }
                        }).call(this, require("_process"), "undefined" !== typeof global ? global : "undefined" !== typeof self ? self : "undefined" !== typeof window ? window : {}, require("buffer").Buffer)
                    }, {
                        "./capability": 432,
                        _process: 399,
                        buffer: 45,
                        inherits: 392,
                        "readable-stream": 415
                    }],
                    435: [function() {
                        if (!_Stringprototype.startsWith) {
                            (function() {
                                "use strict";
                                var defineProperty = function() {
                                        try {
                                            var object = {},
                                                $defineProperty = Object.defineProperty,
                                                result = $defineProperty(object, object, object) && $defineProperty
                                        } catch (error) {}
                                        return result
                                    }(),
                                    toString = {}.toString,
                                    startsWith = function(search) {
                                        if (null == this) {
                                            throw TypeError()
                                        }
                                        var string = this + "";
                                        if (search && "[object RegExp]" == toString.call(search)) {
                                            throw TypeError()
                                        }
                                        var stringLength = string.length,
                                            searchString = search + "",
                                            searchLength = searchString.length,
                                            position = 1 < arguments.length ? arguments[1] : void 0,
                                            pos = position ? +position : 0;
                                        if (pos != pos) {
                                            pos = 0
                                        }
                                        var start = _Mathmin(_Mathmax(pos, 0), stringLength);
                                        if (searchLength + start > stringLength) {
                                            return !1
                                        }
                                        var index = -1;
                                        while (++index < searchLength) {
                                            if (string.charCodeAt(start + index) != searchString.charCodeAt(index)) {
                                                return !1
                                            }
                                        }
                                        return !0
                                    };
                                if (defineProperty) {
                                    defineProperty(String.prototype, "startsWith", {
                                        value: startsWith,
                                        configurable: !0,
                                        writable: !0
                                    })
                                } else {
                                    _Stringprototype.startsWith = startsWith
                                }
                            })()
                        }
                    }, {}],
                    436: [function(require, module, exports) {
                        "use strict";
                        var Buffer = require("safe-buffer").Buffer,
                            isEncoding = Buffer.isEncoding || function(encoding) {
                                encoding = "" + encoding;
                                switch (encoding && encoding.toLowerCase()) {
                                    case "hex":
                                    case "utf8":
                                    case "utf-8":
                                    case "ascii":
                                    case "binary":
                                    case "base64":
                                    case "ucs2":
                                    case "ucs-2":
                                    case "utf16le":
                                    case "utf-16le":
                                    case "raw":
                                        return !0;
                                    default:
                                        return !1;
                                }
                            };

                        function _normalizeEncoding(enc) {
                            if (!enc) return "utf8";
                            var retried;
                            while (!0) {
                                switch (enc) {
                                    case "utf8":
                                    case "utf-8":
                                        return "utf8";
                                    case "ucs2":
                                    case "ucs-2":
                                    case "utf16le":
                                    case "utf-16le":
                                        return "utf16le";
                                    case "latin1":
                                    case "binary":
                                        return "latin1";
                                    case "base64":
                                    case "ascii":
                                    case "hex":
                                        return enc;
                                    default:
                                        if (retried) return;
                                        enc = ("" + enc).toLowerCase();
                                        retried = !0;
                                }
                            }
                        }

                        function normalizeEncoding(enc) {
                            var nenc = _normalizeEncoding(enc);
                            if ("string" !== typeof nenc && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error("Unknown encoding: " + enc);
                            return nenc || enc
                        }
                        exports.StringDecoder = StringDecoder;

                        function StringDecoder(encoding) {
                            this.encoding = normalizeEncoding(encoding);
                            var nb;
                            switch (this.encoding) {
                                case "utf16le":
                                    this.text = utf16Text;
                                    this.end = utf16End;
                                    nb = 4;
                                    break;
                                case "utf8":
                                    this.fillLast = utf8FillLast;
                                    nb = 4;
                                    break;
                                case "base64":
                                    this.text = base64Text;
                                    this.end = base64End;
                                    nb = 3;
                                    break;
                                default:
                                    this.write = simpleWrite;
                                    this.end = simpleEnd;
                                    return;
                            }
                            this.lastNeed = 0;
                            this.lastTotal = 0;
                            this.lastChar = Buffer.allocUnsafe(nb)
                        }
                        StringDecoder.prototype.write = function(buf) {
                            if (0 === buf.length) return "";
                            var r, i;
                            if (this.lastNeed) {
                                r = this.fillLast(buf);
                                if (r === void 0) return "";
                                i = this.lastNeed;
                                this.lastNeed = 0
                            } else {
                                i = 0
                            }
                            if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
                            return r || ""
                        };
                        StringDecoder.prototype.end = function(buf) {
                            var r = buf && buf.length ? this.write(buf) : "";
                            if (this.lastNeed) return r + "\uFFFD".repeat(this.lastTotal - this.lastNeed);
                            return r
                        };
                        StringDecoder.prototype.text = function(buf, i) {
                            var total = utf8CheckIncomplete(this, buf, i);
                            if (!this.lastNeed) return buf.toString("utf8", i);
                            this.lastTotal = total;
                            var end = buf.length - (total - this.lastNeed);
                            buf.copy(this.lastChar, 0, end);
                            return buf.toString("utf8", i, end)
                        };
                        StringDecoder.prototype.fillLast = function(buf) {
                            if (this.lastNeed <= buf.length) {
                                buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
                                return this.lastChar.toString(this.encoding, 0, this.lastTotal)
                            }
                            buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
                            this.lastNeed -= buf.length
                        };

                        function utf8CheckByte(byte) {
                            if (127 >= byte) return 0;
                            else if (6 === byte >> 5) return 2;
                            else if (14 === byte >> 4) return 3;
                            else if (30 === byte >> 3) return 4;
                            return -1
                        }

                        function utf8CheckIncomplete(self, buf, i) {
                            var j = buf.length - 1;
                            if (j < i) return 0;
                            var nb = utf8CheckByte(buf[j]);
                            if (0 <= nb) {
                                if (0 < nb) self.lastNeed = nb - 1;
                                return nb
                            }
                            if (--j < i) return 0;
                            nb = utf8CheckByte(buf[j]);
                            if (0 <= nb) {
                                if (0 < nb) self.lastNeed = nb - 2;
                                return nb
                            }
                            if (--j < i) return 0;
                            nb = utf8CheckByte(buf[j]);
                            if (0 <= nb) {
                                if (0 < nb) {
                                    if (2 === nb) nb = 0;
                                    else self.lastNeed = nb - 3
                                }
                                return nb
                            }
                            return 0
                        }

                        function utf8CheckExtraBytes(self, buf, p) {
                            if (128 !== (192 & buf[0])) {
                                self.lastNeed = 0;
                                return "\uFFFD".repeat(p)
                            }
                            if (1 < self.lastNeed && 1 < buf.length) {
                                if (128 !== (192 & buf[1])) {
                                    self.lastNeed = 1;
                                    return "\uFFFD".repeat(p + 1)
                                }
                                if (2 < self.lastNeed && 2 < buf.length) {
                                    if (128 !== (192 & buf[2])) {
                                        self.lastNeed = 2;
                                        return "\uFFFD".repeat(p + 2)
                                    }
                                }
                            }
                        }

                        function utf8FillLast(buf) {
                            var p = this.lastTotal - this.lastNeed,
                                r = utf8CheckExtraBytes(this, buf, p);
                            if (r !== void 0) return r;
                            if (this.lastNeed <= buf.length) {
                                buf.copy(this.lastChar, p, 0, this.lastNeed);
                                return this.lastChar.toString(this.encoding, 0, this.lastTotal)
                            }
                            buf.copy(this.lastChar, p, 0, buf.length);
                            this.lastNeed -= buf.length
                        }

                        function utf16Text(buf, i) {
                            if (0 === (buf.length - i) % 2) {
                                var r = buf.toString("utf16le", i);
                                if (r) {
                                    var c = r.charCodeAt(r.length - 1);
                                    if (55296 <= c && 56319 >= c) {
                                        this.lastNeed = 2;
                                        this.lastTotal = 4;
                                        this.lastChar[0] = buf[buf.length - 2];
                                        this.lastChar[1] = buf[buf.length - 1];
                                        return r.slice(0, -1)
                                    }
                                }
                                return r
                            }
                            this.lastNeed = 1;
                            this.lastTotal = 2;
                            this.lastChar[0] = buf[buf.length - 1];
                            return buf.toString("utf16le", i, buf.length - 1)
                        }

                        function utf16End(buf) {
                            var r = buf && buf.length ? this.write(buf) : "";
                            if (this.lastNeed) {
                                var end = this.lastTotal - this.lastNeed;
                                return r + this.lastChar.toString("utf16le", 0, end)
                            }
                            return r
                        }

                        function base64Text(buf, i) {
                            var n = (buf.length - i) % 3;
                            if (0 === n) return buf.toString("base64", i);
                            this.lastNeed = 3 - n;
                            this.lastTotal = 3;
                            if (1 === n) {
                                this.lastChar[0] = buf[buf.length - 1]
                            } else {
                                this.lastChar[0] = buf[buf.length - 2];
                                this.lastChar[1] = buf[buf.length - 1]
                            }
                            return buf.toString("base64", i, buf.length - n)
                        }

                        function base64End(buf) {
                            var r = buf && buf.length ? this.write(buf) : "";
                            if (this.lastNeed) return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
                            return r
                        }

                        function simpleWrite(buf) {
                            return buf.toString(this.encoding)
                        }

                        function simpleEnd(buf) {
                            return buf && buf.length ? this.write(buf) : ""
                        }
                    }, {
                        "safe-buffer": 420
                    }],
                    437: [function(require, module) {
                        var Buffer = require("buffer").Buffer;
                        module.exports = function(buf) {
                            if (buf instanceof Uint8Array) {
                                if (0 === buf.byteOffset && buf.byteLength === buf.buffer.byteLength) {
                                    return buf.buffer
                                } else if ("function" === typeof buf.buffer.slice) {
                                    return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength)
                                }
                            }
                            if (Buffer.isBuffer(buf)) {
                                for (var arrayCopy = new Uint8Array(buf.length), len = buf.length, i = 0; i < len; i++) {
                                    arrayCopy[i] = buf[i]
                                }
                                return arrayCopy.buffer
                            } else {
                                throw new Error("Argument must be a Buffer")
                            }
                        }
                    }, {
                        buffer: 45
                    }],
                    438: [function(require, module) {
                        var native = require("./native");

                        function getTypeName(fn) {
                            return fn.name || fn.toString().match(/function (.*?)\s*\(/)[1]
                        }

                        function getValueTypeName(value) {
                            return native.Nil(value) ? "" : getTypeName(value.constructor)
                        }

                        function getValue(value) {
                            if (native.Function(value)) return "";
                            if (native.String(value)) return JSON.stringify(value);
                            if (value && native.Object(value)) return "";
                            return value
                        }

                        function tfJSON(type) {
                            if (native.Function(type)) return type.toJSON ? type.toJSON() : getTypeName(type);
                            if (native.Array(type)) return "Array";
                            if (type && native.Object(type)) return "Object";
                            return type !== void 0 ? type : ""
                        }

                        function tfErrorString(type, value, valueTypeName) {
                            var valueJson = getValue(value);
                            return "Expected " + tfJSON(type) + ", got" + ("" !== valueTypeName ? " " + valueTypeName : "") + ("" !== valueJson ? " " + valueJson : "")
                        }

                        function TfTypeError(type, value, valueTypeName) {
                            valueTypeName = valueTypeName || getValueTypeName(value);
                            this.message = tfErrorString(type, value, valueTypeName);
                            Error.captureStackTrace(this, TfTypeError);
                            this.__type = type;
                            this.__value = value;
                            this.__valueTypeName = valueTypeName
                        }
                        TfTypeError.prototype = Object.create(Error.prototype);
                        TfTypeError.prototype.constructor = TfTypeError;

                        function tfPropertyErrorString(type, label, name, value, valueTypeName) {
                            var description = "\" of type ";
                            if ("key" === label) description = "\" with key type ";
                            return tfErrorString("property \"" + tfJSON(name) + description + tfJSON(type), value, valueTypeName)
                        }

                        function TfPropertyTypeError(type, property, label, value, valueTypeName) {
                            if (type) {
                                valueTypeName = valueTypeName || getValueTypeName(value);
                                this.message = tfPropertyErrorString(type, label, property, value, valueTypeName)
                            } else {
                                this.message = "Unexpected property \"" + property + "\""
                            }
                            Error.captureStackTrace(this, TfTypeError);
                            this.__label = label;
                            this.__property = property;
                            this.__type = type;
                            this.__value = value;
                            this.__valueTypeName = valueTypeName
                        }
                        TfPropertyTypeError.prototype = Object.create(Error.prototype);
                        TfPropertyTypeError.prototype.constructor = TfTypeError;
                        module.exports = {
                            TfTypeError: TfTypeError,
                            TfPropertyTypeError: TfPropertyTypeError,
                            tfCustomError: function(expected, actual) {
                                return new TfTypeError(expected, {}, actual)
                            },
                            tfSubError: function(e, property, label) {
                                if (e instanceof TfPropertyTypeError) {
                                    property = property + "." + e.__property;
                                    e = new TfPropertyTypeError(e.__type, property, e.__label, e.__value, e.__valueTypeName)
                                } else if (e instanceof TfTypeError) {
                                    e = new TfPropertyTypeError(e.__type, property, label, e.__value, e.__valueTypeName)
                                }
                                Error.captureStackTrace(e);
                                return e
                            },
                            tfJSON: tfJSON,
                            getValueTypeName: getValueTypeName
                        }
                    }, {
                        "./native": 441
                    }],
                    439: [function(require, module) {
                        (function(Buffer) {
                            var NATIVE = require("./native"),
                                ERRORS = require("./errors");

                            function _Buffer(value) {
                                return Buffer.isBuffer(value)
                            }

                            function Hex(value) {
                                return "string" === typeof value && /^([0-9a-f]{2})+$/i.test(value)
                            }

                            function _LengthN(type, length) {
                                var name = type.toJSON();

                                function Length(value) {
                                    if (!type(value)) return !1;
                                    if (value.length === length) return !0;
                                    throw ERRORS.tfCustomError(name + "(Length: " + length + ")", name + "(Length: " + value.length + ")")
                                }
                                Length.toJSON = function() {
                                    return name
                                };
                                return Length
                            }
                            var _ArrayN = _LengthN.bind(null, NATIVE.Array),
                                _BufferN = _LengthN.bind(null, _Buffer),
                                _HexN = _LengthN.bind(null, Hex),
                                _StringN = _LengthN.bind(null, NATIVE.String);
                            var types = {
                                ArrayN: _ArrayN,
                                Buffer: _Buffer,
                                BufferN: _BufferN,
                                Finite: function(value) {
                                    return "number" === typeof value && isFinite(value)
                                },
                                Hex: Hex,
                                HexN: _HexN,
                                Int8: function(value) {
                                    return value << 24 >> 24 === value
                                },
                                Int16: function(value) {
                                    return value << 16 >> 16 === value
                                },
                                Int32: function(value) {
                                    return (0 | value) === value
                                },
                                StringN: _StringN,
                                UInt8: function(value) {
                                    return (255 & value) === value
                                },
                                UInt16: function(value) {
                                    return (65535 & value) === value
                                },
                                UInt32: function(value) {
                                    return value >>> 0 === value
                                },
                                UInt53: function(value) {
                                    return "number" === typeof value && 0 <= value && value <= 9007199254740992 - 1 && _Mathfloor(value) === value
                                }
                            };
                            for (var typeName in types) {
                                types[typeName].toJSON = function(t) {
                                    return t
                                }.bind(null, typeName)
                            }
                            module.exports = types
                        }).call(this, {
                            isBuffer: require("../is-buffer/index.js")
                        })
                    }, {
                        "../is-buffer/index.js": 393,
                        "./errors": 438,
                        "./native": 441
                    }],
                    440: [function(require, module) {
                        var ERRORS = require("./errors"),
                            NATIVE = require("./native"),
                            tfJSON = ERRORS.tfJSON,
                            TfTypeError = ERRORS.TfTypeError,
                            TfPropertyTypeError = ERRORS.TfPropertyTypeError,
                            tfSubError = ERRORS.tfSubError,
                            getValueTypeName = ERRORS.getValueTypeName,
                            TYPES = {
                                arrayOf: function(type) {
                                    type = compile(type);

                                    function _arrayOf(array, strict) {
                                        if (!NATIVE.Array(array)) return !1;
                                        if (NATIVE.Nil(array)) return !1;
                                        return array.every(function(value, i) {
                                            try {
                                                return typeforce(type, value, strict)
                                            } catch (e) {
                                                throw tfSubError(e, i)
                                            }
                                        })
                                    }
                                    _arrayOf.toJSON = function() {
                                        return "[" + tfJSON(type) + "]"
                                    };
                                    return _arrayOf
                                },
                                maybe: function maybe(type) {
                                    type = compile(type);

                                    function _maybe(value, strict) {
                                        return NATIVE.Nil(value) || type(value, strict, maybe)
                                    }
                                    _maybe.toJSON = function() {
                                        return "?" + tfJSON(type)
                                    };
                                    return _maybe
                                },
                                map: function(propertyType, propertyKeyType) {
                                    propertyType = compile(propertyType);
                                    if (propertyKeyType) propertyKeyType = compile(propertyKeyType);

                                    function _map(value, strict) {
                                        if (!NATIVE.Object(value)) return !1;
                                        if (NATIVE.Nil(value)) return !1;
                                        for (var propertyName in value) {
                                            try {
                                                if (propertyKeyType) {
                                                    typeforce(propertyKeyType, propertyName, strict)
                                                }
                                            } catch (e) {
                                                throw tfSubError(e, propertyName, "key")
                                            }
                                            try {
                                                var propertyValue = value[propertyName];
                                                typeforce(propertyType, propertyValue, strict)
                                            } catch (e) {
                                                throw tfSubError(e, propertyName)
                                            }
                                        }
                                        return !0
                                    }
                                    if (propertyKeyType) {
                                        _map.toJSON = function() {
                                            return "{" + tfJSON(propertyKeyType) + ": " + tfJSON(propertyType) + "}"
                                        }
                                    } else {
                                        _map.toJSON = function() {
                                            return "{" + tfJSON(propertyType) + "}"
                                        }
                                    }
                                    return _map
                                },
                                object: function(uncompiled) {
                                    var type = {};
                                    for (var typePropertyName in uncompiled) {
                                        type[typePropertyName] = compile(uncompiled[typePropertyName])
                                    }

                                    function _object(value, strict) {
                                        if (!NATIVE.Object(value)) return !1;
                                        if (NATIVE.Nil(value)) return !1;
                                        try {
                                            for (var propertyName in type) {
                                                var propertyType = type[propertyName],
                                                    propertyValue = value[propertyName];
                                                typeforce(propertyType, propertyValue, strict)
                                            }
                                        } catch (e) {
                                            throw tfSubError(e, propertyName)
                                        }
                                        if (strict) {
                                            for (propertyName in value) {
                                                if (type[propertyName]) continue;
                                                throw new TfPropertyTypeError(void 0, propertyName)
                                            }
                                        }
                                        return !0
                                    }
                                    _object.toJSON = function() {
                                        return tfJSON(type)
                                    };
                                    return _object
                                },
                                oneOf: function() {
                                    var types = [].slice.call(arguments).map(compile);

                                    function _oneOf(value, strict) {
                                        return types.some(function(type) {
                                            try {
                                                return typeforce(type, value, strict)
                                            } catch (e) {
                                                return !1
                                            }
                                        })
                                    }
                                    _oneOf.toJSON = function() {
                                        return types.map(tfJSON).join("|")
                                    };
                                    return _oneOf
                                },
                                quacksLike: function(type) {
                                    function _quacksLike(value) {
                                        return type === getValueTypeName(value)
                                    }
                                    _quacksLike.toJSON = function() {
                                        return type
                                    };
                                    return _quacksLike
                                },
                                tuple: function() {
                                    var types = [].slice.call(arguments).map(compile);

                                    function _tuple(values, strict) {
                                        if (NATIVE.Nil(values)) return !1;
                                        if (NATIVE.Nil(values.length)) return !1;
                                        if (strict && values.length !== types.length) return !1;
                                        return types.every(function(type, i) {
                                            try {
                                                return typeforce(type, values[i], strict)
                                            } catch (e) {
                                                throw tfSubError(e, i)
                                            }
                                        })
                                    }
                                    _tuple.toJSON = function() {
                                        return "(" + types.map(tfJSON).join(", ") + ")"
                                    };
                                    return _tuple
                                },
                                value: function(expected) {
                                    function _value(actual) {
                                        return actual === expected
                                    }
                                    _value.toJSON = function() {
                                        return expected
                                    };
                                    return _value
                                }
                            };

                        function compile(type) {
                            if (NATIVE.String(type)) {
                                if ("?" === type[0]) return TYPES.maybe(type.slice(1));
                                return NATIVE[type] || TYPES.quacksLike(type)
                            } else if (type && NATIVE.Object(type)) {
                                if (NATIVE.Array(type)) return TYPES.arrayOf(type[0]);
                                return TYPES.object(type)
                            } else if (NATIVE.Function(type)) {
                                return type
                            }
                            return TYPES.value(type)
                        }

                        function typeforce(type, value, strict, surrogate) {
                            if (NATIVE.Function(type)) {
                                if (type(value, strict)) return !0;
                                throw new TfTypeError(surrogate || type, value)
                            }
                            return typeforce(compile(type), value, strict)
                        }
                        for (var typeName in NATIVE) {
                            typeforce[typeName] = NATIVE[typeName]
                        }
                        for (typeName in TYPES) {
                            typeforce[typeName] = TYPES[typeName]
                        }
                        var EXTRA = require("./extra");
                        for (typeName in EXTRA) {
                            typeforce[typeName] = EXTRA[typeName]
                        }

                        function __async(type, value, strict, callback) {
                            if ("function" === typeof strict) return __async(type, value, !1, strict);
                            try {
                                typeforce(type, value, strict)
                            } catch (e) {
                                return callback(e)
                            }
                            callback()
                        }
                        typeforce.async = __async;
                        typeforce.compile = compile;
                        typeforce.TfTypeError = TfTypeError;
                        typeforce.TfPropertyTypeError = TfPropertyTypeError;
                        module.exports = typeforce
                    }, {
                        "./errors": 438,
                        "./extra": 439,
                        "./native": 441
                    }],
                    441: [function(require, module) {
                        var types = {
                            Array: function(value) {
                                return null !== value && value !== void 0 && value.constructor === Array
                            },
                            Boolean: function(value) {
                                return "boolean" === typeof value
                            },
                            Function: function(value) {
                                return "function" === typeof value
                            },
                            Nil: function(value) {
                                return value === void 0 || null === value
                            },
                            Number: function(value) {
                                return "number" === typeof value
                            },
                            Object: function(value) {
                                return "object" === typeof value
                            },
                            String: function(value) {
                                return "string" === typeof value
                            },
                            "": function() {
                                return !0
                            }
                        };
                        types.Null = types.Nil;
                        for (var typeName in types) {
                            types[typeName].toJSON = function(t) {
                                return t
                            }.bind(null, typeName)
                        }
                        module.exports = types
                    }, {}],
                    442: [function(require, module, exports) {
                        "use strict";
                        var punycode = require("punycode"),
                            util = require("./util");
                        exports.parse = urlParse;
                        exports.resolve = function(source, relative) {
                            return urlParse(source, !1, !0).resolve(relative)
                        };
                        exports.resolveObject = function(source, relative) {
                            if (!source) return relative;
                            return urlParse(source, !1, !0).resolveObject(relative)
                        };
                        exports.format = function(obj) {
                            if (util.isString(obj)) obj = urlParse(obj);
                            if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
                            return obj.format()
                        };
                        exports.Url = Url;

                        function Url() {
                            this.protocol = null;
                            this.slashes = null;
                            this.auth = null;
                            this.host = null;
                            this.port = null;
                            this.hostname = null;
                            this.hash = null;
                            this.search = null;
                            this.query = null;
                            this.pathname = null;
                            this.path = null;
                            this.href = null
                        }
                        var protocolPattern = /^([a-z0-9.+-]+:)/i,
                            portPattern = /:[0-9]*$/,
                            simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,
                            unwise = ["{", "}", "|", "\\", "^", "`"].concat(["<", ">", "\"", "`", " ", "\r", "\n", "\t"]),
                            autoEscape = ["'"].concat(unwise),
                            nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape),
                            hostEndingChars = ["/", "?", "#"],
                            hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
                            hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
                            unsafeProtocol = {
                                javascript: !0,
                                "javascript:": !0
                            },
                            hostlessProtocol = {
                                javascript: !0,
                                "javascript:": !0
                            },
                            slashedProtocol = {
                                http: !0,
                                https: !0,
                                ftp: !0,
                                gopher: !0,
                                file: !0,
                                "http:": !0,
                                "https:": !0,
                                "ftp:": !0,
                                "gopher:": !0,
                                "file:": !0
                            },
                            querystring = require("querystring");

                        function urlParse(url, parseQueryString, slashesDenoteHost) {
                            if (url && util.isObject(url) && url instanceof Url) return url;
                            var u = new Url;
                            u.parse(url, parseQueryString, slashesDenoteHost);
                            return u
                        }
                        Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
                            if (!util.isString(url)) {
                                throw new TypeError("Parameter 'url' must be a string, not " + typeof url)
                            }
                            var queryIndex = url.indexOf("?"),
                                splitter = -1 !== queryIndex && queryIndex < url.indexOf("#") ? "?" : "#",
                                uSplit = url.split(splitter),
                                slashRegex = /\\/g;
                            uSplit[0] = uSplit[0].replace(slashRegex, "/");
                            url = uSplit.join(splitter);
                            var rest = url;
                            rest = rest.trim();
                            if (!slashesDenoteHost && 1 === url.split("#").length) {
                                var simplePath = simplePathPattern.exec(rest);
                                if (simplePath) {
                                    this.path = rest;
                                    this.href = rest;
                                    this.pathname = simplePath[1];
                                    if (simplePath[2]) {
                                        this.search = simplePath[2];
                                        if (parseQueryString) {
                                            this.query = querystring.parse(this.search.substr(1))
                                        } else {
                                            this.query = this.search.substr(1)
                                        }
                                    } else if (parseQueryString) {
                                        this.search = "";
                                        this.query = {}
                                    }
                                    return this
                                }
                            }
                            var proto = protocolPattern.exec(rest);
                            if (proto) {
                                proto = proto[0];
                                var lowerProto = proto.toLowerCase();
                                this.protocol = lowerProto;
                                rest = rest.substr(proto.length)
                            }
                            if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
                                var slashes = "//" === rest.substr(0, 2);
                                if (slashes && !(proto && hostlessProtocol[proto])) {
                                    rest = rest.substr(2);
                                    this.slashes = !0
                                }
                            }
                            if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
                                for (var hostEnd = -1, i = 0, hec; i < hostEndingChars.length; i++) {
                                    hec = rest.indexOf(hostEndingChars[i]);
                                    if (-1 !== hec && (-1 === hostEnd || hec < hostEnd)) hostEnd = hec
                                }
                                var auth, atSign;
                                if (-1 === hostEnd) {
                                    atSign = rest.lastIndexOf("@")
                                } else {
                                    atSign = rest.lastIndexOf("@", hostEnd)
                                }
                                if (-1 !== atSign) {
                                    auth = rest.slice(0, atSign);
                                    rest = rest.slice(atSign + 1);
                                    this.auth = decodeURIComponent(auth)
                                }
                                hostEnd = -1;
                                for (var i = 0, hec; i < nonHostChars.length; i++) {
                                    hec = rest.indexOf(nonHostChars[i]);
                                    if (-1 !== hec && (-1 === hostEnd || hec < hostEnd)) hostEnd = hec
                                }
                                if (-1 === hostEnd) hostEnd = rest.length;
                                this.host = rest.slice(0, hostEnd);
                                rest = rest.slice(hostEnd);
                                this.parseHost();
                                this.hostname = this.hostname || "";
                                var ipv6Hostname = "[" === this.hostname[0] && "]" === this.hostname[this.hostname.length - 1];
                                if (!ipv6Hostname) {
                                    for (var hostparts = this.hostname.split(/\./), i = 0, l = hostparts.length, part; i < l; i++) {
                                        part = hostparts[i];
                                        if (!part) continue;
                                        if (!part.match(hostnamePartPattern)) {
                                            for (var newpart = "", j = 0, k = part.length; j < k; j++) {
                                                if (127 < part.charCodeAt(j)) {
                                                    newpart += "x"
                                                } else {
                                                    newpart += part[j]
                                                }
                                            }
                                            if (!newpart.match(hostnamePartPattern)) {
                                                var validParts = hostparts.slice(0, i),
                                                    notHost = hostparts.slice(i + 1),
                                                    bit = part.match(hostnamePartStart);
                                                if (bit) {
                                                    validParts.push(bit[1]);
                                                    notHost.unshift(bit[2])
                                                }
                                                if (notHost.length) {
                                                    rest = "/" + notHost.join(".") + rest
                                                }
                                                this.hostname = validParts.join(".");
                                                break
                                            }
                                        }
                                    }
                                }
                                if (this.hostname.length > 255) {
                                    this.hostname = ""
                                } else {
                                    this.hostname = this.hostname.toLowerCase()
                                }
                                if (!ipv6Hostname) {
                                    this.hostname = punycode.toASCII(this.hostname)
                                }
                                var p = this.port ? ":" + this.port : "",
                                    h = this.hostname || "";
                                this.host = h + p;
                                this.href += this.host;
                                if (ipv6Hostname) {
                                    this.hostname = this.hostname.substr(1, this.hostname.length - 2);
                                    if ("/" !== rest[0]) {
                                        rest = "/" + rest
                                    }
                                }
                            }
                            if (!unsafeProtocol[lowerProto]) {
                                for (var i = 0, l = autoEscape.length, ae; i < l; i++) {
                                    ae = autoEscape[i];
                                    if (-1 === rest.indexOf(ae)) continue;
                                    var esc = encodeURIComponent(ae);
                                    if (esc === ae) {
                                        esc = escape(ae)
                                    }
                                    rest = rest.split(ae).join(esc)
                                }
                            }
                            var hash = rest.indexOf("#");
                            if (-1 !== hash) {
                                this.hash = rest.substr(hash);
                                rest = rest.slice(0, hash)
                            }
                            var qm = rest.indexOf("?");
                            if (-1 !== qm) {
                                this.search = rest.substr(qm);
                                this.query = rest.substr(qm + 1);
                                if (parseQueryString) {
                                    this.query = querystring.parse(this.query)
                                }
                                rest = rest.slice(0, qm)
                            } else if (parseQueryString) {
                                this.search = "";
                                this.query = {}
                            }
                            if (rest) this.pathname = rest;
                            if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
                                this.pathname = "/"
                            }
                            if (this.pathname || this.search) {
                                var p = this.pathname || "",
                                    s = this.search || "";
                                this.path = p + s
                            }
                            this.href = this.format();
                            return this
                        };
                        Url.prototype.format = function() {
                            var auth = this.auth || "";
                            if (auth) {
                                auth = encodeURIComponent(auth);
                                auth = auth.replace(/%3A/i, ":");
                                auth += "@"
                            }
                            var protocol = this.protocol || "",
                                pathname = this.pathname || "",
                                hash = this.hash || "",
                                host = !1,
                                query = "";
                            if (this.host) {
                                host = auth + this.host
                            } else if (this.hostname) {
                                host = auth + (-1 === this.hostname.indexOf(":") ? this.hostname : "[" + this.hostname + "]");
                                if (this.port) {
                                    host += ":" + this.port
                                }
                            }
                            if (this.query && util.isObject(this.query) && Object.keys(this.query).length) {
                                query = querystring.stringify(this.query)
                            }
                            var search = this.search || query && "?" + query || "";
                            if (protocol && ":" !== protocol.substr(-1)) protocol += ":";
                            if (this.slashes || (!protocol || slashedProtocol[protocol]) && !1 !== host) {
                                host = "//" + (host || "");
                                if (pathname && "/" !== pathname.charAt(0)) pathname = "/" + pathname
                            } else if (!host) {
                                host = ""
                            }
                            if (hash && "#" !== hash.charAt(0)) hash = "#" + hash;
                            if (search && "?" !== search.charAt(0)) search = "?" + search;
                            pathname = pathname.replace(/[?#]/g, function(match) {
                                return encodeURIComponent(match)
                            });
                            search = search.replace("#", "%23");
                            return protocol + host + pathname + search + hash
                        };
                        Url.prototype.resolve = function(relative) {
                            return this.resolveObject(urlParse(relative, !1, !0)).format()
                        };
                        Url.prototype.resolveObject = function(relative) {
                            if (util.isString(relative)) {
                                var rel = new Url;
                                rel.parse(relative, !1, !0);
                                relative = rel
                            }
                            for (var result = new Url, tkeys = Object.keys(this), tk = 0, tkey; tk < tkeys.length; tk++) {
                                tkey = tkeys[tk];
                                result[tkey] = this[tkey]
                            }
                            result.hash = relative.hash;
                            if ("" === relative.href) {
                                result.href = result.format();
                                return result
                            }
                            if (relative.slashes && !relative.protocol) {
                                for (var rkeys = Object.keys(relative), rk = 0, rkey; rk < rkeys.length; rk++) {
                                    rkey = rkeys[rk];
                                    if ("protocol" !== rkey) result[rkey] = relative[rkey]
                                }
                                if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
                                    result.path = result.pathname = "/"
                                }
                                result.href = result.format();
                                return result
                            }
                            if (relative.protocol && relative.protocol !== result.protocol) {
                                if (!slashedProtocol[relative.protocol]) {
                                    for (var keys = Object.keys(relative), v = 0, k; v < keys.length; v++) {
                                        k = keys[v];
                                        result[k] = relative[k]
                                    }
                                    result.href = result.format();
                                    return result
                                }
                                result.protocol = relative.protocol;
                                if (!relative.host && !hostlessProtocol[relative.protocol]) {
                                    var relPath = (relative.pathname || "").split("/");
                                    while (relPath.length && !(relative.host = relPath.shift()));
                                    if (!relative.host) relative.host = "";
                                    if (!relative.hostname) relative.hostname = "";
                                    if ("" !== relPath[0]) relPath.unshift("");
                                    if (2 > relPath.length) relPath.unshift("");
                                    result.pathname = relPath.join("/")
                                } else {
                                    result.pathname = relative.pathname
                                }
                                result.search = relative.search;
                                result.query = relative.query;
                                result.host = relative.host || "";
                                result.auth = relative.auth;
                                result.hostname = relative.hostname || relative.host;
                                result.port = relative.port;
                                if (result.pathname || result.search) {
                                    var p = result.pathname || "",
                                        s = result.search || "";
                                    result.path = p + s
                                }
                                result.slashes = result.slashes || relative.slashes;
                                result.href = result.format();
                                return result
                            }
                            var isSourceAbs = result.pathname && "/" === result.pathname.charAt(0),
                                isRelAbs = relative.host || relative.pathname && "/" === relative.pathname.charAt(0),
                                mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname,
                                removeAllDots = mustEndAbs,
                                srcPath = result.pathname && result.pathname.split("/") || [],
                                relPath = relative.pathname && relative.pathname.split("/") || [],
                                psychotic = result.protocol && !slashedProtocol[result.protocol];
                            if (psychotic) {
                                result.hostname = "";
                                result.port = null;
                                if (result.host) {
                                    if ("" === srcPath[0]) srcPath[0] = result.host;
                                    else srcPath.unshift(result.host)
                                }
                                result.host = "";
                                if (relative.protocol) {
                                    relative.hostname = null;
                                    relative.port = null;
                                    if (relative.host) {
                                        if ("" === relPath[0]) relPath[0] = relative.host;
                                        else relPath.unshift(relative.host)
                                    }
                                    relative.host = null
                                }
                                mustEndAbs = mustEndAbs && ("" === relPath[0] || "" === srcPath[0])
                            }
                            if (isRelAbs) {
                                result.host = relative.host || "" === relative.host ? relative.host : result.host;
                                result.hostname = relative.hostname || "" === relative.hostname ? relative.hostname : result.hostname;
                                result.search = relative.search;
                                result.query = relative.query;
                                srcPath = relPath
                            } else if (relPath.length) {
                                if (!srcPath) srcPath = [];
                                srcPath.pop();
                                srcPath = srcPath.concat(relPath);
                                result.search = relative.search;
                                result.query = relative.query
                            } else if (!util.isNullOrUndefined(relative.search)) {
                                if (psychotic) {
                                    result.hostname = result.host = srcPath.shift();
                                    var authInHost = result.host && 0 < result.host.indexOf("@") ? result.host.split("@") : !1;
                                    if (authInHost) {
                                        result.auth = authInHost.shift();
                                        result.host = result.hostname = authInHost.shift()
                                    }
                                }
                                result.search = relative.search;
                                result.query = relative.query;
                                if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
                                    result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "")
                                }
                                result.href = result.format();
                                return result
                            }
                            if (!srcPath.length) {
                                result.pathname = null;
                                if (result.search) {
                                    result.path = "/" + result.search
                                } else {
                                    result.path = null
                                }
                                result.href = result.format();
                                return result
                            }
                            for (var last = srcPath.slice(-1)[0], hasTrailingSlash = (result.host || relative.host || 1 < srcPath.length) && ("." === last || ".." === last) || "" === last, up = 0, i = srcPath.length; 0 <= i; i--) {
                                last = srcPath[i];
                                if ("." === last) {
                                    srcPath.splice(i, 1)
                                } else if (".." === last) {
                                    srcPath.splice(i, 1);
                                    up++
                                } else if (up) {
                                    srcPath.splice(i, 1);
                                    up--
                                }
                            }
                            if (!mustEndAbs && !removeAllDots) {
                                for (; up--; up) {
                                    srcPath.unshift("..")
                                }
                            }
                            if (mustEndAbs && "" !== srcPath[0] && (!srcPath[0] || "/" !== srcPath[0].charAt(0))) {
                                srcPath.unshift("")
                            }
                            if (hasTrailingSlash && "/" !== srcPath.join("/").substr(-1)) {
                                srcPath.push("")
                            }
                            var isAbsolute = "" === srcPath[0] || srcPath[0] && "/" === srcPath[0].charAt(0);
                            if (psychotic) {
                                result.hostname = result.host = isAbsolute ? "" : srcPath.length ? srcPath.shift() : "";
                                var authInHost = result.host && 0 < result.host.indexOf("@") ? result.host.split("@") : !1;
                                if (authInHost) {
                                    result.auth = authInHost.shift();
                                    result.host = result.hostname = authInHost.shift()
                                }
                            }
                            mustEndAbs = mustEndAbs || result.host && srcPath.length;
                            if (mustEndAbs && !isAbsolute) {
                                srcPath.unshift("")
                            }
                            if (!srcPath.length) {
                                result.pathname = null;
                                result.path = null
                            } else {
                                result.pathname = srcPath.join("/")
                            }
                            if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
                                result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "")
                            }
                            result.auth = relative.auth || result.auth;
                            result.slashes = result.slashes || relative.slashes;
                            result.href = result.format();
                            return result
                        };
                        Url.prototype.parseHost = function() {
                            var host = this.host,
                                port = portPattern.exec(host);
                            if (port) {
                                port = port[0];
                                if (":" !== port) {
                                    this.port = port.substr(1)
                                }
                                host = host.substr(0, host.length - port.length)
                            }
                            if (host) this.hostname = host
                        }
                    }, {
                        "./util": 443,
                        punycode: 400,
                        querystring: 403
                    }],
                    443: [function(require, module) {
                        "use strict";
                        module.exports = {
                            isString: function(arg) {
                                return "string" === typeof arg
                            },
                            isObject: function(arg) {
                                return "object" === typeof arg && null !== arg
                            },
                            isNull: function(arg) {
                                return null === arg
                            },
                            isNullOrUndefined: function(arg) {
                                return null == arg
                            }
                        }
                    }, {}],
                    444: [function(require, module) {
                        (function(global) {
                            module.exports = function(fn, msg) {
                                if (config("noDeprecation")) {
                                    return fn
                                }
                                var warned = !1;

                                function deprecated() {
                                    if (!warned) {
                                        if (config("throwDeprecation")) {
                                            throw new Error(msg)
                                        } else if (config("traceDeprecation")) {
                                            console.trace(msg)
                                        } else {
                                            console.warn(msg)
                                        }
                                        warned = !0
                                    }
                                    return fn.apply(this, arguments)
                                }
                                return deprecated
                            };

                            function config(name) {
                                try {
                                    if (!global.localStorage) return !1
                                } catch (_) {
                                    return !1
                                }
                                var val = global.localStorage[name];
                                if (null == val) return !1;
                                return "true" === (val + "").toLowerCase()
                            }
                        }).call(this, "undefined" !== typeof global ? global : "undefined" !== typeof self ? self : "undefined" !== typeof window ? window : {})
                    }, {}],
                    445: [function(require, module, exports) {
                        arguments[4][392][0].apply(exports, arguments)
                    }, {
                        dup: 392
                    }],
                    446: [function(require, module) {
                        module.exports = function(arg) {
                            return arg && "object" === typeof arg && "function" === typeof arg.copy && "function" === typeof arg.fill && "function" === typeof arg.readUInt8
                        }
                    }, {}],
                    447: [function(require, module, exports) {
                        (function(process, global) {
                            var formatRegExp = /%[sdj%]/g;
                            exports.format = function(f) {
                                if (!isString(f)) {
                                    for (var objects = [], i = 0; i < arguments.length; i++) {
                                        objects.push(inspect(arguments[i]))
                                    }
                                    return objects.join(" ")
                                }
                                for (var i = 1, args = arguments, len = args.length, str = (f + "").replace(formatRegExp, function(x) {
                                        if ("%%" === x) return "%";
                                        if (i >= len) return x;
                                        switch (x) {
                                            case "%s":
                                                return args[i++] + "";
                                            case "%d":
                                                return +args[i++];
                                            case "%j":
                                                try {
                                                    return JSON.stringify(args[i++])
                                                } catch (_) {
                                                    return "[Circular]"
                                                }
                                            default:
                                                return x;
                                        }
                                    }), x = args[i]; i < len; x = args[++i]) {
                                    if (isNull(x) || !isObject(x)) {
                                        str += " " + x
                                    } else {
                                        str += " " + inspect(x)
                                    }
                                }
                                return str
                            };
                            exports.deprecate = function(fn, msg) {
                                if (isUndefined(global.process)) {
                                    return function() {
                                        return exports.deprecate(fn, msg).apply(this, arguments)
                                    }
                                }
                                if (!0 === process.noDeprecation) {
                                    return fn
                                }
                                var warned = !1;

                                function deprecated() {
                                    if (!warned) {
                                        if (process.throwDeprecation) {
                                            throw new Error(msg)
                                        } else if (process.traceDeprecation) {
                                            console.trace(msg)
                                        } else {
                                            console.error(msg)
                                        }
                                        warned = !0
                                    }
                                    return fn.apply(this, arguments)
                                }
                                return deprecated
                            };
                            var debugs = {},
                                debugEnviron;
                            exports.debuglog = function(set) {
                                if (isUndefined(debugEnviron)) debugEnviron = process.env.NODE_DEBUG || "";
                                set = set.toUpperCase();
                                if (!debugs[set]) {
                                    if (new RegExp("\\b" + set + "\\b", "i").test(debugEnviron)) {
                                        var pid = process.pid;
                                        debugs[set] = function() {
                                            var msg = exports.format.apply(exports, arguments);
                                            console.error("%s %d: %s", set, pid, msg)
                                        }
                                    } else {
                                        debugs[set] = function() {}
                                    }
                                }
                                return debugs[set]
                            };

                            function inspect(obj, opts) {
                                var ctx = {
                                    seen: [],
                                    stylize: stylizeNoColor
                                };
                                if (3 <= arguments.length) ctx.depth = arguments[2];
                                if (4 <= arguments.length) ctx.colors = arguments[3];
                                if (isBoolean(opts)) {
                                    ctx.showHidden = opts
                                } else if (opts) {
                                    exports._extend(ctx, opts)
                                }
                                if (isUndefined(ctx.showHidden)) ctx.showHidden = !1;
                                if (isUndefined(ctx.depth)) ctx.depth = 2;
                                if (isUndefined(ctx.colors)) ctx.colors = !1;
                                if (isUndefined(ctx.customInspect)) ctx.customInspect = !0;
                                if (ctx.colors) ctx.stylize = stylizeWithColor;
                                return formatValue(ctx, obj, ctx.depth)
                            }
                            exports.inspect = inspect;
                            inspect.colors = {
                                bold: [1, 22],
                                italic: [3, 23],
                                underline: [4, 24],
                                inverse: [7, 27],
                                white: [37, 39],
                                grey: [90, 39],
                                black: [30, 39],
                                blue: [34, 39],
                                cyan: [36, 39],
                                green: [32, 39],
                                magenta: [35, 39],
                                red: [31, 39],
                                yellow: [33, 39]
                            };
                            inspect.styles = {
                                special: "cyan",
                                number: "yellow",
                                boolean: "yellow",
                                undefined: "grey",
                                null: "bold",
                                string: "green",
                                date: "magenta",
                                regexp: "red"
                            };

                            function stylizeWithColor(str, styleType) {
                                var style = inspect.styles[styleType];
                                if (style) {
                                    return "\x1B[" + inspect.colors[style][0] + "m" + str + "\x1B[" + inspect.colors[style][1] + "m"
                                } else {
                                    return str
                                }
                            }

                            function stylizeNoColor(str) {
                                return str
                            }

                            function arrayToHash(array) {
                                var hash = {};
                                array.forEach(function(val) {
                                    hash[val] = !0
                                });
                                return hash
                            }

                            function formatValue(ctx, value, recurseTimes) {
                                if (ctx.customInspect && value && isFunction(value.inspect) && value.inspect !== exports.inspect && !(value.constructor && value.constructor.prototype === value)) {
                                    var ret = value.inspect(recurseTimes, ctx);
                                    if (!isString(ret)) {
                                        ret = formatValue(ctx, ret, recurseTimes)
                                    }
                                    return ret
                                }
                                var primitive = formatPrimitive(ctx, value);
                                if (primitive) {
                                    return primitive
                                }
                                var keys = Object.keys(value),
                                    visibleKeys = arrayToHash(keys);
                                if (ctx.showHidden) {
                                    keys = Object.getOwnPropertyNames(value)
                                }
                                if (isError(value) && (0 <= keys.indexOf("message") || 0 <= keys.indexOf("description"))) {
                                    return formatError(value)
                                }
                                if (0 === keys.length) {
                                    if (isFunction(value)) {
                                        var name = value.name ? ": " + value.name : "";
                                        return ctx.stylize("[Function" + name + "]", "special")
                                    }
                                    if (isRegExp(value)) {
                                        return ctx.stylize(RegExp.prototype.toString.call(value), "regexp")
                                    }
                                    if (isDate(value)) {
                                        return ctx.stylize(Date.prototype.toString.call(value), "date")
                                    }
                                    if (isError(value)) {
                                        return formatError(value)
                                    }
                                }
                                var base = "",
                                    array = !1,
                                    braces = ["{", "}"];
                                if (isArray(value)) {
                                    array = !0;
                                    braces = ["[", "]"]
                                }
                                if (isFunction(value)) {
                                    var n = value.name ? ": " + value.name : "";
                                    base = " [Function" + n + "]"
                                }
                                if (isRegExp(value)) {
                                    base = " " + RegExp.prototype.toString.call(value)
                                }
                                if (isDate(value)) {
                                    base = " " + Date.prototype.toUTCString.call(value)
                                }
                                if (isError(value)) {
                                    base = " " + formatError(value)
                                }
                                if (0 === keys.length && (!array || 0 == value.length)) {
                                    return braces[0] + base + braces[1]
                                }
                                if (0 > recurseTimes) {
                                    if (isRegExp(value)) {
                                        return ctx.stylize(RegExp.prototype.toString.call(value), "regexp")
                                    } else {
                                        return ctx.stylize("[Object]", "special")
                                    }
                                }
                                ctx.seen.push(value);
                                var output;
                                if (array) {
                                    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys)
                                } else {
                                    output = keys.map(function(key) {
                                        return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array)
                                    })
                                }
                                ctx.seen.pop();
                                return reduceToSingleString(output, base, braces)
                            }

                            function formatPrimitive(ctx, value) {
                                if (isUndefined(value)) return ctx.stylize("undefined", "undefined");
                                if (isString(value)) {
                                    var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, "\"") + "'";
                                    return ctx.stylize(simple, "string")
                                }
                                if (isNumber(value)) return ctx.stylize("" + value, "number");
                                if (isBoolean(value)) return ctx.stylize("" + value, "boolean");
                                if (isNull(value)) return ctx.stylize("null", "null")
                            }

                            function formatError(value) {
                                return "[" + Error.prototype.toString.call(value) + "]"
                            }

                            function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
                                for (var output = [], i = 0, l = value.length; i < l; ++i) {
                                    if (hasOwnProperty(value, i + "")) {
                                        output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, i + "", !0))
                                    } else {
                                        output.push("")
                                    }
                                }
                                keys.forEach(function(key) {
                                    if (!key.match(/^\d+$/)) {
                                        output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, !0))
                                    }
                                });
                                return output
                            }

                            function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
                                var name, str, desc;
                                desc = Object.getOwnPropertyDescriptor(value, key) || {
                                    value: value[key]
                                };
                                if (desc.get) {
                                    if (desc.set) {
                                        str = ctx.stylize("[Getter/Setter]", "special")
                                    } else {
                                        str = ctx.stylize("[Getter]", "special")
                                    }
                                } else {
                                    if (desc.set) {
                                        str = ctx.stylize("[Setter]", "special")
                                    }
                                }
                                if (!hasOwnProperty(visibleKeys, key)) {
                                    name = "[" + key + "]"
                                }
                                if (!str) {
                                    if (0 > ctx.seen.indexOf(desc.value)) {
                                        if (isNull(recurseTimes)) {
                                            str = formatValue(ctx, desc.value, null)
                                        } else {
                                            str = formatValue(ctx, desc.value, recurseTimes - 1)
                                        }
                                        if (-1 < str.indexOf("\n")) {
                                            if (array) {
                                                str = str.split("\n").map(function(line) {
                                                    return "  " + line
                                                }).join("\n").substr(2)
                                            } else {
                                                str = "\n" + str.split("\n").map(function(line) {
                                                    return "   " + line
                                                }).join("\n")
                                            }
                                        }
                                    } else {
                                        str = ctx.stylize("[Circular]", "special")
                                    }
                                }
                                if (isUndefined(name)) {
                                    if (array && key.match(/^\d+$/)) {
                                        return str
                                    }
                                    name = JSON.stringify("" + key);
                                    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
                                        name = name.substr(1, name.length - 2);
                                        name = ctx.stylize(name, "name")
                                    } else {
                                        name = name.replace(/'/g, "\\'").replace(/\\"/g, "\"").replace(/(^"|"$)/g, "'");
                                        name = ctx.stylize(name, "string")
                                    }
                                }
                                return name + ": " + str
                            }

                            function reduceToSingleString(output, base, braces) {
                                var numLinesEst = 0,
                                    length = output.reduce(function(prev, cur) {
                                        numLinesEst++;
                                        if (0 <= cur.indexOf("\n")) numLinesEst++;
                                        return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1
                                    }, 0);
                                if (60 < length) {
                                    return braces[0] + ("" === base ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1]
                                }
                                return braces[0] + base + " " + output.join(", ") + " " + braces[1]
                            }

                            function isArray(ar) {
                                return Array.isArray(ar)
                            }
                            exports.isArray = isArray;

                            function isBoolean(arg) {
                                return "boolean" === typeof arg
                            }
                            exports.isBoolean = isBoolean;

                            function isNull(arg) {
                                return null === arg
                            }
                            exports.isNull = isNull;
                            exports.isNullOrUndefined = function(arg) {
                                return null == arg
                            };

                            function isNumber(arg) {
                                return "number" === typeof arg
                            }
                            exports.isNumber = isNumber;

                            function isString(arg) {
                                return "string" === typeof arg
                            }
                            exports.isString = isString;
                            exports.isSymbol = function(arg) {
                                return "symbol" === typeof arg
                            };

                            function isUndefined(arg) {
                                return void 0 === arg
                            }
                            exports.isUndefined = isUndefined;

                            function isRegExp(re) {
                                return isObject(re) && "[object RegExp]" === objectToString(re)
                            }
                            exports.isRegExp = isRegExp;

                            function isObject(arg) {
                                return "object" === typeof arg && null !== arg
                            }
                            exports.isObject = isObject;

                            function isDate(d) {
                                return isObject(d) && "[object Date]" === objectToString(d)
                            }
                            exports.isDate = isDate;

                            function isError(e) {
                                return isObject(e) && ("[object Error]" === objectToString(e) || e instanceof Error)
                            }
                            exports.isError = isError;

                            function isFunction(arg) {
                                return "function" === typeof arg
                            }
                            exports.isFunction = isFunction;
                            exports.isPrimitive = function(arg) {
                                return null === arg || "boolean" === typeof arg || "number" === typeof arg || "string" === typeof arg || "symbol" === typeof arg || "undefined" === typeof arg
                            };
                            exports.isBuffer = require("./support/isBuffer");

                            function objectToString(o) {
                                return Object.prototype.toString.call(o)
                            }

                            function pad(n) {
                                return 10 > n ? "0" + n.toString(10) : n.toString(10)
                            }
                            var months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];

                            function timestamp() {
                                var d = new Date,
                                    time = [pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds())].join(":");
                                return [d.getDate(), months[d.getMonth()], time].join(" ")
                            }
                            exports.log = function() {
                                console.log("%s - %s", timestamp(), exports.format.apply(exports, arguments))
                            };
                            exports.inherits = require("inherits");
                            exports._extend = function(origin, add) {
                                if (!add || !isObject(add)) return origin;
                                var keys = Object.keys(add),
                                    i = keys.length;
                                while (i--) {
                                    origin[keys[i]] = add[keys[i]]
                                }
                                return origin
                            };

                            function hasOwnProperty(obj, prop) {
                                return Object.prototype.hasOwnProperty.call(obj, prop)
                            }
                        }).call(this, require("_process"), "undefined" !== typeof global ? global : "undefined" !== typeof self ? self : "undefined" !== typeof window ? window : {})
                    }, {
                        "./support/isBuffer": 446,
                        _process: 399,
                        inherits: 445
                    }],
                    448: [function(require, module) {
                        (function(Buffer) {
                            var bs58check = require("bs58check");

                            function decodeRaw(buffer, version) {
                                if (version !== void 0 && buffer[0] !== version) throw new Error("Invalid network version");
                                if (33 === buffer.length) {
                                    return {
                                        version: buffer[0],
                                        privateKey: buffer.slice(1, 33),
                                        compressed: !1
                                    }
                                }
                                if (34 !== buffer.length) throw new Error("Invalid WIF length");
                                if (1 !== buffer[33]) throw new Error("Invalid compression flag");
                                return {
                                    version: buffer[0],
                                    privateKey: buffer.slice(1, 33),
                                    compressed: !0
                                }
                            }

                            function encodeRaw(version, privateKey, compressed) {
                                var result = new Buffer(compressed ? 34 : 33);
                                result.writeUInt8(version, 0);
                                privateKey.copy(result, 1);
                                if (compressed) {
                                    result[33] = 1
                                }
                                return result
                            }
                            module.exports = {
                                decode: function(string, version) {
                                    return decodeRaw(bs58check.decode(string), version)
                                },
                                decodeRaw: decodeRaw,
                                encode: function(version, privateKey, compressed) {
                                    if ("number" === typeof version) return bs58check.encode(encodeRaw(version, privateKey, compressed));
                                    return bs58check.encode(encodeRaw(version.version, version.privateKey, version.compressed))
                                },
                                encodeRaw: encodeRaw
                            }
                        }).call(this, require("buffer").Buffer)
                    }, {
                        bs58check: 41,
                        buffer: 45
                    }],
                    449: [function(require, module, exports) {
                        (function(process, Buffer) {
                            var Url = require("url"),
                                spawn = require("child_process").spawn,
                                fs = require("fs");
                            exports.XMLHttpRequest = function() {
                                "use strict";
                                var self = this,
                                    http = require("http"),
                                    https = require("https"),
                                    request, response, settings = {},
                                    disableHeaderCheck = !1,
                                    defaultHeaders = {
                                        "User-Agent": "node-XMLHttpRequest",
                                        Accept: "*/*"
                                    },
                                    headers = {},
                                    headersCase = {},
                                    forbiddenRequestHeaders = ["accept-charset", "accept-encoding", "access-control-request-headers", "access-control-request-method", "connection", "content-length", "content-transfer-encoding", "cookie", "cookie2", "date", "expect", "host", "keep-alive", "origin", "referer", "te", "trailer", "transfer-encoding", "upgrade", "via"],
                                    forbiddenRequestMethods = ["TRACE", "TRACK", "CONNECT"],
                                    sendFlag = !1,
                                    errorFlag = !1,
                                    listeners = {};
                                this.UNSENT = 0;
                                this.OPENED = 1;
                                this.HEADERS_RECEIVED = 2;
                                this.LOADING = 3;
                                this.DONE = 4;
                                this.readyState = this.UNSENT;
                                this.onreadystatechange = null;
                                this.responseText = "";
                                this.responseXML = "";
                                this.status = null;
                                this.statusText = null;
                                this.withCredentials = !1;
                                var isAllowedHttpHeader = function(header) {
                                        return disableHeaderCheck || header && -1 === forbiddenRequestHeaders.indexOf(header.toLowerCase())
                                    },
                                    isAllowedHttpMethod = function(method) {
                                        return method && -1 === forbiddenRequestMethods.indexOf(method)
                                    };
                                this.open = function(method, url, async, user, password) {
                                    this.abort();
                                    errorFlag = !1;
                                    if (!isAllowedHttpMethod(method)) {
                                        throw new Error("SecurityError: Request method not allowed")
                                    }
                                    settings = {
                                        method: method,
                                        url: url.toString(),
                                        async: "boolean" !== typeof async ? !0 : async,
                                        user: user || null,
                                        password: password || null
                                    };
                                    setState(this.OPENED)
                                };
                                this.setDisableHeaderCheck = function(state) {
                                    disableHeaderCheck = state
                                };
                                this.setRequestHeader = function(header, value) {
                                    if (this.readyState !== this.OPENED) {
                                        throw new Error("INVALID_STATE_ERR: setRequestHeader can only be called when state is OPEN")
                                    }
                                    if (!isAllowedHttpHeader(header)) {
                                        console.warn("Refused to set unsafe header \"" + header + "\"");
                                        return
                                    }
                                    if (sendFlag) {
                                        throw new Error("INVALID_STATE_ERR: send flag is true")
                                    }
                                    header = headersCase[header.toLowerCase()] || header;
                                    headersCase[header.toLowerCase()] = header;
                                    headers[header] = headers[header] ? headers[header] + ", " + value : value
                                };
                                this.getResponseHeader = function(header) {
                                    if ("string" === typeof header && this.readyState > this.OPENED && response && response.headers && response.headers[header.toLowerCase()] && !errorFlag) {
                                        return response.headers[header.toLowerCase()]
                                    }
                                    return null
                                };
                                this.getAllResponseHeaders = function() {
                                    if (this.readyState < this.HEADERS_RECEIVED || errorFlag) {
                                        return ""
                                    }
                                    var result = "";
                                    for (var i in response.headers) {
                                        if ("set-cookie" !== i && "set-cookie2" !== i) {
                                            result += i + ": " + response.headers[i] + "\r\n"
                                        }
                                    }
                                    return result.substr(0, result.length - 2)
                                };
                                this.getRequestHeader = function(name) {
                                    if ("string" === typeof name && headersCase[name.toLowerCase()]) {
                                        return headers[headersCase[name.toLowerCase()]]
                                    }
                                    return ""
                                };
                                this.send = function(data) {
                                    if (this.readyState !== this.OPENED) {
                                        throw new Error("INVALID_STATE_ERR: connection must be opened before send() is called")
                                    }
                                    if (sendFlag) {
                                        throw new Error("INVALID_STATE_ERR: send has already been called")
                                    }
                                    var ssl = !1,
                                        local = !1,
                                        url = Url.parse(settings.url),
                                        host;
                                    switch (url.protocol) {
                                        case "https:":
                                            ssl = !0;
                                        case "http:":
                                            host = url.hostname;
                                            break;
                                        case "file:":
                                            local = !0;
                                            break;
                                        case void 0:
                                        case null:
                                        case "":
                                            host = "localhost";
                                            break;
                                        default:
                                            throw new Error("Protocol not supported.");
                                    }
                                    if (local) {
                                        if ("GET" !== settings.method) {
                                            throw new Error("XMLHttpRequest: Only GET method is supported")
                                        }
                                        if (settings.async) {
                                            fs.readFile(url.pathname, "utf8", function(error, data) {
                                                if (error) {
                                                    self.handleError(error)
                                                } else {
                                                    self.status = 200;
                                                    self.responseText = data;
                                                    setState(self.DONE)
                                                }
                                            })
                                        } else {
                                            try {
                                                this.responseText = fs.readFileSync(url.pathname, "utf8");
                                                this.status = 200;
                                                setState(self.DONE)
                                            } catch (e) {
                                                this.handleError(e)
                                            }
                                        }
                                        return
                                    }
                                    var port = url.port || (ssl ? 443 : 80),
                                        uri = url.pathname + (url.search ? url.search : "");
                                    for (var name in defaultHeaders) {
                                        if (!headersCase[name.toLowerCase()]) {
                                            headers[name] = defaultHeaders[name]
                                        }
                                    }
                                    headers.Host = host;
                                    if (!(ssl && 443 === port || 80 === port)) {
                                        headers.Host += ":" + url.port
                                    }
                                    if (settings.user) {
                                        if ("undefined" === typeof settings.password) {
                                            settings.password = ""
                                        }
                                        var authBuf = new Buffer(settings.user + ":" + settings.password);
                                        headers.Authorization = "Basic " + authBuf.toString("base64")
                                    }
                                    if ("GET" === settings.method || "HEAD" === settings.method) {
                                        data = null
                                    } else if (data) {
                                        headers["Content-Length"] = Buffer.isBuffer(data) ? data.length : Buffer.byteLength(data);
                                        if (!headers["Content-Type"]) {
                                            headers["Content-Type"] = "text/plain;charset=UTF-8"
                                        }
                                    } else if ("POST" === settings.method) {
                                        headers["Content-Length"] = 0
                                    }
                                    var options = {
                                        host: host,
                                        port: port,
                                        path: uri,
                                        method: settings.method,
                                        headers: headers,
                                        agent: !1,
                                        withCredentials: self.withCredentials
                                    };
                                    errorFlag = !1;
                                    if (settings.async) {
                                        var doRequest = ssl ? https.request : http.request;
                                        sendFlag = !0;
                                        self.dispatchEvent("readystatechange");
                                        var responseHandler = function responseHandler(resp) {
                                                response = resp;
                                                if (301 === response.statusCode || 302 === response.statusCode || 303 === response.statusCode || 307 === response.statusCode) {
                                                    settings.url = response.headers.location;
                                                    var url = Url.parse(settings.url);
                                                    host = url.hostname;
                                                    var newOptions = {
                                                        hostname: url.hostname,
                                                        port: url.port,
                                                        path: url.path,
                                                        method: 303 === response.statusCode ? "GET" : settings.method,
                                                        headers: headers,
                                                        withCredentials: self.withCredentials
                                                    };
                                                    request = doRequest(newOptions, responseHandler).on("error", errorHandler);
                                                    request.end();
                                                    return
                                                }
                                                response.setEncoding("utf8");
                                                setState(self.HEADERS_RECEIVED);
                                                self.status = response.statusCode;
                                                response.on("data", function(chunk) {
                                                    if (chunk) {
                                                        self.responseText += chunk
                                                    }
                                                    if (sendFlag) {
                                                        setState(self.LOADING)
                                                    }
                                                });
                                                response.on("end", function() {
                                                    if (sendFlag) {
                                                        setState(self.DONE);
                                                        sendFlag = !1
                                                    }
                                                });
                                                response.on("error", function(error) {
                                                    self.handleError(error)
                                                })
                                            },
                                            errorHandler = function(error) {
                                                self.handleError(error)
                                            };
                                        request = doRequest(options, responseHandler).on("error", errorHandler);
                                        if (data) {
                                            request.write(data)
                                        }
                                        request.end();
                                        self.dispatchEvent("loadstart")
                                    } else {
                                        var contentFile = ".node-xmlhttprequest-content-" + process.pid,
                                            syncFile = ".node-xmlhttprequest-sync-" + process.pid;
                                        fs.writeFileSync(syncFile, "", "utf8");
                                        var execString = "var http = require('http'), https = require('https'), fs = require('fs');" + "var doRequest = http" + (ssl ? "s" : "") + ".request;" + "var options = " + JSON.stringify(options) + ";" + "var responseText = '';" + "var req = doRequest(options, function(response) {" + "response.setEncoding('utf8');" + "response.on('data', function(chunk) {" + "  responseText += chunk;" + "});" + "response.on('end', function() {" + "fs.writeFileSync('" + contentFile + "', JSON.stringify({err: null, data: {statusCode: response.statusCode, headers: response.headers, text: responseText}}), 'utf8');" + "fs.unlinkSync('" + syncFile + "');" + "});" + "response.on('error', function(error) {" + "fs.writeFileSync('" + contentFile + "', JSON.stringify({err: error}), 'utf8');" + "fs.unlinkSync('" + syncFile + "');" + "});" + "}).on('error', function(error) {" + "fs.writeFileSync('" + contentFile + "', JSON.stringify({err: error}), 'utf8');" + "fs.unlinkSync('" + syncFile + "');" + "});" + (data ? "req.write('" + JSON.stringify(data).slice(1, -1).replace(/'/g, "\\'") + "');" : "") + "req.end();",
                                            syncProc = spawn(process.argv[0], ["-e", execString]);
                                        while (fs.existsSync(syncFile)) {}
                                        var resp = JSON.parse(fs.readFileSync(contentFile, "utf8"));
                                        syncProc.stdin.end();
                                        fs.unlinkSync(contentFile);
                                        if (resp.err) {
                                            self.handleError(resp.err)
                                        } else {
                                            response = resp.data;
                                            self.status = resp.data.statusCode;
                                            self.responseText = resp.data.text;
                                            setState(self.DONE)
                                        }
                                    }
                                };
                                this.handleError = function(error) {
                                    this.status = 0;
                                    this.statusText = error;
                                    this.responseText = error.stack;
                                    errorFlag = !0;
                                    setState(this.DONE);
                                    this.dispatchEvent("error")
                                };
                                this.abort = function() {
                                    if (request) {
                                        request.abort();
                                        request = null
                                    }
                                    headers = defaultHeaders;
                                    this.status = 0;
                                    this.responseText = "";
                                    this.responseXML = "";
                                    errorFlag = !0;
                                    if (this.readyState !== this.UNSENT && (this.readyState !== this.OPENED || sendFlag) && this.readyState !== this.DONE) {
                                        sendFlag = !1;
                                        setState(this.DONE)
                                    }
                                    this.readyState = this.UNSENT;
                                    this.dispatchEvent("abort")
                                };
                                this.addEventListener = function(event, callback) {
                                    if (!(event in listeners)) {
                                        listeners[event] = []
                                    }
                                    listeners[event].push(callback)
                                };
                                this.removeEventListener = function(event, callback) {
                                    if (event in listeners) {
                                        listeners[event] = listeners[event].filter(function(ev) {
                                            return ev !== callback
                                        })
                                    }
                                };
                                this.dispatchEvent = function(event) {
                                    if ("function" === typeof self["on" + event]) {
                                        self["on" + event]()
                                    }
                                    if (event in listeners) {
                                        for (var i = 0, len = listeners[event].length; i < len; i++) {
                                            listeners[event][i].call(self)
                                        }
                                    }
                                };
                                var setState = function(state) {
                                    if (state == self.LOADING || self.readyState !== state) {
                                        self.readyState = state;
                                        if (settings.async || self.readyState < self.OPENED || self.readyState === self.DONE) {
                                            self.dispatchEvent("readystatechange")
                                        }
                                        if (self.readyState === self.DONE && !errorFlag) {
                                            self.dispatchEvent("load");
                                            self.dispatchEvent("loadend")
                                        }
                                    }
                                }
                            }
                        }).call(this, require("_process"), require("buffer").Buffer)
                    }, {
                        _process: 399,
                        buffer: 45,
                        child_process: 39,
                        fs: 39,
                        http: 431,
                        https: 390,
                        url: 442
                    }],
                    450: [function(require, module) {
                        module.exports = function() {
                            for (var target = {}, i = 0, source; i < arguments.length; i++) {
                                source = arguments[i];
                                for (var key in source) {
                                    if (hasOwnProperty.call(source, key)) {
                                        target[key] = source[key]
                                    }
                                }
                            }
                            return target
                        };
                        var hasOwnProperty = Object.prototype.hasOwnProperty
                    }, {}]
                }, {}, [7])(7)
            });
        </script>
        <script>
            Polymer({
                is: "credential-verifier",
                behaviors: [Polymer.IronResizableBehavior],
                listeners: {
                    "iron-resize": "onWidthChange"
                },
                properties: {
                    href: {
                        type: String,
                        value: ""
                    },
                    _certificate: {
                        type: Object,
                        value: null
                    },
                    _recipient: {
                        type: String,
                        readOnly: !0
                    },
                    _version: {
                        type: String,
                        value: ""
                    },
                    _publicKey: {
                        type: String,
                        value: ""
                    },
                    _issueDate: {
                        type: String,
                        readOnly: !0
                    },
                    _issuer: {
                        type: String,
                        readOnly: !0
                    },
                    _issuerLogo: {
                        type: String,
                        readOnly: !0
                    },
                    _certificateName: {
                        type: String,
                        value: "",
                        readOnly: !0
                    },
                    _certificateLink: {
                        type: String,
                        value: "",
                        readOnly: !0
                    },
                    _transactionLink: {
                        type: String,
                        value: "",
                        readOnly: !0
                    },
                    _issuanceDomain: {
                        type: String,
                        value: "",
                        readOnly: !0
                    },
                    _view: {
                        type: String,
                        value: "fill-certificate"
                    },
                    _rawCertificateData: {
                        type: String,
                        value: ""
                    },
                    _verifyBtnDisabled: {
                        type: Boolean,
                        value: !0
                    },
                    _showSpinner: {
                        type: Boolean,
                        value: !1
                    },
                    _isMainnet: {
                        type: Boolean,
                        value: !1
                    },
                    _network: {
                        type: String,
                        value: ""
                    },
                    _previousStepCode: {
                        type: String,
                        value: ""
                    },
                    _renderedSteps: {
                        type: Array,
                        value: []
                    },
                    _currentRenderedStepIndex: {
                        type: Number,
                        value: 0
                    },
                    _steps: {
                        type: Array,
                        value: []
                    },
                    _prevStepIndex: {
                        type: Number,
                        value: -1
                    },
                    _prevSubStepIndex: {
                        type: Number,
                        value: -1
                    },
                    _showSuccess: {
                        type: Boolean,
                        value: !1
                    },
                    _errorMsg: {
                        type: String,
                        value: ""
                    },
                    _verificationInterval: {
                        type: Number,
                        value: null
                    },
                    _isCertificateVerified: {
                        type: Boolean,
                        value: !1
                    },
                    _slowestStepCode: {
                        type: String,
                        value: ""
                    }
                },
                resetStandalone: function() {
                    this._certificate = null;
                    this._receipt = null;
                    this._version = null;
                    this._publicKey = null;
                    this._issueDate = null;
                    this._issuer = null;
                    this._issuerLogo = null;
                    this._certificateName = null;
                    this._certificateLink = null;
                    this._transactionLink = null;
                    this._issuanceDomain = null;
                    this._rawCertificateData = "";
                    this._verifyBtnDisabled = !0;
                    this._showSpinner = !1;
                    this._isMainnet = !1;
                    this._network = "";
                    this._previousStepCode = "";
                    this._renderedSteps = [];
                    this._currentRenderedStepIndex = 0;
                    this._steps = [];
                    this._prevStepIndex = -1;
                    this._prevSubStepIndex = -1;
                    this._errorMsg = "";
                    this._verificationInterval = null;
                    this._isCertificateVerified = !1;
                    this._slowestStepCode = "";
                    this.$$("#certificate-json-url").value = "";
                    this.$$("#file-selector").value = "";
                    this._toggleView("fill-certificate");
                    this._setComponentClass("failure", !1);
                    var stepVerified = this.$$(".step-verified");
                    if (stepVerified) {
                        stepVerified.classList.remove("in")
                    }
                    this._showSuccess = !1;
                    this._$progressBar.classList.add("no-transition");
                    this._$progressBar.style.paddingTop = "0px";
                    this._increaseProgressBarHeight(0, !0);
                    var self = this;
                    setTimeout(function() {
                        self._$progressBar.classList.remove("no-transition")
                    }, 100)
                },
                _onLoadJson: function(status, response) {
                    if (!status) {
                        var parsedJson = JSON.parse(JSON.stringify(response));
                        if ("string" === typeof parsedJson) {
                            parsedJson = JSON.parse(response)
                        }
                        this.processJson(parsedJson)
                    } else {
                        this._onLoadError(null, "This is an invalid certificate URL.")
                    }
                },
                _onLoadError: function(err, message) {
                    this._showSpinner = !1;
                    this.urlFieldChanged();
                    console.log("err", err, " - message", message);
                    message = message || "";
                    this._errorMsg = message
                },
                _getDomainFromUrl: function(url, keepProtocol) {
                    keepProtocol = "undefined" === typeof keepProtocol ? !1 : keepProtocol;
                    var result = "",
                        parser = document.createElement("a");
                    parser.href = url;
                    if (keepProtocol) {
                        result = parser.protocol + "//"
                    }
                    result += parser.hostname + ("" !== parser.port ? parser.port : "");
                    return result
                },
                _capitalize: function(str) {
                    return str.charAt(0).toUpperCase() + str.slice(1)
                },
                _setNetwork: function(chain) {
                    var network = "bitcoin" === chain ? "mainnet" : chain;
                    this._isMainnet = "mainnet" === network;
                    this._network = this._capitalize(network);
                    this._slowestStepCode = "mainnet" === chain || "testnet" === chain || "ethmain" === chain ? "fetchingRemoteHash" : "comparingHashes"
                },
                _networkRequiresFetchingHash: function() {
                    var chain = this._network.toLowerCase();
                    return "mainnet" === chain || "testnet" === chain || "ethmain" === chain
                },
                urlFieldChanged: function() {
                    var valLen = this.$$("#certificate-json-url").value.length;
                    this._verifyBtnDisabled = 0 === valLen;
                    if (0 === valLen) {
                        this._errorMsg = ""
                    }
                },
                setFile: function() {
                    this.processFile(this.$$("#file-selector").files[0])
                },
                processFile: function(file) {
                    if (!file) {
                        return
                    }
                    var self = this,
                        reader = new FileReader;
                    reader.onload = function() {
                        return function(e) {
                            try {
                                self.processJson(JSON.parse(e.target.result))
                            } catch (e) {
                                self._onLoadError(e, "Invalid certificate format.")
                            }
                        }
                    }(file);
                    reader.readAsText(file)
                },
                processJson: function(jsonContent) {
                    if (!jsonContent) {
                        return
                    }
                    try {
                        var cert = Verifier.Certificate.parseJson(jsonContent);
                        this._rawCertificateData = JSON.stringify(jsonContent);
                        this.onLoadCertificate({
                            certificate: jsonContent.document ? jsonContent.document : jsonContent,
                            receipt: "1.2" === cert.version ? jsonContent.receipt : jsonContent.signature,
                            version: cert.version,
                            transaction: {
                                id: cert.transactionId,
                                link: cert.transactionLink
                            }
                        });
                        if (!window.certificateTracker) {
                            var issuerData = "1.2" === cert.version ? jsonContent.document.certificate.issuer : jsonContent.badge.issuer,
                                uid = "1.2" === cert.version ? jsonContent.document.assertion.uid : jsonContent.universalIdentifier || jsonContent.id;
                            window.certificateTracker = new Tracker(issuerData, this._getDomainFromUrl(cert.issuer.id, !0), uid, "verification-portal")
                        }
                        this.verify()
                    } catch (err) {
                        throw new Error(err)
                    }
                },
                onLoadCertificate: function(certificateObj) {
                    this._certificate = certificateObj.certificate;
                    this._receipt = certificateObj.receipt;
                    this._version = certificateObj.version;
                    var _recipient = "1.2" === this._version ? this._certificate.recipient : this._certificate.recipient.recipientProfile ? this._certificate.recipient.recipientProfile : this._certificate.recipientProfile;
                    this._publicKey = _recipient.publicKey;
                    var recipientName = "1.2" === this._version ? _recipient.givenName + " " + _recipient.familyName : _recipient.name,
                        certContent = "1.2" === this._version ? this._certificate.assertion : this._certificate,
                        badge = "1.2" === this._version ? this._certificate.certificate : this._certificate.badge;
                    this._set_recipient(recipientName);
                    var objDate = new Date(certContent.issuedOn);
                    this._set_issueDate(["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sept", "Oct", "Nov", "Dec"][objDate.getMonth()] + " " + objDate.getDate() + ", " + objDate.getFullYear());
                    this._set_issuer(badge.issuer.name);
                    this._set_issuerLogo(badge.issuer.image);
                    this._set_certificateName(badge.name);
                    this._set_certificateLink(this._certificate.id);
                    this._set_transactionLink(certificateObj.transaction.link);
                    this._set_issuanceDomain(this._getDomainFromUrl(badge.issuer.url));
                    this._toggleView("show-certificate")
                },
                _toggleView: function(view) {
                    this._view = view
                },
                _ensureJsonFormat: function(url) {
                    var jsonFormat = "format=json";
                    return 0 > url.indexOf(jsonFormat) ? url + (-1 < url.indexOf("?") ? "&" : "?") + jsonFormat : url
                },
                loadJsonUrl: function(url) {
                    var self = this;
                    this._verifyBtnDisabled = !0;
                    this._errorMsg = "";
                    this._showSpinner = !0;
                    if (!url) {
                        var jsonUrl = this.$$("#certificate-json-url").value;
                        if (!jsonUrl) {
                            return
                        }
                    } else {
                        jsonUrl = url
                    }
                    jsonUrl = this._ensureJsonFormat(jsonUrl, "format=json");
                    var xhr = new XMLHttpRequest;
                    xhr.open("GET", jsonUrl, !0);
                    xhr.responseType = "json";
                    xhr.onload = function() {
                        if (!xhr.response || "" === xhr.response) {
                            self._onLoadError(null, "This is an invalid certificate URL:", jsonUrl)
                        }
                        var status = xhr.status;
                        if (200 === status) {
                            self._onLoadJson(null, xhr.response)
                        } else {
                            self._onLoadError(null, "This is an invalid certificate URL.")
                        }
                    };
                    xhr.onerror = function(e) {
                        self._onLoadError(e, "Impossible to load the certificate URL.");
                        self._verifyBtnDisabled = !1
                    };
                    xhr.send()
                },
                _init: function() {
                    this._static = {
                        processDotHeight: 14,
                        listMarginBottom: 13,
                        processingDelay: 1100,
                        showSuccessDelay: 300
                    };
                    this._staticSteps = [{
                        code: "formatValidation",
                        label: "Format validation",
                        labelProcess: "Validating format"
                    }, {
                        code: "hashComparison",
                        label: "Hash comparison",
                        labelProcess: "Comparing hash"
                    }, {
                        code: "statusCheck",
                        label: "Status check",
                        labelProcess: "Checking record status"
                    }];
                    this._staticSubSteps = [{
                        label: "Get transaction ID",
                        code: "getTransactionId",
                        status: "starting",
                        errorTitle: "Error",
                        step: "formatValidation"
                    }, {
                        label: "Compute local hash",
                        code: "computingLocalHash",
                        status: "starting",
                        errorTitle: "Error",
                        step: "formatValidation"
                    }, {
                        label: "Fetch remote hash",
                        code: "fetchingRemoteHash",
                        status: "starting",
                        errorTitle: "Error",
                        step: "formatValidation"
                    }, {
                        label: "Get issuer profile",
                        code: "gettingIssuerProfile",
                        status: "starting",
                        errorTitle: "Error",
                        step: "formatValidation"
                    }, {
                        label: "Parse issuer keys",
                        code: "parsingIssuerKeys",
                        status: "starting",
                        errorTitle: "Error",
                        step: "formatValidation"
                    }, {
                        label: "Compare hashes",
                        code: "comparingHashes",
                        status: "starting",
                        errorTitle: "Error",
                        step: "hashComparison"
                    }, {
                        label: "Check Merkle root",
                        code: "checkingMerkleRoot",
                        status: "starting",
                        errorTitle: "Error",
                        step: "hashComparison"
                    }, {
                        label: "Check receipt",
                        code: "checkingReceipt",
                        status: "starting",
                        errorTitle: "Error",
                        step: "hashComparison"
                    }, {
                        label: "Revoked status check",
                        code: "checkingRevokedStatus",
                        status: "starting",
                        errorTitle: "Revoked",
                        step: "statusCheck"
                    }, {
                        label: "Issuer signature check",
                        code: "checkingAuthenticity",
                        status: "starting",
                        errorTitle: "Invalid",
                        step: "statusCheck"
                    }, {
                        label: "Expired status check",
                        code: "checkingExpiresDate",
                        status: "starting",
                        errorTitle: "Expired",
                        step: "statusCheck"
                    }]
                },
                created: function() {
                    this._init();
                    var self = this;
                    this.addEventListener("certificateLoaded", function(e) {
                        self.onLoadCertificate(e.detail)
                    })
                },
                onWidthChange: function() {
                    var offsetWidth = this.offsetWidth,
                        self = this;
                    [600, 800].forEach(function(breakpoint) {
                        if (offsetWidth <= breakpoint && (self.windowWidth > offsetWidth || !self.windowWidth)) {
                            self._setComponentClass("cf-mq-" + breakpoint, !0)
                        } else if (offsetWidth > breakpoint && (self.windowWidth < offsetWidth || !self.windowWidth)) {
                            self._setComponentClass("cf-mq-" + breakpoint, !1)
                        }
                    });
                    this.windowWidth = offsetWidth
                },
                ready: function() {
                    this._initDragDrop()
                },
                attached: function() {
                    var self = this;
                    document.querySelector("#certificate-json-url").addEventListener("paste", function() {
                        self._showSpinner = !0;
                        setTimeout(function() {
                            self.loadJsonUrl()
                        }, 100)
                    })
                },
                _initDragDrop: function() {
                    var self = this,
                        $dragArea = Polymer.dom(this.root).querySelectorAll(".drag");
                    [].forEach.call($dragArea, function(e) {
                        e.addEventListener("dragenter", function(e) {
                            self._dragEnter(e)
                        }, !1);
                        e.addEventListener("dragleave", function(e) {
                            self._dragLeave(e)
                        }, !1);
                        e.addEventListener("dragover", function(e) {
                            self._dragOver(e)
                        }, !1);
                        e.addEventListener("drop", function(e) {
                            self._drop(e)
                        }, !1)
                    })
                },
                _dragEnter: function(e) {
                    e.stopPropagation();
                    e.preventDefault();
                    this._setComponentClass("drag-on", !0)
                },
                _dragLeave: function(e) {
                    e.stopPropagation();
                    e.preventDefault();
                    this._setComponentClass("drag-on", !1)
                },
                _dragOver: function(e) {
                    e.stopPropagation();
                    e.preventDefault();
                    this._setComponentClass("drag-on", !0)
                },
                _drop: function(e) {
                    e.stopPropagation();
                    e.preventDefault();
                    this._setComponentClass("drag-on", !1);
                    if (this._certificate) {
                        this.resetStandalone()
                    }
                    var dt = (e.originalEvent || e).dataTransfer,
                        file = dt.files[0];
                    if ("application/json" === file.type) {
                        this.processFile(file)
                    }
                },
                verify: function() {
                    var dataString = this._rawCertificateData,
                        self = this,
                        verifier = new Verifier.CertificateVerifier(dataString, function(stepCode, message, status) {
                            self._updateStatus(stepCode, message, status)
                        });
                    this._setNetwork(verifier.certificate.chainAsString);
                    if (this._isMainnet) {
                        window.certificateTracker.track("verified")
                    }
                    verifier.verify(function(stepCode, message, status) {
                        self._isCertificateVerified = "success" === status || "mockSuccess" === status;
                        self._updateStepStatus(self._steps.length - 1)
                    })
                },
                _resetAnimation: function() {
                    this._$progressBar = this.$$(".progress");
                    this._increaseProgressBarHeight(this._static.processDotHeight, !0)
                },
                isStepReached: function(item) {
                    if (!item) {
                        return !1
                    }
                    return "" !== item.status
                },
                toggleSubSteps: function(e, listIdx) {
                    var listIndex;
                    if (null != e) {
                        if (null == e.target) {
                            return
                        }
                        listIndex = parseInt(e.target.getAttribute("data-idx"))
                    } else {
                        listIndex = listIdx
                    }
                    var sublist = this.$$(".sublist-" + listIndex),
                        subListHeight = sublist.getAttribute("data-max-height");
                    if (!subListHeight) {
                        subListHeight = this._getSubListHeight(sublist, listIndex, !1)
                    }
                    if ("undefined" !== typeof listIndex && null != listIndex) {
                        var list = Polymer.dom(this.root).querySelector(".list-" + listIndex),
                            isOpen = this._renderedSteps[listIndex].toggleSubSteps;
                        this.toggleClass("opened", !isOpen, list);
                        this.set(["_renderedSteps", listIndex, "toggleSubSteps"], !isOpen);
                        sublist.style.height = isOpen ? "0" : subListHeight + "px";
                        var newPaddingTop = this._getElementStylePropertyValue(this._$progressBar, "padding-top") + (isOpen ? -1 : 1) * subListHeight;
                        this._$progressBar.style.paddingTop = newPaddingTop + "px"
                    }
                },
                _getSubListHeight: function(sublist, listIndex, full) {
                    var subListItems = document.querySelectorAll(".sublist-" + listIndex + " > li"),
                        subListHeight = 0;
                    [].forEach.call(subListItems, function(s) {
                        subListHeight += s.clientHeight
                    });
                    if (full) {
                        subListHeight += this._getElementStylePropertyValue(sublist, "margin-bottom")
                    }
                    sublist.setAttribute("data-max-height", subListHeight);
                    return subListHeight
                },
                getSubStepTogglerText: function(isOpened, count) {
                    return isOpened ? "Hide" : count + " " + (1 < count ? "Items" : "Item")
                },
                deepCopy: function(obj) {
                    return JSON.parse(JSON.stringify(obj))
                },
                _getStepIndex: function(step) {
                    var stepIndex = this._steps.map(function(e) {
                        return e.code
                    }).indexOf(step);
                    if (-1 === stepIndex) {
                        var newStep = this.deepCopy(this._staticSteps[this._prevStepIndex + 1]);
                        newStep.subSteps = [];
                        newStep.status = "";
                        newStep.toggleSubSteps = !1;
                        this._steps.push(newStep);
                        return this._steps.length - 1
                    } else {
                        return stepIndex
                    }
                },
                _updateStatus: function(stepCode, message, status) {
                    var newSubStep, step, stepIndex, newSubStepIndex = this._prevSubStepIndex;
                    newSubStep = this.deepCopy(this._staticSubSteps.filter(function(e) {
                        return e.code === stepCode
                    })[0]);
                    step = newSubStep.step;
                    stepIndex = this._getStepIndex(step);
                    if (this._previousStepCode !== stepCode) {
                        if (0 === stepIndex && -1 === this._prevSubStepIndex) {
                            this._processStep()
                        }
                        newSubStepIndex = this._steps[stepIndex].subSteps.push(newSubStep) - 1
                    }
                    if (-1 !== this._prevSubStepIndex) {
                        this.set(["_steps", stepIndex, "subSteps", newSubStepIndex, "status"], status);
                        if ("failure" === status) {
                            this.failureTitle = this._steps[stepIndex].subSteps[newSubStepIndex].errorTitle;
                            this.set(["_steps", stepIndex, "subSteps", newSubStepIndex, "errorMessage"], message)
                        }
                        if (this._prevStepIndex !== stepIndex || this._prevStepIndex === stepIndex && "failure" === status) {
                            this._updateStepStatus(this._prevStepIndex)
                        }
                        if (this._prevStepIndex !== stepIndex && "final" !== stepCode && "failure" !== status) {
                            this.set(["_steps", stepIndex, "status"], "starting")
                        }
                    }
                    if (stepCode === this._slowestStepCode && "starting" !== status) {
                        this._startVerificationAnimation()
                    }
                    this._previousStepCode = stepCode;
                    this._prevStepIndex = stepIndex;
                    this._prevSubStepIndex = newSubStepIndex
                },
                _updateStepStatus: function(stepIndex) {
                    var allSubStepsStatuses = this._steps[stepIndex].subSteps.map(function(e) {
                        return e.status
                    });
                    this.set(["_steps", stepIndex, "status"], -1 < allSubStepsStatuses.indexOf("failure") ? "failure" : "success")
                },
                _startVerificationAnimation: function() {
                    var self = this;
                    this._verificationInterval = setInterval(function() {
                        self._concludeStep();
                        if (self._currentRenderedStepIndex < self._steps.length - 1) {
                            self._currentRenderedStepIndex++;
                            self._processStep()
                        } else {
                            self._killVerificationAnimation()
                        }
                    }, this._static.processingDelay)
                },
                _killVerificationAnimation: function() {
                    clearInterval(this._verificationInterval);
                    this._verificationInterval = null;
                    this._showMiniVerified = !0;
                    if (this._isCertificateVerified) {
                        var self = this;
                        setTimeout(function() {
                            self._addSuccessMessage()
                        }, this._static.showSuccessDelay)
                    } else {
                        this._setComponentClass("failure", !0)
                    }
                },
                _concludeStep: function() {
                    var memoryStepStatus = this._steps[this._currentRenderedStepIndex].status,
                        subSteps = this._steps[this._currentRenderedStepIndex].subSteps;
                    this.set(["_renderedSteps", this._currentRenderedStepIndex, "status"], memoryStepStatus);
                    this.set(["_renderedSteps", this._currentRenderedStepIndex, "subSteps"], subSteps);
                    var self = this;
                    setTimeout(function() {
                        if ("failure" !== memoryStepStatus) {
                            self._increaseProgressBarHeight(self._static.listMarginBottom, !1)
                        } else {
                            self._increaseProgressBarHeight(-40, !1);
                            self.$$(".list-" + self._currentRenderedStepIndex + " .error-bar").style.bottom = "-17px";
                            self.toggleSubSteps(null, self._currentRenderedStepIndex)
                        }
                    }, 100)
                },
                _processStep: function() {
                    var self = this,
                        step = this.deepCopy(this._steps[this._currentRenderedStepIndex]);
                    step.status = "starting";
                    this.push("_renderedSteps", step);
                    setTimeout(function() {
                        if (0 === self._currentRenderedStepIndex) {
                            self._resetAnimation()
                        }
                        var $elList = self.$$(".list-" + self._currentRenderedStepIndex),
                            height = self._getElementStylePropertyValue($elList, "height");
                        self._increaseProgressBarHeight(height, !1);
                        setTimeout(function() {
                            $elList.classList.remove("out-starting")
                        }, 200)
                    }, 100)
                },
                _getElementStylePropertyValue: function($el, property) {
                    var elProps = window.getComputedStyle($el);
                    return parseFloat(elProps.getPropertyValue(property))
                },
                _addSuccessMessage: function() {
                    this._showSuccess = !0;
                    var self = this;
                    this._increaseProgressBarHeight(9, !1);
                    setTimeout(function() {
                        var $elSuccess = self.$$(".success.step-verified");
                        $elSuccess.classList.add("in")
                    }, 100)
                },
                _increaseProgressBarHeight: function(height, reset) {
                    var newHeight = reset ? 0 : parseFloat(this._$progressBar.style.height);
                    this._$progressBar.style.height = newHeight + height + "px"
                },
                _setComponentClass: function(cssClass, enable) {
                    var el = document.getElementsByTagName("credential-verifier")[0];
                    if (enable) {
                        el.classList.add(cssClass)
                    } else {
                        el.classList.remove(cssClass)
                    }
                }
            });
        </script>
    </dom-module>
</body>

</html>