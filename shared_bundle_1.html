<html>

<head>
    <script>
        (function() {
            function resolve() {
                document.body.removeAttribute("unresolved")
            }
            if (window.WebComponents) {
                addEventListener("WebComponentsReady", resolve)
            } else {
                if ("interactive" === document.readyState || "complete" === document.readyState) {
                    resolve()
                } else {
                    addEventListener("DOMContentLoaded", resolve)
                }
            }
        })();
        window.Polymer = {
            Settings: function() {
                var settings = window.Polymer || {};
                if (!settings.noUrlSettings) {
                    for (var parts = location.search.slice(1).split("&"), i = 0, o; i < parts.length && (o = parts[i]); i++) {
                        o = o.split("=");
                        o[0] && (settings[o[0]] = o[1] || !0)
                    }
                }
                settings.wantShadow = "shadow" === settings.dom;
                settings.hasShadow = !!Element.prototype.createShadowRoot;
                settings.nativeShadow = settings.hasShadow && !window.ShadowDOMPolyfill;
                settings.useShadow = settings.wantShadow && settings.hasShadow;
                settings.hasNativeImports = !!("import" in document.createElement("link"));
                settings.useNativeImports = settings.hasNativeImports;
                settings.useNativeCustomElements = !window.CustomElements || window.CustomElements.useNative;
                settings.useNativeShadow = settings.useShadow && settings.nativeShadow;
                settings.usePolyfillProto = !settings.useNativeCustomElements && !Object.__proto__;
                settings.hasNativeCSSProperties = !navigator.userAgent.match(/AppleWebKit\/601|Edge\/15/) && window.CSS && CSS.supports && CSS.supports("box-shadow", "0 0 0 var(--foo)");
                settings.useNativeCSSProperties = settings.hasNativeCSSProperties && settings.lazyRegister && settings.useNativeCSSProperties;
                settings.isIE = navigator.userAgent.match("Trident");
                settings.passiveTouchGestures = settings.passiveTouchGestures || !1;
                return settings
            }()
        };
        (function() {
            var userPolymer = window.Polymer;
            window.Polymer = function(prototype) {
                if ("function" === typeof prototype) {
                    prototype = prototype.prototype
                }
                if (!prototype) {
                    prototype = {}
                }
                prototype = desugar(prototype);
                var customCtor = prototype === prototype.constructor.prototype ? prototype.constructor : null,
                    options = {
                        prototype: prototype
                    };
                if (prototype.extends) {
                    options.extends = prototype.extends
                }
                Polymer.telemetry._registrate(prototype);
                var ctor = document.registerElement(prototype.is, options);
                return customCtor || ctor
            };
            var desugar = function(prototype) {
                var base = Polymer.Base;
                if (prototype.extends) {
                    base = Polymer.Base._getExtendedPrototype(prototype.extends)
                }
                prototype = Polymer.Base.chainObject(prototype, base);
                prototype.registerCallback();
                return prototype
            };
            if (userPolymer) {
                for (var i in userPolymer) {
                    Polymer[i] = userPolymer[i]
                }
            }
            Polymer.Class = function(prototype) {
                if (!prototype.factoryImpl) {
                    prototype.factoryImpl = function() {}
                }
                return desugar(prototype).constructor
            }
        })();
        Polymer.telemetry = {
            registrations: [],
            _regLog: function(prototype) {
                console.log("[" + prototype.is + "]: registered")
            },
            _registrate: function(prototype) {
                this.registrations.push(prototype);
                Polymer.log && this._regLog(prototype)
            },
            dumpRegistrations: function() {
                this.registrations.forEach(this._regLog)
            }
        };
        Object.defineProperty(window, "currentImport", {
            enumerable: !0,
            configurable: !0,
            get: function() {
                return (document._currentScript || document.currentScript || {}).ownerDocument
            }
        });
        Polymer.RenderStatus = {
            _ready: !1,
            _callbacks: [],
            whenReady: function(cb) {
                if (this._ready) {
                    cb()
                } else {
                    this._callbacks.push(cb)
                }
            },
            _makeReady: function() {
                this._ready = !0;
                for (var i = 0; i < this._callbacks.length; i++) {
                    this._callbacks[i]()
                }
                this._callbacks = []
            },
            _catchFirstRender: function() {
                requestAnimationFrame(function() {
                    Polymer.RenderStatus._makeReady()
                })
            },
            _afterNextRenderQueue: [],
            _waitingNextRender: !1,
            afterNextRender: function(element, fn, args) {
                this._watchNextRender();
                this._afterNextRenderQueue.push([element, fn, args])
            },
            hasRendered: function() {
                return this._ready
            },
            _watchNextRender: function() {
                if (!this._waitingNextRender) {
                    this._waitingNextRender = !0;
                    var fn = function() {
                        Polymer.RenderStatus._flushNextRender()
                    };
                    if (!this._ready) {
                        this.whenReady(fn)
                    } else {
                        requestAnimationFrame(fn)
                    }
                }
            },
            _flushNextRender: function() {
                var self = this;
                setTimeout(function() {
                    self._flushRenderCallbacks(self._afterNextRenderQueue);
                    self._afterNextRenderQueue = [];
                    self._waitingNextRender = !1
                })
            },
            _flushRenderCallbacks: function(callbacks) {
                for (var i = 0, h; i < callbacks.length; i++) {
                    h = callbacks[i];
                    h[1].apply(h[0], h[2] || Polymer.nar)
                }
            }
        };
        if (window.HTMLImports) {
            HTMLImports.whenReady(function() {
                Polymer.RenderStatus._catchFirstRender()
            })
        } else {
            Polymer.RenderStatus._catchFirstRender()
        }
        Polymer.ImportStatus = Polymer.RenderStatus;
        Polymer.ImportStatus.whenLoaded = Polymer.ImportStatus.whenReady;
        (function() {
            "use strict";
            var settings = Polymer.Settings;
            Polymer.Base = {
                __isPolymerInstance__: !0,
                _addFeature: function(feature) {
                    this.mixin(this, feature)
                },
                registerCallback: function() {
                    if ("max" === settings.lazyRegister) {
                        if (this.beforeRegister) {
                            this.beforeRegister()
                        }
                    } else {
                        this._desugarBehaviors();
                        for (var i = 0, b; i < this.behaviors.length; i++) {
                            b = this.behaviors[i];
                            if (b.beforeRegister) {
                                b.beforeRegister.call(this)
                            }
                        }
                        if (this.beforeRegister) {
                            this.beforeRegister()
                        }
                    }
                    this._registerFeatures();
                    if (!settings.lazyRegister) {
                        this.ensureRegisterFinished()
                    }
                },
                createdCallback: function() {
                    if (settings.disableUpgradeEnabled) {
                        if (this.hasAttribute("disable-upgrade")) {
                            this._propertySetter = disableUpgradePropertySetter;
                            this._configValue = null;
                            this.__data__ = {};
                            return
                        } else {
                            this.__hasInitialized = !0
                        }
                    }
                    this.__initialize()
                },
                __initialize: function() {
                    if (!this.__hasRegisterFinished) {
                        this._ensureRegisterFinished(this.__proto__)
                    }
                    Polymer.telemetry.instanceCount++;
                    this.root = this;
                    for (var i = 0, b; i < this.behaviors.length; i++) {
                        b = this.behaviors[i];
                        if (b.created) {
                            b.created.call(this)
                        }
                    }
                    if (this.created) {
                        this.created()
                    }
                    this._initFeatures()
                },
                ensureRegisterFinished: function() {
                    this._ensureRegisterFinished(this)
                },
                _ensureRegisterFinished: function(proto) {
                    if (proto.__hasRegisterFinished !== proto.is || !proto.is) {
                        if ("max" === settings.lazyRegister) {
                            proto._desugarBehaviors();
                            for (var i = 0, b; i < proto.behaviors.length; i++) {
                                b = proto.behaviors[i];
                                if (b.beforeRegister) {
                                    b.beforeRegister.call(proto)
                                }
                            }
                        }
                        proto.__hasRegisterFinished = proto.is;
                        if (proto._finishRegisterFeatures) {
                            proto._finishRegisterFeatures()
                        }
                        for (var j = 0, pb; j < proto.behaviors.length; j++) {
                            pb = proto.behaviors[j];
                            if (pb.registered) {
                                pb.registered.call(proto)
                            }
                        }
                        if (proto.registered) {
                            proto.registered()
                        }
                        if (settings.usePolyfillProto && proto !== this) {
                            proto.extend(this, proto)
                        }
                    }
                },
                attachedCallback: function() {
                    var self = this;
                    Polymer.RenderStatus.whenReady(function() {
                        self.isAttached = !0;
                        for (var i = 0, b; i < self.behaviors.length; i++) {
                            b = self.behaviors[i];
                            if (b.attached) {
                                b.attached.call(self)
                            }
                        }
                        if (self.attached) {
                            self.attached()
                        }
                    })
                },
                detachedCallback: function() {
                    var self = this;
                    Polymer.RenderStatus.whenReady(function() {
                        self.isAttached = !1;
                        for (var i = 0, b; i < self.behaviors.length; i++) {
                            b = self.behaviors[i];
                            if (b.detached) {
                                b.detached.call(self)
                            }
                        }
                        if (self.detached) {
                            self.detached()
                        }
                    })
                },
                attributeChangedCallback: function(name, oldValue, newValue) {
                    this._attributeChangedImpl(name);
                    for (var i = 0, b; i < this.behaviors.length; i++) {
                        b = this.behaviors[i];
                        if (b.attributeChanged) {
                            b.attributeChanged.call(this, name, oldValue, newValue)
                        }
                    }
                    if (this.attributeChanged) {
                        this.attributeChanged(name, oldValue, newValue)
                    }
                },
                _attributeChangedImpl: function(name) {
                    this._setAttributeToProperty(this, name)
                },
                extend: function(target, source) {
                    if (target && source) {
                        for (var n$ = Object.getOwnPropertyNames(source), i = 0, n; i < n$.length && (n = n$[i]); i++) {
                            this.copyOwnProperty(n, source, target)
                        }
                    }
                    return target || source
                },
                mixin: function(target, source) {
                    for (var i in source) {
                        target[i] = source[i]
                    }
                    return target
                },
                copyOwnProperty: function(name, source, target) {
                    var pd = Object.getOwnPropertyDescriptor(source, name);
                    if (pd) {
                        Object.defineProperty(target, name, pd)
                    }
                },
                _logger: function(level, args) {
                    if (1 === args.length && Array.isArray(args[0])) {
                        args = args[0]
                    }
                    switch (level) {
                        case "log":
                        case "warn":
                        case "error":
                            console[level].apply(console, args);
                            break;
                    }
                },
                _log: function() {
                    var args = Array.prototype.slice.call(arguments, 0);
                    this._logger("log", args)
                },
                _warn: function() {
                    var args = Array.prototype.slice.call(arguments, 0);
                    this._logger("warn", args)
                },
                _error: function() {
                    var args = Array.prototype.slice.call(arguments, 0);
                    this._logger("error", args)
                },
                _logf: function() {
                    return this._logPrefix.concat(this.is).concat(Array.prototype.slice.call(arguments, 0))
                }
            };
            Polymer.Base._logPrefix = function() {
                var color = window.chrome && !/edge/i.test(navigator.userAgent) || /firefox/i.test(navigator.userAgent);
                return color ? ["%c[%s::%s]:", "font-weight: bold; background-color:#EEEE00;"] : ["[%s::%s]:"]
            }();
            Polymer.Base.chainObject = function(object, inherited) {
                if (object && inherited && object !== inherited) {
                    if (!Object.__proto__) {
                        object = Polymer.Base.extend(Object.create(inherited), object)
                    }
                    object.__proto__ = inherited
                }
                return object
            };
            Polymer.Base = Polymer.Base.chainObject(Polymer.Base, HTMLElement.prototype);
            Polymer.BaseDescriptors = {};
            var disableUpgradePropertySetter;
            if (settings.disableUpgradeEnabled) {
                disableUpgradePropertySetter = function(property, value) {
                    this.__data__[property] = value
                };
                var origAttributeChangedCallback = Polymer.Base.attributeChangedCallback;
                Polymer.Base.attributeChangedCallback = function(name, oldValue, newValue) {
                    if (!this.__hasInitialized && "disable-upgrade" === name) {
                        this.__hasInitialized = !0;
                        this._propertySetter = Polymer.Bind._modelApi._propertySetter;
                        this._configValue = Polymer.Base._configValue;
                        this.__initialize()
                    }
                    origAttributeChangedCallback.call(this, name, oldValue, newValue)
                }
            }
            if (window.CustomElements) {
                Polymer.instanceof = CustomElements.instanceof
            } else {
                Polymer.instanceof = function(obj, ctor) {
                    return obj instanceof ctor
                }
            }
            Polymer.isInstance = function(obj) {
                return !!(obj && obj.__isPolymerInstance__)
            };
            Polymer.telemetry.instanceCount = 0
        })();
        (function() {
            var modules = {},
                lcModules = {},
                findModule = function(id) {
                    return modules[id] || lcModules[id.toLowerCase()]
                },
                DomModule = function() {
                    return document.createElement("dom-module")
                };
            DomModule.prototype = Object.create(HTMLElement.prototype);
            Polymer.Base.mixin(DomModule.prototype, {
                createdCallback: function() {
                    this.register()
                },
                register: function(id) {
                    id = id || this.id || this.getAttribute("name") || this.getAttribute("is");
                    if (id) {
                        this.id = id;
                        modules[id] = this;
                        lcModules[id.toLowerCase()] = this
                    }
                },
                import: function(id, selector) {
                    if (id) {
                        var m = findModule(id);
                        if (!m) {
                            forceDomModulesUpgrade();
                            m = findModule(id)
                        }
                        if (m && selector) {
                            m = m.querySelector(selector)
                        }
                        return m
                    }
                }
            });
            Object.defineProperty(DomModule.prototype, "constructor", {
                value: DomModule,
                configurable: !0,
                writable: !0
            });
            var cePolyfill = window.CustomElements && !CustomElements.useNative;
            document.registerElement("dom-module", DomModule);

            function forceDomModulesUpgrade() {
                if (cePolyfill) {
                    for (var script = document._currentScript || document.currentScript, doc = script && script.ownerDocument || document, modules = doc.querySelectorAll("dom-module"), i = modules.length - 1, m; 0 <= i && (m = modules[i]); i--) {
                        if (m.__upgraded__) {
                            return
                        } else {
                            CustomElements.upgrade(m)
                        }
                    }
                }
            }
        })();
        Polymer.Base._addFeature({
            _prepIs: function() {
                if (!this.is) {
                    var module = (document._currentScript || document.currentScript).parentNode;
                    if ("dom-module" === module.localName) {
                        var id = module.id || module.getAttribute("name") || module.getAttribute("is");
                        this.is = id
                    }
                }
                if (this.is) {
                    this.is = this.is.toLowerCase()
                }
            }
        });
        Polymer.Base._addFeature({
            behaviors: [],
            _desugarBehaviors: function() {
                if (this.behaviors.length) {
                    this.behaviors = this._desugarSomeBehaviors(this.behaviors)
                }
            },
            _desugarSomeBehaviors: function(behaviors) {
                var behaviorSet = [];
                behaviors = this._flattenBehaviorsList(behaviors);
                for (var i = behaviors.length - 1, b; 0 <= i; i--) {
                    b = behaviors[i];
                    if (-1 === behaviorSet.indexOf(b)) {
                        this._mixinBehavior(b);
                        behaviorSet.unshift(b)
                    }
                }
                return behaviorSet
            },
            _flattenBehaviorsList: function(behaviors) {
                for (var flat = [], i = 0, b; i < behaviors.length; i++) {
                    b = behaviors[i];
                    if (b instanceof Array) {
                        flat = flat.concat(this._flattenBehaviorsList(b))
                    } else if (b) {
                        flat.push(b)
                    } else {
                        this._warn(this._logf("_flattenBehaviorsList", "behavior is null, check for missing or 404 import"))
                    }
                }
                return flat
            },
            _mixinBehavior: function(b) {
                for (var n$ = Object.getOwnPropertyNames(b), useAssignment = b._noAccessors, i = 0, n; i < n$.length && (n = n$[i]); i++) {
                    if (!Polymer.Base._behaviorProperties[n] && !this.hasOwnProperty(n)) {
                        if (useAssignment) {
                            this[n] = b[n]
                        } else {
                            this.copyOwnProperty(n, b, this)
                        }
                    }
                }
            },
            _prepBehaviors: function() {
                this._prepFlattenedBehaviors(this.behaviors)
            },
            _prepFlattenedBehaviors: function(behaviors) {
                for (var i = 0, l = behaviors.length; i < l; i++) {
                    this._prepBehavior(behaviors[i])
                }
                this._prepBehavior(this)
            },
            _marshalBehaviors: function() {
                for (var i = 0; i < this.behaviors.length; i++) {
                    this._marshalBehavior(this.behaviors[i])
                }
                this._marshalBehavior(this)
            }
        });
        Polymer.Base._behaviorProperties = {
            hostAttributes: !0,
            beforeRegister: !0,
            registered: !0,
            properties: !0,
            observers: !0,
            listeners: !0,
            created: !0,
            attached: !0,
            detached: !0,
            attributeChanged: !0,
            ready: !0,
            _noAccessors: !0
        };
        Polymer.Base._addFeature({
            _getExtendedPrototype: function(tag) {
                return this._getExtendedNativePrototype(tag)
            },
            _nativePrototypes: {},
            _getExtendedNativePrototype: function(tag) {
                var p = this._nativePrototypes[tag];
                if (!p) {
                    p = Object.create(this.getNativePrototype(tag));
                    for (var p$ = Object.getOwnPropertyNames(Polymer.Base), i = 0, n; i < p$.length && (n = p$[i]); i++) {
                        if (!Polymer.BaseDescriptors[n]) {
                            p[n] = Polymer.Base[n]
                        }
                    }
                    Object.defineProperties(p, Polymer.BaseDescriptors);
                    this._nativePrototypes[tag] = p
                }
                return p
            },
            getNativePrototype: function(tag) {
                return Object.getPrototypeOf(document.createElement(tag))
            }
        });
        Polymer.Base._addFeature({
            _prepConstructor: function() {
                this._factoryArgs = this.extends ? [this.extends, this.is] : [this.is];
                var ctor = function() {
                    return this._factory(arguments)
                };
                if (this.hasOwnProperty("extends")) {
                    ctor.extends = this.extends
                }
                Object.defineProperty(this, "constructor", {
                    value: ctor,
                    writable: !0,
                    configurable: !0
                });
                ctor.prototype = this
            },
            _factory: function(args) {
                var elt = document.createElement.apply(document, this._factoryArgs);
                if (this.factoryImpl) {
                    this.factoryImpl.apply(elt, args)
                }
                return elt
            }
        });
        Polymer.nob = Object.create(null);
        Polymer.Base._addFeature({
            getPropertyInfo: function(property) {
                var info = this._getPropertyInfo(property, this.properties);
                if (!info) {
                    for (var i = 0; i < this.behaviors.length; i++) {
                        info = this._getPropertyInfo(property, this.behaviors[i].properties);
                        if (info) {
                            return info
                        }
                    }
                }
                return info || Polymer.nob
            },
            _getPropertyInfo: function(property, properties) {
                var p = properties && properties[property];
                if ("function" === typeof p) {
                    p = properties[property] = {
                        type: p
                    }
                }
                if (p) {
                    p.defined = !0
                }
                return p
            },
            _prepPropertyInfo: function() {
                this._propertyInfo = {};
                for (var i = 0; i < this.behaviors.length; i++) {
                    this._addPropertyInfo(this._propertyInfo, this.behaviors[i].properties)
                }
                this._addPropertyInfo(this._propertyInfo, this.properties);
                this._addPropertyInfo(this._propertyInfo, this._propertyEffects)
            },
            _addPropertyInfo: function(target, source) {
                if (source) {
                    var t, s;
                    for (var i in source) {
                        t = target[i];
                        s = source[i];
                        if ("_" === i[0] && !s.readOnly) {
                            continue
                        }
                        if (!target[i]) {
                            target[i] = {
                                type: "function" === typeof s ? s : s.type,
                                readOnly: s.readOnly,
                                attribute: Polymer.CaseMap.camelToDashCase(i)
                            }
                        } else {
                            if (!t.type) {
                                t.type = s.type
                            }
                            if (!t.readOnly) {
                                t.readOnly = s.readOnly
                            }
                        }
                    }
                }
            }
        });
        (function() {
            var propertiesDesc = {
                configurable: !0,
                writable: !0,
                enumerable: !0,
                value: {}
            };
            Polymer.BaseDescriptors.properties = propertiesDesc;
            Object.defineProperty(Polymer.Base, "properties", propertiesDesc)
        })();
        Polymer.CaseMap = {
            _caseMap: {},
            _rx: {
                dashToCamel: /-[a-z]/g,
                camelToDash: /([A-Z])/g
            },
            dashToCamelCase: function(dash) {
                return this._caseMap[dash] || (this._caseMap[dash] = 0 > dash.indexOf("-") ? dash : dash.replace(this._rx.dashToCamel, function(m) {
                    return m[1].toUpperCase()
                }))
            },
            camelToDashCase: function(camel) {
                return this._caseMap[camel] || (this._caseMap[camel] = camel.replace(this._rx.camelToDash, "-$1").toLowerCase())
            }
        };
        Polymer.Base._addFeature({
            _addHostAttributes: function(attributes) {
                if (!this._aggregatedAttributes) {
                    this._aggregatedAttributes = {}
                }
                if (attributes) {
                    this.mixin(this._aggregatedAttributes, attributes)
                }
            },
            _marshalHostAttributes: function() {
                if (this._aggregatedAttributes) {
                    this._applyAttributes(this, this._aggregatedAttributes)
                }
            },
            _applyAttributes: function(node, attr$) {
                for (var n in attr$) {
                    if (!this.hasAttribute(n) && "class" !== n) {
                        var v = attr$[n];
                        this.serializeValueToAttribute(v, n, this)
                    }
                }
            },
            _marshalAttributes: function() {
                this._takeAttributesToModel(this)
            },
            _takeAttributesToModel: function(model) {
                if (this.hasAttributes()) {
                    for (var i in this._propertyInfo) {
                        var info = this._propertyInfo[i];
                        if (this.hasAttribute(info.attribute)) {
                            this._setAttributeToProperty(model, info.attribute, i, info)
                        }
                    }
                }
            },
            _setAttributeToProperty: function(model, attribute, property, info) {
                if (!this._serializing) {
                    property = property || Polymer.CaseMap.dashToCamelCase(attribute);
                    info = info || this._propertyInfo && this._propertyInfo[property];
                    if (info && !info.readOnly) {
                        var v = this.getAttribute(attribute);
                        model[property] = this.deserialize(v, info.type)
                    }
                }
            },
            _serializing: !1,
            reflectPropertyToAttribute: function(property, attribute, value) {
                this._serializing = !0;
                value = value === void 0 ? this[property] : value;
                this.serializeValueToAttribute(value, attribute || Polymer.CaseMap.camelToDashCase(property));
                this._serializing = !1
            },
            serializeValueToAttribute: function(value, attribute, node) {
                var str = this.serialize(value);
                node = node || this;
                if (str === void 0) {
                    node.removeAttribute(attribute)
                } else {
                    node.setAttribute(attribute, str)
                }
            },
            deserialize: function(value, type) {
                switch (type) {
                    case Number:
                        value = +value;
                        break;
                    case Boolean:
                        value = null != value;
                        break;
                    case Object:
                        try {
                            value = JSON.parse(value)
                        } catch (x) {}
                        break;
                    case Array:
                        try {
                            value = JSON.parse(value)
                        } catch (x) {
                            value = null;
                            console.warn("Polymer::Attributes: couldn`t decode Array as JSON")
                        }
                        break;
                    case Date:
                        value = new Date(value);
                        break;
                    case String:
                    default:
                        break;
                }
                return value
            },
            serialize: function(value) {
                switch (typeof value) {
                    case "boolean":
                        return value ? "" : void 0;
                    case "object":
                        if (value instanceof Date) {
                            return value.toString()
                        } else if (value) {
                            try {
                                return JSON.stringify(value)
                            } catch (x) {
                                return ""
                            }
                        }
                    default:
                        return null != value ? value : void 0;
                }
            }
        });
        Polymer.version = "1.11.3";
        Polymer.Base._addFeature({
            _registerFeatures: function() {
                this._prepIs();
                this._prepBehaviors();
                this._prepConstructor();
                this._prepPropertyInfo()
            },
            _prepBehavior: function(b) {
                this._addHostAttributes(b.hostAttributes)
            },
            _marshalBehavior: function() {},
            _initFeatures: function() {
                this._marshalHostAttributes();
                this._marshalBehaviors()
            }
        });
    </script>
    <script>
        (function() {
            function resolveCss(cssText, ownerDocument) {
                return cssText.replace(CSS_URL_RX, function(m, pre, url, post) {
                    return pre + "'" + resolve(url.replace(/["']/g, ""), ownerDocument) + "'" + post
                })
            }

            function resolve(url, ownerDocument) {
                if (url && ABS_URL.test(url)) {
                    return url
                }
                var resolver = getUrlResolver(ownerDocument);
                resolver.href = url;
                return resolver.href || url
            }
            var tempDoc, tempDocBase;

            function resolveUrl(url, baseUri) {
                if (!tempDoc) {
                    tempDoc = document.implementation.createHTMLDocument("temp");
                    tempDocBase = tempDoc.createElement("base");
                    tempDoc.head.appendChild(tempDocBase)
                }
                tempDocBase.href = baseUri;
                return resolve(url, tempDoc)
            }

            function getUrlResolver(ownerDocument) {
                return ownerDocument.body.__urlResolver || (ownerDocument.body.__urlResolver = ownerDocument.createElement("a"))
            }

            function pathFromUrl(url) {
                return url.substring(0, url.lastIndexOf("/") + 1)
            }
            var CSS_URL_RX = /(url\()([^)]*)(\))/g,
                URL_ATTRS = {
                    "*": ["href", "src", "style", "url"],
                    form: ["action"]
                },
                ABS_URL = /(^\/)|(^#)|(^[\w-\d]*:)/,
                BINDING_RX = /\{\{|\[\[/;
            Polymer.ResolveUrl = {
                resolveCss: resolveCss,
                resolveAttrs: function(element, ownerDocument) {
                    for (var name in URL_ATTRS) {
                        for (var a$ = URL_ATTRS[name], i = 0, l = a$.length, a, at, v; i < l && (a = a$[i]); i++) {
                            if ("*" === name || element.localName === name) {
                                at = element.attributes[a];
                                v = at && at.value;
                                if (v && 0 > v.search(BINDING_RX)) {
                                    at.value = "style" === a ? resolveCss(v, ownerDocument) : resolve(v, ownerDocument)
                                }
                            }
                        }
                    }
                },
                resolveUrl: resolveUrl,
                pathFromUrl: pathFromUrl
            };
            Polymer.rootPath = Polymer.Settings.rootPath || pathFromUrl(document.baseURI || window.location.href)
        })();
        Polymer.Base._addFeature({
            _prepTemplate: function() {
                var module;
                if (this._template === void 0) {
                    module = Polymer.DomModule.import(this.is);
                    this._template = module && module.querySelector("template")
                }
                if (module) {
                    var assetPath = module.getAttribute("assetpath") || "",
                        importURL = Polymer.ResolveUrl.resolveUrl(assetPath, module.ownerDocument.baseURI);
                    this._importPath = Polymer.ResolveUrl.pathFromUrl(importURL)
                } else {
                    this._importPath = ""
                }
                if (this._template && this._template.hasAttribute("is")) {
                    this._warn(this._logf("_prepTemplate", "top-level Polymer template " + "must not be a type-extension, found", this._template, "Move inside simple <template>."))
                }
                if (this._template && !this._template.content && window.HTMLTemplateElement && HTMLTemplateElement.decorate) {
                    HTMLTemplateElement.decorate(this._template)
                }
            },
            _stampTemplate: function() {
                if (this._template) {
                    this.root = this.instanceTemplate(this._template)
                }
            },
            instanceTemplate: function(template) {
                var dom = document.importNode(template._content || template.content, !0);
                return dom
            }
        });
        (function() {
            var baseAttachedCallback = Polymer.Base.attachedCallback,
                baseDetachedCallback = Polymer.Base.detachedCallback;
            Polymer.Base._addFeature({
                _hostStack: [],
                ready: function() {},
                _registerHost: function(host) {
                    this.dataHost = host = host || Polymer.Base._hostStack[Polymer.Base._hostStack.length - 1];
                    if (host && host._clients) {
                        host._clients.push(this)
                    }
                    this._clients = null;
                    this._clientsReadied = !1
                },
                _beginHosting: function() {
                    Polymer.Base._hostStack.push(this);
                    if (!this._clients) {
                        this._clients = []
                    }
                },
                _endHosting: function() {
                    Polymer.Base._hostStack.pop()
                },
                _tryReady: function() {
                    this._readied = !1;
                    if (this._canReady()) {
                        this._ready()
                    }
                },
                _canReady: function() {
                    return !this.dataHost || this.dataHost._clientsReadied
                },
                _ready: function() {
                    this._beforeClientsReady();
                    if (this._template) {
                        this._setupRoot();
                        this._readyClients()
                    }
                    this._clientsReadied = !0;
                    this._clients = null;
                    this._afterClientsReady();
                    this._readySelf()
                },
                _readyClients: function() {
                    this._beginDistribute();
                    var c$ = this._clients;
                    if (c$) {
                        for (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {
                            c._ready()
                        }
                    }
                    this._finishDistribute()
                },
                _readySelf: function() {
                    for (var i = 0, b; i < this.behaviors.length; i++) {
                        b = this.behaviors[i];
                        if (b.ready) {
                            b.ready.call(this)
                        }
                    }
                    if (this.ready) {
                        this.ready()
                    }
                    this._readied = !0;
                    if (this._attachedPending) {
                        this._attachedPending = !1;
                        this.attachedCallback()
                    }
                },
                _beforeClientsReady: function() {},
                _afterClientsReady: function() {},
                _beforeAttached: function() {},
                attachedCallback: function() {
                    if (this._readied) {
                        this._beforeAttached();
                        baseAttachedCallback.call(this)
                    } else {
                        this._attachedPending = !0
                    }
                },
                detachedCallback: function() {
                    if (this._readied) {
                        baseDetachedCallback.call(this)
                    } else {
                        this._attachedPending = !1
                    }
                }
            })
        })();
        Polymer.ArraySplice = function() {
            function newSplice(index, removed, addedCount) {
                return {
                    index: index,
                    removed: removed,
                    addedCount: addedCount
                }
            }
            var EDIT_LEAVE = 0,
                EDIT_UPDATE = 1,
                EDIT_ADD = 2,
                EDIT_DELETE = 3;

            function ArraySplice() {}
            ArraySplice.prototype = {
                calcEditDistances: function(current, currentStart, currentEnd, old, oldStart, oldEnd) {
                    for (var rowCount = oldEnd - oldStart + 1, columnCount = currentEnd - currentStart + 1, distances = Array(rowCount), i = 0; i < rowCount; i++) {
                        distances[i] = Array(columnCount);
                        distances[i][0] = i
                    }
                    for (var j = 0; j < columnCount; j++) distances[0][j] = j;
                    for (i = 1; i < rowCount; i++) {
                        for (j = 1; j < columnCount; j++) {
                            if (this.equals(current[currentStart + j - 1], old[oldStart + i - 1])) distances[i][j] = distances[i - 1][j - 1];
                            else {
                                var north = distances[i - 1][j] + 1,
                                    west = distances[i][j - 1] + 1;
                                distances[i][j] = north < west ? north : west
                            }
                        }
                    }
                    return distances
                },
                spliceOperationsFromEditDistances: function(distances) {
                    var i = distances.length - 1,
                        j = distances[0].length - 1,
                        current = distances[i][j],
                        edits = [];
                    while (0 < i || 0 < j) {
                        if (0 == i) {
                            edits.push(EDIT_ADD);
                            j--;
                            continue
                        }
                        if (0 == j) {
                            edits.push(EDIT_DELETE);
                            i--;
                            continue
                        }
                        var northWest = distances[i - 1][j - 1],
                            west = distances[i - 1][j],
                            north = distances[i][j - 1],
                            min;
                        if (west < north) min = west < northWest ? west : northWest;
                        else min = north < northWest ? north : northWest;
                        if (min == northWest) {
                            if (northWest == current) {
                                edits.push(EDIT_LEAVE)
                            } else {
                                edits.push(EDIT_UPDATE);
                                current = northWest
                            }
                            i--;
                            j--
                        } else if (min == west) {
                            edits.push(EDIT_DELETE);
                            i--;
                            current = west
                        } else {
                            edits.push(EDIT_ADD);
                            j--;
                            current = north
                        }
                    }
                    edits.reverse();
                    return edits
                },
                calcSplices: function(current, currentStart, currentEnd, old, oldStart, oldEnd) {
                    var prefixCount = 0,
                        suffixCount = 0,
                        minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);
                    if (0 == currentStart && 0 == oldStart) prefixCount = this.sharedPrefix(current, old, minLength);
                    if (currentEnd == current.length && oldEnd == old.length) suffixCount = this.sharedSuffix(current, old, minLength - prefixCount);
                    currentStart += prefixCount;
                    oldStart += prefixCount;
                    currentEnd -= suffixCount;
                    oldEnd -= suffixCount;
                    if (0 == currentEnd - currentStart && 0 == oldEnd - oldStart) return [];
                    if (currentStart == currentEnd) {
                        var splice = newSplice(currentStart, [], 0);
                        while (oldStart < oldEnd) splice.removed.push(old[oldStart++]);
                        return [splice]
                    } else if (oldStart == oldEnd) return [newSplice(currentStart, [], currentEnd - currentStart)];
                    var ops = this.spliceOperationsFromEditDistances(this.calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd));
                    splice = void 0;
                    for (var splices = [], index = currentStart, oldIndex = oldStart, i = 0; i < ops.length; i++) {
                        switch (ops[i]) {
                            case EDIT_LEAVE:
                                if (splice) {
                                    splices.push(splice);
                                    splice = void 0
                                }
                                index++;
                                oldIndex++;
                                break;
                            case EDIT_UPDATE:
                                if (!splice) splice = newSplice(index, [], 0);
                                splice.addedCount++;
                                index++;
                                splice.removed.push(old[oldIndex]);
                                oldIndex++;
                                break;
                            case EDIT_ADD:
                                if (!splice) splice = newSplice(index, [], 0);
                                splice.addedCount++;
                                index++;
                                break;
                            case EDIT_DELETE:
                                if (!splice) splice = newSplice(index, [], 0);
                                splice.removed.push(old[oldIndex]);
                                oldIndex++;
                                break;
                        }
                    }
                    if (splice) {
                        splices.push(splice)
                    }
                    return splices
                },
                sharedPrefix: function(current, old, searchLength) {
                    for (var i = 0; i < searchLength; i++)
                        if (!this.equals(current[i], old[i])) return i;
                    return searchLength
                },
                sharedSuffix: function(current, old, searchLength) {
                    var index1 = current.length,
                        index2 = old.length,
                        count = 0;
                    while (count < searchLength && this.equals(current[--index1], old[--index2])) count++;
                    return count
                },
                calculateSplices: function(current, previous) {
                    return this.calcSplices(current, 0, current.length, previous, 0, previous.length)
                },
                equals: function(currentValue, previousValue) {
                    return currentValue === previousValue
                }
            };
            return new ArraySplice
        }();
        Polymer.domInnerHTML = function() {
            var escapeAttrRegExp = /[&\u00A0"]/g,
                escapeDataRegExp = /[&\u00A0<>]/g;

            function escapeReplace(c) {
                switch (c) {
                    case "&":
                        return "&amp;";
                    case "<":
                        return "&lt;";
                    case ">":
                        return "&gt;";
                    case "\"":
                        return "&quot;";
                    case "\xA0":
                        return "&nbsp;";
                }
            }

            function escapeAttr(s) {
                return s.replace(escapeAttrRegExp, escapeReplace)
            }

            function escapeData(s) {
                return s.replace(escapeDataRegExp, escapeReplace)
            }

            function makeSet(arr) {
                for (var set = {}, i = 0; i < arr.length; i++) {
                    set[arr[i]] = !0
                }
                return set
            }
            var voidElements = makeSet(["area", "base", "br", "col", "command", "embed", "hr", "img", "input", "keygen", "link", "meta", "param", "source", "track", "wbr"]),
                plaintextParents = makeSet(["style", "script", "xmp", "iframe", "noembed", "noframes", "plaintext", "noscript"]);

            function getOuterHTML(node, parentNode, composed) {
                switch (node.nodeType) {
                    case Node.ELEMENT_NODE:
                        for (var tagName = node.localName, s = "<" + tagName, attrs = node.attributes, i = 0, attr; attr = attrs[i]; i++) {
                            s += " " + attr.name + "=\"" + escapeAttr(attr.value) + "\""
                        }
                        s += ">";
                        if (voidElements[tagName]) {
                            return s
                        }
                        return s + getInnerHTML(node, composed) + "</" + tagName + ">";
                    case Node.TEXT_NODE:
                        var data = node.data;
                        if (parentNode && plaintextParents[parentNode.localName]) {
                            return data
                        }
                        return escapeData(data);
                    case Node.COMMENT_NODE:
                        return "<!--" + node.data + "-->";
                    default:
                        console.error(node);
                        throw new Error("not implemented");
                }
            }

            function getInnerHTML(node, composed) {
                if (node instanceof HTMLTemplateElement) node = node.content;
                for (var s = "", c$ = Polymer.dom(node).childNodes, i = 0, l = c$.length, child; i < l && (child = c$[i]); i++) {
                    s += getOuterHTML(child, node, composed)
                }
                return s
            }
            return {
                getInnerHTML: getInnerHTML
            }
        }();
        (function() {
            "use strict";
            var nativeInsertBefore = Element.prototype.insertBefore,
                nativeAppendChild = Element.prototype.appendChild,
                nativeRemoveChild = Element.prototype.removeChild;
            Polymer.TreeApi = {
                arrayCopyChildNodes: function(parent) {
                    for (var copy = [], i = 0, n = parent.firstChild; n; n = n.nextSibling) {
                        copy[i++] = n
                    }
                    return copy
                },
                arrayCopyChildren: function(parent) {
                    for (var copy = [], i = 0, n = parent.firstElementChild; n; n = n.nextElementSibling) {
                        copy[i++] = n
                    }
                    return copy
                },
                arrayCopy: function(a$) {
                    for (var l = a$.length, copy = Array(l), i = 0; i < l; i++) {
                        copy[i] = a$[i]
                    }
                    return copy
                }
            };
            Polymer.TreeApi.Logical = {
                hasParentNode: function(node) {
                    return !!(node.__dom && node.__dom.parentNode)
                },
                hasChildNodes: function(node) {
                    return !!(node.__dom && node.__dom.childNodes !== void 0)
                },
                getChildNodes: function(node) {
                    return this.hasChildNodes(node) ? this._getChildNodes(node) : node.childNodes
                },
                _getChildNodes: function(node) {
                    if (!node.__dom.childNodes) {
                        node.__dom.childNodes = [];
                        for (var n = node.__dom.firstChild; n; n = n.__dom.nextSibling) {
                            node.__dom.childNodes.push(n)
                        }
                    }
                    return node.__dom.childNodes
                },
                getParentNode: function(node) {
                    return node.__dom && node.__dom.parentNode !== void 0 ? node.__dom.parentNode : node.parentNode
                },
                getFirstChild: function(node) {
                    return node.__dom && node.__dom.firstChild !== void 0 ? node.__dom.firstChild : node.firstChild
                },
                getLastChild: function(node) {
                    return node.__dom && node.__dom.lastChild !== void 0 ? node.__dom.lastChild : node.lastChild
                },
                getNextSibling: function(node) {
                    return node.__dom && node.__dom.nextSibling !== void 0 ? node.__dom.nextSibling : node.nextSibling
                },
                getPreviousSibling: function(node) {
                    return node.__dom && node.__dom.previousSibling !== void 0 ? node.__dom.previousSibling : node.previousSibling
                },
                getFirstElementChild: function(node) {
                    return node.__dom && node.__dom.firstChild !== void 0 ? this._getFirstElementChild(node) : node.firstElementChild
                },
                _getFirstElementChild: function(node) {
                    var n = node.__dom.firstChild;
                    while (n && n.nodeType !== Node.ELEMENT_NODE) {
                        n = n.__dom.nextSibling
                    }
                    return n
                },
                getLastElementChild: function(node) {
                    return node.__dom && node.__dom.lastChild !== void 0 ? this._getLastElementChild(node) : node.lastElementChild
                },
                _getLastElementChild: function(node) {
                    var n = node.__dom.lastChild;
                    while (n && n.nodeType !== Node.ELEMENT_NODE) {
                        n = n.__dom.previousSibling
                    }
                    return n
                },
                getNextElementSibling: function(node) {
                    return node.__dom && node.__dom.nextSibling !== void 0 ? this._getNextElementSibling(node) : node.nextElementSibling
                },
                _getNextElementSibling: function(node) {
                    var n = node.__dom.nextSibling;
                    while (n && n.nodeType !== Node.ELEMENT_NODE) {
                        n = n.__dom.nextSibling
                    }
                    return n
                },
                getPreviousElementSibling: function(node) {
                    return node.__dom && node.__dom.previousSibling !== void 0 ? this._getPreviousElementSibling(node) : node.previousElementSibling
                },
                _getPreviousElementSibling: function(node) {
                    var n = node.__dom.previousSibling;
                    while (n && n.nodeType !== Node.ELEMENT_NODE) {
                        n = n.__dom.previousSibling
                    }
                    return n
                },
                saveChildNodes: function(node) {
                    if (!this.hasChildNodes(node)) {
                        node.__dom = node.__dom || {};
                        node.__dom.firstChild = node.firstChild;
                        node.__dom.lastChild = node.lastChild;
                        node.__dom.childNodes = [];
                        for (var n = node.firstChild; n; n = n.nextSibling) {
                            n.__dom = n.__dom || {};
                            n.__dom.parentNode = node;
                            node.__dom.childNodes.push(n);
                            n.__dom.nextSibling = n.nextSibling;
                            n.__dom.previousSibling = n.previousSibling
                        }
                    }
                },
                recordInsertBefore: function(node, container, ref_node) {
                    container.__dom.childNodes = null;
                    if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
                        for (var n = node.firstChild; n; n = n.nextSibling) {
                            this._linkNode(n, container, ref_node)
                        }
                    } else {
                        this._linkNode(node, container, ref_node)
                    }
                },
                _linkNode: function(node, container, ref_node) {
                    node.__dom = node.__dom || {};
                    container.__dom = container.__dom || {};
                    if (ref_node) {
                        ref_node.__dom = ref_node.__dom || {}
                    }
                    node.__dom.previousSibling = ref_node ? ref_node.__dom.previousSibling : container.__dom.lastChild;
                    if (node.__dom.previousSibling) {
                        node.__dom.previousSibling.__dom.nextSibling = node
                    }
                    node.__dom.nextSibling = ref_node || null;
                    if (node.__dom.nextSibling) {
                        node.__dom.nextSibling.__dom.previousSibling = node
                    }
                    node.__dom.parentNode = container;
                    if (ref_node) {
                        if (ref_node === container.__dom.firstChild) {
                            container.__dom.firstChild = node
                        }
                    } else {
                        container.__dom.lastChild = node;
                        if (!container.__dom.firstChild) {
                            container.__dom.firstChild = node
                        }
                    }
                    container.__dom.childNodes = null
                },
                recordRemoveChild: function(node, container) {
                    node.__dom = node.__dom || {};
                    container.__dom = container.__dom || {};
                    if (node === container.__dom.firstChild) {
                        container.__dom.firstChild = node.__dom.nextSibling
                    }
                    if (node === container.__dom.lastChild) {
                        container.__dom.lastChild = node.__dom.previousSibling
                    }
                    var p = node.__dom.previousSibling,
                        n = node.__dom.nextSibling;
                    if (p) {
                        p.__dom.nextSibling = n
                    }
                    if (n) {
                        n.__dom.previousSibling = p
                    }
                    node.__dom.parentNode = node.__dom.previousSibling = node.__dom.nextSibling = void 0;
                    container.__dom.childNodes = null
                }
            };
            Polymer.TreeApi.Composed = {
                getChildNodes: function(node) {
                    return Polymer.TreeApi.arrayCopyChildNodes(node)
                },
                getParentNode: function(node) {
                    return node.parentNode
                },
                clearChildNodes: function(node) {
                    node.textContent = ""
                },
                insertBefore: function(parentNode, newChild, refChild) {
                    return nativeInsertBefore.call(parentNode, newChild, refChild || null)
                },
                appendChild: function(parentNode, newChild) {
                    return nativeAppendChild.call(parentNode, newChild)
                },
                removeChild: function(parentNode, node) {
                    return nativeRemoveChild.call(parentNode, node)
                }
            }
        })();
        Polymer.DomApi = function() {
            "use strict";
            var Settings = Polymer.Settings,
                TreeApi = Polymer.TreeApi,
                DomApi = function(node) {
                    this.node = needsToWrap ? DomApi.wrap(node) : node
                },
                needsToWrap = Settings.hasShadow && !Settings.nativeShadow;
            DomApi.wrap = window.wrap ? window.wrap : function(node) {
                return node
            };
            DomApi.prototype = {
                flush: function() {
                    Polymer.dom.flush()
                },
                deepContains: function(node) {
                    if (this.node.contains(node)) {
                        return !0
                    }
                    var n = node,
                        doc = node.ownerDocument;
                    while (n && n !== doc && n !== this.node) {
                        n = Polymer.dom(n).parentNode || n.host
                    }
                    return n === this.node
                },
                queryDistributedElements: function(selector) {
                    for (var c$ = this.getEffectiveChildNodes(), list = [], i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {
                        if (c.nodeType === Node.ELEMENT_NODE && DomApi.matchesSelector.call(c, selector)) {
                            list.push(c)
                        }
                    }
                    return list
                },
                getEffectiveChildNodes: function() {
                    for (var list = [], c$ = this.childNodes, i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {
                        if (c.localName === CONTENT) {
                            for (var d$ = dom(c).getDistributedNodes(), j = 0; j < d$.length; j++) {
                                list.push(d$[j])
                            }
                        } else {
                            list.push(c)
                        }
                    }
                    return list
                },
                observeNodes: function(callback) {
                    if (callback) {
                        if (!this.observer) {
                            this.observer = this.node.localName === CONTENT ? new DomApi.DistributedNodesObserver(this) : new DomApi.EffectiveNodesObserver(this)
                        }
                        return this.observer.addListener(callback)
                    }
                },
                unobserveNodes: function(handle) {
                    if (this.observer) {
                        this.observer.removeListener(handle)
                    }
                },
                notifyObserver: function() {
                    if (this.observer) {
                        this.observer.notify()
                    }
                },
                _query: function(matcher, node, halter) {
                    node = node || this.node;
                    var list = [];
                    this._queryElements(TreeApi.Logical.getChildNodes(node), matcher, halter, list);
                    return list
                },
                _queryElements: function(elements, matcher, halter, list) {
                    for (var i = 0, l = elements.length, c; i < l && (c = elements[i]); i++) {
                        if (c.nodeType === Node.ELEMENT_NODE) {
                            if (this._queryElement(c, matcher, halter, list)) {
                                return !0
                            }
                        }
                    }
                },
                _queryElement: function(node, matcher, halter, list) {
                    var result = matcher(node);
                    if (result) {
                        list.push(node)
                    }
                    if (halter && halter(result)) {
                        return result
                    }
                    this._queryElements(TreeApi.Logical.getChildNodes(node), matcher, halter, list)
                }
            };
            var CONTENT = DomApi.CONTENT = "content",
                dom = DomApi.factory = function(node) {
                    node = node || document;
                    if (!node.__domApi) {
                        node.__domApi = new DomApi.ctor(node)
                    }
                    return node.__domApi
                };
            DomApi.hasApi = function(node) {
                return !!node.__domApi
            };
            DomApi.ctor = DomApi;
            Polymer.dom = function(obj, patch) {
                if (obj instanceof Event) {
                    return Polymer.EventApi.factory(obj)
                } else {
                    return DomApi.factory(obj, patch)
                }
            };
            var p = Element.prototype;
            DomApi.matchesSelector = p.matches || p.matchesSelector || p.mozMatchesSelector || p.msMatchesSelector || p.oMatchesSelector || p.webkitMatchesSelector;
            return DomApi
        }();
        (function() {
            "use strict";
            var Settings = Polymer.Settings,
                DomApi = Polymer.DomApi,
                dom = DomApi.factory,
                TreeApi = Polymer.TreeApi,
                getInnerHTML = Polymer.domInnerHTML.getInnerHTML,
                CONTENT = DomApi.CONTENT;
            if (Settings.useShadow) {
                return
            }
            var nativeCloneNode = Element.prototype.cloneNode,
                nativeImportNode = Document.prototype.importNode;
            Polymer.Base.mixin(DomApi.prototype, {
                _lazyDistribute: function(host) {
                    if (host.shadyRoot && host.shadyRoot._distributionClean) {
                        host.shadyRoot._distributionClean = !1;
                        Polymer.dom.addDebouncer(host.debounce("_distribute", host._distributeContent))
                    }
                },
                appendChild: function(node) {
                    return this.insertBefore(node)
                },
                insertBefore: function(node, ref_node) {
                    if (ref_node && TreeApi.Logical.getParentNode(ref_node) !== this.node) {
                        throw Error("The ref_node to be inserted before is not a child " + "of this node")
                    }
                    if (node.nodeType !== Node.DOCUMENT_FRAGMENT_NODE) {
                        var parent = TreeApi.Logical.getParentNode(node);
                        if (parent) {
                            if (DomApi.hasApi(parent)) {
                                dom(parent).notifyObserver()
                            }
                            this._removeNode(node)
                        } else {
                            this._removeOwnerShadyRoot(node)
                        }
                    }
                    if (!this._addNode(node, ref_node)) {
                        if (ref_node) {
                            ref_node = ref_node.localName === CONTENT ? this._firstComposedNode(ref_node) : ref_node
                        }
                        var container = this.node._isShadyRoot ? this.node.host : this.node;
                        if (ref_node) {
                            TreeApi.Composed.insertBefore(container, node, ref_node)
                        } else {
                            TreeApi.Composed.appendChild(container, node)
                        }
                    }
                    this.notifyObserver();
                    return node
                },
                _addNode: function(node, ref_node) {
                    var root = this.getOwnerRoot();
                    if (root) {
                        var ipAdded = this._maybeAddInsertionPoint(node, this.node);
                        if (!root._invalidInsertionPoints) {
                            root._invalidInsertionPoints = ipAdded
                        }
                        this._addNodeToHost(root.host, node)
                    }
                    if (TreeApi.Logical.hasChildNodes(this.node)) {
                        TreeApi.Logical.recordInsertBefore(node, this.node, ref_node)
                    }
                    var handled = this._maybeDistribute(node) || this.node.shadyRoot;
                    if (handled) {
                        if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
                            while (node.firstChild) {
                                TreeApi.Composed.removeChild(node, node.firstChild)
                            }
                        } else {
                            var parent = TreeApi.Composed.getParentNode(node);
                            if (parent) {
                                TreeApi.Composed.removeChild(parent, node)
                            }
                        }
                    }
                    return handled
                },
                removeChild: function(node) {
                    if (TreeApi.Logical.getParentNode(node) !== this.node) {
                        throw Error("The node to be removed is not a child of this node: " + node)
                    }
                    if (!this._removeNode(node)) {
                        var container = this.node._isShadyRoot ? this.node.host : this.node,
                            parent = TreeApi.Composed.getParentNode(node);
                        if (container === parent) {
                            TreeApi.Composed.removeChild(container, node)
                        }
                    }
                    this.notifyObserver();
                    return node
                },
                _removeNode: function(node) {
                    var logicalParent = TreeApi.Logical.hasParentNode(node) && TreeApi.Logical.getParentNode(node),
                        distributed, root = this._ownerShadyRootForNode(node);
                    if (logicalParent) {
                        distributed = dom(node)._maybeDistributeParent();
                        TreeApi.Logical.recordRemoveChild(node, logicalParent);
                        if (root && this._removeDistributedChildren(root, node)) {
                            root._invalidInsertionPoints = !0;
                            this._lazyDistribute(root.host)
                        }
                    }
                    this._removeOwnerShadyRoot(node);
                    if (root) {
                        this._removeNodeFromHost(root.host, node)
                    }
                    return distributed
                },
                replaceChild: function(node, ref_node) {
                    this.insertBefore(node, ref_node);
                    this.removeChild(ref_node);
                    return node
                },
                _hasCachedOwnerRoot: function(node) {
                    return !!(node._ownerShadyRoot !== void 0)
                },
                getOwnerRoot: function() {
                    return this._ownerShadyRootForNode(this.node)
                },
                _ownerShadyRootForNode: function(node) {
                    if (!node) {
                        return
                    }
                    var root = node._ownerShadyRoot;
                    if (root === void 0) {
                        if (node._isShadyRoot) {
                            root = node
                        } else {
                            var parent = TreeApi.Logical.getParentNode(node);
                            if (parent) {
                                root = parent._isShadyRoot ? parent : this._ownerShadyRootForNode(parent)
                            } else {
                                root = null
                            }
                        }
                        if (root || document.documentElement.contains(node)) {
                            node._ownerShadyRoot = root
                        }
                    }
                    return root
                },
                _maybeDistribute: function(node) {
                    var fragContent = node.nodeType === Node.DOCUMENT_FRAGMENT_NODE && !node.__noContent && dom(node).querySelector(CONTENT),
                        wrappedContent = fragContent && TreeApi.Logical.getParentNode(fragContent).nodeType !== Node.DOCUMENT_FRAGMENT_NODE,
                        hasContent = fragContent || node.localName === CONTENT;
                    if (hasContent) {
                        var root = this.getOwnerRoot();
                        if (root) {
                            this._lazyDistribute(root.host)
                        }
                    }
                    var needsDist = this._nodeNeedsDistribution(this.node);
                    if (needsDist) {
                        this._lazyDistribute(this.node)
                    }
                    return needsDist || hasContent && !wrappedContent
                },
                _maybeAddInsertionPoint: function(node, parent) {
                    var added;
                    if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE && !node.__noContent) {
                        for (var c$ = dom(node).querySelectorAll(CONTENT), i = 0, n, np, na; i < c$.length && (n = c$[i]); i++) {
                            np = TreeApi.Logical.getParentNode(n);
                            if (np === node) {
                                np = parent
                            }
                            na = this._maybeAddInsertionPoint(n, np);
                            added = added || na
                        }
                    } else if (node.localName === CONTENT) {
                        TreeApi.Logical.saveChildNodes(parent);
                        TreeApi.Logical.saveChildNodes(node);
                        added = !0
                    }
                    return added
                },
                _updateInsertionPoints: function(host) {
                    for (var i$ = host.shadyRoot._insertionPoints = dom(host.shadyRoot).querySelectorAll(CONTENT), i = 0, c; i < i$.length; i++) {
                        c = i$[i];
                        TreeApi.Logical.saveChildNodes(c);
                        TreeApi.Logical.saveChildNodes(TreeApi.Logical.getParentNode(c))
                    }
                },
                _nodeNeedsDistribution: function(node) {
                    return node && node.shadyRoot && DomApi.hasInsertionPoint(node.shadyRoot)
                },
                _addNodeToHost: function(host, node) {
                    if (host._elementAdd) {
                        host._elementAdd(node)
                    }
                },
                _removeNodeFromHost: function(host, node) {
                    if (host._elementRemove) {
                        host._elementRemove(node)
                    }
                },
                _removeDistributedChildren: function(root, container) {
                    for (var hostNeedsDist, ip$ = root._insertionPoints, i = 0, content; i < ip$.length; i++) {
                        content = ip$[i];
                        if (this._contains(container, content)) {
                            for (var dc$ = dom(content).getDistributedNodes(), j = 0; j < dc$.length; j++) {
                                hostNeedsDist = !0;
                                var node = dc$[j],
                                    parent = TreeApi.Composed.getParentNode(node);
                                if (parent) {
                                    TreeApi.Composed.removeChild(parent, node)
                                }
                            }
                        }
                    }
                    return hostNeedsDist
                },
                _contains: function(container, node) {
                    while (node) {
                        if (node == container) {
                            return !0
                        }
                        node = TreeApi.Logical.getParentNode(node)
                    }
                },
                _removeOwnerShadyRoot: function(node) {
                    if (this._hasCachedOwnerRoot(node)) {
                        for (var c$ = TreeApi.Logical.getChildNodes(node), i = 0, l = c$.length, n; i < l && (n = c$[i]); i++) {
                            this._removeOwnerShadyRoot(n)
                        }
                    }
                    node._ownerShadyRoot = void 0
                },
                _firstComposedNode: function(content) {
                    for (var n$ = dom(content).getDistributedNodes(), i = 0, l = n$.length, n, p$; i < l && (n = n$[i]); i++) {
                        p$ = dom(n).getDestinationInsertionPoints();
                        if (p$[p$.length - 1] === content) {
                            return n
                        }
                    }
                },
                querySelector: function(selector) {
                    var result = this._query(function(n) {
                        return DomApi.matchesSelector.call(n, selector)
                    }, this.node, function(n) {
                        return !!n
                    })[0];
                    return result || null
                },
                querySelectorAll: function(selector) {
                    return this._query(function(n) {
                        return DomApi.matchesSelector.call(n, selector)
                    }, this.node)
                },
                getDestinationInsertionPoints: function() {
                    return this.node._destinationInsertionPoints || []
                },
                getDistributedNodes: function() {
                    return this.node._distributedNodes || []
                },
                _clear: function() {
                    while (this.childNodes.length) {
                        this.removeChild(this.childNodes[0])
                    }
                },
                setAttribute: function(name, value) {
                    this.node.setAttribute(name, value);
                    this._maybeDistributeParent()
                },
                removeAttribute: function(name) {
                    this.node.removeAttribute(name);
                    this._maybeDistributeParent()
                },
                _maybeDistributeParent: function() {
                    if (this._nodeNeedsDistribution(this.parentNode)) {
                        this._lazyDistribute(this.parentNode);
                        return !0
                    }
                },
                cloneNode: function(deep) {
                    var n = nativeCloneNode.call(this.node, !1);
                    if (deep) {
                        for (var c$ = this.childNodes, d = dom(n), i = 0, nc; i < c$.length; i++) {
                            nc = dom(c$[i]).cloneNode(!0);
                            d.appendChild(nc)
                        }
                    }
                    return n
                },
                importNode: function(externalNode, deep) {
                    var doc = this.node instanceof Document ? this.node : this.node.ownerDocument,
                        n = nativeImportNode.call(doc, externalNode, !1);
                    if (deep) {
                        for (var c$ = TreeApi.Logical.getChildNodes(externalNode), d = dom(n), i = 0, nc; i < c$.length; i++) {
                            nc = dom(doc).importNode(c$[i], !0);
                            d.appendChild(nc)
                        }
                    }
                    return n
                },
                _getComposedInnerHTML: function() {
                    return getInnerHTML(this.node, !0)
                }
            });
            Object.defineProperties(DomApi.prototype, {
                activeElement: {
                    get: function() {
                        var active = document.activeElement;
                        if (!active) {
                            return null
                        }
                        var isShadyRoot = !!this.node._isShadyRoot;
                        if (this.node !== document) {
                            if (!isShadyRoot) {
                                return null
                            }
                            if (this.node.host === active || !this.node.host.contains(active)) {
                                return null
                            }
                        }
                        var activeRoot = dom(active).getOwnerRoot();
                        while (activeRoot && activeRoot !== this.node) {
                            active = activeRoot.host;
                            activeRoot = dom(active).getOwnerRoot()
                        }
                        if (this.node === document) {
                            return activeRoot ? null : active
                        } else {
                            return activeRoot === this.node ? active : null
                        }
                    },
                    configurable: !0
                },
                childNodes: {
                    get: function() {
                        var c$ = TreeApi.Logical.getChildNodes(this.node);
                        return Array.isArray(c$) ? c$ : TreeApi.arrayCopyChildNodes(this.node)
                    },
                    configurable: !0
                },
                children: {
                    get: function() {
                        if (TreeApi.Logical.hasChildNodes(this.node)) {
                            return Array.prototype.filter.call(this.childNodes, function(n) {
                                return n.nodeType === Node.ELEMENT_NODE
                            })
                        } else {
                            return TreeApi.arrayCopyChildren(this.node)
                        }
                    },
                    configurable: !0
                },
                parentNode: {
                    get: function() {
                        return TreeApi.Logical.getParentNode(this.node)
                    },
                    configurable: !0
                },
                firstChild: {
                    get: function() {
                        return TreeApi.Logical.getFirstChild(this.node)
                    },
                    configurable: !0
                },
                lastChild: {
                    get: function() {
                        return TreeApi.Logical.getLastChild(this.node)
                    },
                    configurable: !0
                },
                nextSibling: {
                    get: function() {
                        return TreeApi.Logical.getNextSibling(this.node)
                    },
                    configurable: !0
                },
                previousSibling: {
                    get: function() {
                        return TreeApi.Logical.getPreviousSibling(this.node)
                    },
                    configurable: !0
                },
                firstElementChild: {
                    get: function() {
                        return TreeApi.Logical.getFirstElementChild(this.node)
                    },
                    configurable: !0
                },
                lastElementChild: {
                    get: function() {
                        return TreeApi.Logical.getLastElementChild(this.node)
                    },
                    configurable: !0
                },
                nextElementSibling: {
                    get: function() {
                        return TreeApi.Logical.getNextElementSibling(this.node)
                    },
                    configurable: !0
                },
                previousElementSibling: {
                    get: function() {
                        return TreeApi.Logical.getPreviousElementSibling(this.node)
                    },
                    configurable: !0
                },
                textContent: {
                    get: function() {
                        var nt = this.node.nodeType;
                        if (nt === Node.TEXT_NODE || nt === Node.COMMENT_NODE) {
                            return this.node.textContent
                        } else {
                            for (var tc = [], i = 0, cn = this.childNodes, c; c = cn[i]; i++) {
                                if (c.nodeType !== Node.COMMENT_NODE) {
                                    tc.push(c.textContent)
                                }
                            }
                            return tc.join("")
                        }
                    },
                    set: function(text) {
                        var nt = this.node.nodeType;
                        if (nt === Node.TEXT_NODE || nt === Node.COMMENT_NODE) {
                            this.node.textContent = text
                        } else {
                            this._clear();
                            if (text) {
                                this.appendChild(document.createTextNode(text))
                            }
                        }
                    },
                    configurable: !0
                },
                innerHTML: {
                    get: function() {
                        var nt = this.node.nodeType;
                        if (nt === Node.TEXT_NODE || nt === Node.COMMENT_NODE) {
                            return null
                        } else {
                            return getInnerHTML(this.node)
                        }
                    },
                    set: function(text) {
                        var nt = this.node.nodeType;
                        if (nt !== Node.TEXT_NODE || nt !== Node.COMMENT_NODE) {
                            this._clear();
                            var d = document.createElement("div");
                            d.innerHTML = text;
                            for (var c$ = TreeApi.arrayCopyChildNodes(d), i = 0; i < c$.length; i++) {
                                this.appendChild(c$[i])
                            }
                        }
                    },
                    configurable: !0
                }
            });
            DomApi.hasInsertionPoint = function(root) {
                return !!(root && root._insertionPoints.length)
            }
        })();
        (function() {
            "use strict";
            var Settings = Polymer.Settings,
                TreeApi = Polymer.TreeApi,
                DomApi = Polymer.DomApi;
            if (!Settings.useShadow) {
                return
            }
            Polymer.Base.mixin(DomApi.prototype, {
                querySelectorAll: function(selector) {
                    return TreeApi.arrayCopy(this.node.querySelectorAll(selector))
                },
                getOwnerRoot: function() {
                    var n = this.node;
                    while (n) {
                        if (n.nodeType === Node.DOCUMENT_FRAGMENT_NODE && n.host) {
                            return n
                        }
                        n = n.parentNode
                    }
                },
                importNode: function(externalNode, deep) {
                    var doc = this.node instanceof Document ? this.node : this.node.ownerDocument;
                    return doc.importNode(externalNode, deep)
                },
                getDestinationInsertionPoints: function() {
                    var n$ = this.node.getDestinationInsertionPoints && this.node.getDestinationInsertionPoints();
                    return n$ ? TreeApi.arrayCopy(n$) : []
                },
                getDistributedNodes: function() {
                    var n$ = this.node.getDistributedNodes && this.node.getDistributedNodes();
                    return n$ ? TreeApi.arrayCopy(n$) : []
                }
            });
            Object.defineProperties(DomApi.prototype, {
                activeElement: {
                    get: function() {
                        var node = DomApi.wrap(this.node),
                            activeElement = node.activeElement;
                        return node.contains(activeElement) ? activeElement : null
                    },
                    configurable: !0
                },
                childNodes: {
                    get: function() {
                        return TreeApi.arrayCopyChildNodes(this.node)
                    },
                    configurable: !0
                },
                children: {
                    get: function() {
                        return TreeApi.arrayCopyChildren(this.node)
                    },
                    configurable: !0
                },
                textContent: {
                    get: function() {
                        return this.node.textContent
                    },
                    set: function(value) {
                        return this.node.textContent = value
                    },
                    configurable: !0
                },
                innerHTML: {
                    get: function() {
                        return this.node.innerHTML
                    },
                    set: function(value) {
                        return this.node.innerHTML = value
                    },
                    configurable: !0
                }
            });
            var forwardMethod = function(method) {
                DomApi.prototype[method] = function() {
                    return this.node[method].apply(this.node, arguments)
                }
            };
            (function(m$) {
                for (var i = 0; i < m$.length; i++) {
                    forwardMethod(m$[i])
                }
            })(["cloneNode", "appendChild", "insertBefore", "removeChild", "replaceChild", "setAttribute", "removeAttribute", "querySelector"]);
            var forwardProperty = function(name) {
                Object.defineProperty(DomApi.prototype, name, {
                    get: function() {
                        return this.node[name]
                    },
                    configurable: !0
                })
            };
            (function(f$) {
                for (var i = 0; i < f$.length; i++) {
                    forwardProperty(f$[i])
                }
            })(["parentNode", "firstChild", "lastChild", "nextSibling", "previousSibling", "firstElementChild", "lastElementChild", "nextElementSibling", "previousElementSibling"])
        })();
        Polymer.Base.mixin(Polymer.dom, {
            _flushGuard: 0,
            _FLUSH_MAX: 100,
            _needsTakeRecords: !Polymer.Settings.useNativeCustomElements,
            _debouncers: [],
            _staticFlushList: [],
            _finishDebouncer: null,
            flush: function() {
                this._flushGuard = 0;
                this._prepareFlush();
                while (this._debouncers.length && this._flushGuard < this._FLUSH_MAX) {
                    while (this._debouncers.length) {
                        this._debouncers.shift().complete()
                    }
                    if (this._finishDebouncer) {
                        this._finishDebouncer.complete()
                    }
                    this._prepareFlush();
                    this._flushGuard++
                }
                if (this._flushGuard >= this._FLUSH_MAX) {
                    console.warn("Polymer.dom.flush aborted. Flush may not be complete.")
                }
            },
            _prepareFlush: function() {
                if (this._needsTakeRecords) {
                    CustomElements.takeRecords()
                }
                for (var i = 0; i < this._staticFlushList.length; i++) {
                    this._staticFlushList[i]()
                }
            },
            addStaticFlush: function(fn) {
                this._staticFlushList.push(fn)
            },
            removeStaticFlush: function(fn) {
                var i = this._staticFlushList.indexOf(fn);
                if (0 <= i) {
                    this._staticFlushList.splice(i, 1)
                }
            },
            addDebouncer: function(debouncer) {
                this._debouncers.push(debouncer);
                this._finishDebouncer = Polymer.Debounce(this._finishDebouncer, this._finishFlush)
            },
            _finishFlush: function() {
                Polymer.dom._debouncers = []
            }
        });
        Polymer.EventApi = function() {
            "use strict";
            var DomApi = Polymer.DomApi.ctor,
                Settings = Polymer.Settings;
            DomApi.Event = function(event) {
                this.event = event
            };
            if (Settings.useShadow) {
                DomApi.Event.prototype = {
                    get rootTarget() {
                        return this.event.path[0]
                    },
                    get localTarget() {
                        return this.event.target
                    },
                    get path() {
                        var path = this.event.path;
                        if (!Array.isArray(path)) {
                            path = Array.prototype.slice.call(path)
                        }
                        return path
                    }
                }
            } else {
                DomApi.Event.prototype = {
                    get rootTarget() {
                        return this.event.target
                    },
                    get localTarget() {
                        for (var current = this.event.currentTarget, currentRoot = current && Polymer.dom(current).getOwnerRoot(), p$ = this.path, i = 0; i < p$.length; i++) {
                            if (Polymer.dom(p$[i]).getOwnerRoot() === currentRoot) {
                                return p$[i]
                            }
                        }
                    },
                    get path() {
                        if (!this.event._path) {
                            var path = [],
                                current = this.rootTarget;
                            while (current) {
                                path.push(current);
                                var insertionPoints = Polymer.dom(current).getDestinationInsertionPoints();
                                if (insertionPoints.length) {
                                    for (var i = 0; i < insertionPoints.length - 1; i++) {
                                        path.push(insertionPoints[i])
                                    }
                                    current = insertionPoints[insertionPoints.length - 1]
                                } else {
                                    current = Polymer.dom(current).parentNode || current.host
                                }
                            }
                            path.push(window);
                            this.event._path = path
                        }
                        return this.event._path
                    }
                }
            }
            return {
                factory: function(event) {
                    if (!event.__eventApi) {
                        event.__eventApi = new DomApi.Event(event)
                    }
                    return event.__eventApi
                }
            }
        }();
        (function() {
            "use strict";
            var DomApi = Polymer.DomApi.ctor,
                useShadow = Polymer.Settings.useShadow;
            Object.defineProperty(DomApi.prototype, "classList", {
                get: function() {
                    if (!this._classList) {
                        this._classList = new DomApi.ClassList(this)
                    }
                    return this._classList
                },
                configurable: !0
            });
            DomApi.ClassList = function(host) {
                this.domApi = host;
                this.node = host.node
            };
            DomApi.ClassList.prototype = {
                add: function() {
                    this.node.classList.add.apply(this.node.classList, arguments);
                    this._distributeParent()
                },
                remove: function() {
                    this.node.classList.remove.apply(this.node.classList, arguments);
                    this._distributeParent()
                },
                toggle: function() {
                    this.node.classList.toggle.apply(this.node.classList, arguments);
                    this._distributeParent()
                },
                _distributeParent: function() {
                    if (!useShadow) {
                        this.domApi._maybeDistributeParent()
                    }
                },
                contains: function() {
                    return this.node.classList.contains.apply(this.node.classList, arguments)
                }
            }
        })();
        (function() {
            "use strict";
            var DomApi = Polymer.DomApi.ctor,
                Settings = Polymer.Settings;
            DomApi.EffectiveNodesObserver = function(domApi) {
                this.domApi = domApi;
                this.node = this.domApi.node;
                this._listeners = []
            };
            DomApi.EffectiveNodesObserver.prototype = {
                addListener: function(callback) {
                    if (!this._isSetup) {
                        this._setup();
                        this._isSetup = !0
                    }
                    var listener = {
                        fn: callback,
                        _nodes: []
                    };
                    this._listeners.push(listener);
                    this._scheduleNotify();
                    return listener
                },
                removeListener: function(handle) {
                    var i = this._listeners.indexOf(handle);
                    if (0 <= i) {
                        this._listeners.splice(i, 1);
                        handle._nodes = []
                    }
                    if (!this._hasListeners()) {
                        this._cleanup();
                        this._isSetup = !1
                    }
                },
                _setup: function() {
                    this._observeContentElements(this.domApi.childNodes)
                },
                _cleanup: function() {
                    this._unobserveContentElements(this.domApi.childNodes)
                },
                _hasListeners: function() {
                    return !!this._listeners.length
                },
                _scheduleNotify: function() {
                    if (this._debouncer) {
                        this._debouncer.stop()
                    }
                    this._debouncer = Polymer.Debounce(this._debouncer, this._notify);
                    this._debouncer.context = this;
                    Polymer.dom.addDebouncer(this._debouncer)
                },
                notify: function() {
                    if (this._hasListeners()) {
                        this._scheduleNotify()
                    }
                },
                _notify: function() {
                    this._beforeCallListeners();
                    this._callListeners()
                },
                _beforeCallListeners: function() {
                    this._updateContentElements()
                },
                _updateContentElements: function() {
                    this._observeContentElements(this.domApi.childNodes)
                },
                _observeContentElements: function(elements) {
                    for (var i = 0, n; i < elements.length && (n = elements[i]); i++) {
                        if (this._isContent(n)) {
                            n.__observeNodesMap = n.__observeNodesMap || new WeakMap;
                            if (!n.__observeNodesMap.has(this)) {
                                n.__observeNodesMap.set(this, this._observeContent(n))
                            }
                        }
                    }
                },
                _observeContent: function(content) {
                    var self = this,
                        h = Polymer.dom(content).observeNodes(function() {
                            self._scheduleNotify()
                        });
                    h._avoidChangeCalculation = !0;
                    return h
                },
                _unobserveContentElements: function(elements) {
                    for (var i = 0, n, h; i < elements.length && (n = elements[i]); i++) {
                        if (this._isContent(n)) {
                            h = n.__observeNodesMap.get(this);
                            if (h) {
                                Polymer.dom(n).unobserveNodes(h);
                                n.__observeNodesMap.delete(this)
                            }
                        }
                    }
                },
                _isContent: function(node) {
                    return "content" === node.localName
                },
                _callListeners: function() {
                    for (var o$ = this._listeners, nodes = this._getEffectiveNodes(), i = 0, o, info; i < o$.length && (o = o$[i]); i++) {
                        info = this._generateListenerInfo(o, nodes);
                        if (info || o._alwaysNotify) {
                            this._callListener(o, info)
                        }
                    }
                },
                _getEffectiveNodes: function() {
                    return this.domApi.getEffectiveChildNodes()
                },
                _generateListenerInfo: function(listener, newNodes) {
                    if (listener._avoidChangeCalculation) {
                        return !0
                    }
                    for (var oldNodes = listener._nodes, info = {
                            target: this.node,
                            addedNodes: [],
                            removedNodes: []
                        }, splices = Polymer.ArraySplice.calculateSplices(newNodes, oldNodes), i = 0, s; i < splices.length && (s = splices[i]); i++) {
                        for (var j = 0, n; j < s.removed.length && (n = s.removed[j]); j++) {
                            info.removedNodes.push(n)
                        }
                    }
                    for (i = 0, s; i < splices.length && (s = splices[i]); i++) {
                        for (j = s.index; j < s.index + s.addedCount; j++) {
                            info.addedNodes.push(newNodes[j])
                        }
                    }
                    listener._nodes = newNodes;
                    if (info.addedNodes.length || info.removedNodes.length) {
                        return info
                    }
                },
                _callListener: function(listener, info) {
                    return listener.fn.call(this.node, info)
                },
                enableShadowAttributeTracking: function() {}
            };
            if (Settings.useShadow) {
                var baseSetup = DomApi.EffectiveNodesObserver.prototype._setup,
                    baseCleanup = DomApi.EffectiveNodesObserver.prototype._cleanup;
                Polymer.Base.mixin(DomApi.EffectiveNodesObserver.prototype, {
                    _setup: function() {
                        if (!this._observer) {
                            var self = this;
                            this._mutationHandler = function(mxns) {
                                if (mxns && mxns.length) {
                                    self._scheduleNotify()
                                }
                            };
                            this._observer = new MutationObserver(this._mutationHandler);
                            this._boundFlush = function() {
                                self._flush()
                            };
                            Polymer.dom.addStaticFlush(this._boundFlush);
                            this._observer.observe(this.node, {
                                childList: !0
                            })
                        }
                        baseSetup.call(this)
                    },
                    _cleanup: function() {
                        this._observer.disconnect();
                        this._observer = null;
                        this._mutationHandler = null;
                        Polymer.dom.removeStaticFlush(this._boundFlush);
                        baseCleanup.call(this)
                    },
                    _flush: function() {
                        if (this._observer) {
                            this._mutationHandler(this._observer.takeRecords())
                        }
                    },
                    enableShadowAttributeTracking: function() {
                        if (this._observer) {
                            this._makeContentListenersAlwaysNotify();
                            this._observer.disconnect();
                            this._observer.observe(this.node, {
                                childList: !0,
                                attributes: !0,
                                subtree: !0
                            });
                            var root = this.domApi.getOwnerRoot(),
                                host = root && root.host;
                            if (host && Polymer.dom(host).observer) {
                                Polymer.dom(host).observer.enableShadowAttributeTracking()
                            }
                        }
                    },
                    _makeContentListenersAlwaysNotify: function() {
                        for (var i = 0, h; i < this._listeners.length; i++) {
                            h = this._listeners[i];
                            h._alwaysNotify = h._isContentListener
                        }
                    }
                })
            }
        })();
        (function() {
            "use strict";
            var DomApi = Polymer.DomApi.ctor,
                Settings = Polymer.Settings;
            DomApi.DistributedNodesObserver = function(domApi) {
                DomApi.EffectiveNodesObserver.call(this, domApi)
            };
            DomApi.DistributedNodesObserver.prototype = Object.create(DomApi.EffectiveNodesObserver.prototype);
            Polymer.Base.mixin(DomApi.DistributedNodesObserver.prototype, {
                _setup: function() {},
                _cleanup: function() {},
                _beforeCallListeners: function() {},
                _getEffectiveNodes: function() {
                    return this.domApi.getDistributedNodes()
                }
            });
            if (Settings.useShadow) {
                Polymer.Base.mixin(DomApi.DistributedNodesObserver.prototype, {
                    _setup: function() {
                        if (!this._observer) {
                            var root = this.domApi.getOwnerRoot(),
                                host = root && root.host;
                            if (host) {
                                var self = this;
                                this._observer = Polymer.dom(host).observeNodes(function() {
                                    self._scheduleNotify()
                                });
                                this._observer._isContentListener = !0;
                                if (this._hasAttrSelect()) {
                                    Polymer.dom(host).observer.enableShadowAttributeTracking()
                                }
                            }
                        }
                    },
                    _hasAttrSelect: function() {
                        var select = this.node.getAttribute("select");
                        return select && select.match(/[[.]+/)
                    },
                    _cleanup: function() {
                        var root = this.domApi.getOwnerRoot(),
                            host = root && root.host;
                        if (host) {
                            Polymer.dom(host).unobserveNodes(this._observer)
                        }
                        this._observer = null
                    }
                })
            }
        })();
        (function() {
            var DomApi = Polymer.DomApi,
                TreeApi = Polymer.TreeApi;
            Polymer.Base._addFeature({
                _prepShady: function() {
                    this._useContent = this._useContent || !!this._template
                },
                _setupShady: function() {
                    this.shadyRoot = null;
                    if (!this.__domApi) {
                        this.__domApi = null
                    }
                    if (!this.__dom) {
                        this.__dom = null
                    }
                    if (!this._ownerShadyRoot) {
                        this._ownerShadyRoot = void 0
                    }
                },
                _poolContent: function() {
                    if (this._useContent) {
                        TreeApi.Logical.saveChildNodes(this)
                    }
                },
                _setupRoot: function() {
                    if (this._useContent) {
                        this._createLocalRoot();
                        if (!this.dataHost) {
                            upgradeLogicalChildren(TreeApi.Logical.getChildNodes(this))
                        }
                    }
                },
                _createLocalRoot: function() {
                    this.shadyRoot = this.root;
                    this.shadyRoot._distributionClean = !1;
                    this.shadyRoot._hasDistributed = !1;
                    this.shadyRoot._isShadyRoot = !0;
                    this.shadyRoot._dirtyRoots = [];
                    var i$ = this.shadyRoot._insertionPoints = !this._notes || this._notes._hasContent ? this.shadyRoot.querySelectorAll("content") : [];
                    TreeApi.Logical.saveChildNodes(this.shadyRoot);
                    for (var i = 0, c; i < i$.length; i++) {
                        c = i$[i];
                        TreeApi.Logical.saveChildNodes(c);
                        TreeApi.Logical.saveChildNodes(c.parentNode)
                    }
                    this.shadyRoot.host = this
                },
                distributeContent: function(updateInsertionPoints) {
                    if (this.shadyRoot) {
                        this.shadyRoot._invalidInsertionPoints = this.shadyRoot._invalidInsertionPoints || updateInsertionPoints;
                        var host = getTopDistributingHost(this);
                        Polymer.dom(this)._lazyDistribute(host)
                    }
                },
                _distributeContent: function() {
                    if (this._useContent && !this.shadyRoot._distributionClean) {
                        if (this.shadyRoot._invalidInsertionPoints) {
                            Polymer.dom(this)._updateInsertionPoints(this);
                            this.shadyRoot._invalidInsertionPoints = !1
                        }
                        this._beginDistribute();
                        this._distributeDirtyRoots();
                        this._finishDistribute()
                    }
                },
                _beginDistribute: function() {
                    if (this._useContent && DomApi.hasInsertionPoint(this.shadyRoot)) {
                        this._resetDistribution();
                        this._distributePool(this.shadyRoot, this._collectPool())
                    }
                },
                _distributeDirtyRoots: function() {
                    for (var c$ = this.shadyRoot._dirtyRoots, i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {
                        c._distributeContent()
                    }
                    this.shadyRoot._dirtyRoots = []
                },
                _finishDistribute: function() {
                    if (this._useContent) {
                        this.shadyRoot._distributionClean = !0;
                        if (DomApi.hasInsertionPoint(this.shadyRoot)) {
                            this._composeTree();
                            notifyContentObservers(this.shadyRoot)
                        } else {
                            if (!this.shadyRoot._hasDistributed) {
                                TreeApi.Composed.clearChildNodes(this);
                                this.appendChild(this.shadyRoot)
                            } else {
                                var children = this._composeNode(this);
                                this._updateChildNodes(this, children)
                            }
                        }
                        if (!this.shadyRoot._hasDistributed) {
                            notifyInitialDistribution(this)
                        }
                        this.shadyRoot._hasDistributed = !0
                    }
                },
                elementMatches: function(selector, node) {
                    node = node || this;
                    return DomApi.matchesSelector.call(node, selector)
                },
                _resetDistribution: function() {
                    for (var children = TreeApi.Logical.getChildNodes(this), i = 0, child; i < children.length; i++) {
                        child = children[i];
                        if (child._destinationInsertionPoints) {
                            child._destinationInsertionPoints = void 0
                        }
                        if (isInsertionPoint(child)) {
                            clearDistributedDestinationInsertionPoints(child)
                        }
                    }
                    for (var root = this.shadyRoot, p$ = root._insertionPoints, j = 0; j < p$.length; j++) {
                        p$[j]._distributedNodes = []
                    }
                },
                _collectPool: function() {
                    for (var pool = [], children = TreeApi.Logical.getChildNodes(this), i = 0, child; i < children.length; i++) {
                        child = children[i];
                        if (isInsertionPoint(child)) {
                            pool.push.apply(pool, child._distributedNodes)
                        } else {
                            pool.push(child)
                        }
                    }
                    return pool
                },
                _distributePool: function(node, pool) {
                    for (var p$ = node._insertionPoints, i = 0, l = p$.length, p; i < l && (p = p$[i]); i++) {
                        this._distributeInsertionPoint(p, pool);
                        maybeRedistributeParent(p, this)
                    }
                },
                _distributeInsertionPoint: function(content, pool) {
                    for (var anyDistributed = !1, i = 0, l = pool.length, node; i < l; i++) {
                        node = pool[i];
                        if (!node) {
                            continue
                        }
                        if (this._matchesContentSelect(node, content)) {
                            distributeNodeInto(node, content);
                            pool[i] = void 0;
                            anyDistributed = !0
                        }
                    }
                    if (!anyDistributed) {
                        for (var children = TreeApi.Logical.getChildNodes(content), j = 0; j < children.length; j++) {
                            distributeNodeInto(children[j], content)
                        }
                    }
                },
                _composeTree: function() {
                    this._updateChildNodes(this, this._composeNode(this));
                    for (var p$ = this.shadyRoot._insertionPoints, i = 0, l = p$.length, p, parent; i < l && (p = p$[i]); i++) {
                        parent = TreeApi.Logical.getParentNode(p);
                        if (!parent._useContent && parent !== this && parent !== this.shadyRoot) {
                            this._updateChildNodes(parent, this._composeNode(parent))
                        }
                    }
                },
                _composeNode: function(node) {
                    for (var children = [], c$ = TreeApi.Logical.getChildNodes(node.shadyRoot || node), i = 0, child; i < c$.length; i++) {
                        child = c$[i];
                        if (isInsertionPoint(child)) {
                            for (var distributedNodes = child._distributedNodes, j = 0, distributedNode; j < distributedNodes.length; j++) {
                                distributedNode = distributedNodes[j];
                                if (isFinalDestination(child, distributedNode)) {
                                    children.push(distributedNode)
                                }
                            }
                        } else {
                            children.push(child)
                        }
                    }
                    return children
                },
                _updateChildNodes: function(container, children) {
                    for (var composed = TreeApi.Composed.getChildNodes(container), splices = Polymer.ArraySplice.calculateSplices(children, composed), i = 0, d = 0, s; i < splices.length && (s = splices[i]); i++) {
                        for (var j = 0, n; j < s.removed.length && (n = s.removed[j]); j++) {
                            if (TreeApi.Composed.getParentNode(n) === container) {
                                TreeApi.Composed.removeChild(container, n)
                            }
                            composed.splice(s.index + d, 1)
                        }
                        d -= s.addedCount
                    }
                    for (var i = 0, s, next; i < splices.length && (s = splices[i]); i++) {
                        next = composed[s.index];
                        for (j = s.index, n; j < s.index + s.addedCount; j++) {
                            n = children[j];
                            TreeApi.Composed.insertBefore(container, n, next);
                            composed.splice(j, 0, n)
                        }
                    }
                },
                _matchesContentSelect: function(node, contentElement) {
                    var select = contentElement.getAttribute("select");
                    if (!select) {
                        return !0
                    }
                    select = select.trim();
                    if (!select) {
                        return !0
                    }
                    if (!(node instanceof Element)) {
                        return !1
                    }
                    var validSelectors = /^(:not\()?[*.#[a-zA-Z_|]/;
                    if (!validSelectors.test(select)) {
                        return !1
                    }
                    return this.elementMatches(select, node)
                },
                _elementAdd: function() {},
                _elementRemove: function() {}
            });
            var domHostDesc = {
                get: function() {
                    var root = Polymer.dom(this).getOwnerRoot();
                    return root && root.host
                },
                configurable: !0
            };
            Object.defineProperty(Polymer.Base, "domHost", domHostDesc);
            Polymer.BaseDescriptors.domHost = domHostDesc;

            function distributeNodeInto(child, insertionPoint) {
                insertionPoint._distributedNodes.push(child);
                var points = child._destinationInsertionPoints;
                if (!points) {
                    child._destinationInsertionPoints = [insertionPoint]
                } else {
                    points.push(insertionPoint)
                }
            }

            function clearDistributedDestinationInsertionPoints(content) {
                var e$ = content._distributedNodes;
                if (e$) {
                    for (var i = 0, d; i < e$.length; i++) {
                        d = e$[i]._destinationInsertionPoints;
                        if (d) {
                            d.splice(d.indexOf(content) + 1, d.length)
                        }
                    }
                }
            }

            function maybeRedistributeParent(content, host) {
                var parent = TreeApi.Logical.getParentNode(content);
                if (parent && parent.shadyRoot && DomApi.hasInsertionPoint(parent.shadyRoot) && parent.shadyRoot._distributionClean) {
                    parent.shadyRoot._distributionClean = !1;
                    host.shadyRoot._dirtyRoots.push(parent)
                }
            }

            function isFinalDestination(insertionPoint, node) {
                var points = node._destinationInsertionPoints;
                return points && points[points.length - 1] === insertionPoint
            }

            function isInsertionPoint(node) {
                return "content" == node.localName
            }

            function getTopDistributingHost(host) {
                while (host && hostNeedsRedistribution(host)) {
                    host = host.domHost
                }
                return host
            }

            function hostNeedsRedistribution(host) {
                for (var c$ = TreeApi.Logical.getChildNodes(host), i = 0, c; i < c$.length; i++) {
                    c = c$[i];
                    if (c.localName && "content" === c.localName) {
                        return host.domHost
                    }
                }
            }

            function notifyContentObservers(root) {
                for (var i = 0, c; i < root._insertionPoints.length; i++) {
                    c = root._insertionPoints[i];
                    if (DomApi.hasApi(c)) {
                        Polymer.dom(c).notifyObserver()
                    }
                }
            }

            function notifyInitialDistribution(host) {
                if (DomApi.hasApi(host)) {
                    Polymer.dom(host).notifyObserver()
                }
            }
            var needsUpgrade = window.CustomElements && !CustomElements.useNative;

            function upgradeLogicalChildren(children) {
                if (needsUpgrade && children) {
                    for (var i = 0; i < children.length; i++) {
                        CustomElements.upgrade(children[i])
                    }
                }
            }
        })();
        if (Polymer.Settings.useShadow) {
            Polymer.Base._addFeature({
                _poolContent: function() {},
                _beginDistribute: function() {},
                distributeContent: function() {},
                _distributeContent: function() {},
                _finishDistribute: function() {},
                _createLocalRoot: function() {
                    this.createShadowRoot();
                    this.shadowRoot.appendChild(this.root);
                    this.root = this.shadowRoot
                }
            })
        }
        Polymer.Async = {
            _currVal: 0,
            _lastVal: 0,
            _callbacks: [],
            _twiddleContent: 0,
            _twiddle: document.createTextNode(""),
            run: function(callback, waitTime) {
                if (0 < waitTime) {
                    return ~setTimeout(callback, waitTime)
                } else {
                    this._twiddle.textContent = this._twiddleContent++;
                    this._callbacks.push(callback);
                    return this._currVal++
                }
            },
            cancel: function(handle) {
                if (0 > handle) {
                    clearTimeout(~handle)
                } else {
                    var idx = handle - this._lastVal;
                    if (0 <= idx) {
                        if (!this._callbacks[idx]) {
                            throw "invalid async handle: " + handle
                        }
                        this._callbacks[idx] = null
                    }
                }
            },
            _atEndOfMicrotask: function() {
                for (var len = this._callbacks.length, i = 0, cb; i < len; i++) {
                    cb = this._callbacks[i];
                    if (cb) {
                        try {
                            cb()
                        } catch (e) {
                            i++;
                            this._callbacks.splice(0, i);
                            this._lastVal += i;
                            this._twiddle.textContent = this._twiddleContent++;
                            throw e
                        }
                    }
                }
                this._callbacks.splice(0, len);
                this._lastVal += len
            }
        };
        new window.MutationObserver(function() {
            Polymer.Async._atEndOfMicrotask()
        }).observe(Polymer.Async._twiddle, {
            characterData: !0
        });
        Polymer.Debounce = function() {
            var Async = Polymer.Async,
                Debouncer = function(context) {
                    this.context = context;
                    var self = this;
                    this.boundComplete = function() {
                        self.complete()
                    }
                };
            Debouncer.prototype = {
                go: function(callback, wait) {
                    var h;
                    this.finish = function() {
                        Async.cancel(h)
                    };
                    h = Async.run(this.boundComplete, wait);
                    this.callback = callback
                },
                stop: function() {
                    if (this.finish) {
                        this.finish();
                        this.finish = null;
                        this.callback = null
                    }
                },
                complete: function() {
                    if (this.finish) {
                        var callback = this.callback;
                        this.stop();
                        callback.call(this.context)
                    }
                }
            };
            return function(debouncer, callback, wait) {
                if (debouncer) {
                    debouncer.stop()
                } else {
                    debouncer = new Debouncer(this)
                }
                debouncer.go(callback, wait);
                return debouncer
            }
        }();
        Polymer.Base._addFeature({
            _setupDebouncers: function() {
                this._debouncers = {}
            },
            debounce: function(jobName, callback, wait) {
                return this._debouncers[jobName] = Polymer.Debounce.call(this, this._debouncers[jobName], callback, wait)
            },
            isDebouncerActive: function(jobName) {
                var debouncer = this._debouncers[jobName];
                return !!(debouncer && debouncer.finish)
            },
            flushDebouncer: function(jobName) {
                var debouncer = this._debouncers[jobName];
                if (debouncer) {
                    debouncer.complete()
                }
            },
            cancelDebouncer: function(jobName) {
                var debouncer = this._debouncers[jobName];
                if (debouncer) {
                    debouncer.stop()
                }
            }
        });
        Polymer.DomModule = document.createElement("dom-module");
        Polymer.Base._addFeature({
            _registerFeatures: function() {
                this._prepIs();
                this._prepBehaviors();
                this._prepConstructor();
                this._prepTemplate();
                this._prepShady();
                this._prepPropertyInfo()
            },
            _prepBehavior: function(b) {
                this._addHostAttributes(b.hostAttributes)
            },
            _initFeatures: function() {
                this._registerHost();
                if (this._template) {
                    this._poolContent();
                    this._beginHosting();
                    this._stampTemplate();
                    this._endHosting()
                }
                this._marshalHostAttributes();
                this._setupDebouncers();
                this._marshalBehaviors();
                this._tryReady()
            },
            _marshalBehavior: function() {}
        });
    </script>
    <script>
        (function() {
            Polymer.nar = [];
            var disableUpgradeEnabled = Polymer.Settings.disableUpgradeEnabled;
            Polymer.Annotations = {
                parseAnnotations: function(template, stripWhiteSpace) {
                    var list = [],
                        content = template._content || template.content;
                    this._parseNodeAnnotations(content, list, stripWhiteSpace || template.hasAttribute("strip-whitespace"));
                    return list
                },
                _parseNodeAnnotations: function(node, list, stripWhiteSpace) {
                    return node.nodeType === Node.TEXT_NODE ? this._parseTextNodeAnnotation(node, list) : this._parseElementAnnotations(node, list, stripWhiteSpace)
                },
                _bindingRegex: function() {
                    var IDENT = "(?:" + "[a-zA-Z_$][\\w.:$\\-*]*" + ")",
                        ARGUMENT = "(?:" + IDENT + "|" + ("(?:" + "[-+]?[0-9]*\\.?[0-9]+(?:[eE][-+]?[0-9]+)?" + ")") + "|" + ("(?:" + ("(?:" + "'(?:[^'\\\\]|\\\\.)*'" + ")") + "|" + ("(?:" + "\"(?:[^\"\\\\]|\\\\.)*\"" + ")") + ")") + "\\s*" + ")";
                    return new RegExp("(\\[\\[|{{)" + "\\s*" + "(?:(!)\\s*)?" + ("(" + IDENT + "\\s*" + ("(?:" + "\\(\\s*" + "(?:" + ("(?:" + ARGUMENT + "(?:,\\s*" + ARGUMENT + ")*" + ")") + "?" + ")" + "\\)\\s*" + ")") + "?" + ")") + "(?:]]|}})", "g")
                }(),
                _parseBindings: function(text) {
                    var re = this._bindingRegex,
                        parts = [],
                        lastIndex = 0,
                        m;
                    while (null !== (m = re.exec(text))) {
                        if (m.index > lastIndex) {
                            parts.push({
                                literal: text.slice(lastIndex, m.index)
                            })
                        }
                        var mode = m[1][0],
                            negate = !!m[2],
                            value = m[3].trim(),
                            customEvent, notifyEvent, colon;
                        if ("{" == mode && 0 < (colon = value.indexOf("::"))) {
                            notifyEvent = value.substring(colon + 2);
                            value = value.substring(0, colon);
                            customEvent = !0
                        }
                        parts.push({
                            compoundIndex: parts.length,
                            value: value,
                            mode: mode,
                            negate: negate,
                            event: notifyEvent,
                            customEvent: customEvent
                        });
                        lastIndex = re.lastIndex
                    }
                    if (lastIndex && lastIndex < text.length) {
                        var literal = text.substring(lastIndex);
                        if (literal) {
                            parts.push({
                                literal: literal
                            })
                        }
                    }
                    if (parts.length) {
                        return parts
                    }
                },
                _literalFromParts: function(parts) {
                    for (var s = "", i = 0, literal; i < parts.length; i++) {
                        literal = parts[i].literal;
                        s += literal || ""
                    }
                    return s
                },
                _parseTextNodeAnnotation: function(node, list) {
                    var parts = this._parseBindings(node.textContent);
                    if (parts) {
                        node.textContent = this._literalFromParts(parts) || " ";
                        var annote = {
                            bindings: [{
                                kind: "text",
                                name: "textContent",
                                parts: parts,
                                isCompound: 1 !== parts.length
                            }]
                        };
                        list.push(annote);
                        return annote
                    }
                },
                _parseElementAnnotations: function(element, list, stripWhiteSpace) {
                    var annote = {
                        bindings: [],
                        events: []
                    };
                    if ("content" === element.localName) {
                        list._hasContent = !0
                    }
                    this._parseChildNodesAnnotations(element, annote, list, stripWhiteSpace);
                    if (element.attributes) {
                        this._parseNodeAttributeAnnotations(element, annote, list);
                        if (this.prepElement) {
                            this.prepElement(element)
                        }
                    }
                    if (annote.bindings.length || annote.events.length || annote.id) {
                        list.push(annote)
                    }
                    return annote
                },
                _parseChildNodesAnnotations: function(root, annote, list, stripWhiteSpace) {
                    if (root.firstChild) {
                        var node = root.firstChild,
                            i = 0;
                        while (node) {
                            var next = node.nextSibling;
                            if ("template" === node.localName && !node.hasAttribute("preserve-content")) {
                                this._parseTemplate(node, i, list, annote, stripWhiteSpace)
                            }
                            if ("slot" == node.localName) {
                                node = this._replaceSlotWithContent(node)
                            }
                            if (node.nodeType === Node.TEXT_NODE) {
                                var n = next;
                                while (n && n.nodeType === Node.TEXT_NODE) {
                                    node.textContent += n.textContent;
                                    next = n.nextSibling;
                                    root.removeChild(n);
                                    n = next
                                }
                                if (stripWhiteSpace && !node.textContent.trim()) {
                                    root.removeChild(node);
                                    i--
                                }
                            }
                            if (node.parentNode) {
                                var childAnnotation = this._parseNodeAnnotations(node, list, stripWhiteSpace);
                                if (childAnnotation) {
                                    childAnnotation.parent = annote;
                                    childAnnotation.index = i
                                }
                            }
                            node = next;
                            i++
                        }
                    }
                },
                _replaceSlotWithContent: function(slot) {
                    var content = slot.ownerDocument.createElement("content");
                    while (slot.firstChild) {
                        content.appendChild(slot.firstChild)
                    }
                    for (var attrs = slot.attributes, i = 0, attr; i < attrs.length; i++) {
                        attr = attrs[i];
                        content.setAttribute(attr.name, attr.value)
                    }
                    var name = slot.getAttribute("name");
                    if (name) {
                        content.setAttribute("select", "[slot='" + name + "']")
                    }
                    slot.parentNode.replaceChild(content, slot);
                    return content
                },
                _parseTemplate: function(node, index, list, parent, stripWhiteSpace) {
                    var content = document.createDocumentFragment();
                    content._notes = this.parseAnnotations(node, stripWhiteSpace);
                    content.appendChild(node.content);
                    list.push({
                        bindings: Polymer.nar,
                        events: Polymer.nar,
                        templateContent: content,
                        parent: parent,
                        index: index
                    })
                },
                _parseNodeAttributeAnnotations: function(node, annotation) {
                    for (var attrs = Array.prototype.slice.call(node.attributes), i = attrs.length - 1, a; a = attrs[i]; i--) {
                        var n = a.name,
                            v = a.value,
                            b;
                        if ("on-" === n.slice(0, 3)) {
                            node.removeAttribute(n);
                            annotation.events.push({
                                name: n.slice(3),
                                value: v
                            })
                        } else if (b = this._parseNodeAttributeAnnotation(node, n, v)) {
                            annotation.bindings.push(b)
                        } else if ("id" === n) {
                            annotation.id = v
                        }
                    }
                },
                _parseNodeAttributeAnnotation: function(node, name, value) {
                    var parts = this._parseBindings(value);
                    if (parts) {
                        var origName = name,
                            kind = "property";
                        if ("$" == name[name.length - 1]) {
                            name = name.slice(0, -1);
                            kind = "attribute"
                        }
                        var literal = this._literalFromParts(parts);
                        if (literal && "attribute" == kind) {
                            node.setAttribute(name, literal)
                        }
                        if ("input" === node.localName && "value" === origName) {
                            node.setAttribute(origName, "")
                        }
                        if (disableUpgradeEnabled && "disable-upgrade$" === origName) {
                            node.setAttribute(name, "")
                        }
                        node.removeAttribute(origName);
                        var propertyName = Polymer.CaseMap.dashToCamelCase(name);
                        if ("property" === kind) {
                            name = propertyName
                        }
                        return {
                            kind: kind,
                            name: name,
                            propertyName: propertyName,
                            parts: parts,
                            literal: literal,
                            isCompound: 1 !== parts.length
                        }
                    }
                },
                findAnnotatedNode: function(root, annote) {
                    var parent = annote.parent && Polymer.Annotations.findAnnotatedNode(root, annote.parent);
                    if (parent) {
                        for (var n = parent.firstChild, i = 0; n; n = n.nextSibling) {
                            if (annote.index === i++) {
                                return n
                            }
                        }
                    } else {
                        return root
                    }
                }
            }
        })();
        Polymer.Path = {
            root: function(path) {
                var dotIndex = path.indexOf(".");
                if (-1 === dotIndex) {
                    return path
                }
                return path.slice(0, dotIndex)
            },
            isDeep: function(path) {
                return -1 !== path.indexOf(".")
            },
            isAncestor: function(base, path) {
                return 0 === base.indexOf(path + ".")
            },
            isDescendant: function(base, path) {
                return 0 === path.indexOf(base + ".")
            },
            translate: function(base, newBase, path) {
                return newBase + path.slice(base.length)
            },
            matches: function(base, wildcard, path) {
                return base === path || this.isAncestor(base, path) || !!wildcard && this.isDescendant(base, path)
            }
        };
        Polymer.Base._addFeature({
            _prepAnnotations: function() {
                if (!this._template) {
                    this._notes = []
                } else {
                    var self = this;
                    Polymer.Annotations.prepElement = function(element) {
                        self._prepElement(element)
                    };
                    if (this._template._content && this._template._content._notes) {
                        this._notes = this._template._content._notes
                    } else {
                        this._notes = Polymer.Annotations.parseAnnotations(this._template);
                        this._processAnnotations(this._notes)
                    }
                    Polymer.Annotations.prepElement = null
                }
            },
            _processAnnotations: function(notes) {
                for (var i = 0, note; i < notes.length; i++) {
                    note = notes[i];
                    for (var j = 0, b; j < note.bindings.length; j++) {
                        b = note.bindings[j];
                        for (var k = 0, p; k < b.parts.length; k++) {
                            p = b.parts[k];
                            if (!p.literal) {
                                var signature = this._parseMethod(p.value);
                                if (signature) {
                                    p.signature = signature
                                } else {
                                    p.model = Polymer.Path.root(p.value)
                                }
                            }
                        }
                    }
                    if (note.templateContent) {
                        this._processAnnotations(note.templateContent._notes);
                        var pp = note.templateContent._parentProps = this._discoverTemplateParentProps(note.templateContent._notes),
                            bindings = [];
                        for (var prop in pp) {
                            var name = "_parent_" + prop;
                            bindings.push({
                                index: note.index,
                                kind: "property",
                                name: name,
                                propertyName: name,
                                parts: [{
                                    mode: "{",
                                    model: prop,
                                    value: prop
                                }]
                            })
                        }
                        note.bindings = note.bindings.concat(bindings)
                    }
                }
            },
            _discoverTemplateParentProps: function(notes) {
                for (var pp = {}, i = 0, n; i < notes.length && (n = notes[i]); i++) {
                    for (var j = 0, b$ = n.bindings, b; j < b$.length && (b = b$[j]); j++) {
                        for (var k = 0, p$ = b.parts, p; k < p$.length && (p = p$[k]); k++) {
                            if (p.signature) {
                                for (var args = p.signature.args, kk = 0, model; kk < args.length; kk++) {
                                    model = args[kk].model;
                                    if (model) {
                                        pp[model] = !0
                                    }
                                }
                                if (p.signature.dynamicFn) {
                                    pp[p.signature.method] = !0
                                }
                            } else {
                                if (p.model) {
                                    pp[p.model] = !0
                                }
                            }
                        }
                    }
                    if (n.templateContent) {
                        var tpp = n.templateContent._parentProps;
                        Polymer.Base.mixin(pp, tpp)
                    }
                }
                return pp
            },
            _prepElement: function(element) {
                Polymer.ResolveUrl.resolveAttrs(element, this._template.ownerDocument)
            },
            _findAnnotatedNode: Polymer.Annotations.findAnnotatedNode,
            _marshalAnnotationReferences: function() {
                if (this._template) {
                    this._marshalIdNodes();
                    this._marshalAnnotatedNodes();
                    this._marshalAnnotatedListeners()
                }
            },
            _configureAnnotationReferences: function() {
                for (var notes = this._notes, nodes = this._nodes, i = 0; i < notes.length; i++) {
                    var note = notes[i],
                        node = nodes[i];
                    this._configureTemplateContent(note, node);
                    this._configureCompoundBindings(note, node)
                }
            },
            _configureTemplateContent: function(note, node) {
                if (note.templateContent) {
                    node._content = note.templateContent
                }
            },
            _configureCompoundBindings: function(note, node) {
                for (var bindings = note.bindings, i = 0, binding; i < bindings.length; i++) {
                    binding = bindings[i];
                    if (binding.isCompound) {
                        for (var storage = node.__compoundStorage__ || (node.__compoundStorage__ = {}), parts = binding.parts, literals = Array(parts.length), j = 0; j < parts.length; j++) {
                            literals[j] = parts[j].literal
                        }
                        var name = binding.name;
                        storage[name] = literals;
                        if (binding.literal && "property" == binding.kind) {
                            if (node._configValue) {
                                node._configValue(name, binding.literal)
                            } else {
                                node[name] = binding.literal
                            }
                        }
                    }
                }
            },
            _marshalIdNodes: function() {
                this.$ = {};
                for (var i = 0, l = this._notes.length, a; i < l && (a = this._notes[i]); i++) {
                    if (a.id) {
                        this.$[a.id] = this._findAnnotatedNode(this.root, a)
                    }
                }
            },
            _marshalAnnotatedNodes: function() {
                if (this._notes && this._notes.length) {
                    for (var r = Array(this._notes.length), i = 0; i < this._notes.length; i++) {
                        r[i] = this._findAnnotatedNode(this.root, this._notes[i])
                    }
                    this._nodes = r
                }
            },
            _marshalAnnotatedListeners: function() {
                for (var i = 0, l = this._notes.length, a; i < l && (a = this._notes[i]); i++) {
                    if (a.events && a.events.length) {
                        for (var node = this._findAnnotatedNode(this.root, a), j = 0, e$ = a.events, e; j < e$.length && (e = e$[j]); j++) {
                            this.listen(node, e.name, e.value)
                        }
                    }
                }
            }
        });
        Polymer.Base._addFeature({
            listeners: {},
            _listenListeners: function(listeners) {
                var node, name, eventName;
                for (eventName in listeners) {
                    if (0 > eventName.indexOf(".")) {
                        node = this;
                        name = eventName
                    } else {
                        name = eventName.split(".");
                        node = this.$[name[0]];
                        name = name[1]
                    }
                    this.listen(node, name, listeners[eventName])
                }
            },
            listen: function(node, eventName, methodName) {
                var handler = this._recallEventHandler(this, eventName, node, methodName);
                if (!handler) {
                    handler = this._createEventHandler(node, eventName, methodName)
                }
                if (handler._listening) {
                    return
                }
                this._listen(node, eventName, handler);
                handler._listening = !0
            },
            _boundListenerKey: function(eventName, methodName) {
                return eventName + ":" + methodName
            },
            _recordEventHandler: function(host, eventName, target, methodName, handler) {
                var hbl = host.__boundListeners;
                if (!hbl) {
                    hbl = host.__boundListeners = new WeakMap
                }
                var bl = hbl.get(target);
                if (!bl) {
                    bl = {};
                    if (!Polymer.Settings.isIE || target != window) {
                        hbl.set(target, bl)
                    }
                }
                var key = this._boundListenerKey(eventName, methodName);
                bl[key] = handler
            },
            _recallEventHandler: function(host, eventName, target, methodName) {
                var hbl = host.__boundListeners;
                if (!hbl) {
                    return
                }
                var bl = hbl.get(target);
                if (!bl) {
                    return
                }
                var key = this._boundListenerKey(eventName, methodName);
                return bl[key]
            },
            _createEventHandler: function(node, eventName, methodName) {
                var host = this,
                    handler = function(e) {
                        if (host[methodName]) {
                            host[methodName](e, e.detail)
                        } else {
                            host._warn(host._logf("_createEventHandler", "listener method `" + methodName + "` not defined"))
                        }
                    };
                handler._listening = !1;
                this._recordEventHandler(host, eventName, node, methodName, handler);
                return handler
            },
            unlisten: function(node, eventName, methodName) {
                var handler = this._recallEventHandler(this, eventName, node, methodName);
                if (handler) {
                    this._unlisten(node, eventName, handler);
                    handler._listening = !1
                }
            },
            _listen: function(node, eventName, handler) {
                node.addEventListener(eventName, handler)
            },
            _unlisten: function(node, eventName, handler) {
                node.removeEventListener(eventName, handler)
            }
        });
        (function() {
            "use strict";
            var _Mathabs = Math.abs,
                wrap = Polymer.DomApi.wrap,
                HAS_NATIVE_TA = "string" === typeof document.head.style.touchAction,
                GESTURE_KEY = "__polymerGestures",
                HANDLED_OBJ = "__polymerGesturesHandled",
                TOUCH_ACTION = "__polymerGesturesTouchAction",
                TAP_DISTANCE = 25,
                TRACK_DISTANCE = 5,
                MOUSE_EVENTS = ["mousedown", "mousemove", "mouseup", "click"],
                MOUSE_WHICH_TO_BUTTONS = [0, 1, 4, 2],
                MOUSE_HAS_BUTTONS = function() {
                    try {
                        return 1 === new MouseEvent("test", {
                            buttons: 1
                        }).buttons
                    } catch (e) {
                        return !1
                    }
                }();

            function isMouseEvent(name) {
                return -1 < MOUSE_EVENTS.indexOf(name)
            }
            var SUPPORTS_PASSIVE = !1;
            (function() {
                try {
                    var opts = Object.defineProperty({}, "passive", {
                        get: function() {
                            SUPPORTS_PASSIVE = !0
                        }
                    });
                    window.addEventListener("test", null, opts);
                    window.removeEventListener("test", null, opts)
                } catch (e) {}
            })();

            function PASSIVE_TOUCH(eventName) {
                if (isMouseEvent(eventName) || "touchend" === eventName) {
                    return
                }
                if (HAS_NATIVE_TA && SUPPORTS_PASSIVE && Polymer.Settings.passiveTouchGestures) {
                    return {
                        passive: !0
                    }
                }
            }
            var IS_TOUCH_ONLY = navigator.userAgent.match(/iP(?:[oa]d|hone)|Android/),
                mouseCanceller = function(mouseEvent) {
                    var sc = mouseEvent.sourceCapabilities;
                    if (sc && !sc.firesTouchEvents) {
                        return
                    }
                    mouseEvent[HANDLED_OBJ] = {
                        skip: !0
                    };
                    if ("click" === mouseEvent.type) {
                        var path = Polymer.dom(mouseEvent).path;
                        if (path) {
                            for (var i = 0; i < path.length; i++) {
                                if (path[i] === POINTERSTATE.mouse.target) {
                                    return
                                }
                            }
                        }
                        mouseEvent.preventDefault();
                        mouseEvent.stopPropagation()
                    }
                };

            function setupTeardownMouseCanceller(setup) {
                for (var events = IS_TOUCH_ONLY ? ["click"] : MOUSE_EVENTS, i = 0, en; i < events.length; i++) {
                    en = events[i];
                    if (setup) {
                        document.addEventListener(en, mouseCanceller, !0)
                    } else {
                        document.removeEventListener(en, mouseCanceller, !0)
                    }
                }
            }

            function hasLeftMouseButton(ev) {
                var type = ev.type;
                if (!isMouseEvent(type)) {
                    return !1
                }
                if ("mousemove" === type) {
                    var buttons = ev.buttons === void 0 ? 1 : ev.buttons;
                    if (ev instanceof window.MouseEvent && !MOUSE_HAS_BUTTONS) {
                        buttons = MOUSE_WHICH_TO_BUTTONS[ev.which] || 0
                    }
                    return !!(1 & buttons)
                } else {
                    var button = ev.button === void 0 ? 0 : ev.button;
                    return 0 === button
                }
            }

            function isSyntheticClick(ev) {
                if ("click" === ev.type) {
                    if (0 === ev.detail) {
                        return !0
                    }
                    var t = Gestures.findOriginalTarget(ev),
                        bcr = t.getBoundingClientRect(),
                        x = ev.pageX,
                        y = ev.pageY;
                    return !(x >= bcr.left && x <= bcr.right && y >= bcr.top && y <= bcr.bottom)
                }
                return !1
            }
            var POINTERSTATE = {
                mouse: {
                    target: null,
                    mouseIgnoreJob: null
                },
                touch: {
                    x: 0,
                    y: 0,
                    id: -1,
                    scrollDecided: !1
                }
            };

            function firstTouchAction(ev) {
                for (var path = Polymer.dom(ev).path, ta = "auto", i = 0, n; i < path.length; i++) {
                    n = path[i];
                    if (n[TOUCH_ACTION]) {
                        ta = n[TOUCH_ACTION];
                        break
                    }
                }
                return ta
            }

            function trackDocument(stateObj, movefn, upfn) {
                stateObj.movefn = movefn;
                stateObj.upfn = upfn;
                document.addEventListener("mousemove", movefn);
                document.addEventListener("mouseup", upfn)
            }

            function untrackDocument(stateObj) {
                document.removeEventListener("mousemove", stateObj.movefn);
                document.removeEventListener("mouseup", stateObj.upfn);
                stateObj.movefn = null;
                stateObj.upfn = null
            }
            document.addEventListener("touchend", function(ev) {
                if (!POINTERSTATE.mouse.mouseIgnoreJob) {
                    setupTeardownMouseCanceller(!0)
                }
                POINTERSTATE.mouse.target = Polymer.dom(ev).rootTarget;
                POINTERSTATE.mouse.mouseIgnoreJob = Polymer.Debounce(POINTERSTATE.mouse.mouseIgnoreJob, function() {
                    setupTeardownMouseCanceller();
                    POINTERSTATE.mouse.target = null;
                    POINTERSTATE.mouse.mouseIgnoreJob = null
                }, 2500)
            }, SUPPORTS_PASSIVE ? {
                passive: !0
            } : !1);
            var Gestures = {
                gestures: {},
                recognizers: [],
                deepTargetFind: function(x, y) {
                    var node = document.elementFromPoint(x, y),
                        next = node;
                    while (next && next.shadowRoot) {
                        next = next.shadowRoot.elementFromPoint(x, y);
                        if (next) {
                            node = next
                        }
                    }
                    return node
                },
                findOriginalTarget: function(ev) {
                    if (ev.path) {
                        return ev.path[0]
                    }
                    return ev.target
                },
                handleNative: function(ev) {
                    var handled, type = ev.type,
                        node = wrap(ev.currentTarget),
                        gobj = node[GESTURE_KEY];
                    if (!gobj) {
                        return
                    }
                    var gs = gobj[type];
                    if (!gs) {
                        return
                    }
                    if (!ev[HANDLED_OBJ]) {
                        ev[HANDLED_OBJ] = {};
                        if ("touch" === type.slice(0, 5)) {
                            var t = ev.changedTouches[0];
                            if ("touchstart" === type) {
                                if (1 === ev.touches.length) {
                                    POINTERSTATE.touch.id = t.identifier
                                }
                            }
                            if (POINTERSTATE.touch.id !== t.identifier) {
                                return
                            }
                            if (!HAS_NATIVE_TA) {
                                if ("touchstart" === type || "touchmove" === type) {
                                    Gestures.handleTouchAction(ev)
                                }
                            }
                        }
                    }
                    handled = ev[HANDLED_OBJ];
                    if (handled.skip) {
                        return
                    }
                    for (var recognizers = Gestures.recognizers, i = 0, r; i < recognizers.length; i++) {
                        r = recognizers[i];
                        if (gs[r.name] && !handled[r.name]) {
                            if (r.flow && -1 < r.flow.start.indexOf(ev.type) && r.reset) {
                                r.reset()
                            }
                        }
                    }
                    for (i = 0, r; i < recognizers.length; i++) {
                        r = recognizers[i];
                        if (gs[r.name] && !handled[r.name]) {
                            handled[r.name] = !0;
                            r[type](ev)
                        }
                    }
                },
                handleTouchAction: function(ev) {
                    var t = ev.changedTouches[0],
                        type = ev.type;
                    if ("touchstart" === type) {
                        POINTERSTATE.touch.x = t.clientX;
                        POINTERSTATE.touch.y = t.clientY;
                        POINTERSTATE.touch.scrollDecided = !1
                    } else if ("touchmove" === type) {
                        if (POINTERSTATE.touch.scrollDecided) {
                            return
                        }
                        POINTERSTATE.touch.scrollDecided = !0;
                        var ta = firstTouchAction(ev),
                            prevent = !1,
                            dx = _Mathabs(POINTERSTATE.touch.x - t.clientX),
                            dy = _Mathabs(POINTERSTATE.touch.y - t.clientY);
                        if (!ev.cancelable) {} else if ("none" === ta) {
                            prevent = !0
                        } else if ("pan-x" === ta) {
                            prevent = dy > dx
                        } else if ("pan-y" === ta) {
                            prevent = dx > dy
                        }
                        if (prevent) {
                            ev.preventDefault()
                        } else {
                            Gestures.prevent("track")
                        }
                    }
                },
                add: function(node, evType, handler) {
                    node = wrap(node);
                    var recognizer = this.gestures[evType],
                        deps = recognizer.deps,
                        name = recognizer.name,
                        gobj = node[GESTURE_KEY];
                    if (!gobj) {
                        node[GESTURE_KEY] = gobj = {}
                    }
                    for (var i = 0, dep, gd; i < deps.length; i++) {
                        dep = deps[i];
                        if (IS_TOUCH_ONLY && isMouseEvent(dep) && "click" !== dep) {
                            continue
                        }
                        gd = gobj[dep];
                        if (!gd) {
                            gobj[dep] = gd = {
                                _count: 0
                            }
                        }
                        if (0 === gd._count) {
                            node.addEventListener(dep, this.handleNative, PASSIVE_TOUCH(dep))
                        }
                        gd[name] = (gd[name] || 0) + 1;
                        gd._count = (gd._count || 0) + 1
                    }
                    node.addEventListener(evType, handler);
                    if (recognizer.touchAction) {
                        this.setTouchAction(node, recognizer.touchAction)
                    }
                },
                remove: function(node, evType, handler) {
                    node = wrap(node);
                    var recognizer = this.gestures[evType],
                        deps = recognizer.deps,
                        name = recognizer.name,
                        gobj = node[GESTURE_KEY];
                    if (gobj) {
                        for (var i = 0, dep, gd; i < deps.length; i++) {
                            dep = deps[i];
                            gd = gobj[dep];
                            if (gd && gd[name]) {
                                gd[name] = (gd[name] || 1) - 1;
                                gd._count = (gd._count || 1) - 1;
                                if (0 === gd._count) {
                                    node.removeEventListener(dep, this.handleNative, PASSIVE_TOUCH(dep))
                                }
                            }
                        }
                    }
                    node.removeEventListener(evType, handler)
                },
                register: function(recog) {
                    this.recognizers.push(recog);
                    for (var i = 0; i < recog.emits.length; i++) {
                        this.gestures[recog.emits[i]] = recog
                    }
                },
                findRecognizerByEvent: function(evName) {
                    for (var i = 0, r; i < this.recognizers.length; i++) {
                        r = this.recognizers[i];
                        for (var j = 0, n; j < r.emits.length; j++) {
                            n = r.emits[j];
                            if (n === evName) {
                                return r
                            }
                        }
                    }
                    return null
                },
                setTouchAction: function(node, value) {
                    if (HAS_NATIVE_TA) {
                        node.style.touchAction = value
                    }
                    node[TOUCH_ACTION] = value
                },
                fire: function(target, type, detail) {
                    var ev = Polymer.Base.fire(type, detail, {
                        node: target,
                        bubbles: !0,
                        cancelable: !0
                    });
                    if (ev.defaultPrevented) {
                        var preventer = detail.preventer || detail.sourceEvent;
                        if (preventer && preventer.preventDefault) {
                            preventer.preventDefault()
                        }
                    }
                },
                prevent: function(evName) {
                    var recognizer = this.findRecognizerByEvent(evName);
                    if (recognizer.info) {
                        recognizer.info.prevent = !0
                    }
                },
                resetMouseCanceller: function() {
                    if (POINTERSTATE.mouse.mouseIgnoreJob) {
                        POINTERSTATE.mouse.mouseIgnoreJob.complete()
                    }
                }
            };
            Gestures.register({
                name: "downup",
                deps: ["mousedown", "touchstart", "touchend"],
                flow: {
                    start: ["mousedown", "touchstart"],
                    end: ["mouseup", "touchend"]
                },
                emits: ["down", "up"],
                info: {
                    movefn: null,
                    upfn: null
                },
                reset: function() {
                    untrackDocument(this.info)
                },
                mousedown: function(e) {
                    if (!hasLeftMouseButton(e)) {
                        return
                    }
                    var t = Gestures.findOriginalTarget(e),
                        self = this;
                    trackDocument(this.info, function(e) {
                        if (!hasLeftMouseButton(e)) {
                            self.fire("up", t, e);
                            untrackDocument(self.info)
                        }
                    }, function(e) {
                        if (hasLeftMouseButton(e)) {
                            self.fire("up", t, e)
                        }
                        untrackDocument(self.info)
                    });
                    this.fire("down", t, e)
                },
                touchstart: function(e) {
                    this.fire("down", Gestures.findOriginalTarget(e), e.changedTouches[0], e)
                },
                touchend: function(e) {
                    this.fire("up", Gestures.findOriginalTarget(e), e.changedTouches[0], e)
                },
                fire: function(type, target, event, preventer) {
                    Gestures.fire(target, type, {
                        x: event.clientX,
                        y: event.clientY,
                        sourceEvent: event,
                        preventer: preventer,
                        prevent: function(e) {
                            return Gestures.prevent(e)
                        }
                    })
                }
            });
            Gestures.register({
                name: "track",
                touchAction: "none",
                deps: ["mousedown", "touchstart", "touchmove", "touchend"],
                flow: {
                    start: ["mousedown", "touchstart"],
                    end: ["mouseup", "touchend"]
                },
                emits: ["track"],
                info: {
                    x: 0,
                    y: 0,
                    state: "start",
                    started: !1,
                    moves: [],
                    addMove: function(move) {
                        if (this.moves.length > 2) {
                            this.moves.shift()
                        }
                        this.moves.push(move)
                    },
                    movefn: null,
                    upfn: null,
                    prevent: !1
                },
                reset: function() {
                    this.info.state = "start";
                    this.info.started = !1;
                    this.info.moves = [];
                    this.info.x = 0;
                    this.info.y = 0;
                    this.info.prevent = !1;
                    untrackDocument(this.info)
                },
                hasMovedEnough: function(x, y) {
                    if (this.info.prevent) {
                        return !1
                    }
                    if (this.info.started) {
                        return !0
                    }
                    var dx = _Mathabs(this.info.x - x),
                        dy = _Mathabs(this.info.y - y);
                    return dx >= TRACK_DISTANCE || dy >= TRACK_DISTANCE
                },
                mousedown: function(e) {
                    if (!hasLeftMouseButton(e)) {
                        return
                    }
                    var t = Gestures.findOriginalTarget(e),
                        self = this,
                        movefn = function(e) {
                            var x = e.clientX,
                                y = e.clientY;
                            if (self.hasMovedEnough(x, y)) {
                                self.info.state = self.info.started ? "mouseup" === e.type ? "end" : "track" : "start";
                                if ("start" === self.info.state) {
                                    Gestures.prevent("tap")
                                }
                                self.info.addMove({
                                    x: x,
                                    y: y
                                });
                                if (!hasLeftMouseButton(e)) {
                                    self.info.state = "end";
                                    untrackDocument(self.info)
                                }
                                self.fire(t, e);
                                self.info.started = !0
                            }
                        };
                    trackDocument(this.info, movefn, function(e) {
                        if (self.info.started) {
                            movefn(e)
                        }
                        untrackDocument(self.info)
                    });
                    this.info.x = e.clientX;
                    this.info.y = e.clientY
                },
                touchstart: function(e) {
                    var ct = e.changedTouches[0];
                    this.info.x = ct.clientX;
                    this.info.y = ct.clientY
                },
                touchmove: function(e) {
                    var t = Gestures.findOriginalTarget(e),
                        ct = e.changedTouches[0],
                        x = ct.clientX,
                        y = ct.clientY;
                    if (this.hasMovedEnough(x, y)) {
                        if ("start" === this.info.state) {
                            Gestures.prevent("tap")
                        }
                        this.info.addMove({
                            x: x,
                            y: y
                        });
                        this.fire(t, ct);
                        this.info.state = "track";
                        this.info.started = !0
                    }
                },
                touchend: function(e) {
                    var t = Gestures.findOriginalTarget(e),
                        ct = e.changedTouches[0];
                    if (this.info.started) {
                        this.info.state = "end";
                        this.info.addMove({
                            x: ct.clientX,
                            y: ct.clientY
                        });
                        this.fire(t, ct, e)
                    }
                },
                fire: function(target, touch, preventer) {
                    var secondlast = this.info.moves[this.info.moves.length - 2],
                        lastmove = this.info.moves[this.info.moves.length - 1],
                        dx = lastmove.x - this.info.x,
                        dy = lastmove.y - this.info.y,
                        ddx, ddy = 0;
                    if (secondlast) {
                        ddx = lastmove.x - secondlast.x;
                        ddy = lastmove.y - secondlast.y
                    }
                    return Gestures.fire(target, "track", {
                        state: this.info.state,
                        x: touch.clientX,
                        y: touch.clientY,
                        dx: dx,
                        dy: dy,
                        ddx: ddx,
                        ddy: ddy,
                        sourceEvent: touch,
                        preventer: preventer,
                        hover: function() {
                            return Gestures.deepTargetFind(touch.clientX, touch.clientY)
                        }
                    })
                }
            });
            Gestures.register({
                name: "tap",
                deps: ["mousedown", "click", "touchstart", "touchend"],
                flow: {
                    start: ["mousedown", "touchstart"],
                    end: ["click", "touchend"]
                },
                emits: ["tap"],
                info: {
                    x: NaN,
                    y: NaN,
                    prevent: !1
                },
                reset: function() {
                    this.info.x = NaN;
                    this.info.y = NaN;
                    this.info.prevent = !1
                },
                save: function(e) {
                    this.info.x = e.clientX;
                    this.info.y = e.clientY
                },
                mousedown: function(e) {
                    if (hasLeftMouseButton(e)) {
                        this.save(e)
                    }
                },
                click: function(e) {
                    if (hasLeftMouseButton(e)) {
                        this.forward(e)
                    }
                },
                touchstart: function(e) {
                    this.save(e.changedTouches[0], e)
                },
                touchend: function(e) {
                    this.forward(e.changedTouches[0], e)
                },
                forward: function(e, preventer) {
                    var dx = _Mathabs(e.clientX - this.info.x),
                        dy = _Mathabs(e.clientY - this.info.y),
                        t = Gestures.findOriginalTarget(e);
                    if (isNaN(dx) || isNaN(dy) || dx <= TAP_DISTANCE && dy <= TAP_DISTANCE || isSyntheticClick(e)) {
                        if (!this.info.prevent) {
                            Gestures.fire(t, "tap", {
                                x: e.clientX,
                                y: e.clientY,
                                sourceEvent: e,
                                preventer: preventer
                            })
                        }
                    }
                }
            });
            var DIRECTION_MAP = {
                x: "pan-x",
                y: "pan-y",
                none: "none",
                all: "auto"
            };
            Polymer.Base._addFeature({
                _setupGestures: function() {
                    this.__polymerGestures = null
                },
                _listen: function(node, eventName, handler) {
                    if (Gestures.gestures[eventName]) {
                        Gestures.add(node, eventName, handler)
                    } else {
                        node.addEventListener(eventName, handler)
                    }
                },
                _unlisten: function(node, eventName, handler) {
                    if (Gestures.gestures[eventName]) {
                        Gestures.remove(node, eventName, handler)
                    } else {
                        node.removeEventListener(eventName, handler)
                    }
                },
                setScrollDirection: function(direction, node) {
                    node = node || this;
                    Gestures.setTouchAction(node, DIRECTION_MAP[direction] || "auto")
                }
            });
            Polymer.Gestures = Gestures
        })();
        (function() {
            "use strict";
            Polymer.Base._addFeature({
                $$: function(slctr) {
                    return Polymer.dom(this.root).querySelector(slctr)
                },
                toggleClass: function(name, bool, node) {
                    node = node || this;
                    if (1 == arguments.length) {
                        bool = !node.classList.contains(name)
                    }
                    if (bool) {
                        Polymer.dom(node).classList.add(name)
                    } else {
                        Polymer.dom(node).classList.remove(name)
                    }
                },
                toggleAttribute: function(name, bool, node) {
                    node = node || this;
                    if (1 == arguments.length) {
                        bool = !node.hasAttribute(name)
                    }
                    if (bool) {
                        Polymer.dom(node).setAttribute(name, "")
                    } else {
                        Polymer.dom(node).removeAttribute(name)
                    }
                },
                classFollows: function(name, toElement, fromElement) {
                    if (fromElement) {
                        Polymer.dom(fromElement).classList.remove(name)
                    }
                    if (toElement) {
                        Polymer.dom(toElement).classList.add(name)
                    }
                },
                attributeFollows: function(name, toElement, fromElement) {
                    if (fromElement) {
                        Polymer.dom(fromElement).removeAttribute(name)
                    }
                    if (toElement) {
                        Polymer.dom(toElement).setAttribute(name, "")
                    }
                },
                getEffectiveChildNodes: function() {
                    return Polymer.dom(this).getEffectiveChildNodes()
                },
                getEffectiveChildren: function() {
                    var list = Polymer.dom(this).getEffectiveChildNodes();
                    return list.filter(function(n) {
                        return n.nodeType === Node.ELEMENT_NODE
                    })
                },
                getEffectiveTextContent: function() {
                    for (var cn = this.getEffectiveChildNodes(), tc = [], i = 0, c; c = cn[i]; i++) {
                        if (c.nodeType !== Node.COMMENT_NODE) {
                            tc.push(Polymer.dom(c).textContent)
                        }
                    }
                    return tc.join("")
                },
                queryEffectiveChildren: function(slctr) {
                    var e$ = Polymer.dom(this).queryDistributedElements(slctr);
                    return e$ && e$[0]
                },
                queryAllEffectiveChildren: function(slctr) {
                    return Polymer.dom(this).queryDistributedElements(slctr)
                },
                getContentChildNodes: function(slctr) {
                    var content = Polymer.dom(this.root).querySelector(slctr || "content");
                    return content ? Polymer.dom(content).getDistributedNodes() : []
                },
                getContentChildren: function(slctr) {
                    return this.getContentChildNodes(slctr).filter(function(n) {
                        return n.nodeType === Node.ELEMENT_NODE
                    })
                },
                fire: function(type, detail, options) {
                    options = options || Polymer.nob;
                    var node = options.node || this;
                    detail = null === detail || detail === void 0 ? {} : detail;
                    var bubbles = options.bubbles === void 0 ? !0 : options.bubbles,
                        cancelable = !!options.cancelable,
                        useCache = options._useCache,
                        event = this._getEvent(type, bubbles, cancelable, useCache);
                    event.detail = detail;
                    if (useCache) {
                        this.__eventCache[type] = null
                    }
                    node.dispatchEvent(event);
                    if (useCache) {
                        this.__eventCache[type] = event
                    }
                    return event
                },
                __eventCache: {},
                _getEvent: function(type, bubbles, cancelable, useCache) {
                    var event = useCache && this.__eventCache[type];
                    if (!event || event.bubbles != bubbles || event.cancelable != cancelable) {
                        event = new Event(type, {
                            bubbles: !!bubbles,
                            cancelable: cancelable
                        })
                    }
                    return event
                },
                async: function(callback, waitTime) {
                    var self = this;
                    return Polymer.Async.run(function() {
                        callback.call(self)
                    }, waitTime)
                },
                cancelAsync: function(handle) {
                    Polymer.Async.cancel(handle)
                },
                arrayDelete: function(path, item) {
                    var index;
                    if (Array.isArray(path)) {
                        index = path.indexOf(item);
                        if (0 <= index) {
                            return path.splice(index, 1)
                        }
                    } else {
                        var arr = this._get(path);
                        index = arr.indexOf(item);
                        if (0 <= index) {
                            return this.splice(path, index, 1)
                        }
                    }
                },
                transform: function(transform, node) {
                    node = node || this;
                    node.style.webkitTransform = transform;
                    node.style.transform = transform
                },
                translate3d: function(x, y, z, node) {
                    node = node || this;
                    this.transform("translate3d(" + x + "," + y + "," + z + ")", node)
                },
                importHref: function(href, onload, onerror, optAsync) {
                    var link = document.createElement("link");
                    link.rel = "import";
                    link.href = href;
                    var list = Polymer.Base.importHref.imported = Polymer.Base.importHref.imported || {},
                        cached = list[link.href],
                        imprt = cached || link,
                        self = this,
                        loadListener = function(e) {
                            e.target.__firedLoad = !0;
                            e.target.removeEventListener("load", loadListener);
                            e.target.removeEventListener("error", errorListener);
                            return onload.call(self, e)
                        },
                        errorListener = function(e) {
                            e.target.__firedError = !0;
                            e.target.removeEventListener("load", loadListener);
                            e.target.removeEventListener("error", errorListener);
                            return onerror.call(self, e)
                        };
                    if (onload) {
                        imprt.addEventListener("load", loadListener)
                    }
                    if (onerror) {
                        imprt.addEventListener("error", errorListener)
                    }
                    if (cached) {
                        if (cached.__firedLoad) {
                            cached.dispatchEvent(new Event("load"))
                        }
                        if (cached.__firedError) {
                            cached.dispatchEvent(new Event("error"))
                        }
                    } else {
                        list[link.href] = link;
                        optAsync = !!optAsync;
                        if (optAsync) {
                            link.setAttribute("async", "")
                        }
                        document.head.appendChild(link)
                    }
                    return imprt
                },
                create: function(tag, props) {
                    var elt = document.createElement(tag);
                    if (props) {
                        for (var n in props) {
                            elt[n] = props[n]
                        }
                    }
                    return elt
                },
                isLightDescendant: function(node) {
                    return this !== node && this.contains(node) && Polymer.dom(this).getOwnerRoot() === Polymer.dom(node).getOwnerRoot()
                },
                isLocalDescendant: function(node) {
                    return this.root === Polymer.dom(node).getOwnerRoot()
                }
            });
            if (!Polymer.Settings.useNativeCustomElements) {
                var importHref = Polymer.Base.importHref;
                Polymer.Base.importHref = function(href, onload, onerror, optAsync) {
                    CustomElements.ready = !1;
                    return importHref.call(this, href, function(e) {
                        CustomElements.upgradeDocumentTree(document);
                        CustomElements.ready = !0;
                        if (onload) {
                            return onload.call(this, e)
                        }
                    }, onerror, optAsync)
                }
            }
        })();
        Polymer.Bind = {
            prepareModel: function(model) {
                Polymer.Base.mixin(model, this._modelApi)
            },
            _modelApi: {
                _notifyChange: function(source, event, value) {
                    value = value === void 0 ? this[source] : value;
                    event = event || Polymer.CaseMap.camelToDashCase(source) + "-changed";
                    this.fire(event, {
                        value: value
                    }, {
                        bubbles: !1,
                        cancelable: !1,
                        _useCache: Polymer.Settings.eventDataCache || !Polymer.Settings.isIE
                    })
                },
                _propertySetter: function(property, value, effects, fromAbove) {
                    var old = this.__data__[property];
                    if (old !== value && (old === old || value === value)) {
                        this.__data__[property] = value;
                        if ("object" == typeof value) {
                            this._clearPath(property)
                        }
                        if (this._propertyChanged) {
                            this._propertyChanged(property, value, old)
                        }
                        if (effects) {
                            this._effectEffects(property, value, effects, old, fromAbove)
                        }
                    }
                    return old
                },
                __setProperty: function(property, value, quiet, node) {
                    node = node || this;
                    var effects = node._propertyEffects && node._propertyEffects[property];
                    if (effects) {
                        node._propertySetter(property, value, effects, quiet)
                    } else if (node[property] !== value) {
                        node[property] = value
                    }
                },
                _effectEffects: function(property, value, effects, old, fromAbove) {
                    for (var i = 0, l = effects.length, fx; i < l && (fx = effects[i]); i++) {
                        fx.fn.call(this, property, this[property], fx.effect, old, fromAbove)
                    }
                },
                _clearPath: function(path) {
                    for (var prop in this.__data__) {
                        if (Polymer.Path.isDescendant(path, prop)) {
                            this.__data__[prop] = void 0
                        }
                    }
                }
            },
            ensurePropertyEffects: function(model, property) {
                if (!model._propertyEffects) {
                    model._propertyEffects = {}
                }
                var fx = model._propertyEffects[property];
                if (!fx) {
                    fx = model._propertyEffects[property] = []
                }
                return fx
            },
            addPropertyEffect: function(model, property, kind, effect) {
                var fx = this.ensurePropertyEffects(model, property),
                    propEffect = {
                        kind: kind,
                        effect: effect,
                        fn: Polymer.Bind["_" + kind + "Effect"]
                    };
                fx.push(propEffect);
                return propEffect
            },
            createBindings: function(model) {
                var fx$ = model._propertyEffects;
                if (fx$) {
                    for (var n in fx$) {
                        var fx = fx$[n];
                        fx.sort(this._sortPropertyEffects);
                        this._createAccessors(model, n, fx)
                    }
                }
            },
            _sortPropertyEffects: function() {
                var EFFECT_ORDER = {
                    compute: 0,
                    annotation: 1,
                    annotatedComputation: 2,
                    reflect: 3,
                    notify: 4,
                    observer: 5,
                    complexObserver: 6,
                    function: 7
                };
                return function(a, b) {
                    return EFFECT_ORDER[a.kind] - EFFECT_ORDER[b.kind]
                }
            }(),
            _createAccessors: function(model, property, effects) {
                var defun = {
                        get: function() {
                            return this.__data__[property]
                        }
                    },
                    setter = function(value) {
                        this._propertySetter(property, value, effects)
                    },
                    info = model.getPropertyInfo && model.getPropertyInfo(property);
                if (info && info.readOnly) {
                    if (!info.computed) {
                        model["_set" + this.upper(property)] = setter
                    }
                } else {
                    defun.set = setter
                }
                Object.defineProperty(model, property, defun)
            },
            upper: function(name) {
                return name[0].toUpperCase() + name.substring(1)
            },
            _addAnnotatedListener: function(model, index, property, path, event, negated) {
                if (!model._bindListeners) {
                    model._bindListeners = []
                }
                var fn = this._notedListenerFactory(property, path, Polymer.Path.isDeep(path), negated),
                    eventName = event || Polymer.CaseMap.camelToDashCase(property) + "-changed";
                model._bindListeners.push({
                    index: index,
                    property: property,
                    path: path,
                    changedFn: fn,
                    event: eventName
                })
            },
            _isEventBogus: function(e, target) {
                return e.path && e.path[0] !== target
            },
            _notedListenerFactory: function(property, path, isStructured, negated) {
                return function(target, value, targetPath) {
                    if (targetPath) {
                        var newPath = Polymer.Path.translate(property, path, targetPath);
                        this._notifyPath(newPath, value)
                    } else {
                        value = target[property];
                        if (negated) {
                            value = !value
                        }
                        if (!isStructured) {
                            this[path] = value
                        } else {
                            if (this.__data__[path] != value) {
                                this.set(path, value)
                            }
                        }
                    }
                }
            },
            prepareInstance: function(inst) {
                inst.__data__ = Object.create(null)
            },
            setupBindListeners: function(inst) {
                for (var b$ = inst._bindListeners, i = 0, l = b$.length, info, node; i < l && (info = b$[i]); i++) {
                    node = inst._nodes[info.index];
                    this._addNotifyListener(node, inst, info.event, info.changedFn)
                }
            },
            _addNotifyListener: function(element, context, event, changedFn) {
                element.addEventListener(event, function(e) {
                    return context._notifyListener(changedFn, e)
                })
            }
        };
        Polymer.Base.mixin(Polymer.Bind, {
            _shouldAddListener: function(effect) {
                return effect.name && "attribute" != effect.kind && "text" != effect.kind && !effect.isCompound && "{" === effect.parts[0].mode
            },
            _annotationEffect: function(source, value, effect) {
                if (source != effect.value) {
                    value = this._get(effect.value);
                    this.__data__[effect.value] = value
                }
                this._applyEffectValue(effect, value)
            },
            _reflectEffect: function(source, value, effect) {
                this.reflectPropertyToAttribute(source, effect.attribute, value)
            },
            _notifyEffect: function(source, value, effect, old, fromAbove) {
                if (!fromAbove) {
                    this._notifyChange(source, effect.event, value)
                }
            },
            _functionEffect: function(source, value, fn, old, fromAbove) {
                fn.call(this, source, value, old, fromAbove)
            },
            _observerEffect: function(source, value, effect, old) {
                var fn = this[effect.method];
                if (fn) {
                    fn.call(this, value, old)
                } else {
                    this._warn(this._logf("_observerEffect", "observer method `" + effect.method + "` not defined"))
                }
            },
            _complexObserverEffect: function(source, value, effect) {
                var fn = this[effect.method];
                if (fn) {
                    var args = Polymer.Bind._marshalArgs(this.__data__, effect, source, value);
                    if (args) {
                        fn.apply(this, args)
                    }
                } else if (!effect.dynamicFn) {
                    this._warn(this._logf("_complexObserverEffect", "observer method `" + effect.method + "` not defined"))
                }
            },
            _computeEffect: function(source, value, effect) {
                var fn = this[effect.method];
                if (fn) {
                    var args = Polymer.Bind._marshalArgs(this.__data__, effect, source, value);
                    if (args) {
                        var computedvalue = fn.apply(this, args);
                        this.__setProperty(effect.name, computedvalue)
                    }
                } else if (!effect.dynamicFn) {
                    this._warn(this._logf("_computeEffect", "compute method `" + effect.method + "` not defined"))
                }
            },
            _annotatedComputationEffect: function(source, value, effect) {
                var computedHost = this._rootDataHost || this,
                    fn = computedHost[effect.method];
                if (fn) {
                    var args = Polymer.Bind._marshalArgs(this.__data__, effect, source, value);
                    if (args) {
                        var computedvalue = fn.apply(computedHost, args);
                        this._applyEffectValue(effect, computedvalue)
                    }
                } else if (!effect.dynamicFn) {
                    computedHost._warn(computedHost._logf("_annotatedComputationEffect", "compute method `" + effect.method + "` not defined"))
                }
            },
            _marshalArgs: function(model, effect, path, value) {
                for (var values = [], args = effect.args, bailoutEarly = 1 < args.length || effect.dynamicFn, i = 0, l = args.length; i < l; i++) {
                    var arg = args[i],
                        name = arg.name,
                        v;
                    if (arg.literal) {
                        v = arg.value
                    } else if (path === name) {
                        v = value
                    } else {
                        v = model[name];
                        if (v === void 0 && arg.structured) {
                            v = Polymer.Base._get(name, model)
                        }
                    }
                    if (bailoutEarly && v === void 0) {
                        return
                    }
                    if (arg.wildcard) {
                        var matches = Polymer.Path.isAncestor(path, name);
                        values[i] = {
                            path: matches ? path : name,
                            value: matches ? value : v,
                            base: v
                        }
                    } else {
                        values[i] = v
                    }
                }
                return values
            }
        });
        Polymer.Base._addFeature({
            _addPropertyEffect: function(property, kind, effect) {
                var prop = Polymer.Bind.addPropertyEffect(this, property, kind, effect);
                prop.pathFn = this["_" + prop.kind + "PathEffect"]
            },
            _prepEffects: function() {
                Polymer.Bind.prepareModel(this);
                this._addAnnotationEffects(this._notes)
            },
            _prepBindings: function() {
                Polymer.Bind.createBindings(this)
            },
            _addPropertyEffects: function(properties) {
                if (properties) {
                    for (var p in properties) {
                        var prop = properties[p];
                        if (prop.observer) {
                            this._addObserverEffect(p, prop.observer)
                        }
                        if (prop.computed) {
                            prop.readOnly = !0;
                            this._addComputedEffect(p, prop.computed)
                        }
                        if (prop.notify) {
                            this._addPropertyEffect(p, "notify", {
                                event: Polymer.CaseMap.camelToDashCase(p) + "-changed"
                            })
                        }
                        if (prop.reflectToAttribute) {
                            var attr = Polymer.CaseMap.camelToDashCase(p);
                            if ("-" === attr[0]) {
                                this._warn(this._logf("_addPropertyEffects", "Property " + p + " cannot be reflected to attribute " + attr + " because \"-\" is not a valid starting attribute name. Use a lowercase first letter for the property instead."))
                            } else {
                                this._addPropertyEffect(p, "reflect", {
                                    attribute: attr
                                })
                            }
                        }
                        if (prop.readOnly) {
                            Polymer.Bind.ensurePropertyEffects(this, p)
                        }
                    }
                }
            },
            _addComputedEffect: function(name, expression) {
                for (var sig = this._parseMethod(expression), dynamicFn = sig.dynamicFn, i = 0, arg; i < sig.args.length && (arg = sig.args[i]); i++) {
                    this._addPropertyEffect(arg.model, "compute", {
                        method: sig.method,
                        args: sig.args,
                        trigger: arg,
                        name: name,
                        dynamicFn: dynamicFn
                    })
                }
                if (dynamicFn) {
                    this._addPropertyEffect(sig.method, "compute", {
                        method: sig.method,
                        args: sig.args,
                        trigger: null,
                        name: name,
                        dynamicFn: dynamicFn
                    })
                }
            },
            _addObserverEffect: function(property, observer) {
                this._addPropertyEffect(property, "observer", {
                    method: observer,
                    property: property
                })
            },
            _addComplexObserverEffects: function(observers) {
                if (observers) {
                    for (var i = 0, o; i < observers.length && (o = observers[i]); i++) {
                        this._addComplexObserverEffect(o)
                    }
                }
            },
            _addComplexObserverEffect: function(observer) {
                var sig = this._parseMethod(observer);
                if (!sig) {
                    throw new Error("Malformed observer expression '" + observer + "'")
                }
                for (var dynamicFn = sig.dynamicFn, i = 0, arg; i < sig.args.length && (arg = sig.args[i]); i++) {
                    this._addPropertyEffect(arg.model, "complexObserver", {
                        method: sig.method,
                        args: sig.args,
                        trigger: arg,
                        dynamicFn: dynamicFn
                    })
                }
                if (dynamicFn) {
                    this._addPropertyEffect(sig.method, "complexObserver", {
                        method: sig.method,
                        args: sig.args,
                        trigger: null,
                        dynamicFn: dynamicFn
                    })
                }
            },
            _addAnnotationEffects: function(notes) {
                for (var i = 0, note, b$; i < notes.length && (note = notes[i]); i++) {
                    b$ = note.bindings;
                    for (var j = 0, binding; j < b$.length && (binding = b$[j]); j++) {
                        this._addAnnotationEffect(binding, i)
                    }
                }
            },
            _addAnnotationEffect: function(note, index) {
                if (Polymer.Bind._shouldAddListener(note)) {
                    Polymer.Bind._addAnnotatedListener(this, index, note.name, note.parts[0].value, note.parts[0].event, note.parts[0].negate)
                }
                for (var i = 0, part; i < note.parts.length; i++) {
                    part = note.parts[i];
                    if (part.signature) {
                        this._addAnnotatedComputationEffect(note, part, index)
                    } else if (!part.literal) {
                        if ("attribute" === note.kind && "-" === note.name[0]) {
                            this._warn(this._logf("_addAnnotationEffect", "Cannot set attribute " + note.name + " because \"-\" is not a valid attribute starting character"))
                        } else {
                            this._addPropertyEffect(part.model, "annotation", {
                                kind: note.kind,
                                index: index,
                                name: note.name,
                                propertyName: note.propertyName,
                                value: part.value,
                                isCompound: note.isCompound,
                                compoundIndex: part.compoundIndex,
                                event: part.event,
                                customEvent: part.customEvent,
                                negate: part.negate
                            })
                        }
                    }
                }
            },
            _addAnnotatedComputationEffect: function(note, part, index) {
                var sig = part.signature;
                if (sig.static) {
                    this.__addAnnotatedComputationEffect("__static__", index, note, part, null)
                } else {
                    for (var i = 0, arg; i < sig.args.length && (arg = sig.args[i]); i++) {
                        if (!arg.literal) {
                            this.__addAnnotatedComputationEffect(arg.model, index, note, part, arg)
                        }
                    }
                    if (sig.dynamicFn) {
                        this.__addAnnotatedComputationEffect(sig.method, index, note, part, null)
                    }
                }
            },
            __addAnnotatedComputationEffect: function(property, index, note, part, trigger) {
                this._addPropertyEffect(property, "annotatedComputation", {
                    index: index,
                    isCompound: note.isCompound,
                    compoundIndex: part.compoundIndex,
                    kind: note.kind,
                    name: note.name,
                    negate: part.negate,
                    method: part.signature.method,
                    args: part.signature.args,
                    trigger: trigger,
                    dynamicFn: part.signature.dynamicFn
                })
            },
            _parseMethod: function(expression) {
                var m = expression.match(/([^\s]+?)\(([\s\S]*)\)/);
                if (m) {
                    var sig = {
                        method: m[1],
                        static: !0
                    };
                    if (this.getPropertyInfo(sig.method) !== Polymer.nob) {
                        sig.static = !1;
                        sig.dynamicFn = !0
                    }
                    if (m[2].trim()) {
                        var args = m[2].replace(/\\,/g, "&comma;").split(",");
                        return this._parseArgs(args, sig)
                    } else {
                        sig.args = Polymer.nar;
                        return sig
                    }
                }
            },
            _parseArgs: function(argList, sig) {
                sig.args = argList.map(function(rawArg) {
                    var arg = this._parseArg(rawArg);
                    if (!arg.literal) {
                        sig.static = !1
                    }
                    return arg
                }, this);
                return sig
            },
            _parseArg: function(rawArg) {
                var arg = rawArg.trim().replace(/&comma;/g, ",").replace(/\\(.)/g, "$1"),
                    a = {
                        name: arg
                    },
                    fc = arg[0];
                if ("-" === fc) {
                    fc = arg[1]
                }
                if ("0" <= fc && "9" >= fc) {
                    fc = "#"
                }
                switch (fc) {
                    case "'":
                    case "\"":
                        a.value = arg.slice(1, -1);
                        a.literal = !0;
                        break;
                    case "#":
                        a.value = +arg;
                        a.literal = !0;
                        break;
                }
                if (!a.literal) {
                    a.model = Polymer.Path.root(arg);
                    a.structured = Polymer.Path.isDeep(arg);
                    if (a.structured) {
                        a.wildcard = ".*" == arg.slice(-2);
                        if (a.wildcard) {
                            a.name = arg.slice(0, -2)
                        }
                    }
                }
                return a
            },
            _marshalInstanceEffects: function() {
                Polymer.Bind.prepareInstance(this);
                if (this._bindListeners) {
                    Polymer.Bind.setupBindListeners(this)
                }
            },
            _applyEffectValue: function(info, value) {
                var node = this._nodes[info.index],
                    property = info.name;
                value = this._computeFinalAnnotationValue(node, property, value, info);
                if ("attribute" == info.kind) {
                    this.serializeValueToAttribute(value, property, node)
                } else {
                    var pinfo = node._propertyInfo && node._propertyInfo[property];
                    if (pinfo && pinfo.readOnly) {
                        return
                    }
                    this.__setProperty(property, value, Polymer.Settings.suppressBindingNotifications, node)
                }
            },
            _computeFinalAnnotationValue: function(node, property, value, info) {
                if (info.negate) {
                    value = !value
                }
                if (info.isCompound) {
                    var storage = node.__compoundStorage__[property];
                    storage[info.compoundIndex] = value;
                    value = storage.join("")
                }
                if ("attribute" !== info.kind) {
                    if ("className" === property) {
                        value = this._scopeElementClass(node, value)
                    }
                    if ("textContent" === property || "input" == node.localName && "value" == property) {
                        value = value == void 0 ? "" : value
                    }
                }
                return value
            },
            _executeStaticEffects: function() {
                if (this._propertyEffects && this._propertyEffects.__static__) {
                    this._effectEffects("__static__", null, this._propertyEffects.__static__)
                }
            }
        });
        (function() {
            var usePolyfillProto = Polymer.Settings.usePolyfillProto,
                avoidInstanceProperties = !!Object.getOwnPropertyDescriptor(document.documentElement, "properties");
            Polymer.Base._addFeature({
                _setupConfigure: function(initialConfig) {
                    this._config = {};
                    this._handlers = [];
                    this._aboveConfig = null;
                    if (initialConfig) {
                        for (var i in initialConfig) {
                            if (initialConfig[i] !== void 0) {
                                this._config[i] = initialConfig[i]
                            }
                        }
                    }
                },
                _marshalAttributes: function() {
                    this._takeAttributesToModel(this._config)
                },
                _attributeChangedImpl: function(name) {
                    var model = this._clientsReadied ? this : this._config;
                    this._setAttributeToProperty(model, name)
                },
                _configValue: function(name, value) {
                    var info = this._propertyInfo[name];
                    if (!info || !info.readOnly) {
                        this._config[name] = value
                    }
                },
                _beforeClientsReady: function() {
                    this._configure()
                },
                _configure: function() {
                    this._configureAnnotationReferences();
                    this._configureInstanceProperties();
                    this._aboveConfig = this.mixin({}, this._config);
                    for (var config = {}, i = 0; i < this.behaviors.length; i++) {
                        this._configureProperties(this.behaviors[i].properties, config)
                    }
                    this._configureProperties(avoidInstanceProperties ? this.__proto__.properties : this.properties, config);
                    this.mixin(config, this._aboveConfig);
                    this._config = config;
                    if (this._clients && this._clients.length) {
                        this._distributeConfig(this._config)
                    }
                },
                _configureInstanceProperties: function() {
                    for (var i in this._propertyEffects) {
                        if (!usePolyfillProto && this.hasOwnProperty(i)) {
                            this._configValue(i, this[i]);
                            delete this[i]
                        }
                    }
                },
                _configureProperties: function(properties, config) {
                    for (var i in properties) {
                        var c = properties[i];
                        if (c.value !== void 0) {
                            var value = c.value;
                            if ("function" == typeof value) {
                                value = value.call(this, this._config)
                            }
                            config[i] = value
                        }
                    }
                },
                _distributeConfig: function(config) {
                    var fx$ = this._propertyEffects;
                    if (fx$) {
                        for (var p in config) {
                            var fx = fx$[p];
                            if (fx) {
                                for (var i = 0, l = fx.length, x; i < l && (x = fx[i]); i++) {
                                    if ("annotation" === x.kind) {
                                        var node = this._nodes[x.effect.index],
                                            name = x.effect.propertyName,
                                            isAttr = "attribute" == x.effect.kind,
                                            hasEffect = node._propertyEffects && node._propertyEffects[name];
                                        if (node._configValue && (hasEffect || !isAttr)) {
                                            var value = p === x.effect.value ? config[p] : this._get(x.effect.value, config);
                                            value = this._computeFinalAnnotationValue(node, name, value, x.effect);
                                            if (isAttr) {
                                                value = node.deserialize(this.serialize(value), node._propertyInfo[name].type)
                                            }
                                            node._configValue(name, value)
                                        }
                                    }
                                }
                            }
                        }
                    }
                },
                _afterClientsReady: function() {
                    this.importPath = this._importPath;
                    this.rootPath = Polymer.rootPath;
                    this._executeStaticEffects();
                    this._applyConfig(this._config, this._aboveConfig);
                    this._flushHandlers()
                },
                _applyConfig: function(config, aboveConfig) {
                    for (var n in config) {
                        if (this[n] === void 0) {
                            this.__setProperty(n, config[n], n in aboveConfig)
                        }
                    }
                },
                _notifyListener: function(fn, e) {
                    if (!Polymer.Bind._isEventBogus(e, e.target)) {
                        var value, path;
                        if (e.detail) {
                            value = e.detail.value;
                            path = e.detail.path
                        }
                        if (!this._clientsReadied) {
                            this._queueHandler([fn, e.target, value, path])
                        } else {
                            return fn.call(this, e.target, value, path)
                        }
                    }
                },
                _queueHandler: function(args) {
                    this._handlers.push(args)
                },
                _flushHandlers: function() {
                    for (var h$ = this._handlers, i = 0, l = h$.length, h; i < l && (h = h$[i]); i++) {
                        h[0].call(this, h[1], h[2], h[3])
                    }
                    this._handlers = []
                }
            })
        })();
        (function() {
            "use strict";
            var Path = Polymer.Path;
            Polymer.Base._addFeature({
                notifyPath: function(path, value, fromAbove) {
                    var info = {},
                        v = this._get(path, this, info);
                    if (1 === arguments.length) {
                        value = v
                    }
                    if (info.path) {
                        this._notifyPath(info.path, value, fromAbove)
                    }
                },
                _notifyPath: function(path, value, fromAbove) {
                    var old = this._propertySetter(path, value);
                    if (old !== value && (old === old || value === value)) {
                        this._pathEffector(path, value);
                        if (!fromAbove) {
                            this._notifyPathUp(path, value)
                        }
                        return !0
                    }
                },
                _getPathParts: function(path) {
                    if (Array.isArray(path)) {
                        for (var parts = [], i = 0, args; i < path.length; i++) {
                            args = path[i].toString().split(".");
                            for (var j = 0; j < args.length; j++) {
                                parts.push(args[j])
                            }
                        }
                        return parts
                    } else {
                        return path.toString().split(".")
                    }
                },
                set: function(path, value, root) {
                    var prop = root || this,
                        parts = this._getPathParts(path),
                        array, last = parts[parts.length - 1];
                    if (1 < parts.length) {
                        for (var i = 0, part; i < parts.length - 1; i++) {
                            part = parts[i];
                            if (array && "#" == part[0]) {
                                prop = Polymer.Collection.get(array).getItem(part)
                            } else {
                                prop = prop[part];
                                if (array && parseInt(part, 10) == part) {
                                    parts[i] = Polymer.Collection.get(array).getKey(prop)
                                }
                            }
                            if (!prop) {
                                return
                            }
                            array = Array.isArray(prop) ? prop : null
                        }
                        if (array) {
                            var coll = Polymer.Collection.get(array),
                                old, key;
                            if ("#" == last[0]) {
                                key = last;
                                old = coll.getItem(key);
                                last = array.indexOf(old);
                                coll.setItem(key, value)
                            } else if (parseInt(last, 10) == last) {
                                old = prop[last];
                                key = coll.getKey(old);
                                parts[i] = key;
                                coll.setItem(key, value)
                            }
                        }
                        prop[last] = value;
                        if (!root) {
                            this._notifyPath(parts.join("."), value)
                        }
                    } else {
                        prop[path] = value
                    }
                },
                get: function(path, root) {
                    return this._get(path, root)
                },
                _get: function(path, root, info) {
                    for (var prop = root || this, parts = this._getPathParts(path), array, i = 0; i < parts.length; i++) {
                        if (!prop) {
                            return
                        }
                        var part = parts[i];
                        if (array && "#" == part[0]) {
                            prop = Polymer.Collection.get(array).getItem(part)
                        } else {
                            prop = prop[part];
                            if (info && array && parseInt(part, 10) == part) {
                                parts[i] = Polymer.Collection.get(array).getKey(prop)
                            }
                        }
                        array = Array.isArray(prop) ? prop : null
                    }
                    if (info) {
                        info.path = parts.join(".")
                    }
                    return prop
                },
                _pathEffector: function(path, value) {
                    var model = Path.root(path),
                        fx$ = this._propertyEffects && this._propertyEffects[model];
                    if (fx$) {
                        for (var i = 0, fx, fxFn; i < fx$.length && (fx = fx$[i]); i++) {
                            fxFn = fx.pathFn;
                            if (fxFn) {
                                fxFn.call(this, path, value, fx.effect)
                            }
                        }
                    }
                    if (this._boundPaths) {
                        this._notifyBoundPaths(path, value)
                    }
                },
                _annotationPathEffect: function(path, value, effect) {
                    if (Path.matches(effect.value, !1, path)) {
                        Polymer.Bind._annotationEffect.call(this, path, value, effect)
                    } else if (!effect.negate && Path.isDescendant(effect.value, path)) {
                        var node = this._nodes[effect.index];
                        if (node && node._notifyPath) {
                            var newPath = Path.translate(effect.value, effect.name, path);
                            node._notifyPath(newPath, value, !0)
                        }
                    }
                },
                _complexObserverPathEffect: function(path, value, effect) {
                    if (Path.matches(effect.trigger.name, effect.trigger.wildcard, path)) {
                        Polymer.Bind._complexObserverEffect.call(this, path, value, effect)
                    }
                },
                _computePathEffect: function(path, value, effect) {
                    if (Path.matches(effect.trigger.name, effect.trigger.wildcard, path)) {
                        Polymer.Bind._computeEffect.call(this, path, value, effect)
                    }
                },
                _annotatedComputationPathEffect: function(path, value, effect) {
                    if (Path.matches(effect.trigger.name, effect.trigger.wildcard, path)) {
                        Polymer.Bind._annotatedComputationEffect.call(this, path, value, effect)
                    }
                },
                linkPaths: function(to, from) {
                    this._boundPaths = this._boundPaths || {};
                    if (from) {
                        this._boundPaths[to] = from
                    } else {
                        this.unlinkPaths(to)
                    }
                },
                unlinkPaths: function(path) {
                    if (this._boundPaths) {
                        delete this._boundPaths[path]
                    }
                },
                _notifyBoundPaths: function(path, value) {
                    for (var a in this._boundPaths) {
                        var b = this._boundPaths[a];
                        if (Path.isDescendant(a, path)) {
                            this._notifyPath(Path.translate(a, b, path), value)
                        } else if (Path.isDescendant(b, path)) {
                            this._notifyPath(Path.translate(b, a, path), value)
                        }
                    }
                },
                _notifyPathUp: function(path, value) {
                    var rootName = Path.root(path),
                        dashCaseName = Polymer.CaseMap.camelToDashCase(rootName),
                        eventName = dashCaseName + this._EVENT_CHANGED;
                    this.fire(eventName, {
                        path: path,
                        value: value
                    }, {
                        bubbles: !1,
                        _useCache: Polymer.Settings.eventDataCache || !Polymer.Settings.isIE
                    })
                },
                _EVENT_CHANGED: "-changed",
                notifySplices: function(path, splices) {
                    var info = {},
                        array = this._get(path, this, info);
                    this._notifySplices(array, info.path, splices)
                },
                _notifySplices: function(array, path, splices) {
                    var change = {
                            keySplices: Polymer.Collection.applySplices(array, splices),
                            indexSplices: splices
                        },
                        splicesPath = path + ".splices";
                    this._notifyPath(splicesPath, change);
                    this._notifyPath(path + ".length", array.length);
                    this.__data__[splicesPath] = {
                        keySplices: null,
                        indexSplices: null
                    }
                },
                _notifySplice: function(array, path, index, added, removed) {
                    this._notifySplices(array, path, [{
                        index: index,
                        addedCount: added,
                        removed: removed,
                        object: array,
                        type: "splice"
                    }])
                },
                push: function(path) {
                    var info = {},
                        array = this._get(path, this, info),
                        args = Array.prototype.slice.call(arguments, 1),
                        len = array.length,
                        ret = array.push.apply(array, args);
                    if (args.length) {
                        this._notifySplice(array, info.path, len, args.length, [])
                    }
                    return ret
                },
                pop: function(path) {
                    var info = {},
                        array = this._get(path, this, info),
                        hadLength = !!array.length,
                        args = Array.prototype.slice.call(arguments, 1),
                        ret = array.pop.apply(array, args);
                    if (hadLength) {
                        this._notifySplice(array, info.path, array.length, 0, [ret])
                    }
                    return ret
                },
                splice: function(path, start) {
                    var _Mathfloor = Math.floor,
                        info = {},
                        array = this._get(path, this, info);
                    if (0 > start) {
                        start = array.length - _Mathfloor(-start)
                    } else {
                        start = _Mathfloor(start)
                    }
                    if (!start) {
                        start = 0
                    }
                    var args = Array.prototype.slice.call(arguments, 1),
                        ret = array.splice.apply(array, args),
                        addedCount = Math.max(args.length - 2, 0);
                    if (addedCount || ret.length) {
                        this._notifySplice(array, info.path, start, addedCount, ret)
                    }
                    return ret
                },
                shift: function(path) {
                    var info = {},
                        array = this._get(path, this, info),
                        hadLength = !!array.length,
                        args = Array.prototype.slice.call(arguments, 1),
                        ret = array.shift.apply(array, args);
                    if (hadLength) {
                        this._notifySplice(array, info.path, 0, 0, [ret])
                    }
                    return ret
                },
                unshift: function(path) {
                    var info = {},
                        array = this._get(path, this, info),
                        args = Array.prototype.slice.call(arguments, 1),
                        ret = array.unshift.apply(array, args);
                    if (args.length) {
                        this._notifySplice(array, info.path, 0, args.length, [])
                    }
                    return ret
                },
                prepareModelNotifyPath: function(model) {
                    this.mixin(model, {
                        fire: Polymer.Base.fire,
                        _getEvent: Polymer.Base._getEvent,
                        __eventCache: Polymer.Base.__eventCache,
                        notifyPath: Polymer.Base.notifyPath,
                        _get: Polymer.Base._get,
                        _EVENT_CHANGED: Polymer.Base._EVENT_CHANGED,
                        _notifyPath: Polymer.Base._notifyPath,
                        _notifyPathUp: Polymer.Base._notifyPathUp,
                        _pathEffector: Polymer.Base._pathEffector,
                        _annotationPathEffect: Polymer.Base._annotationPathEffect,
                        _complexObserverPathEffect: Polymer.Base._complexObserverPathEffect,
                        _annotatedComputationPathEffect: Polymer.Base._annotatedComputationPathEffect,
                        _computePathEffect: Polymer.Base._computePathEffect,
                        _notifyBoundPaths: Polymer.Base._notifyBoundPaths,
                        _getPathParts: Polymer.Base._getPathParts
                    })
                }
            })
        })();
        Polymer.Base._addFeature({
            resolveUrl: function(url) {
                return Polymer.ResolveUrl.resolveUrl(url, this._importPath)
            }
        });
        Polymer.CssParse = function() {
            return {
                parse: function(text) {
                    text = this._clean(text);
                    return this._parseCss(this._lex(text), text)
                },
                _clean: function(cssText) {
                    return cssText.replace(this._rx.comments, "").replace(this._rx.port, "")
                },
                _lex: function(text) {
                    for (var root = {
                            start: 0,
                            end: text.length
                        }, n = root, i = 0, l = text.length; i < l; i++) {
                        switch (text[i]) {
                            case this.OPEN_BRACE:
                                if (!n.rules) {
                                    n.rules = []
                                }
                                var p = n,
                                    previous = p.rules[p.rules.length - 1];
                                n = {
                                    start: i + 1,
                                    parent: p,
                                    previous: previous
                                };
                                p.rules.push(n);
                                break;
                            case this.CLOSE_BRACE:
                                n.end = i + 1;
                                n = n.parent || root;
                                break;
                        }
                    }
                    return root
                },
                _parseCss: function(node, text) {
                    var t = text.substring(node.start, node.end - 1);
                    node.parsedCssText = node.cssText = t.trim();
                    if (node.parent) {
                        var ss = node.previous ? node.previous.end : node.parent.start;
                        t = text.substring(ss, node.start - 1);
                        t = this._expandUnicodeEscapes(t);
                        t = t.replace(this._rx.multipleSpaces, " ");
                        t = t.substring(t.lastIndexOf(";") + 1);
                        var s = node.parsedSelector = node.selector = t.trim();
                        node.atRule = 0 === s.indexOf(this.AT_START);
                        if (node.atRule) {
                            if (0 === s.indexOf(this.MEDIA_START)) {
                                node.type = this.types.MEDIA_RULE
                            } else if (s.match(this._rx.keyframesRule)) {
                                node.type = this.types.KEYFRAMES_RULE;
                                node.keyframesName = node.selector.split(this._rx.multipleSpaces).pop()
                            }
                        } else {
                            if (0 === s.indexOf(this.VAR_START)) {
                                node.type = this.types.MIXIN_RULE
                            } else {
                                node.type = this.types.STYLE_RULE
                            }
                        }
                    }
                    var r$ = node.rules;
                    if (r$) {
                        for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {
                            this._parseCss(r, text)
                        }
                    }
                    return node
                },
                _expandUnicodeEscapes: function(s) {
                    return s.replace(/\\([0-9a-f]{1,6})\s/gi, function() {
                        var code = arguments[1],
                            repeat = 6 - code.length;
                        while (repeat--) {
                            code = "0" + code
                        }
                        return "\\" + code
                    })
                },
                stringify: function(node, preserveProperties, text) {
                    text = text || "";
                    var cssText = "";
                    if (node.cssText || node.rules) {
                        var r$ = node.rules;
                        if (r$ && !this._hasMixinRules(r$)) {
                            for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {
                                cssText = this.stringify(r, preserveProperties, cssText)
                            }
                        } else {
                            cssText = preserveProperties ? node.cssText : this.removeCustomProps(node.cssText);
                            cssText = cssText.trim();
                            if (cssText) {
                                cssText = "  " + cssText + "\n"
                            }
                        }
                    }
                    if (cssText) {
                        if (node.selector) {
                            text += node.selector + " " + this.OPEN_BRACE + "\n"
                        }
                        text += cssText;
                        if (node.selector) {
                            text += this.CLOSE_BRACE + "\n\n"
                        }
                    }
                    return text
                },
                _hasMixinRules: function(rules) {
                    return 0 === rules[0].selector.indexOf(this.VAR_START)
                },
                removeCustomProps: function(cssText) {
                    cssText = this.removeCustomPropAssignment(cssText);
                    return this.removeCustomPropApply(cssText)
                },
                removeCustomPropAssignment: function(cssText) {
                    return cssText.replace(this._rx.customProp, "").replace(this._rx.mixinProp, "")
                },
                removeCustomPropApply: function(cssText) {
                    return cssText.replace(this._rx.mixinApply, "").replace(this._rx.varApply, "")
                },
                types: {
                    STYLE_RULE: 1,
                    KEYFRAMES_RULE: 7,
                    MEDIA_RULE: 4,
                    MIXIN_RULE: 1e3
                },
                OPEN_BRACE: "{",
                CLOSE_BRACE: "}",
                _rx: {
                    comments: /\/\*[^*]*\*+([^\/*][^*]*\*+)*\//gim,
                    port: /@import[^;]*;/gim,
                    customProp: /(?:^[^;\-\s}]+)?--[^;{}]*?:[^{};]*?(?:[;\n]|$)/gim,
                    mixinProp: /(?:^[^;\-\s}]+)?--[^;{}]*?:[^{};]*?{[^}]*?}(?:[;\n]|$)?/gim,
                    mixinApply: /@apply\s*\(?[^);]*\)?\s*(?:[;\n]|$)?/gim,
                    varApply: /[^;:]*?:[^;]*?var\([^;]*\)(?:[;\n]|$)?/gim,
                    keyframesRule: /^@[^\s]*keyframes/,
                    multipleSpaces: /\s+/g
                },
                VAR_START: "--",
                MEDIA_START: "@media",
                AT_START: "@"
            }
        }();
        Polymer.StyleUtil = function() {
            var settings = Polymer.Settings;
            return {
                unscopedStyleImports: new WeakMap,
                SHADY_UNSCOPED_ATTR: "shady-unscoped",
                NATIVE_VARIABLES: Polymer.Settings.useNativeCSSProperties,
                MODULE_STYLES_SELECTOR: "style, link[rel=import][type~=css], template",
                INCLUDE_ATTR: "include",
                toCssText: function(rules, callback) {
                    if ("string" === typeof rules) {
                        rules = this.parser.parse(rules)
                    }
                    if (callback) {
                        this.forEachRule(rules, callback)
                    }
                    return this.parser.stringify(rules, this.NATIVE_VARIABLES)
                },
                forRulesInStyles: function(styles, styleRuleCallback, keyframesRuleCallback) {
                    if (styles) {
                        for (var i = 0, l = styles.length, s; i < l && (s = styles[i]); i++) {
                            this.forEachRuleInStyle(s, styleRuleCallback, keyframesRuleCallback)
                        }
                    }
                },
                forActiveRulesInStyles: function(styles, styleRuleCallback, keyframesRuleCallback) {
                    if (styles) {
                        for (var i = 0, l = styles.length, s; i < l && (s = styles[i]); i++) {
                            this.forEachRuleInStyle(s, styleRuleCallback, keyframesRuleCallback, !0)
                        }
                    }
                },
                rulesForStyle: function(style) {
                    if (!style.__cssRules && style.textContent) {
                        style.__cssRules = this.parser.parse(style.textContent)
                    }
                    return style.__cssRules
                },
                isKeyframesSelector: function(rule) {
                    return rule.parent && rule.parent.type === this.ruleTypes.KEYFRAMES_RULE
                },
                forEachRuleInStyle: function(style, styleRuleCallback, keyframesRuleCallback, onlyActiveRules) {
                    var rules = this.rulesForStyle(style),
                        styleCallback, keyframeCallback;
                    if (styleRuleCallback) {
                        styleCallback = function(rule) {
                            styleRuleCallback(rule, style)
                        }
                    }
                    if (keyframesRuleCallback) {
                        keyframeCallback = function(rule) {
                            keyframesRuleCallback(rule, style)
                        }
                    }
                    this.forEachRule(rules, styleCallback, keyframeCallback, onlyActiveRules)
                },
                forEachRule: function(node, styleRuleCallback, keyframesRuleCallback, onlyActiveRules) {
                    if (!node) {
                        return
                    }
                    var skipRules = !1;
                    if (onlyActiveRules) {
                        if (node.type === this.ruleTypes.MEDIA_RULE) {
                            var matchMedia = node.selector.match(this.rx.MEDIA_MATCH);
                            if (matchMedia) {
                                if (!window.matchMedia(matchMedia[1]).matches) {
                                    skipRules = !0
                                }
                            }
                        }
                    }
                    if (node.type === this.ruleTypes.STYLE_RULE) {
                        styleRuleCallback(node)
                    } else if (keyframesRuleCallback && node.type === this.ruleTypes.KEYFRAMES_RULE) {
                        keyframesRuleCallback(node)
                    } else if (node.type === this.ruleTypes.MIXIN_RULE) {
                        skipRules = !0
                    }
                    var r$ = node.rules;
                    if (r$ && !skipRules) {
                        for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {
                            this.forEachRule(r, styleRuleCallback, keyframesRuleCallback, onlyActiveRules)
                        }
                    }
                },
                applyCss: function(cssText, moniker, target, contextNode) {
                    var style = this.createScopeStyle(cssText, moniker);
                    return this.applyStyle(style, target, contextNode)
                },
                applyStyle: function(style, target, contextNode) {
                    target = target || document.head;
                    var after = contextNode && contextNode.nextSibling || target.firstChild;
                    this.__lastHeadApplyNode = style;
                    return target.insertBefore(style, after)
                },
                createScopeStyle: function(cssText, moniker) {
                    var style = document.createElement("style");
                    if (moniker) {
                        style.setAttribute("scope", moniker)
                    }
                    style.textContent = cssText;
                    return style
                },
                __lastHeadApplyNode: null,
                applyStylePlaceHolder: function(moniker) {
                    var placeHolder = document.createComment(" Shady DOM styles for " + moniker + " "),
                        after = this.__lastHeadApplyNode ? this.__lastHeadApplyNode.nextSibling : null,
                        scope = document.head;
                    scope.insertBefore(placeHolder, after || scope.firstChild);
                    this.__lastHeadApplyNode = placeHolder;
                    return placeHolder
                },
                cssFromModules: function(moduleIds, warnIfNotFound) {
                    for (var modules = moduleIds.trim().split(/\s+/), cssText = "", i = 0; i < modules.length; i++) {
                        cssText += this.cssFromModule(modules[i], warnIfNotFound)
                    }
                    return cssText
                },
                cssFromModule: function(moduleId, warnIfNotFound) {
                    var m = Polymer.DomModule.import(moduleId);
                    if (m && !m._cssText) {
                        m._cssText = this.cssFromElement(m)
                    }
                    if (!m && warnIfNotFound) {
                        console.warn("Could not find style data in module named", moduleId)
                    }
                    return m && m._cssText || ""
                },
                cssFromElement: function(element) {
                    for (var cssText = "", content = element.content || element, e$ = Polymer.TreeApi.arrayCopy(content.querySelectorAll(this.MODULE_STYLES_SELECTOR)), i = 0, e; i < e$.length; i++) {
                        e = e$[i];
                        if ("template" === e.localName) {
                            if (!e.hasAttribute("preserve-content")) {
                                cssText += this.cssFromElement(e)
                            }
                        } else {
                            if ("style" === e.localName) {
                                var include = e.getAttribute(this.INCLUDE_ATTR);
                                if (include) {
                                    cssText += this.cssFromModules(include, !0)
                                }
                                e = e.__appliedElement || e;
                                e.parentNode.removeChild(e);
                                var css = this.resolveCss(e.textContent, element.ownerDocument);
                                if (!settings.useNativeShadow && e.hasAttribute(this.SHADY_UNSCOPED_ATTR)) {
                                    e.textContent = css;
                                    document.head.insertBefore(e, document.head.firstChild)
                                } else {
                                    cssText += css
                                }
                            } else if (e.import && e.import.body) {
                                var importCss = this.resolveCss(e.import.body.textContent, e.import);
                                if (!settings.useNativeShadow && e.hasAttribute(this.SHADY_UNSCOPED_ATTR)) {
                                    if (!this.unscopedStyleImports.has(e.import)) {
                                        this.unscopedStyleImports.set(e.import, !0);
                                        var importStyle = document.createElement("style");
                                        importStyle.setAttribute(this.SHADY_UNSCOPED_ATTR, "");
                                        importStyle.textContent = importCss;
                                        document.head.insertBefore(importStyle, document.head.firstChild)
                                    }
                                } else {
                                    cssText += importCss
                                }
                            }
                        }
                    }
                    return cssText
                },
                styleIncludesToTemplate: function(targetTemplate) {
                    for (var styles = targetTemplate.content.querySelectorAll("style[include]"), i = 0, s; i < styles.length; i++) {
                        s = styles[i];
                        s.parentNode.insertBefore(this._includesToFragment(s.getAttribute("include")), s)
                    }
                },
                _includesToFragment: function(styleIncludes) {
                    for (var includeArray = styleIncludes.trim().split(" "), frag = document.createDocumentFragment(), i = 0, t; i < includeArray.length; i++) {
                        t = Polymer.DomModule.import(includeArray[i], "template");
                        if (t) {
                            this._addStylesToFragment(frag, t.content)
                        }
                    }
                    return frag
                },
                _addStylesToFragment: function(frag, source) {
                    for (var s$ = source.querySelectorAll("style"), i = 0, s; i < s$.length; i++) {
                        s = s$[i];
                        var include = s.getAttribute("include");
                        if (include) {
                            frag.appendChild(this._includesToFragment(include))
                        }
                        if (s.textContent) {
                            frag.appendChild(s.cloneNode(!0))
                        }
                    }
                },
                isTargetedBuild: function(buildType) {
                    return settings.useNativeShadow ? "shadow" === buildType : "shady" === buildType
                },
                cssBuildTypeForModule: function(module) {
                    var dm = Polymer.DomModule.import(module);
                    if (dm) {
                        return this.getCssBuildType(dm)
                    }
                },
                getCssBuildType: function(element) {
                    return element.getAttribute("css-build")
                },
                _findMatchingParen: function(text, start) {
                    for (var level = 0, i = start, l = text.length; i < l; i++) {
                        switch (text[i]) {
                            case "(":
                                level++;
                                break;
                            case ")":
                                if (0 === --level) {
                                    return i
                                }
                                break;
                        }
                    }
                    return -1
                },
                processVariableAndFallback: function(str, callback) {
                    var start = str.indexOf("var(");
                    if (-1 === start) {
                        return callback(str, "", "", "")
                    }
                    var end = this._findMatchingParen(str, start + 3),
                        inner = str.substring(start + 4, end),
                        prefix = str.substring(0, start),
                        suffix = this.processVariableAndFallback(str.substring(end + 1), callback),
                        comma = inner.indexOf(",");
                    if (-1 === comma) {
                        return callback(prefix, inner.trim(), "", suffix)
                    }
                    var value = inner.substring(0, comma).trim(),
                        fallback = inner.substring(comma + 1).trim();
                    return callback(prefix, value, fallback, suffix)
                },
                rx: {
                    VAR_ASSIGN: /(?:^|[;\s{]\s*)(--[\w-]*?)\s*:\s*(?:([^;{]*)|{([^}]*)})(?:(?=[;\s}])|$)/gi,
                    MIXIN_MATCH: /(?:^|\W+)@apply\s*\(?([^);\n]*)\)?/gi,
                    VAR_CONSUMED: /(--[\w-]+)\s*([:,;)]|$)/gi,
                    ANIMATION_MATCH: /(animation\s*:)|(animation-name\s*:)/,
                    MEDIA_MATCH: /@media[^(]*(\([^)]*\))/,
                    IS_VAR: /^--/,
                    BRACKETED: /\{[^}]*\}/g,
                    HOST_PREFIX: "(?:^|[^.#[:])",
                    HOST_SUFFIX: "($|[.:[\\s>+~])"
                },
                resolveCss: Polymer.ResolveUrl.resolveCss,
                parser: Polymer.CssParse,
                ruleTypes: Polymer.CssParse.types
            }
        }();
        Polymer.StyleTransformer = function() {
            var styleUtil = Polymer.StyleUtil,
                settings = Polymer.Settings,
                api = {
                    dom: function(node, scope, useAttr, shouldRemoveScope) {
                        this._transformDom(node, scope || "", useAttr, shouldRemoveScope)
                    },
                    _transformDom: function(node, selector, useAttr, shouldRemoveScope) {
                        if (node.setAttribute) {
                            this.element(node, selector, useAttr, shouldRemoveScope)
                        }
                        for (var c$ = Polymer.dom(node).childNodes, i = 0; i < c$.length; i++) {
                            this._transformDom(c$[i], selector, useAttr, shouldRemoveScope)
                        }
                    },
                    element: function(element, scope, useAttr, shouldRemoveScope) {
                        if (useAttr) {
                            if (shouldRemoveScope) {
                                element.removeAttribute(SCOPE_NAME)
                            } else {
                                element.setAttribute(SCOPE_NAME, scope)
                            }
                        } else {
                            if (scope) {
                                if (element.classList) {
                                    if (shouldRemoveScope) {
                                        element.classList.remove(SCOPE_NAME);
                                        element.classList.remove(scope)
                                    } else {
                                        element.classList.add(SCOPE_NAME);
                                        element.classList.add(scope)
                                    }
                                } else if (element.getAttribute) {
                                    var c = element.getAttribute(CLASS);
                                    if (shouldRemoveScope) {
                                        if (c) {
                                            element.setAttribute(CLASS, c.replace(SCOPE_NAME, "").replace(scope, ""))
                                        }
                                    } else {
                                        element.setAttribute(CLASS, (c ? c + " " : "") + SCOPE_NAME + " " + scope)
                                    }
                                }
                            }
                        }
                    },
                    elementStyles: function(element, callback) {
                        var styles = element._styles,
                            cssText = "",
                            cssBuildType = element.__cssBuild,
                            passthrough = settings.useNativeShadow || "shady" === cssBuildType,
                            cb;
                        if (passthrough) {
                            var self = this;
                            cb = function(rule) {
                                rule.selector = self._slottedToContent(rule.selector);
                                rule.selector = rule.selector.replace(ROOT, ":host > *");
                                rule.selector = self._dirShadowTransform(rule.selector);
                                if (callback) {
                                    callback(rule)
                                }
                            }
                        }
                        for (var i = 0, l = styles.length, s, rules; i < l && (s = styles[i]); i++) {
                            rules = styleUtil.rulesForStyle(s);
                            cssText += passthrough ? styleUtil.toCssText(rules, cb) : this.css(rules, element.is, element.extends, callback, element._scopeCssViaAttr) + "\n\n"
                        }
                        return cssText.trim()
                    },
                    css: function(rules, scope, ext, callback, useAttr) {
                        var hostScope = this._calcHostScope(scope, ext);
                        scope = this._calcElementScope(scope, useAttr);
                        var self = this;
                        return styleUtil.toCssText(rules, function(rule) {
                            if (!rule.isScoped) {
                                self.rule(rule, scope, hostScope);
                                rule.isScoped = !0
                            }
                            if (callback) {
                                callback(rule, scope, hostScope)
                            }
                        })
                    },
                    _calcElementScope: function(scope, useAttr) {
                        if (scope) {
                            return useAttr ? "[" + SCOPE_NAME + "~=" + scope + "]" : "." + scope
                        } else {
                            return ""
                        }
                    },
                    _calcHostScope: function(scope, ext) {
                        return ext ? "[is=" + scope + "]" : scope
                    },
                    rule: function(rule, scope, hostScope) {
                        this._transformRule(rule, this._transformComplexSelector, scope, hostScope)
                    },
                    _transformRule: function(rule, transformer, scope, hostScope) {
                        rule.selector = rule.transformedSelector = this._transformRuleCss(rule, transformer, scope, hostScope)
                    },
                    _splitSelectorList: function(selector) {
                        for (var parts = [], part = "", i = 0; 0 <= i && i < selector.length; i++) {
                            if ("(" === selector[i]) {
                                var end = styleUtil._findMatchingParen(selector, i);
                                part += selector.slice(i, end + 1);
                                i = end
                            } else if (selector[i] === COMPLEX_SELECTOR_SEP) {
                                parts.push(part);
                                part = ""
                            } else {
                                part += selector[i]
                            }
                        }
                        if (part) {
                            parts.push(part)
                        }
                        if (0 === parts.length) {
                            parts.push(selector)
                        }
                        return parts
                    },
                    _transformRuleCss: function(rule, transformer, scope, hostScope) {
                        var p$ = this._splitSelectorList(rule.selector);
                        if (!styleUtil.isKeyframesSelector(rule)) {
                            for (var i = 0, l = p$.length, p; i < l && (p = p$[i]); i++) {
                                p$[i] = transformer.call(this, p, scope, hostScope)
                            }
                        }
                        return p$.join(COMPLEX_SELECTOR_SEP)
                    },
                    _ensureScopedDir: function(s) {
                        var m = s.match(DIR_PAREN);
                        if (m && "" === m[1] && m[0].length === s.length) {
                            s = "*" + s
                        }
                        return s
                    },
                    _additionalDirSelectors: function(dir, after, prefix) {
                        if (!dir || !after) {
                            return ""
                        }
                        prefix = prefix || "";
                        return COMPLEX_SELECTOR_SEP + prefix + " " + dir + " " + after
                    },
                    _transformComplexSelector: function(selector, scope, hostScope) {
                        var stop = !1,
                            hostContext = !1,
                            dir = !1,
                            self = this;
                        selector = selector.trim();
                        selector = this._slottedToContent(selector);
                        selector = selector.replace(ROOT, ":host > *");
                        selector = selector.replace(CONTENT_START, HOST + " $1");
                        selector = this._ensureScopedDir(selector);
                        selector = selector.replace(SIMPLE_SELECTOR_SEP, function(m, c, s) {
                            if (!stop) {
                                var info = self._transformCompoundSelector(s, c, scope, hostScope);
                                stop = stop || info.stop;
                                hostContext = hostContext || info.hostContext;
                                dir = dir || info.dir;
                                c = info.combinator;
                                s = info.value
                            } else {
                                s = s.replace(SCOPE_JUMP, " ")
                            }
                            return c + s
                        });
                        if (hostContext) {
                            selector = selector.replace(HOST_CONTEXT_PAREN, function(m, pre, paren, post) {
                                var replacement = pre + paren + " " + hostScope + post + COMPLEX_SELECTOR_SEP + " " + pre + hostScope + paren + post;
                                if (dir) {
                                    replacement += self._additionalDirSelectors(paren, post, hostScope)
                                }
                                return replacement
                            })
                        }
                        return selector
                    },
                    _transformDir: function(s) {
                        s = s.replace(HOST_DIR, ":host-context([dir=\"$1\"])");
                        s = s.replace(DIR_PAREN, ":host-context([dir=\"$2\"]) $1");
                        return s
                    },
                    _transformCompoundSelector: function(selector, combinator, scope, hostScope) {
                        var jumpIndex = selector.search(SCOPE_JUMP),
                            hostContext = !1,
                            dir = !1;
                        if (selector.match(DIR_PAREN)) {
                            selector = this._transformDir(selector);
                            dir = !0
                        }
                        if (0 <= selector.indexOf(":host-context")) {
                            hostContext = !0
                        } else if (0 <= selector.indexOf(HOST)) {
                            selector = this._transformHostSelector(selector, hostScope)
                        } else if (0 !== jumpIndex) {
                            selector = scope ? this._transformSimpleSelector(selector, scope) : selector
                        }
                        if (0 <= selector.indexOf(CONTENT)) {
                            combinator = ""
                        }
                        var stop;
                        if (0 <= jumpIndex) {
                            selector = selector.replace(SCOPE_JUMP, " ");
                            stop = !0
                        }
                        return {
                            value: selector,
                            combinator: combinator,
                            stop: stop,
                            hostContext: hostContext,
                            dir: dir
                        }
                    },
                    _transformSimpleSelector: function(selector, scope) {
                        var p$ = selector.split(PSEUDO_PREFIX);
                        p$[0] += scope;
                        return p$.join(PSEUDO_PREFIX)
                    },
                    _transformHostSelector: function(selector, hostScope) {
                        var m = selector.match(HOST_PAREN),
                            paren = m && m[2].trim() || "";
                        if (paren) {
                            if (!paren[0].match(SIMPLE_SELECTOR_PREFIX)) {
                                var typeSelector = paren.split(SIMPLE_SELECTOR_PREFIX)[0];
                                if (typeSelector === hostScope) {
                                    return paren
                                } else {
                                    return "should_not_match"
                                }
                            } else {
                                return selector.replace(HOST_PAREN, function(m, host, paren) {
                                    return hostScope + paren
                                })
                            }
                        } else {
                            return selector.replace(HOST, hostScope)
                        }
                    },
                    documentRule: function(rule) {
                        rule.selector = rule.parsedSelector;
                        this.normalizeRootSelector(rule);
                        if (!settings.useNativeShadow) {
                            this._transformRule(rule, this._transformDocumentSelector)
                        }
                    },
                    normalizeRootSelector: function(rule) {
                        rule.selector = rule.selector.replace(ROOT, "html");
                        var parts = this._splitSelectorList(rule.selector);
                        parts = parts.filter(function(part) {
                            return !part.match(HOST_OR_HOST_GT_STAR)
                        });
                        rule.selector = parts.join(COMPLEX_SELECTOR_SEP)
                    },
                    _transformDocumentSelector: function(selector) {
                        return this._transformComplexSelector(selector, ":not([" + SCOPE_NAME + "])" + ":not(." + SCOPE_NAME + ")")
                    },
                    _slottedToContent: function(cssText) {
                        return cssText.replace(SLOTTED_PAREN, CONTENT + "> $1")
                    },
                    _dirShadowTransform: function(selector) {
                        if (!selector.match(/:dir\(/)) {
                            return selector
                        }
                        return this._splitSelectorList(selector).map(function(s) {
                            s = this._ensureScopedDir(s);
                            s = this._transformDir(s);
                            var m = HOST_CONTEXT_PAREN.exec(s);
                            if (m) {
                                s += this._additionalDirSelectors(m[2], m[3], "")
                            }
                            return s
                        }, this).join(COMPLEX_SELECTOR_SEP)
                    },
                    SCOPE_NAME: "style-scope"
                },
                SCOPE_NAME = api.SCOPE_NAME,
                COMPLEX_SELECTOR_SEP = ",",
                SIMPLE_SELECTOR_SEP = /(^|[\s>+~]+)((?:\[.+?\]|[^\s>+~=\[])+)/g,
                SIMPLE_SELECTOR_PREFIX = /[[.:#*]/,
                HOST = ":host",
                ROOT = ":root",
                HOST_PAREN = /(:host)(?:\(((?:\([^)(]*\)|[^)(]*)+?)\))/,
                HOST_CONTEXT_PAREN = /(.*)(?::host-context)(?:\(((?:\([^)(]*\)|[^)(]*)+?)\))(.*)/,
                CONTENT = "::content",
                SCOPE_JUMP = /::content|::shadow|\/deep\//,
                PSEUDO_PREFIX = ":",
                CLASS = "class",
                CONTENT_START = new RegExp("^(" + CONTENT + ")"),
                SLOTTED_PAREN = /(?:::slotted)(?:\(((?:\([^)(]*\)|[^)(]*)+?)\))/g,
                HOST_OR_HOST_GT_STAR = /:host(?:\s*>\s*\*)?/,
                DIR_PAREN = /(.*):dir\((ltr|rtl)\)/,
                HOST_DIR = /:host\(:dir\((rtl|ltr)\)\)/g;
            return api
        }();
        Polymer.StyleExtends = function() {
            var styleUtil = Polymer.StyleUtil;
            return {
                hasExtends: function(cssText) {
                    return !!cssText.match(this.rx.EXTEND)
                },
                transform: function(style) {
                    var rules = styleUtil.rulesForStyle(style),
                        self = this;
                    styleUtil.forEachRule(rules, function(rule) {
                        self._mapRuleOntoParent(rule);
                        if (rule.parent) {
                            var m;
                            while (m = self.rx.EXTEND.exec(rule.cssText)) {
                                var extend = m[1],
                                    extendor = self._findExtendor(extend, rule);
                                if (extendor) {
                                    self._extendRule(rule, extendor)
                                }
                            }
                        }
                        rule.cssText = rule.cssText.replace(self.rx.EXTEND, "")
                    });
                    return styleUtil.toCssText(rules, function(rule) {
                        if (rule.selector.match(self.rx.STRIP)) {
                            rule.cssText = ""
                        }
                    }, !0)
                },
                _mapRuleOntoParent: function(rule) {
                    if (rule.parent) {
                        for (var map = rule.parent.map || (rule.parent.map = {}), parts = rule.selector.split(","), i = 0, p; i < parts.length; i++) {
                            p = parts[i];
                            map[p.trim()] = rule
                        }
                        return map
                    }
                },
                _findExtendor: function(extend, rule) {
                    return rule.parent && rule.parent.map && rule.parent.map[extend] || this._findExtendor(extend, rule.parent)
                },
                _extendRule: function(target, source) {
                    if (target.parent !== source.parent) {
                        this._cloneAndAddRuleToParent(source, target.parent)
                    }
                    target.extends = target.extends || [];
                    target.extends.push(source);
                    source.selector = source.selector.replace(this.rx.STRIP, "");
                    source.selector = (source.selector && source.selector + ",\n") + target.selector;
                    if (source.extends) {
                        source.extends.forEach(function(e) {
                            this._extendRule(target, e)
                        }, this)
                    }
                },
                _cloneAndAddRuleToParent: function(rule, parent) {
                    rule = Object.create(rule);
                    rule.parent = parent;
                    if (rule.extends) {
                        rule.extends = rule.extends.slice()
                    }
                    parent.rules.push(rule)
                },
                rx: {
                    EXTEND: /@extends\(([^)]*)\)\s*?;/gim,
                    STRIP: /%[^,]*$/
                }
            }
        }();
        Polymer.ApplyShim = function() {
            "use strict";
            var styleUtil = Polymer.StyleUtil,
                MIXIN_MATCH = styleUtil.rx.MIXIN_MATCH,
                VAR_ASSIGN = styleUtil.rx.VAR_ASSIGN,
                BAD_VAR = /var\(\s*(--[^,]*),\s*(--[^)]*)\)/g,
                APPLY_NAME_CLEAN = /;\s*/m,
                INITIAL_INHERIT = /^\s*(initial)|(inherit)\s*$/,
                MIXIN_VAR_SEP = "_-_",
                mixinMap = {};

            function mapSet(name, props) {
                name = name.trim();
                mixinMap[name] = {
                    properties: props,
                    dependants: {}
                }
            }

            function mapGet(name) {
                name = name.trim();
                return mixinMap[name]
            }

            function replaceInitialOrInherit(property, value) {
                var match = INITIAL_INHERIT.exec(value);
                if (match) {
                    if (match[1]) {
                        value = ApplyShim._getInitialValueForProperty(property)
                    } else {
                        value = "apply-shim-inherit"
                    }
                }
                return value
            }

            function cssTextToMap(text) {
                for (var props = text.split(";"), property, value, out = {}, i = 0, p, sp; i < props.length; i++) {
                    p = props[i];
                    if (p) {
                        sp = p.split(":");
                        if (1 < sp.length) {
                            property = sp[0].trim();
                            value = replaceInitialOrInherit(property, sp.slice(1).join(":"));
                            out[property] = value
                        }
                    }
                }
                return out
            }

            function invalidateMixinEntry(mixinEntry) {
                var currentProto = ApplyShim.__currentElementProto,
                    currentElementName = currentProto && currentProto.is;
                for (var elementName in mixinEntry.dependants) {
                    if (elementName !== currentElementName) {
                        mixinEntry.dependants[elementName].__applyShimInvalid = !0
                    }
                }
            }

            function produceCssProperties(matchText, propertyName, valueProperty, valueMixin) {
                if (valueProperty) {
                    styleUtil.processVariableAndFallback(valueProperty, function(prefix, value) {
                        if (value && mapGet(value)) {
                            valueMixin = "@apply " + value + ";"
                        }
                    })
                }
                if (!valueMixin) {
                    return matchText
                }
                var mixinAsProperties = consumeCssProperties(valueMixin),
                    prefix = matchText.slice(0, matchText.indexOf("--")),
                    mixinValues = cssTextToMap(mixinAsProperties),
                    combinedProps = mixinValues,
                    mixinEntry = mapGet(propertyName),
                    oldProps = mixinEntry && mixinEntry.properties;
                if (oldProps) {
                    combinedProps = Object.create(oldProps);
                    combinedProps = Polymer.Base.mixin(combinedProps, mixinValues)
                } else {
                    mapSet(propertyName, combinedProps)
                }
                var out = [],
                    p, v, needToInvalidate = !1;
                for (p in combinedProps) {
                    v = mixinValues[p];
                    if (v === void 0) {
                        v = "initial"
                    }
                    if (oldProps && !(p in oldProps)) {
                        needToInvalidate = !0
                    }
                    out.push(propertyName + MIXIN_VAR_SEP + p + ": " + v)
                }
                if (needToInvalidate) {
                    invalidateMixinEntry(mixinEntry)
                }
                if (mixinEntry) {
                    mixinEntry.properties = combinedProps
                }
                if (valueProperty) {
                    prefix = matchText + ";" + prefix
                }
                return prefix + out.join("; ") + ";"
            }

            function fixVars(matchText, varA, varB) {
                return "var(" + varA + "," + "var(" + varB + "))"
            }

            function atApplyToCssProperties(mixinName, fallbacks) {
                mixinName = mixinName.replace(APPLY_NAME_CLEAN, "");
                var vars = [],
                    mixinEntry = mapGet(mixinName);
                if (!mixinEntry) {
                    mapSet(mixinName, {});
                    mixinEntry = mapGet(mixinName)
                }
                if (mixinEntry) {
                    var currentProto = ApplyShim.__currentElementProto;
                    if (currentProto) {
                        mixinEntry.dependants[currentProto.is] = currentProto
                    }
                    var p, parts, f;
                    for (p in mixinEntry.properties) {
                        f = fallbacks && fallbacks[p];
                        parts = [p, ": var(", mixinName, MIXIN_VAR_SEP, p];
                        if (f) {
                            parts.push(",", f)
                        }
                        parts.push(")");
                        vars.push(parts.join(""))
                    }
                }
                return vars.join("; ")
            }

            function consumeCssProperties(text) {
                var m;
                while (m = MIXIN_MATCH.exec(text)) {
                    var matchText = m[0],
                        mixinName = m[1],
                        idx = m.index,
                        applyPos = idx + matchText.indexOf("@apply"),
                        afterApplyPos = idx + matchText.length,
                        textBeforeApply = text.slice(0, applyPos),
                        textAfterApply = text.slice(afterApplyPos),
                        defaults = cssTextToMap(textBeforeApply),
                        replacement = atApplyToCssProperties(mixinName, defaults);
                    text = [textBeforeApply, replacement, textAfterApply].join("");
                    MIXIN_MATCH.lastIndex = idx + replacement.length
                }
                return text
            }
            var ApplyShim = {
                _measureElement: null,
                _map: mixinMap,
                _separator: MIXIN_VAR_SEP,
                transform: function(styles, elementProto) {
                    this.__currentElementProto = elementProto;
                    styleUtil.forRulesInStyles(styles, this._boundFindDefinitions);
                    styleUtil.forRulesInStyles(styles, this._boundFindApplications);
                    if (elementProto) {
                        elementProto.__applyShimInvalid = !1
                    }
                    this.__currentElementProto = null
                },
                _findDefinitions: function(rule) {
                    var cssText = rule.parsedCssText;
                    cssText = cssText.replace(BAD_VAR, fixVars);
                    cssText = cssText.replace(VAR_ASSIGN, produceCssProperties);
                    rule.cssText = cssText;
                    if (":root" === rule.selector) {
                        rule.selector = ":host > *"
                    }
                },
                _findApplications: function(rule) {
                    rule.cssText = consumeCssProperties(rule.cssText)
                },
                transformRule: function(rule) {
                    this._findDefinitions(rule);
                    this._findApplications(rule)
                },
                _getInitialValueForProperty: function(property) {
                    if (!this._measureElement) {
                        this._measureElement = document.createElement("meta");
                        this._measureElement.style.all = "initial";
                        document.head.appendChild(this._measureElement)
                    }
                    return window.getComputedStyle(this._measureElement).getPropertyValue(property)
                }
            };
            ApplyShim._boundTransformRule = ApplyShim.transformRule.bind(ApplyShim);
            ApplyShim._boundFindDefinitions = ApplyShim._findDefinitions.bind(ApplyShim);
            ApplyShim._boundFindApplications = ApplyShim._findApplications.bind(ApplyShim);
            return ApplyShim
        }();
        (function() {
            var prepElement = Polymer.Base._prepElement,
                nativeShadow = Polymer.Settings.useNativeShadow,
                styleUtil = Polymer.StyleUtil,
                styleTransformer = Polymer.StyleTransformer,
                styleExtends = Polymer.StyleExtends,
                applyShim = Polymer.ApplyShim,
                settings = Polymer.Settings;
            Polymer.Base._addFeature({
                _prepElement: function(element) {
                    if (this._encapsulateStyle && "shady" !== this.__cssBuild) {
                        styleTransformer.element(element, this.is, this._scopeCssViaAttr)
                    }
                    prepElement.call(this, element)
                },
                _prepStyles: function() {
                    if (this._encapsulateStyle === void 0) {
                        this._encapsulateStyle = !nativeShadow
                    }
                    if (!nativeShadow) {
                        this._scopeStyle = styleUtil.applyStylePlaceHolder(this.is)
                    }
                    this.__cssBuild = styleUtil.cssBuildTypeForModule(this.is)
                },
                _prepShimStyles: function() {
                    if (this._template) {
                        var hasTargetedCssBuild = styleUtil.isTargetedBuild(this.__cssBuild);
                        if (settings.useNativeCSSProperties && "shadow" === this.__cssBuild && hasTargetedCssBuild) {
                            if (settings.preserveStyleIncludes) {
                                styleUtil.styleIncludesToTemplate(this._template)
                            }
                            return
                        }
                        this._styles = this._styles || this._collectStyles();
                        if (settings.useNativeCSSProperties && !this.__cssBuild) {
                            applyShim.transform(this._styles, this)
                        }
                        var cssText = settings.useNativeCSSProperties && hasTargetedCssBuild ? this._styles.length && this._styles[0].textContent.trim() : styleTransformer.elementStyles(this);
                        this._prepStyleProperties();
                        if (!this._needsStyleProperties() && cssText) {
                            styleUtil.applyCss(cssText, this.is, nativeShadow ? this._template.content : null, this._scopeStyle)
                        }
                    } else {
                        this._styles = []
                    }
                },
                _collectStyles: function() {
                    var styles = [],
                        cssText = "",
                        m$ = this.styleModules;
                    if (m$) {
                        for (var i = 0, l = m$.length, m; i < l && (m = m$[i]); i++) {
                            cssText += styleUtil.cssFromModule(m)
                        }
                    }
                    cssText += styleUtil.cssFromModule(this.is);
                    var p = this._template && this._template.parentNode;
                    if (this._template && (!p || p.id.toLowerCase() !== this.is)) {
                        cssText += styleUtil.cssFromElement(this._template)
                    }
                    if (cssText) {
                        var style = document.createElement("style");
                        style.textContent = cssText;
                        if (styleExtends.hasExtends(style.textContent)) {
                            cssText = styleExtends.transform(style)
                        }
                        styles.push(style)
                    }
                    return styles
                },
                _elementAdd: function(node) {
                    if (this._encapsulateStyle) {
                        if (node.__styleScoped) {
                            node.__styleScoped = !1
                        } else {
                            styleTransformer.dom(node, this.is, this._scopeCssViaAttr)
                        }
                    }
                },
                _elementRemove: function(node) {
                    if (this._encapsulateStyle) {
                        styleTransformer.dom(node, this.is, this._scopeCssViaAttr, !0)
                    }
                },
                scopeSubtree: function(container, shouldObserve) {
                    if (nativeShadow) {
                        return
                    }
                    var self = this,
                        scopify = function(node) {
                            if (node.nodeType === Node.ELEMENT_NODE) {
                                var className = node.getAttribute("class");
                                node.setAttribute("class", self._scopeElementClass(node, className));
                                for (var n$ = node.querySelectorAll("*"), i = 0, n; i < n$.length && (n = n$[i]); i++) {
                                    className = n.getAttribute("class");
                                    n.setAttribute("class", self._scopeElementClass(n, className))
                                }
                            }
                        };
                    scopify(container);
                    if (shouldObserve) {
                        var mo = new MutationObserver(function(mxns) {
                            for (var i = 0, m; i < mxns.length && (m = mxns[i]); i++) {
                                if (m.addedNodes) {
                                    for (var j = 0; j < m.addedNodes.length; j++) {
                                        scopify(m.addedNodes[j])
                                    }
                                }
                            }
                        });
                        mo.observe(container, {
                            childList: !0,
                            subtree: !0
                        });
                        return mo
                    }
                }
            })
        })();
        Polymer.StyleProperties = function() {
            "use strict";
            var matchesSelector = Polymer.DomApi.matchesSelector,
                styleUtil = Polymer.StyleUtil,
                styleTransformer = Polymer.StyleTransformer,
                IS_IE = navigator.userAgent.match("Trident"),
                settings = Polymer.Settings;
            return {
                decorateStyles: function(styles, scope) {
                    var self = this,
                        props = {},
                        keyframes = [],
                        ruleIndex = 0,
                        scopeSelector = styleTransformer._calcHostScope(scope.is, scope.extends);
                    styleUtil.forRulesInStyles(styles, function(rule, style) {
                        self.decorateRule(rule);
                        rule.index = ruleIndex++;
                        self.whenHostOrRootRule(scope, rule, style, function(info) {
                            if (rule.parent.type === styleUtil.ruleTypes.MEDIA_RULE) {
                                scope.__notStyleScopeCacheable = !0
                            }
                            if (info.isHost) {
                                var hostContextOrFunction = info.selector.split(" ").some(function(s) {
                                    return 0 === s.indexOf(scopeSelector) && s.length !== scopeSelector.length
                                });
                                scope.__notStyleScopeCacheable = scope.__notStyleScopeCacheable || hostContextOrFunction
                            }
                        });
                        self.collectPropertiesInCssText(rule.propertyInfo.cssText, props)
                    }, function(rule) {
                        keyframes.push(rule)
                    });
                    styles._keyframes = keyframes;
                    var names = [];
                    for (var i in props) {
                        names.push(i)
                    }
                    return names
                },
                decorateRule: function(rule) {
                    if (rule.propertyInfo) {
                        return rule.propertyInfo
                    }
                    var info = {},
                        properties = {},
                        hasProperties = this.collectProperties(rule, properties);
                    if (hasProperties) {
                        info.properties = properties;
                        rule.rules = null
                    }
                    info.cssText = this.collectCssText(rule);
                    rule.propertyInfo = info;
                    return info
                },
                collectProperties: function(rule, properties) {
                    var info = rule.propertyInfo;
                    if (info) {
                        if (info.properties) {
                            Polymer.Base.mixin(properties, info.properties);
                            return !0
                        }
                    } else {
                        var m, rx = this.rx.VAR_ASSIGN,
                            cssText = rule.parsedCssText,
                            value, any;
                        while (m = rx.exec(cssText)) {
                            value = (m[2] || m[3]).trim();
                            if ("inherit" !== value) {
                                properties[m[1].trim()] = value
                            }
                            any = !0
                        }
                        return any
                    }
                },
                collectCssText: function(rule) {
                    return this.collectConsumingCssText(rule.parsedCssText)
                },
                collectConsumingCssText: function(cssText) {
                    return cssText.replace(this.rx.BRACKETED, "").replace(this.rx.VAR_ASSIGN, "")
                },
                collectPropertiesInCssText: function(cssText, props) {
                    var m;
                    while (m = this.rx.VAR_CONSUMED.exec(cssText)) {
                        var name = m[1];
                        if (":" !== m[2]) {
                            props[name] = !0
                        }
                    }
                },
                reify: function(props) {
                    for (var names = Object.getOwnPropertyNames(props), i = 0, n; i < names.length; i++) {
                        n = names[i];
                        props[n] = this.valueForProperty(props[n], props)
                    }
                },
                valueForProperty: function(property, props) {
                    if (property) {
                        if (0 <= property.indexOf(";")) {
                            property = this.valueForProperties(property, props)
                        } else {
                            var self = this,
                                fn = function(prefix, value, fallback, suffix) {
                                    var propertyValue = self.valueForProperty(props[value], props);
                                    if (!propertyValue || "initial" === propertyValue) {
                                        propertyValue = self.valueForProperty(props[fallback] || fallback, props) || fallback
                                    } else if ("apply-shim-inherit" === propertyValue) {
                                        propertyValue = "inherit"
                                    }
                                    return prefix + (propertyValue || "") + suffix
                                };
                            property = styleUtil.processVariableAndFallback(property, fn)
                        }
                    }
                    return property && property.trim() || ""
                },
                valueForProperties: function(property, props) {
                    for (var parts = property.split(";"), i = 0, p, m; i < parts.length; i++) {
                        if (p = parts[i]) {
                            this.rx.MIXIN_MATCH.lastIndex = 0;
                            m = this.rx.MIXIN_MATCH.exec(p);
                            if (m) {
                                p = this.valueForProperty(props[m[1]], props)
                            } else {
                                var colon = p.indexOf(":");
                                if (-1 !== colon) {
                                    var pp = p.substring(colon);
                                    pp = pp.trim();
                                    pp = this.valueForProperty(pp, props) || pp;
                                    p = p.substring(0, colon) + pp
                                }
                            }
                            parts[i] = p && p.lastIndexOf(";") === p.length - 1 ? p.slice(0, -1) : p || ""
                        }
                    }
                    return parts.join(";")
                },
                applyProperties: function(rule, props) {
                    var output = "";
                    if (!rule.propertyInfo) {
                        this.decorateRule(rule)
                    }
                    if (rule.propertyInfo.cssText) {
                        output = this.valueForProperties(rule.propertyInfo.cssText, props)
                    }
                    rule.cssText = output
                },
                applyKeyframeTransforms: function(rule, keyframeTransforms) {
                    var input = rule.cssText,
                        output = rule.cssText;
                    if (null == rule.hasAnimations) {
                        rule.hasAnimations = this.rx.ANIMATION_MATCH.test(input)
                    }
                    if (rule.hasAnimations) {
                        var transform;
                        if (null == rule.keyframeNamesToTransform) {
                            rule.keyframeNamesToTransform = [];
                            for (var keyframe in keyframeTransforms) {
                                transform = keyframeTransforms[keyframe];
                                output = transform(input);
                                if (input !== output) {
                                    input = output;
                                    rule.keyframeNamesToTransform.push(keyframe)
                                }
                            }
                        } else {
                            for (var i = 0; i < rule.keyframeNamesToTransform.length; ++i) {
                                transform = keyframeTransforms[rule.keyframeNamesToTransform[i]];
                                input = transform(input)
                            }
                            output = input
                        }
                    }
                    rule.cssText = output
                },
                propertyDataFromStyles: function(styles, element) {
                    var props = {},
                        self = this,
                        o = [];
                    styleUtil.forActiveRulesInStyles(styles, function(rule) {
                        if (!rule.propertyInfo) {
                            self.decorateRule(rule)
                        }
                        var selectorToMatch = rule.transformedSelector || rule.parsedSelector;
                        if (element && rule.propertyInfo.properties && selectorToMatch) {
                            if (matchesSelector.call(element, selectorToMatch)) {
                                self.collectProperties(rule, props);
                                addToBitMask(rule.index, o)
                            }
                        }
                    });
                    return {
                        properties: props,
                        key: o
                    }
                },
                _rootSelector: /:root|:host\s*>\s*\*/,
                _checkRoot: function(hostScope, selector) {
                    return !!selector.match(this._rootSelector) || "html" === hostScope && -1 < selector.indexOf("html")
                },
                whenHostOrRootRule: function(scope, rule, style, callback) {
                    if (!rule.propertyInfo) {
                        self.decorateRule(rule)
                    }
                    if (!rule.propertyInfo.properties) {
                        return
                    }
                    var hostScope = scope.is ? styleTransformer._calcHostScope(scope.is, scope.extends) : "html",
                        parsedSelector = rule.parsedSelector,
                        isRoot = this._checkRoot(hostScope, parsedSelector),
                        isHost = !isRoot && 0 === parsedSelector.indexOf(":host"),
                        cssBuild = scope.__cssBuild || style.__cssBuild;
                    if ("shady" === cssBuild) {
                        isRoot = parsedSelector === hostScope + " > *." + hostScope || -1 < parsedSelector.indexOf("html");
                        isHost = !isRoot && 0 === parsedSelector.indexOf(hostScope)
                    }
                    if (!isRoot && !isHost) {
                        return
                    }
                    var selectorToMatch = hostScope;
                    if (isHost) {
                        if (settings.useNativeShadow && !rule.transformedSelector) {
                            rule.transformedSelector = styleTransformer._transformRuleCss(rule, styleTransformer._transformComplexSelector, scope.is, hostScope)
                        }
                        selectorToMatch = rule.transformedSelector || rule.parsedSelector
                    }
                    if (isRoot && "html" === hostScope) {
                        selectorToMatch = rule.transformedSelector || rule.parsedSelector
                    }
                    callback({
                        selector: selectorToMatch,
                        isHost: isHost,
                        isRoot: isRoot
                    })
                },
                hostAndRootPropertiesForScope: function(scope) {
                    var hostProps = {},
                        rootProps = {},
                        self = this;
                    styleUtil.forActiveRulesInStyles(scope._styles, function(rule, style) {
                        self.whenHostOrRootRule(scope, rule, style, function(info) {
                            var element = scope._element || scope;
                            if (matchesSelector.call(element, info.selector)) {
                                if (info.isHost) {
                                    self.collectProperties(rule, hostProps)
                                } else {
                                    self.collectProperties(rule, rootProps)
                                }
                            }
                        })
                    });
                    return {
                        rootProps: rootProps,
                        hostProps: hostProps
                    }
                },
                transformStyles: function(element, properties, scopeSelector) {
                    var self = this,
                        hostSelector = styleTransformer._calcHostScope(element.is, element.extends),
                        rxHostSelector = element.extends ? "\\" + hostSelector.slice(0, -1) + "\\]" : hostSelector,
                        hostRx = new RegExp(this.rx.HOST_PREFIX + rxHostSelector + this.rx.HOST_SUFFIX),
                        keyframeTransforms = this._elementKeyframeTransforms(element, scopeSelector);
                    return styleTransformer.elementStyles(element, function(rule) {
                        self.applyProperties(rule, properties);
                        if (!settings.useNativeShadow && !Polymer.StyleUtil.isKeyframesSelector(rule) && rule.cssText) {
                            self.applyKeyframeTransforms(rule, keyframeTransforms);
                            self._scopeSelector(rule, hostRx, hostSelector, element._scopeCssViaAttr, scopeSelector)
                        }
                    })
                },
                _elementKeyframeTransforms: function(element, scopeSelector) {
                    var keyframesRules = element._styles._keyframes,
                        keyframeTransforms = {};
                    if (!settings.useNativeShadow && keyframesRules) {
                        for (var i = 0, keyframesRule = keyframesRules[i]; i < keyframesRules.length; keyframesRule = keyframesRules[++i]) {
                            this._scopeKeyframes(keyframesRule, scopeSelector);
                            keyframeTransforms[keyframesRule.keyframesName] = this._keyframesRuleTransformer(keyframesRule)
                        }
                    }
                    return keyframeTransforms
                },
                _keyframesRuleTransformer: function(keyframesRule) {
                    return function(cssText) {
                        return cssText.replace(keyframesRule.keyframesNameRx, keyframesRule.transformedKeyframesName)
                    }
                },
                _scopeKeyframes: function(rule, scopeId) {
                    rule.keyframesNameRx = new RegExp("\\b" + rule.keyframesName + "(?!\\B|-)", "g");
                    rule.transformedKeyframesName = rule.keyframesName + "-" + scopeId;
                    rule.transformedSelector = rule.transformedSelector || rule.selector;
                    rule.selector = rule.transformedSelector.replace(rule.keyframesName, rule.transformedKeyframesName)
                },
                _hasDirOrHostContext: function(parsedSelector) {
                    return /:host-context|:dir/.test(parsedSelector)
                },
                _scopeSelector: function(rule, hostRx, hostSelector, viaAttr, scopeId) {
                    rule.transformedSelector = rule.transformedSelector || rule.selector;
                    for (var selector = rule.transformedSelector, scope = styleTransformer._calcElementScope(scopeId, viaAttr), hostScope = styleTransformer._calcElementScope(hostSelector, viaAttr), parts = selector.split(","), isDirOrHostContextSelector = this._hasDirOrHostContext(rule.parsedSelector), i = 0, l = parts.length, p; i < l && (p = parts[i]); i++) {
                        parts[i] = p.match(hostRx) ? p.replace(hostSelector, scope) : isDirOrHostContextSelector ? p.replace(hostScope, scope + " " + hostScope) : scope + " " + p
                    }
                    rule.selector = parts.join(",")
                },
                applyElementScopeSelector: function(element, selector, old, viaAttr) {
                    var c = viaAttr ? element.getAttribute(styleTransformer.SCOPE_NAME) : element.getAttribute("class") || "",
                        v = old ? c.replace(old, selector) : (c ? c + " " : "") + this.XSCOPE_NAME + " " + selector;
                    if (c !== v) {
                        if (viaAttr) {
                            element.setAttribute(styleTransformer.SCOPE_NAME, v)
                        } else {
                            element.setAttribute("class", v)
                        }
                    }
                },
                applyElementStyle: function(element, properties, selector, style) {
                    var cssText = style ? style.textContent || "" : this.transformStyles(element, properties, selector),
                        s = element._customStyle;
                    if (s && !settings.useNativeShadow && s !== style) {
                        s._useCount--;
                        if (0 >= s._useCount && s.parentNode) {
                            s.parentNode.removeChild(s)
                        }
                    }
                    if (settings.useNativeShadow) {
                        if (element._customStyle) {
                            element._customStyle.textContent = cssText;
                            style = element._customStyle
                        } else if (cssText) {
                            style = styleUtil.applyCss(cssText, selector, element.root, element._scopeStyle)
                        }
                    } else {
                        if (!style) {
                            if (cssText) {
                                style = styleUtil.applyCss(cssText, selector, null, element._scopeStyle)
                            }
                        } else if (!style.parentNode) {
                            if (IS_IE && -1 < cssText.indexOf("@media")) {
                                style.textContent = cssText
                            }
                            styleUtil.applyStyle(style, null, element._scopeStyle)
                        }
                    }
                    if (style) {
                        style._useCount = style._useCount || 0;
                        if (element._customStyle != style) {
                            style._useCount++
                        }
                        element._customStyle = style
                    }
                    return style
                },
                mixinCustomStyle: function(props, customStyle) {
                    var v;
                    for (var i in customStyle) {
                        v = customStyle[i];
                        if (v || 0 === v) {
                            props[i] = v
                        }
                    }
                },
                updateNativeStyleProperties: function(element, properties) {
                    var oldPropertyNames = element.__customStyleProperties;
                    if (oldPropertyNames) {
                        for (var i = 0; i < oldPropertyNames.length; i++) {
                            element.style.removeProperty(oldPropertyNames[i])
                        }
                    }
                    var propertyNames = [];
                    for (var p in properties) {
                        if (null !== properties[p]) {
                            element.style.setProperty(p, properties[p]);
                            propertyNames.push(p)
                        }
                    }
                    element.__customStyleProperties = propertyNames
                },
                rx: styleUtil.rx,
                XSCOPE_NAME: "x-scope"
            };

            function addToBitMask(n, bits) {
                var o = parseInt(n / 32);
                bits[o] = (bits[o] || 0) | 1 << n % 32
            }
        }();
        (function() {
            Polymer.StyleCache = function() {
                this.cache = {}
            };
            Polymer.StyleCache.prototype = {
                MAX: 100,
                store: function(is, data, keyValues, keyStyles) {
                    data.keyValues = keyValues;
                    data.styles = keyStyles;
                    var s$ = this.cache[is] = this.cache[is] || [];
                    s$.push(data);
                    if (s$.length > this.MAX) {
                        s$.shift()
                    }
                },
                retrieve: function(is, keyValues, keyStyles) {
                    var cache = this.cache[is];
                    if (cache) {
                        for (var i = cache.length - 1, data; 0 <= i; i--) {
                            data = cache[i];
                            if (keyStyles === data.styles && this._objectsEqual(keyValues, data.keyValues)) {
                                return data
                            }
                        }
                    }
                },
                clear: function() {
                    this.cache = {}
                },
                _objectsEqual: function(target, source) {
                    var t, s;
                    for (var i in target) {
                        t = target[i], s = source[i];
                        if (!("object" === typeof t && t ? this._objectsStrictlyEqual(t, s) : t === s)) {
                            return !1
                        }
                    }
                    if (Array.isArray(target)) {
                        return target.length === source.length
                    }
                    return !0
                },
                _objectsStrictlyEqual: function(target, source) {
                    return this._objectsEqual(target, source) && this._objectsEqual(source, target)
                }
            }
        })();
        Polymer.StyleDefaults = function() {
            var styleProperties = Polymer.StyleProperties,
                StyleCache = Polymer.StyleCache,
                nativeVariables = Polymer.Settings.useNativeCSSProperties,
                api = {
                    _styles: [],
                    _properties: null,
                    customStyle: {},
                    _styleCache: new StyleCache,
                    _element: Polymer.DomApi.wrap(document.documentElement),
                    addStyle: function(style) {
                        this._styles.push(style);
                        this._properties = null
                    },
                    get _styleProperties() {
                        if (!this._properties) {
                            styleProperties.decorateStyles(this._styles, this);
                            this._styles._scopeStyleProperties = null;
                            this._properties = styleProperties.hostAndRootPropertiesForScope(this).rootProps;
                            styleProperties.mixinCustomStyle(this._properties, this.customStyle);
                            styleProperties.reify(this._properties)
                        }
                        return this._properties
                    },
                    hasStyleProperties: function() {
                        return !!this._properties
                    },
                    _needsStyleProperties: function() {},
                    _computeStyleProperties: function() {
                        return this._styleProperties
                    },
                    updateStyles: function(properties) {
                        this._properties = null;
                        if (properties) {
                            Polymer.Base.mixin(this.customStyle, properties)
                        }
                        this._styleCache.clear();
                        for (var i = 0, s; i < this._styles.length; i++) {
                            s = this._styles[i];
                            s = s.__importElement || s;
                            s._apply()
                        }
                        if (nativeVariables) {
                            styleProperties.updateNativeStyleProperties(document.documentElement, this.customStyle)
                        }
                    }
                };
            return api
        }();
        (function() {
            "use strict";
            var serializeValueToAttribute = Polymer.Base.serializeValueToAttribute,
                propertyUtils = Polymer.StyleProperties,
                styleTransformer = Polymer.StyleTransformer,
                styleDefaults = Polymer.StyleDefaults,
                nativeShadow = Polymer.Settings.useNativeShadow,
                nativeVariables = Polymer.Settings.useNativeCSSProperties;
            Polymer.Base._addFeature({
                _prepStyleProperties: function() {
                    if (!nativeVariables) {
                        this._ownStylePropertyNames = this._styles && this._styles.length ? propertyUtils.decorateStyles(this._styles, this) : null
                    }
                },
                customStyle: null,
                getComputedStyleValue: function(property) {
                    if (!nativeVariables && !this._styleProperties) {
                        this._computeStyleProperties()
                    }
                    return !nativeVariables && this._styleProperties && this._styleProperties[property] || getComputedStyle(this).getPropertyValue(property)
                },
                _setupStyleProperties: function() {
                    this.customStyle = {};
                    this._styleCache = null;
                    this._styleProperties = null;
                    this._scopeSelector = null;
                    this._ownStyleProperties = null;
                    this._customStyle = null
                },
                _needsStyleProperties: function() {
                    return !!(!nativeVariables && this._ownStylePropertyNames && this._ownStylePropertyNames.length)
                },
                _validateApplyShim: function() {
                    if (this.__applyShimInvalid) {
                        Polymer.ApplyShim.transform(this._styles, this.__proto__);
                        var cssText = styleTransformer.elementStyles(this);
                        if (nativeShadow) {
                            var templateStyle = this._template.content.querySelector("style");
                            if (templateStyle) {
                                templateStyle.textContent = cssText
                            }
                        } else {
                            var shadyStyle = this._scopeStyle && this._scopeStyle.nextSibling;
                            if (shadyStyle) {
                                shadyStyle.textContent = cssText
                            }
                        }
                    }
                },
                _beforeAttached: function() {
                    if ((!this._scopeSelector || this.__stylePropertiesInvalid) && this._needsStyleProperties()) {
                        this.__stylePropertiesInvalid = !1;
                        this._updateStyleProperties()
                    }
                },
                _findStyleHost: function() {
                    var e = this,
                        root;
                    while (root = Polymer.dom(e).getOwnerRoot()) {
                        if (Polymer.isInstance(root.host)) {
                            return root.host
                        }
                        e = root.host
                    }
                    return styleDefaults
                },
                _updateStyleProperties: function() {
                    var info, scope = this._findStyleHost();
                    if (!scope._styleProperties) {
                        scope._computeStyleProperties()
                    }
                    if (!scope._styleCache) {
                        scope._styleCache = new Polymer.StyleCache
                    }
                    var scopeData = propertyUtils.propertyDataFromStyles(scope._styles, this),
                        scopeCacheable = !this.__notStyleScopeCacheable;
                    if (scopeCacheable) {
                        scopeData.key.customStyle = this.customStyle;
                        info = scope._styleCache.retrieve(this.is, scopeData.key, this._styles)
                    }
                    var scopeCached = !!info;
                    if (scopeCached) {
                        this._styleProperties = info._styleProperties
                    } else {
                        this._computeStyleProperties(scopeData.properties)
                    }
                    this._computeOwnStyleProperties();
                    if (!scopeCached) {
                        info = styleCache.retrieve(this.is, this._ownStyleProperties, this._styles)
                    }
                    var globalCached = !!info && !scopeCached,
                        style = this._applyStyleProperties(info);
                    if (!scopeCached) {
                        style = style && nativeShadow ? style.cloneNode(!0) : style;
                        info = {
                            style: style,
                            _scopeSelector: this._scopeSelector,
                            _styleProperties: this._styleProperties
                        };
                        if (scopeCacheable) {
                            scopeData.key.customStyle = {};
                            this.mixin(scopeData.key.customStyle, this.customStyle);
                            scope._styleCache.store(this.is, info, scopeData.key, this._styles)
                        }
                        if (!globalCached) {
                            styleCache.store(this.is, Object.create(info), this._ownStyleProperties, this._styles)
                        }
                    }
                },
                _computeStyleProperties: function(scopeProps) {
                    var scope = this._findStyleHost();
                    if (!scope._styleProperties) {
                        scope._computeStyleProperties()
                    }
                    var props = Object.create(scope._styleProperties),
                        hostAndRootProps = propertyUtils.hostAndRootPropertiesForScope(this);
                    this.mixin(props, hostAndRootProps.hostProps);
                    scopeProps = scopeProps || propertyUtils.propertyDataFromStyles(scope._styles, this).properties;
                    this.mixin(props, scopeProps);
                    this.mixin(props, hostAndRootProps.rootProps);
                    propertyUtils.mixinCustomStyle(props, this.customStyle);
                    propertyUtils.reify(props);
                    this._styleProperties = props
                },
                _computeOwnStyleProperties: function() {
                    for (var props = {}, i = 0, n; i < this._ownStylePropertyNames.length; i++) {
                        n = this._ownStylePropertyNames[i];
                        props[n] = this._styleProperties[n]
                    }
                    this._ownStyleProperties = props
                },
                _scopeCount: 0,
                _applyStyleProperties: function(info) {
                    var oldScopeSelector = this._scopeSelector;
                    this._scopeSelector = info ? info._scopeSelector : this.is + "-" + this.__proto__._scopeCount++;
                    var style = propertyUtils.applyElementStyle(this, this._styleProperties, this._scopeSelector, info && info.style);
                    if (!nativeShadow) {
                        propertyUtils.applyElementScopeSelector(this, this._scopeSelector, oldScopeSelector, this._scopeCssViaAttr)
                    }
                    return style
                },
                serializeValueToAttribute: function(value, attribute, node) {
                    node = node || this;
                    if ("class" === attribute && !nativeShadow) {
                        var host = node === this ? this.domHost || this.dataHost : this;
                        if (host) {
                            value = host._scopeElementClass(node, value)
                        }
                    }
                    node = this.shadyRoot && this.shadyRoot._hasDistributed ? Polymer.dom(node) : node;
                    serializeValueToAttribute.call(this, value, attribute, node)
                },
                _scopeElementClass: function(element, selector) {
                    if (!nativeShadow && !this._scopeCssViaAttr) {
                        selector = (selector ? selector + " " : "") + SCOPE_NAME + " " + this.is + (element._scopeSelector ? " " + XSCOPE_NAME + " " + element._scopeSelector : "")
                    }
                    return selector
                },
                updateStyles: function(properties) {
                    if (properties) {
                        this.mixin(this.customStyle, properties)
                    }
                    if (nativeVariables) {
                        propertyUtils.updateNativeStyleProperties(this, this.customStyle)
                    } else {
                        if (this.isAttached) {
                            if (this._needsStyleProperties()) {
                                this._updateStyleProperties()
                            } else {
                                this._styleProperties = null
                            }
                        } else {
                            this.__stylePropertiesInvalid = !0
                        }
                        if (this._styleCache) {
                            this._styleCache.clear()
                        }
                        this._updateRootStyles()
                    }
                },
                _updateRootStyles: function(root) {
                    root = root || this.root;
                    for (var c$ = Polymer.dom(root)._query(function(e) {
                            return e.shadyRoot || e.shadowRoot
                        }), i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {
                        if (c.updateStyles) {
                            c.updateStyles()
                        }
                    }
                }
            });
            Polymer.updateStyles = function(properties) {
                styleDefaults.updateStyles(properties);
                Polymer.Base._updateRootStyles(document)
            };
            var styleCache = new Polymer.StyleCache;
            Polymer.customStyleCache = styleCache;
            var SCOPE_NAME = styleTransformer.SCOPE_NAME,
                XSCOPE_NAME = propertyUtils.XSCOPE_NAME
        })();
        Polymer.Base._addFeature({
            _registerFeatures: function() {
                this._prepIs();
                if (this.factoryImpl) {
                    this._prepConstructor()
                }
                this._prepStyles()
            },
            _finishRegisterFeatures: function() {
                this._prepTemplate();
                this._prepShimStyles();
                this._prepAnnotations();
                this._prepEffects();
                this._prepBehaviors();
                this._prepPropertyInfo();
                this._prepBindings();
                this._prepShady()
            },
            _prepBehavior: function(b) {
                this._addPropertyEffects(b.properties);
                this._addComplexObserverEffects(b.observers);
                this._addHostAttributes(b.hostAttributes)
            },
            _initFeatures: function() {
                this._setupGestures();
                this._setupConfigure(this.__data__);
                this._setupStyleProperties();
                this._setupDebouncers();
                this._setupShady();
                this._registerHost();
                if (this._template) {
                    this._validateApplyShim();
                    this._poolContent();
                    this._beginHosting();
                    this._stampTemplate();
                    this._endHosting();
                    this._marshalAnnotationReferences()
                }
                this._marshalInstanceEffects();
                this._marshalBehaviors();
                this._marshalHostAttributes();
                this._marshalAttributes();
                this._tryReady()
            },
            _marshalBehavior: function(b) {
                if (b.listeners) {
                    this._listenListeners(b.listeners)
                }
            }
        });
        (function() {
            var propertyUtils = Polymer.StyleProperties,
                styleUtil = Polymer.StyleUtil,
                cssParse = Polymer.CssParse,
                styleDefaults = Polymer.StyleDefaults,
                styleTransformer = Polymer.StyleTransformer,
                applyShim = Polymer.ApplyShim,
                debounce = Polymer.Debounce,
                settings = Polymer.Settings,
                updateDebouncer;
            Polymer({
                is: "custom-style",
                extends: "style",
                _template: null,
                properties: {
                    include: String
                },
                ready: function() {
                    this.__appliedElement = this.__appliedElement || this;
                    this.__cssBuild = styleUtil.getCssBuildType(this);
                    if (this.__appliedElement !== this) {
                        this.__appliedElement.__cssBuild = this.__cssBuild
                    }
                    if (this.ownerDocument !== window.document && this.__appliedElement === this) {
                        document.head.appendChild(this)
                    }
                    this._tryApply()
                },
                attached: function() {
                    this._tryApply()
                },
                _tryApply: function() {
                    if (!this._appliesToDocument) {
                        if (this.parentNode && "dom-module" !== this.parentNode.localName) {
                            this._appliesToDocument = !0;
                            var e = this.__appliedElement;
                            if (!settings.useNativeCSSProperties) {
                                this.__needsUpdateStyles = styleDefaults.hasStyleProperties();
                                styleDefaults.addStyle(e)
                            }
                            if (e.textContent || this.include) {
                                this._apply(!0)
                            } else {
                                var self = this,
                                    observer = new MutationObserver(function() {
                                        observer.disconnect();
                                        self._apply(!0)
                                    });
                                observer.observe(e, {
                                    childList: !0
                                })
                            }
                        }
                    }
                },
                _updateStyles: function() {
                    Polymer.updateStyles()
                },
                _apply: function(initialApply) {
                    var e = this.__appliedElement;
                    if (this.include) {
                        e.textContent = styleUtil.cssFromModules(this.include, !0) + e.textContent
                    }
                    if (!e.textContent) {
                        return
                    }
                    var buildType = this.__cssBuild,
                        targetedBuild = styleUtil.isTargetedBuild(buildType);
                    if (settings.useNativeCSSProperties && targetedBuild) {
                        return
                    }
                    var styleRules = styleUtil.rulesForStyle(e);
                    if (!targetedBuild) {
                        styleUtil.forEachRule(styleRules, function(rule) {
                            styleTransformer.documentRule(rule)
                        });
                        if (settings.useNativeCSSProperties && !buildType) {
                            applyShim.transform([e])
                        }
                    }
                    if (settings.useNativeCSSProperties) {
                        e.textContent = styleUtil.toCssText(styleRules)
                    } else {
                        var self = this,
                            fn = function() {
                                self._flushCustomProperties()
                            };
                        if (initialApply) {
                            Polymer.RenderStatus.whenReady(fn)
                        } else {
                            fn()
                        }
                    }
                },
                _flushCustomProperties: function() {
                    if (this.__needsUpdateStyles) {
                        this.__needsUpdateStyles = !1;
                        updateDebouncer = debounce(updateDebouncer, this._updateStyles)
                    } else {
                        this._applyCustomProperties()
                    }
                },
                _applyCustomProperties: function() {
                    var element = this.__appliedElement;
                    this._computeStyleProperties();
                    var props = this._styleProperties,
                        rules = styleUtil.rulesForStyle(element);
                    if (!rules) {
                        return
                    }
                    element.textContent = styleUtil.toCssText(rules, function(rule) {
                        var css = rule.cssText = rule.parsedCssText;
                        if (rule.propertyInfo && rule.propertyInfo.cssText) {
                            css = cssParse.removeCustomPropAssignment(css);
                            rule.cssText = propertyUtils.valueForProperties(css, props)
                        }
                    })
                }
            })
        })();
        Polymer.Templatizer = {
            properties: {
                __hideTemplateChildren__: {
                    observer: "_showHideChildren"
                }
            },
            _instanceProps: Polymer.nob,
            _parentPropPrefix: "_parent_",
            templatize: function(template) {
                this._templatized = template;
                if (!template._content) {
                    template._content = template.content
                }
                if (template._content._ctor) {
                    this.ctor = template._content._ctor;
                    this._prepParentProperties(this.ctor.prototype, template);
                    return
                }
                var archetype = Object.create(Polymer.Base);
                this._customPrepAnnotations(archetype, template);
                this._prepParentProperties(archetype, template);
                archetype._prepEffects();
                this._customPrepEffects(archetype);
                archetype._prepBehaviors();
                archetype._prepPropertyInfo();
                archetype._prepBindings();
                archetype._notifyPathUp = this._notifyPathUpImpl;
                archetype._scopeElementClass = this._scopeElementClassImpl;
                archetype.listen = this._listenImpl;
                archetype._showHideChildren = this._showHideChildrenImpl;
                archetype.__setPropertyOrig = this.__setProperty;
                archetype.__setProperty = this.__setPropertyImpl;
                var _constructor = this._constructorImpl,
                    ctor = function(model, host) {
                        _constructor.call(this, model, host)
                    };
                ctor.prototype = archetype;
                archetype.constructor = ctor;
                template._content._ctor = ctor;
                this.ctor = ctor
            },
            _getRootDataHost: function() {
                return this.dataHost && this.dataHost._rootDataHost || this.dataHost
            },
            _showHideChildrenImpl: function(hide) {
                for (var c = this._children, i = 0, n; i < c.length; i++) {
                    n = c[i];
                    if (!!hide != !!n.__hideTemplateChildren__) {
                        if (n.nodeType === Node.TEXT_NODE) {
                            if (hide) {
                                n.__polymerTextContent__ = n.textContent;
                                n.textContent = ""
                            } else {
                                n.textContent = n.__polymerTextContent__
                            }
                        } else if (n.style) {
                            if (hide) {
                                n.__polymerDisplay__ = n.style.display;
                                n.style.display = "none"
                            } else {
                                n.style.display = n.__polymerDisplay__
                            }
                        }
                    }
                    n.__hideTemplateChildren__ = hide
                }
            },
            __setPropertyImpl: function(property, value, fromAbove, node) {
                if (node && node.__hideTemplateChildren__ && "textContent" == property) {
                    property = "__polymerTextContent__"
                }
                this.__setPropertyOrig(property, value, fromAbove, node)
            },
            _debounceTemplate: function(fn) {
                Polymer.dom.addDebouncer(this.debounce("_debounceTemplate", fn))
            },
            _flushTemplates: function() {
                Polymer.dom.flush()
            },
            _customPrepEffects: function(archetype) {
                var parentProps = archetype._parentProps;
                for (var prop in parentProps) {
                    archetype._addPropertyEffect(prop, "function", this._createHostPropEffector(prop))
                }
                for (prop in this._instanceProps) {
                    archetype._addPropertyEffect(prop, "function", this._createInstancePropEffector(prop))
                }
            },
            _customPrepAnnotations: function(archetype, template) {
                var t = archetype._template = document.createElement("template"),
                    c = t._content = template._content;
                if (!c._notes) {
                    var rootDataHost = archetype._rootDataHost;
                    if (rootDataHost) {
                        Polymer.Annotations.prepElement = function() {
                            rootDataHost._prepElement()
                        }
                    }
                    c._notes = Polymer.Annotations.parseAnnotations(template);
                    Polymer.Annotations.prepElement = null;
                    this._processAnnotations(c._notes)
                }
                archetype._notes = c._notes;
                archetype._parentProps = c._parentProps
            },
            _prepParentProperties: function(archetype, template) {
                var parentProps = this._parentProps = archetype._parentProps;
                if (this._forwardParentProp && parentProps) {
                    var proto = archetype._parentPropProto,
                        prop;
                    if (!proto) {
                        for (prop in this._instanceProps) {
                            delete parentProps[prop]
                        }
                        proto = archetype._parentPropProto = Object.create(null);
                        if (template != this) {
                            Polymer.Bind.prepareModel(proto);
                            Polymer.Base.prepareModelNotifyPath(proto)
                        }
                        for (prop in parentProps) {
                            var parentProp = this._parentPropPrefix + prop,
                                effects = [{
                                    kind: "function",
                                    effect: this._createForwardPropEffector(prop),
                                    fn: Polymer.Bind._functionEffect
                                }, {
                                    kind: "notify",
                                    fn: Polymer.Bind._notifyEffect,
                                    effect: {
                                        event: Polymer.CaseMap.camelToDashCase(parentProp) + "-changed"
                                    }
                                }];
                            proto._propertyEffects = proto._propertyEffects || {};
                            proto._propertyEffects[parentProp] = effects;
                            Polymer.Bind._createAccessors(proto, parentProp, effects)
                        }
                    }
                    var self = this;
                    if (template != this) {
                        Polymer.Bind.prepareInstance(template);
                        template._forwardParentProp = function(source, value) {
                            self._forwardParentProp(source, value)
                        }
                    }
                    this._extendTemplate(template, proto);
                    template._pathEffector = function(path, value, fromAbove) {
                        return self._pathEffectorImpl(path, value, fromAbove)
                    }
                }
            },
            _createForwardPropEffector: function(prop) {
                return function(source, value) {
                    this._forwardParentProp(prop, value)
                }
            },
            _createHostPropEffector: function(prop) {
                var prefix = this._parentPropPrefix;
                return function(source, value) {
                    this.dataHost._templatized[prefix + prop] = value
                }
            },
            _createInstancePropEffector: function(prop) {
                return function(source, value, old, fromAbove) {
                    if (!fromAbove) {
                        this.dataHost._forwardInstanceProp(this, prop, value)
                    }
                }
            },
            _extendTemplate: function(template, proto) {
                var n$ = Object.getOwnPropertyNames(proto);
                if (proto._propertySetter) {
                    template._propertySetter = proto._propertySetter
                }
                for (var i = 0, n, val; i < n$.length && (n = n$[i]); i++) {
                    val = template[n];
                    if (val && "_propertyEffects" == n) {
                        var pe = Polymer.Base.mixin({}, val);
                        template._propertyEffects = Polymer.Base.mixin(pe, proto._propertyEffects)
                    } else {
                        var pd = Object.getOwnPropertyDescriptor(proto, n);
                        Object.defineProperty(template, n, pd);
                        if (val !== void 0) {
                            template._propertySetter(n, val)
                        }
                    }
                }
            },
            _showHideChildren: function() {},
            _forwardInstancePath: function() {},
            _forwardInstanceProp: function() {},
            _notifyPathUpImpl: function(path, value) {
                var dataHost = this.dataHost,
                    root = Polymer.Path.root(path);
                dataHost._forwardInstancePath.call(dataHost, this, path, value);
                if (root in dataHost._parentProps) {
                    dataHost._templatized._notifyPath(dataHost._parentPropPrefix + path, value)
                }
            },
            _pathEffectorImpl: function(path, value, fromAbove) {
                if (this._forwardParentPath) {
                    if (0 === path.indexOf(this._parentPropPrefix)) {
                        var subPath = path.substring(this._parentPropPrefix.length),
                            model = Polymer.Path.root(subPath);
                        if (model in this._parentProps) {
                            this._forwardParentPath(subPath, value)
                        }
                    }
                }
                Polymer.Base._pathEffector.call(this._templatized, path, value, fromAbove)
            },
            _constructorImpl: function(model, host) {
                this._rootDataHost = host._getRootDataHost();
                this._setupConfigure(model);
                this._registerHost(host);
                this._beginHosting();
                this.root = this.instanceTemplate(this._template);
                this.root.__noContent = !this._notes._hasContent;
                this.root.__styleScoped = !0;
                this._endHosting();
                this._marshalAnnotatedNodes();
                this._marshalInstanceEffects();
                this._marshalAnnotatedListeners();
                for (var children = [], n = this.root.firstChild; n; n = n.nextSibling) {
                    children.push(n);
                    n._templateInstance = this
                }
                this._children = children;
                if (host.__hideTemplateChildren__) {
                    this._showHideChildren(!0)
                }
                this._tryReady()
            },
            _listenImpl: function(node, eventName, methodName) {
                var model = this,
                    host = this._rootDataHost,
                    handler = host._createEventHandler(node, eventName, methodName);
                host._listen(node, eventName, function(e) {
                    e.model = model;
                    handler(e)
                })
            },
            _scopeElementClassImpl: function(node, value) {
                var host = this._rootDataHost;
                if (host) {
                    return host._scopeElementClass(node, value)
                }
                return value
            },
            stamp: function(model) {
                model = model || {};
                if (this._parentProps) {
                    var templatized = this._templatized;
                    for (var prop in this._parentProps) {
                        if (model[prop] === void 0) {
                            model[prop] = templatized[this._parentPropPrefix + prop]
                        }
                    }
                }
                return new this.ctor(model, this)
            },
            modelForElement: function(el) {
                var model;
                while (el) {
                    if (model = el._templateInstance) {
                        if (model.dataHost != this) {
                            el = model.dataHost
                        } else {
                            return model
                        }
                    } else {
                        el = el.parentNode
                    }
                }
            }
        };
        Polymer({
            is: "dom-template",
            extends: "template",
            _template: null,
            behaviors: [Polymer.Templatizer],
            ready: function() {
                this.templatize(this)
            }
        });
        Polymer._collections = new WeakMap;
        Polymer.Collection = function(userArray) {
            Polymer._collections.set(userArray, this);
            this.userArray = userArray;
            this.store = userArray.slice();
            this.initMap()
        };
        Polymer.Collection.prototype = {
            constructor: Polymer.Collection,
            initMap: function() {
                for (var omap = this.omap = new WeakMap, pmap = this.pmap = {}, s = this.store, i = 0, item; i < s.length; i++) {
                    item = s[i];
                    if (item && "object" == typeof item) {
                        omap.set(item, i)
                    } else {
                        pmap[item] = i
                    }
                }
            },
            add: function(item) {
                var key = this.store.push(item) - 1;
                if (item && "object" == typeof item) {
                    this.omap.set(item, key)
                } else {
                    this.pmap[item] = key
                }
                return "#" + key
            },
            removeKey: function(key) {
                if (key = this._parseKey(key)) {
                    this._removeFromMap(this.store[key]);
                    delete this.store[key]
                }
            },
            _removeFromMap: function(item) {
                if (item && "object" == typeof item) {
                    this.omap.delete(item)
                } else {
                    delete this.pmap[item]
                }
            },
            remove: function(item) {
                var key = this.getKey(item);
                this.removeKey(key);
                return key
            },
            getKey: function(item) {
                var key;
                if (item && "object" == typeof item) {
                    key = this.omap.get(item)
                } else {
                    key = this.pmap[item]
                }
                if (key != void 0) {
                    return "#" + key
                }
            },
            getKeys: function() {
                return Object.keys(this.store).map(function(key) {
                    return "#" + key
                })
            },
            _parseKey: function(key) {
                if (key && "#" == key[0]) {
                    return key.slice(1)
                }
            },
            setItem: function(key, item) {
                if (key = this._parseKey(key)) {
                    var old = this.store[key];
                    if (old) {
                        this._removeFromMap(old)
                    }
                    if (item && "object" == typeof item) {
                        this.omap.set(item, key)
                    } else {
                        this.pmap[item] = key
                    }
                    this.store[key] = item
                }
            },
            getItem: function(key) {
                if (key = this._parseKey(key)) {
                    return this.store[key]
                }
            },
            getItems: function() {
                var items = [],
                    store = this.store;
                for (var key in store) {
                    items.push(store[key])
                }
                return items
            },
            _applySplices: function(splices) {
                for (var keyMap = {}, key, i = 0, s; i < splices.length && (s = splices[i]); i++) {
                    s.addedKeys = [];
                    for (var j = 0; j < s.removed.length; j++) {
                        key = this.getKey(s.removed[j]);
                        keyMap[key] = keyMap[key] ? null : -1
                    }
                    for (j = 0; j < s.addedCount; j++) {
                        var item = this.userArray[s.index + j];
                        key = this.getKey(item);
                        key = key === void 0 ? this.add(item) : key;
                        keyMap[key] = keyMap[key] ? null : 1;
                        s.addedKeys.push(key)
                    }
                }
                var removed = [],
                    added = [];
                for (key in keyMap) {
                    if (0 > keyMap[key]) {
                        this.removeKey(key);
                        removed.push(key)
                    }
                    if (0 < keyMap[key]) {
                        added.push(key)
                    }
                }
                return [{
                    removed: removed,
                    added: added
                }]
            }
        };
        Polymer.Collection.get = function(userArray) {
            return Polymer._collections.get(userArray) || new Polymer.Collection(userArray)
        };
        Polymer.Collection.applySplices = function(userArray, splices) {
            var coll = Polymer._collections.get(userArray);
            return coll ? coll._applySplices(splices) : null
        };
        Polymer({
            is: "dom-repeat",
            extends: "template",
            _template: null,
            properties: {
                items: {
                    type: Array
                },
                as: {
                    type: String,
                    value: "item"
                },
                indexAs: {
                    type: String,
                    value: "index"
                },
                sort: {
                    type: Function,
                    observer: "_sortChanged"
                },
                filter: {
                    type: Function,
                    observer: "_filterChanged"
                },
                observe: {
                    type: String,
                    observer: "_observeChanged"
                },
                delay: Number,
                renderedItemCount: {
                    type: Number,
                    notify: !Polymer.Settings.suppressTemplateNotifications,
                    readOnly: !0
                },
                initialCount: {
                    type: Number,
                    observer: "_initializeChunking"
                },
                targetFramerate: {
                    type: Number,
                    value: 20
                },
                notifyDomChange: {
                    type: Boolean
                },
                _targetFrameTime: {
                    type: Number,
                    computed: "_computeFrameTime(targetFramerate)"
                }
            },
            behaviors: [Polymer.Templatizer],
            observers: ["_itemsChanged(items.*)"],
            created: function() {
                this._instances = [];
                this._pool = [];
                this._limit = 1 / 0;
                var self = this;
                this._boundRenderChunk = function() {
                    self._renderChunk()
                }
            },
            detached: function() {
                this.__isDetached = !0;
                for (var i = 0; i < this._instances.length; i++) {
                    this._detachInstance(i)
                }
            },
            attached: function() {
                if (this.__isDetached) {
                    this.__isDetached = !1;
                    var refNode, parentNode = Polymer.dom(this).parentNode;
                    if (parentNode.localName == this.is) {
                        refNode = parentNode;
                        parentNode = Polymer.dom(parentNode).parentNode
                    } else {
                        refNode = this
                    }
                    for (var parent = Polymer.dom(parentNode), i = 0; i < this._instances.length; i++) {
                        this._attachInstance(i, parent, refNode)
                    }
                }
            },
            ready: function() {
                this._instanceProps = {
                    __key__: !0
                };
                this._instanceProps[this.as] = !0;
                this._instanceProps[this.indexAs] = !0;
                if (!this.ctor) {
                    this.templatize(this)
                }
            },
            _sortChanged: function(sort) {
                var dataHost = this._getRootDataHost();
                this._sortFn = sort && ("function" == typeof sort ? sort : function() {
                    return dataHost[sort].apply(dataHost, arguments)
                });
                this._needFullRefresh = !0;
                if (this.items) {
                    this._debounceTemplate(this._render)
                }
            },
            _filterChanged: function(filter) {
                var dataHost = this._getRootDataHost();
                this._filterFn = filter && ("function" == typeof filter ? filter : function() {
                    return dataHost[filter].apply(dataHost, arguments)
                });
                this._needFullRefresh = !0;
                if (this.items) {
                    this._debounceTemplate(this._render)
                }
            },
            _computeFrameTime: function(rate) {
                return Math.ceil(1e3 / rate)
            },
            _initializeChunking: function() {
                if (this.initialCount) {
                    this._limit = this.initialCount;
                    this._chunkCount = this.initialCount;
                    this._lastChunkTime = performance.now()
                }
            },
            _tryRenderChunk: function() {
                if (this.items && this._limit < this.items.length) {
                    this.debounce("renderChunk", this._requestRenderChunk)
                }
            },
            _requestRenderChunk: function() {
                requestAnimationFrame(this._boundRenderChunk)
            },
            _renderChunk: function() {
                var currChunkTime = performance.now(),
                    ratio = this._targetFrameTime / (currChunkTime - this._lastChunkTime);
                this._chunkCount = Math.round(this._chunkCount * ratio) || 1;
                this._limit += this._chunkCount;
                this._lastChunkTime = currChunkTime;
                this._debounceTemplate(this._render)
            },
            _observeChanged: function() {
                this._observePaths = this.observe && this.observe.replace(".*", ".").split(" ")
            },
            _itemsChanged: function(change) {
                if ("items" == change.path) {
                    if (Array.isArray(this.items)) {
                        this.collection = Polymer.Collection.get(this.items)
                    } else if (!this.items) {
                        this.collection = null
                    } else {
                        this._error(this._logf("dom-repeat", "expected array for `items`," + " found", this.items))
                    }
                    this._keySplices = [];
                    this._indexSplices = [];
                    this._needFullRefresh = !0;
                    this._initializeChunking();
                    this._debounceTemplate(this._render)
                } else if ("items.splices" == change.path) {
                    this._keySplices = this._keySplices.concat(change.value.keySplices);
                    this._indexSplices = this._indexSplices.concat(change.value.indexSplices);
                    this._debounceTemplate(this._render)
                } else {
                    var subpath = change.path.slice(6);
                    this._forwardItemPath(subpath, change.value);
                    this._checkObservedPaths(subpath)
                }
            },
            _checkObservedPaths: function(path) {
                if (this._observePaths) {
                    path = path.substring(path.indexOf(".") + 1);
                    for (var paths = this._observePaths, i = 0; i < paths.length; i++) {
                        if (0 === path.indexOf(paths[i])) {
                            this._needFullRefresh = !0;
                            if (this.delay) {
                                this.debounce("render", this._render, this.delay)
                            } else {
                                this._debounceTemplate(this._render)
                            }
                            return
                        }
                    }
                }
            },
            render: function() {
                this._needFullRefresh = !0;
                this._debounceTemplate(this._render);
                this._flushTemplates()
            },
            _render: function() {
                if (this._needFullRefresh) {
                    this._applyFullRefresh();
                    this._needFullRefresh = !1
                } else if (this._keySplices.length) {
                    if (this._sortFn) {
                        this._applySplicesUserSort(this._keySplices)
                    } else {
                        if (this._filterFn) {
                            this._applyFullRefresh()
                        } else {
                            this._applySplicesArrayOrder(this._indexSplices)
                        }
                    }
                }
                this._keySplices = [];
                this._indexSplices = [];
                for (var keyToIdx = this._keyToInstIdx = {}, i = this._instances.length - 1, inst; 0 <= i; i--) {
                    inst = this._instances[i];
                    if (inst.isPlaceholder && i < this._limit) {
                        inst = this._insertInstance(i, inst.__key__)
                    } else if (!inst.isPlaceholder && i >= this._limit) {
                        inst = this._downgradeInstance(i, inst.__key__)
                    }
                    keyToIdx[inst.__key__] = i;
                    if (!inst.isPlaceholder) {
                        inst.__setProperty(this.indexAs, i, !0)
                    }
                }
                this._pool.length = 0;
                this._setRenderedItemCount(this._instances.length);
                if (!Polymer.Settings.suppressTemplateNotifications || this.notifyDomChange) {
                    this.fire("dom-change")
                }
                this._tryRenderChunk()
            },
            _applyFullRefresh: function() {
                var c = this.collection,
                    keys;
                if (this._sortFn) {
                    keys = c ? c.getKeys() : []
                } else {
                    keys = [];
                    var items = this.items;
                    if (items) {
                        for (var i = 0; i < items.length; i++) {
                            keys.push(c.getKey(items[i]))
                        }
                    }
                }
                var self = this;
                if (this._filterFn) {
                    keys = keys.filter(function(a) {
                        return self._filterFn(c.getItem(a))
                    })
                }
                if (this._sortFn) {
                    keys.sort(function(a, b) {
                        return self._sortFn(c.getItem(a), c.getItem(b))
                    })
                }
                for (i = 0; i < keys.length; i++) {
                    var key = keys[i],
                        inst = this._instances[i];
                    if (inst) {
                        inst.__key__ = key;
                        if (!inst.isPlaceholder && i < this._limit) {
                            inst.__setProperty(this.as, c.getItem(key), !0)
                        }
                    } else if (i < this._limit) {
                        this._insertInstance(i, key)
                    } else {
                        this._insertPlaceholder(i, key)
                    }
                }
                for (var j = this._instances.length - 1; j >= i; j--) {
                    this._detachAndRemoveInstance(j)
                }
            },
            _numericSort: function(a, b) {
                return a - b
            },
            _applySplicesUserSort: function(splices) {
                for (var c = this.collection, keyMap = {}, key, i = 0, s; i < splices.length && (s = splices[i]); i++) {
                    for (var j = 0; j < s.removed.length; j++) {
                        key = s.removed[j];
                        keyMap[key] = keyMap[key] ? null : -1
                    }
                    for (j = 0; j < s.added.length; j++) {
                        key = s.added[j];
                        keyMap[key] = keyMap[key] ? null : 1
                    }
                }
                var removedIdxs = [],
                    addedKeys = [];
                for (key in keyMap) {
                    if (-1 === keyMap[key]) {
                        removedIdxs.push(this._keyToInstIdx[key])
                    }
                    if (1 === keyMap[key]) {
                        addedKeys.push(key)
                    }
                }
                if (removedIdxs.length) {
                    removedIdxs.sort(this._numericSort);
                    for (i = removedIdxs.length - 1; 0 <= i; i--) {
                        var idx = removedIdxs[i];
                        if (idx !== void 0) {
                            this._detachAndRemoveInstance(idx)
                        }
                    }
                }
                var self = this;
                if (addedKeys.length) {
                    if (this._filterFn) {
                        addedKeys = addedKeys.filter(function(a) {
                            return self._filterFn(c.getItem(a))
                        })
                    }
                    addedKeys.sort(function(a, b) {
                        return self._sortFn(c.getItem(a), c.getItem(b))
                    });
                    var start = 0;
                    for (i = 0; i < addedKeys.length; i++) {
                        start = this._insertRowUserSort(start, addedKeys[i])
                    }
                }
            },
            _insertRowUserSort: function(start, key) {
                var c = this.collection,
                    item = c.getItem(key),
                    end = this._instances.length - 1,
                    idx = -1;
                while (start <= end) {
                    var mid = start + end >> 1,
                        midKey = this._instances[mid].__key__,
                        cmp = this._sortFn(c.getItem(midKey), item);
                    if (0 > cmp) {
                        start = mid + 1
                    } else if (0 < cmp) {
                        end = mid - 1
                    } else {
                        idx = mid;
                        break
                    }
                }
                if (0 > idx) {
                    idx = end + 1
                }
                this._insertPlaceholder(idx, key);
                return idx
            },
            _applySplicesArrayOrder: function(splices) {
                for (var i = 0, s; i < splices.length && (s = splices[i]); i++) {
                    for (var j = 0; j < s.removed.length; j++) {
                        this._detachAndRemoveInstance(s.index)
                    }
                    for (j = 0; j < s.addedKeys.length; j++) {
                        this._insertPlaceholder(s.index + j, s.addedKeys[j])
                    }
                }
            },
            _detachInstance: function(idx) {
                var inst = this._instances[idx];
                if (!inst.isPlaceholder) {
                    for (var i = 0, el; i < inst._children.length; i++) {
                        el = inst._children[i];
                        Polymer.dom(inst.root).appendChild(el)
                    }
                    return inst
                }
            },
            _attachInstance: function(idx, parent, refNode) {
                var inst = this._instances[idx];
                if (!inst.isPlaceholder) {
                    parent.insertBefore(inst.root, refNode)
                }
            },
            _detachAndRemoveInstance: function(idx) {
                var inst = this._detachInstance(idx);
                if (inst) {
                    this._pool.push(inst)
                }
                this._instances.splice(idx, 1)
            },
            _insertPlaceholder: function(idx, key) {
                this._instances.splice(idx, 0, {
                    isPlaceholder: !0,
                    __key__: key
                })
            },
            _stampInstance: function(idx, key) {
                var model = {
                    __key__: key
                };
                model[this.as] = this.collection.getItem(key);
                model[this.indexAs] = idx;
                return this.stamp(model)
            },
            _insertInstance: function(idx, key) {
                var inst = this._pool.pop();
                if (inst) {
                    inst.__setProperty(this.as, this.collection.getItem(key), !0);
                    inst.__setProperty("__key__", key, !0)
                } else {
                    inst = this._stampInstance(idx, key)
                }
                var beforeRow = this._instances[idx + 1],
                    beforeNode = beforeRow && !beforeRow.isPlaceholder ? beforeRow._children[0] : this,
                    parentNode = Polymer.dom(this).parentNode;
                if (parentNode.localName == this.is) {
                    if (beforeNode == this) {
                        beforeNode = parentNode
                    }
                    parentNode = Polymer.dom(parentNode).parentNode
                }
                Polymer.dom(parentNode).insertBefore(inst.root, beforeNode);
                this._instances[idx] = inst;
                return inst
            },
            _downgradeInstance: function(idx, key) {
                var inst = this._detachInstance(idx);
                if (inst) {
                    this._pool.push(inst)
                }
                inst = {
                    isPlaceholder: !0,
                    __key__: key
                };
                this._instances[idx] = inst;
                return inst
            },
            _showHideChildren: function(hidden) {
                for (var i = 0; i < this._instances.length; i++) {
                    if (!this._instances[i].isPlaceholder) this._instances[i]._showHideChildren(hidden)
                }
            },
            _forwardInstanceProp: function(inst, prop, value) {
                if (prop == this.as) {
                    var idx;
                    if (this._sortFn || this._filterFn) {
                        idx = this.items.indexOf(this.collection.getItem(inst.__key__))
                    } else {
                        idx = inst[this.indexAs]
                    }
                    this.set("items." + idx, value)
                }
            },
            _forwardInstancePath: function(inst, path, value) {
                if (0 === path.indexOf(this.as + ".")) {
                    this._notifyPath("items." + inst.__key__ + "." + path.slice(this.as.length + 1), value)
                }
            },
            _forwardParentProp: function(prop, value) {
                for (var i$ = this._instances, i = 0, inst; i < i$.length && (inst = i$[i]); i++) {
                    if (!inst.isPlaceholder) {
                        inst.__setProperty(prop, value, !0)
                    }
                }
            },
            _forwardParentPath: function(path, value) {
                for (var i$ = this._instances, i = 0, inst; i < i$.length && (inst = i$[i]); i++) {
                    if (!inst.isPlaceholder) {
                        inst._notifyPath(path, value, !0)
                    }
                }
            },
            _forwardItemPath: function(path, value) {
                if (this._keyToInstIdx) {
                    var dot = path.indexOf("."),
                        key = path.substring(0, 0 > dot ? path.length : dot),
                        idx = this._keyToInstIdx[key],
                        inst = this._instances[idx];
                    if (inst && !inst.isPlaceholder) {
                        if (0 <= dot) {
                            path = this.as + "." + path.substring(dot + 1);
                            inst._notifyPath(path, value, !0)
                        } else {
                            inst.__setProperty(this.as, value, !0)
                        }
                    }
                }
            },
            itemForElement: function(el) {
                var instance = this.modelForElement(el);
                return instance && instance[this.as]
            },
            keyForElement: function(el) {
                var instance = this.modelForElement(el);
                return instance && instance.__key__
            },
            indexForElement: function(el) {
                var instance = this.modelForElement(el);
                return instance && instance[this.indexAs]
            }
        });
        Polymer({
            is: "array-selector",
            _template: null,
            properties: {
                items: {
                    type: Array,
                    observer: "clearSelection"
                },
                multi: {
                    type: Boolean,
                    value: !1,
                    observer: "clearSelection"
                },
                selected: {
                    type: Object,
                    notify: !0
                },
                selectedItem: {
                    type: Object,
                    notify: !0
                },
                toggle: {
                    type: Boolean,
                    value: !1
                }
            },
            clearSelection: function() {
                if (Array.isArray(this.selected)) {
                    for (var i = 0; i < this.selected.length; i++) {
                        this.unlinkPaths("selected." + i)
                    }
                } else {
                    this.unlinkPaths("selected");
                    this.unlinkPaths("selectedItem")
                }
                if (this.multi) {
                    if (!this.selected || this.selected.length) {
                        this.selected = [];
                        this._selectedColl = Polymer.Collection.get(this.selected)
                    }
                } else {
                    this.selected = null;
                    this._selectedColl = null
                }
                this.selectedItem = null
            },
            isSelected: function(item) {
                if (this.multi) {
                    return this._selectedColl.getKey(item) !== void 0
                } else {
                    return this.selected == item
                }
            },
            deselect: function(item) {
                if (this.multi) {
                    if (this.isSelected(item)) {
                        var skey = this._selectedColl.getKey(item);
                        this.arrayDelete("selected", item);
                        this.unlinkPaths("selected." + skey)
                    }
                } else {
                    this.selected = null;
                    this.selectedItem = null;
                    this.unlinkPaths("selected");
                    this.unlinkPaths("selectedItem")
                }
            },
            select: function(item) {
                var icol = Polymer.Collection.get(this.items),
                    key = icol.getKey(item);
                if (this.multi) {
                    if (this.isSelected(item)) {
                        if (this.toggle) {
                            this.deselect(item)
                        }
                    } else {
                        this.push("selected", item);
                        var skey = this._selectedColl.getKey(item);
                        this.linkPaths("selected." + skey, "items." + key)
                    }
                } else {
                    if (this.toggle && item == this.selected) {
                        this.deselect()
                    } else {
                        this.selected = item;
                        this.selectedItem = item;
                        this.linkPaths("selected", "items." + key);
                        this.linkPaths("selectedItem", "items." + key)
                    }
                }
            }
        });
        Polymer({
            is: "dom-if",
            extends: "template",
            _template: null,
            properties: {
                if: {
                    type: Boolean,
                    value: !1,
                    observer: "_queueRender"
                },
                restamp: {
                    type: Boolean,
                    value: !1,
                    observer: "_queueRender"
                },
                notifyDomChange: {
                    type: Boolean
                }
            },
            behaviors: [Polymer.Templatizer],
            _queueRender: function() {
                this._debounceTemplate(this._render)
            },
            detached: function() {
                var parentNode = this.parentNode;
                if (parentNode && parentNode.localName == this.is) {
                    parentNode = Polymer.dom(parentNode).parentNode
                }
                if (!parentNode || parentNode.nodeType == Node.DOCUMENT_FRAGMENT_NODE && (!Polymer.Settings.hasShadow || !(parentNode instanceof ShadowRoot))) {
                    this._teardownInstance()
                }
            },
            attached: function() {
                if (this.if && this.ctor) {
                    this.async(this._ensureInstance)
                }
            },
            render: function() {
                this._flushTemplates()
            },
            _render: function() {
                if (this.if) {
                    if (!this.ctor) {
                        this.templatize(this)
                    }
                    this._ensureInstance();
                    this._showHideChildren()
                } else if (this.restamp) {
                    this._teardownInstance()
                }
                if (!this.restamp && this._instance) {
                    this._showHideChildren()
                }
                if (this.if != this._lastIf) {
                    if (!Polymer.Settings.suppressTemplateNotifications || this.notifyDomChange) {
                        this.fire("dom-change")
                    }
                    this._lastIf = this.if
                }
            },
            _ensureInstance: function() {
                var refNode, parentNode = Polymer.dom(this).parentNode;
                if (parentNode && parentNode.localName == this.is) {
                    refNode = parentNode;
                    parentNode = Polymer.dom(parentNode).parentNode
                } else {
                    refNode = this
                }
                if (parentNode) {
                    if (!this._instance) {
                        this._instance = this.stamp();
                        var root = this._instance.root;
                        Polymer.dom(parentNode).insertBefore(root, refNode)
                    } else {
                        var c$ = this._instance._children;
                        if (c$ && c$.length) {
                            var lastChild = Polymer.dom(refNode).previousSibling;
                            if (lastChild !== c$[c$.length - 1]) {
                                for (var i = 0, n; i < c$.length && (n = c$[i]); i++) {
                                    Polymer.dom(parentNode).insertBefore(n, refNode)
                                }
                            }
                        }
                    }
                }
            },
            _teardownInstance: function() {
                if (this._instance) {
                    var c$ = this._instance._children;
                    if (c$ && c$.length) {
                        for (var parent = Polymer.dom(Polymer.dom(c$[0]).parentNode), i = 0, n; i < c$.length && (n = c$[i]); i++) {
                            parent.removeChild(n)
                        }
                    }
                    this._instance = null
                }
            },
            _showHideChildren: function() {
                var hidden = this.__hideTemplateChildren__ || !this.if;
                if (this._instance) {
                    this._instance._showHideChildren(hidden)
                }
            },
            _forwardParentProp: function(prop, value) {
                if (this._instance) {
                    this._instance.__setProperty(prop, value, !0)
                }
            },
            _forwardParentPath: function(path, value) {
                if (this._instance) {
                    this._instance._notifyPath(path, value, !0)
                }
            }
        });
        Polymer({
            is: "dom-bind",
            properties: {
                notifyDomChange: {
                    type: Boolean
                }
            },
            extends: "template",
            _template: null,
            created: function() {
                var self = this;
                Polymer.RenderStatus.whenReady(function() {
                    if ("loading" == document.readyState) {
                        document.addEventListener("DOMContentLoaded", function() {
                            self._markImportsReady()
                        })
                    } else {
                        self._markImportsReady()
                    }
                })
            },
            _ensureReady: function() {
                if (!this._readied) {
                    this._readySelf()
                }
            },
            _markImportsReady: function() {
                this._importsReady = !0;
                this._ensureReady()
            },
            _registerFeatures: function() {
                this._prepConstructor()
            },
            _insertChildren: function() {
                var refNode, parentNode = Polymer.dom(this).parentNode;
                if (parentNode.localName == this.is) {
                    refNode = parentNode;
                    parentNode = Polymer.dom(parentNode).parentNode
                } else {
                    refNode = this
                }
                Polymer.dom(parentNode).insertBefore(this.root, refNode)
            },
            _removeChildren: function() {
                if (this._children) {
                    for (var i = 0; i < this._children.length; i++) {
                        this.root.appendChild(this._children[i])
                    }
                }
            },
            _initFeatures: function() {},
            _scopeElementClass: function(element, selector) {
                if (this.dataHost) {
                    return this.dataHost._scopeElementClass(element, selector)
                } else {
                    return selector
                }
            },
            _configureInstanceProperties: function() {},
            _prepConfigure: function() {
                var config = {};
                for (var prop in this._propertyEffects) {
                    config[prop] = this[prop]
                }
                var setupConfigure = this._setupConfigure;
                this._setupConfigure = function() {
                    setupConfigure.call(this, config)
                }
            },
            attached: function() {
                if (this._importsReady) {
                    this.render()
                }
            },
            detached: function() {
                this._removeChildren()
            },
            render: function() {
                this._ensureReady();
                if (!this._children) {
                    this._template = this;
                    this._prepAnnotations();
                    this._prepEffects();
                    this._prepBehaviors();
                    this._prepConfigure();
                    this._prepBindings();
                    this._prepPropertyInfo();
                    Polymer.Base._initFeatures.call(this);
                    this._children = Polymer.TreeApi.arrayCopyChildNodes(this.root)
                }
                this._insertChildren();
                if (!Polymer.Settings.suppressTemplateNotifications || this.notifyDomChange) {
                    this.fire("dom-change")
                }
            }
        });
    </script>
    <script>
        function MakePromise(asap) {
            function Promise(fn) {
                if ("object" !== typeof this || "function" !== typeof fn) throw new TypeError;
                this._state = null;
                this._value = null;
                this._deferreds = [];
                doResolve(fn, resolve.bind(this), reject.bind(this))
            }

            function handle(deferred) {
                var me = this;
                if (null === this._state) {
                    this._deferreds.push(deferred);
                    return
                }
                asap(function() {
                    var cb = me._state ? deferred.onFulfilled : deferred.onRejected;
                    if ("function" !== typeof cb) {
                        (me._state ? deferred.resolve : deferred.reject)(me._value);
                        return
                    }
                    var ret;
                    try {
                        ret = cb(me._value)
                    } catch (e) {
                        deferred.reject(e);
                        return
                    }
                    deferred.resolve(ret)
                })
            }

            function resolve(newValue) {
                try {
                    if (newValue === this) throw new TypeError;
                    if (newValue && ("object" === typeof newValue || "function" === typeof newValue)) {
                        var then = newValue.then;
                        if ("function" === typeof then) {
                            doResolve(then.bind(newValue), resolve.bind(this), reject.bind(this));
                            return
                        }
                    }
                    this._state = !0;
                    this._value = newValue;
                    finale.call(this)
                } catch (e) {
                    reject.call(this, e)
                }
            }

            function reject(newValue) {
                this._state = !1;
                this._value = newValue;
                finale.call(this)
            }

            function finale() {
                for (var i = 0, len = this._deferreds.length; i < len; i++) {
                    handle.call(this, this._deferreds[i])
                }
                this._deferreds = null
            }

            function doResolve(fn, onFulfilled, onRejected) {
                var done = !1;
                try {
                    fn(function(value) {
                        if (done) return;
                        done = !0;
                        onFulfilled(value)
                    }, function(reason) {
                        if (done) return;
                        done = !0;
                        onRejected(reason)
                    })
                } catch (ex) {
                    if (done) return;
                    done = !0;
                    onRejected(ex)
                }
            }
            Promise.prototype["catch"] = function(onRejected) {
                return this.then(null, onRejected)
            };
            Promise.prototype.then = function(onFulfilled, onRejected) {
                var me = this;
                return new Promise(function(resolve, reject) {
                    handle.call(me, {
                        onFulfilled: onFulfilled,
                        onRejected: onRejected,
                        resolve: resolve,
                        reject: reject
                    })
                })
            };
            Promise.resolve = function(value) {
                if (value && "object" === typeof value && value.constructor === Promise) {
                    return value
                }
                return new Promise(function(resolve) {
                    resolve(value)
                })
            };
            Promise.reject = function(value) {
                return new Promise(function(resolve, reject) {
                    reject(value)
                })
            };
            return Promise
        }
        if ("undefined" !== typeof module) {
            module.exports = MakePromise
        }
    </script>
    <script>
        if (!window.Promise) {
            window.Promise = MakePromise(Polymer.Base.async)
        }
    </script>
    <script>
        "use strict";
        Polymer({
            is: "iron-request",
            hostAttributes: {
                hidden: !0
            },
            properties: {
                xhr: {
                    type: Object,
                    notify: !0,
                    readOnly: !0,
                    value: function() {
                        return new XMLHttpRequest
                    }
                },
                response: {
                    type: Object,
                    notify: !0,
                    readOnly: !0,
                    value: function() {
                        return null
                    }
                },
                status: {
                    type: Number,
                    notify: !0,
                    readOnly: !0,
                    value: 0
                },
                statusText: {
                    type: String,
                    notify: !0,
                    readOnly: !0,
                    value: ""
                },
                completes: {
                    type: Object,
                    readOnly: !0,
                    notify: !0,
                    value: function() {
                        return new Promise(function(resolve, reject) {
                            this.resolveCompletes = resolve;
                            this.rejectCompletes = reject
                        }.bind(this))
                    }
                },
                progress: {
                    type: Object,
                    notify: !0,
                    readOnly: !0,
                    value: function() {
                        return {}
                    }
                },
                aborted: {
                    type: Boolean,
                    notify: !0,
                    readOnly: !0,
                    value: !1
                },
                errored: {
                    type: Boolean,
                    notify: !0,
                    readOnly: !0,
                    value: !1
                },
                timedOut: {
                    type: Boolean,
                    notify: !0,
                    readOnly: !0,
                    value: !1
                }
            },
            get succeeded() {
                if (this.errored || this.aborted || this.timedOut) {
                    return !1
                }
                var status = this.xhr.status || 0;
                return 0 === status || 200 <= status && 300 > status
            },
            send: function(options) {
                var xhr = this.xhr;
                if (0 < xhr.readyState) {
                    return null
                }
                xhr.addEventListener("progress", function(progress) {
                    this._setProgress({
                        lengthComputable: progress.lengthComputable,
                        loaded: progress.loaded,
                        total: progress.total
                    })
                }.bind(this));
                xhr.addEventListener("error", function(error) {
                    this._setErrored(!0);
                    this._updateStatus();
                    this.rejectCompletes(error)
                }.bind(this));
                xhr.addEventListener("timeout", function(error) {
                    this._setTimedOut(!0);
                    this._updateStatus();
                    this.rejectCompletes(error)
                }.bind(this));
                xhr.addEventListener("abort", function() {
                    this._updateStatus();
                    this.rejectCompletes(new Error("Request aborted."))
                }.bind(this));
                xhr.addEventListener("loadend", function() {
                    this._updateStatus();
                    this._setResponse(this.parseResponse());
                    if (!this.succeeded) {
                        this.rejectCompletes(new Error("The request failed with status code: " + this.xhr.status));
                        return
                    }
                    this.resolveCompletes(this)
                }.bind(this));
                this.url = options.url;
                xhr.open(options.method || "GET", options.url, !1 !== options.async);
                var acceptType = {
                        json: "application/json",
                        text: "text/plain",
                        html: "text/html",
                        xml: "application/xml",
                        arraybuffer: "application/octet-stream"
                    } [options.handleAs],
                    headers = options.headers || Object.create(null),
                    newHeaders = Object.create(null);
                for (var key in headers) {
                    newHeaders[key.toLowerCase()] = headers[key]
                }
                headers = newHeaders;
                if (acceptType && !headers.accept) {
                    headers.accept = acceptType
                }
                Object.keys(headers).forEach(function(requestHeader) {
                    if (/[A-Z]/.test(requestHeader)) {
                        Polymer.Base._error("Headers must be lower case, got", requestHeader)
                    }
                    xhr.setRequestHeader(requestHeader, headers[requestHeader])
                }, this);
                if (!1 !== options.async) {
                    if (options.async) {
                        xhr.timeout = options.timeout
                    }
                    var handleAs = options.handleAs;
                    if (!!options.jsonPrefix || !handleAs) {
                        handleAs = "text"
                    }
                    xhr.responseType = xhr._responseType = handleAs;
                    if (!!options.jsonPrefix) {
                        xhr._jsonPrefix = options.jsonPrefix
                    }
                }
                xhr.withCredentials = !!options.withCredentials;
                var body = this._encodeBodyObject(options.body, headers["content-type"]);
                xhr.send(body);
                return this.completes
            },
            parseResponse: function() {
                var xhr = this.xhr,
                    responseType = xhr.responseType || xhr._responseType,
                    preferResponseText = !this.xhr.responseType,
                    prefixLen = xhr._jsonPrefix && xhr._jsonPrefix.length || 0;
                try {
                    switch (responseType) {
                        case "json":
                            if (preferResponseText || xhr.response === void 0) {
                                try {
                                    return JSON.parse(xhr.responseText)
                                } catch (_) {
                                    return null
                                }
                            }
                            return xhr.response;
                        case "xml":
                            return xhr.responseXML;
                        case "blob":
                        case "document":
                        case "arraybuffer":
                            return xhr.response;
                        case "text":
                        default:
                            {
                                if (prefixLen) {
                                    try {
                                        return JSON.parse(xhr.responseText.substring(prefixLen))
                                    } catch (_) {
                                        return null
                                    }
                                }
                                return xhr.responseText
                            }
                    }
                } catch (e) {
                    this.rejectCompletes(new Error("Could not parse response. " + e.message))
                }
            },
            abort: function() {
                this._setAborted(!0);
                this.xhr.abort()
            },
            _encodeBodyObject: function(body, contentType) {
                if ("string" == typeof body) {
                    return body
                }
                var bodyObj = body;
                switch (contentType) {
                    case "application/json":
                        return JSON.stringify(bodyObj);
                    case "application/x-www-form-urlencoded":
                        return this._wwwFormUrlEncode(bodyObj);
                }
                return body
            },
            _wwwFormUrlEncode: function(object) {
                if (!object) {
                    return ""
                }
                var pieces = [];
                Object.keys(object).forEach(function(key) {
                    pieces.push(this._wwwFormUrlEncodePiece(key) + "=" + this._wwwFormUrlEncodePiece(object[key]))
                }, this);
                return pieces.join("&")
            },
            _wwwFormUrlEncodePiece: function(str) {
                if (null === str) {
                    return ""
                }
                return encodeURIComponent(str.toString().replace(/\r?\n/g, "\r\n")).replace(/%20/g, "+")
            },
            _updateStatus: function() {
                this._setStatus(this.xhr.status);
                this._setStatusText(this.xhr.statusText === void 0 ? "" : this.xhr.statusText)
            }
        });
    </script>
    <script>
        "use strict";
        Polymer({
            is: "iron-ajax",
            hostAttributes: {
                hidden: !0
            },
            properties: {
                url: {
                    type: String
                },
                params: {
                    type: Object,
                    value: function() {
                        return {}
                    }
                },
                method: {
                    type: String,
                    value: "GET"
                },
                headers: {
                    type: Object,
                    value: function() {
                        return {}
                    }
                },
                contentType: {
                    type: String,
                    value: null
                },
                body: {
                    type: Object,
                    value: null
                },
                sync: {
                    type: Boolean,
                    value: !1
                },
                handleAs: {
                    type: String,
                    value: "json"
                },
                withCredentials: {
                    type: Boolean,
                    value: !1
                },
                timeout: {
                    type: Number,
                    value: 0
                },
                auto: {
                    type: Boolean,
                    value: !1
                },
                verbose: {
                    type: Boolean,
                    value: !1
                },
                lastRequest: {
                    type: Object,
                    notify: !0,
                    readOnly: !0
                },
                loading: {
                    type: Boolean,
                    notify: !0,
                    readOnly: !0
                },
                lastResponse: {
                    type: Object,
                    notify: !0,
                    readOnly: !0
                },
                lastError: {
                    type: Object,
                    notify: !0,
                    readOnly: !0
                },
                activeRequests: {
                    type: Array,
                    notify: !0,
                    readOnly: !0,
                    value: function() {
                        return []
                    }
                },
                debounceDuration: {
                    type: Number,
                    value: 0,
                    notify: !0
                },
                jsonPrefix: {
                    type: String,
                    value: ""
                },
                bubbles: {
                    type: Boolean,
                    value: !1
                },
                _boundHandleResponse: {
                    type: Function,
                    value: function() {
                        return this._handleResponse.bind(this)
                    }
                }
            },
            observers: ["_requestOptionsChanged(url, method, params.*, headers, contentType, " + "body, sync, handleAs, jsonPrefix, withCredentials, timeout, auto)"],
            get queryString() {
                var queryParts = [],
                    param, value;
                for (param in this.params) {
                    value = this.params[param];
                    param = window.encodeURIComponent(param);
                    if (Array.isArray(value)) {
                        for (var i = 0; i < value.length; i++) {
                            queryParts.push(param + "=" + window.encodeURIComponent(value[i]))
                        }
                    } else if (null !== value) {
                        queryParts.push(param + "=" + window.encodeURIComponent(value))
                    } else {
                        queryParts.push(param)
                    }
                }
                return queryParts.join("&")
            },
            get requestUrl() {
                var queryString = this.queryString,
                    url = this.url || "";
                if (queryString) {
                    var bindingChar = 0 <= url.indexOf("?") ? "&" : "?";
                    return url + bindingChar + queryString
                }
                return url
            },
            get requestHeaders() {
                var headers = {},
                    contentType = this.contentType;
                if (null == contentType && "string" === typeof this.body) {
                    contentType = "application/x-www-form-urlencoded"
                }
                if (contentType) {
                    headers["content-type"] = contentType
                }
                if (this.headers instanceof Object) {
                    for (var header in this.headers) {
                        headers[header] = this.headers[header].toString()
                    }
                }
                return headers
            },
            toRequestOptions: function() {
                return {
                    url: this.requestUrl || "",
                    method: this.method,
                    headers: this.requestHeaders,
                    body: this.body,
                    async: !this.sync,
                    handleAs: this.handleAs,
                    jsonPrefix: this.jsonPrefix,
                    withCredentials: this.withCredentials,
                    timeout: this.timeout
                }
            },
            generateRequest: function() {
                var request = document.createElement("iron-request"),
                    requestOptions = this.toRequestOptions();
                this.push("activeRequests", request);
                request.completes.then(this._boundHandleResponse).catch(this._handleError.bind(this, request)).then(this._discardRequest.bind(this, request));
                request.send(requestOptions);
                this._setLastRequest(request);
                this._setLoading(!0);
                this.fire("request", {
                    request: request,
                    options: requestOptions
                }, {
                    bubbles: this.bubbles
                });
                this.fire("iron-ajax-request", {
                    request: request,
                    options: requestOptions
                }, {
                    bubbles: this.bubbles
                });
                return request
            },
            _handleResponse: function(request) {
                if (request === this.lastRequest) {
                    this._setLastResponse(request.response);
                    this._setLastError(null);
                    this._setLoading(!1)
                }
                this.fire("response", request, {
                    bubbles: this.bubbles
                });
                this.fire("iron-ajax-response", request, {
                    bubbles: this.bubbles
                })
            },
            _handleError: function(request, error) {
                if (this.verbose) {
                    Polymer.Base._error(error)
                }
                if (request === this.lastRequest) {
                    this._setLastError({
                        request: request,
                        error: error,
                        status: request.xhr.status,
                        statusText: request.xhr.statusText,
                        response: request.xhr.response
                    });
                    this._setLastResponse(null);
                    this._setLoading(!1)
                }
                this.fire("iron-ajax-error", {
                    request: request,
                    error: error
                }, {
                    bubbles: this.bubbles
                });
                this.fire("error", {
                    request: request,
                    error: error
                }, {
                    bubbles: this.bubbles
                })
            },
            _discardRequest: function(request) {
                var requestIndex = this.activeRequests.indexOf(request);
                if (-1 < requestIndex) {
                    this.splice("activeRequests", requestIndex, 1)
                }
            },
            _requestOptionsChanged: function() {
                this.debounce("generate-request", function() {
                    if (null == this.url) {
                        return
                    }
                    if (this.auto) {
                        this.generateRequest()
                    }
                }, this.debounceDuration)
            }
        });
    </script>
    <script>
        Polymer.IronResizableBehavior = {
            properties: {
                _parentResizable: {
                    type: Object,
                    observer: "_parentResizableChanged"
                },
                _notifyingDescendant: {
                    type: Boolean,
                    value: !1
                }
            },
            listeners: {
                "iron-request-resize-notifications": "_onIronRequestResizeNotifications"
            },
            created: function() {
                this._interestedResizables = [];
                this._boundNotifyResize = this.notifyResize.bind(this)
            },
            attached: function() {
                this.fire("iron-request-resize-notifications", null, {
                    node: this,
                    bubbles: !0,
                    cancelable: !0
                });
                if (!this._parentResizable) {
                    window.addEventListener("resize", this._boundNotifyResize);
                    this.notifyResize()
                }
            },
            detached: function() {
                if (this._parentResizable) {
                    this._parentResizable.stopResizeNotificationsFor(this)
                } else {
                    window.removeEventListener("resize", this._boundNotifyResize)
                }
                this._parentResizable = null
            },
            notifyResize: function() {
                if (!this.isAttached) {
                    return
                }
                this._interestedResizables.forEach(function(resizable) {
                    if (this.resizerShouldNotify(resizable)) {
                        this._notifyDescendant(resizable)
                    }
                }, this);
                this._fireResize()
            },
            assignParentResizable: function(parentResizable) {
                this._parentResizable = parentResizable
            },
            stopResizeNotificationsFor: function(target) {
                var index = this._interestedResizables.indexOf(target);
                if (-1 < index) {
                    this._interestedResizables.splice(index, 1);
                    this.unlisten(target, "iron-resize", "_onDescendantIronResize")
                }
            },
            resizerShouldNotify: function() {
                return !0
            },
            _onDescendantIronResize: function(event) {
                if (this._notifyingDescendant) {
                    event.stopPropagation();
                    return
                }
                if (!Polymer.Settings.useShadow) {
                    this._fireResize()
                }
            },
            _fireResize: function() {
                this.fire("iron-resize", null, {
                    node: this,
                    bubbles: !1
                })
            },
            _onIronRequestResizeNotifications: function(event) {
                var target = event.path ? event.path[0] : event.target;
                if (target === this) {
                    return
                }
                if (-1 === this._interestedResizables.indexOf(target)) {
                    this._interestedResizables.push(target);
                    this.listen(target, "iron-resize", "_onDescendantIronResize")
                }
                target.assignParentResizable(this);
                this._notifyDescendant(target);
                event.stopPropagation()
            },
            _parentResizableChanged: function(parentResizable) {
                if (parentResizable) {
                    window.removeEventListener("resize", this._boundNotifyResize)
                }
            },
            _notifyDescendant: function(descendant) {
                if (!this.isAttached) {
                    return
                }
                this._notifyingDescendant = !0;
                descendant.notifyResize();
                this._notifyingDescendant = !1
            }
        };
    </script>
</head>

<body></body>

</html>